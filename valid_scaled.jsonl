{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-4038_557eec4f", "label": 1, "code": "@Override\npublic double getCost(Filter filter, NodeState root) {\n    if (filter.getFullTextConstraint() != null) {\n        // not an appropriate index for full-text search\n        return Double.POSITIVE_INFINITY;\n    }\n    if (filter.containsNativeConstraint()) {\n        // not an appropriate index for native search\n        return Double.POSITIVE_INFINITY;\n    }\n    if (filter.getPropertyRestrictions().isEmpty() && filter.getSelector().getSelectorConstraints().isEmpty()) {\n        // not an appropriate index for no property restrictions & selector constraints\n        return Double.POSITIVE_INFINITY;\n    }\n    PropertyIndexPlan plan = getPlan(root, filter);\n    if (plan != null) {\n        return plan.getCost();\n    } else {\n        return Double.POSITIVE_INFINITY;\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic double getCost(Filter filter, NodeState root) {\n    if (filter.getFullTextConstraint() != null) {\n                return Double.POSITIVE_INFINITY;\n    }\n    if (filter.containsNativeConstraint()) {\n                return Double.POSITIVE_INFINITY;\n    }\n    if (filter.getPropertyRestrictions().isEmpty() && filter.getSelector().getSelectorConstraints().isEmpty()) {\n                return Double.POSITIVE_INFINITY;\n    }\n    PropertyIndexPlan plan = getPlan(root, filter);\n    if (plan != null) {\n        return plan.getCost();\n    } else {\n        return Double.POSITIVE_INFINITY;\n    }\n}", "lc": 0.18181818181818182, "pi": -0.19897959183673475, "ma": 0.16666666666666666, "nbd": -0.5, "ml": 0.4166666666666667, "d": -0.00692041522491348, "mi": -0.12159449383424176, "fo": 0.25, "r": 0.0, "e": -0.019470535075659254}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1363_69b68890", "label": 0, "code": "@Override\npublic boolean commit() throws LoginException {\n    if (tokenCredentials != null) {\n        updateSubject(tokenCredentials, getAuthInfo(tokenInfo), principals);\n        return true;\n    }\n    if (tokenProvider != null && sharedState.containsKey(SHARED_KEY_CREDENTIALS)) {\n        Credentials shared = getSharedCredentials();\n        if (shared != null && tokenProvider.doCreateToken(shared)) {\n            TokenInfo ti = tokenProvider.createToken(shared);\n            if (ti != null) {\n                TokenCredentials tc = new TokenCredentials(ti.getToken());\n                Map<String, String> attributes = ti.getPrivateAttributes();\n                for (String name : attributes.keySet()) {\n                    tc.setAttribute(name, attributes.get(name));\n                }\n                attributes = ti.getPublicAttributes();\n                for (String name : attributes.keySet()) {\n                    tc.setAttribute(name, attributes.get(name));\n                }\n                updateSubject(tc, getAuthInfo(ti), null);\n            } else {\n                // failed to create token -> fail commit()\n                log.debug(\"TokenProvider failed to create a login token for user \" + userId);\n                throw new LoginException(\"Failed to create login token for user \" + userId);\n            }\n        }\n    }\n    // the login attempt on this module did not succeed: clear state\n    clearState();\n    return false;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean commit() throws LoginException {\n    if (tokenCredentials != null) {\n        updateSubject(tokenCredentials, getAuthInfo(tokenInfo), principals);\n        return true;\n    }\n    if (tokenProvider != null && sharedState.containsKey(SHARED_KEY_CREDENTIALS)) {\n        Credentials shared = getSharedCredentials();\n        if (shared != null && tokenProvider.doCreateToken(shared)) {\n            TokenInfo ti = tokenProvider.createToken(shared);\n            if (ti != null) {\n                TokenCredentials tc = new TokenCredentials(ti.getToken());\n                Map<String, String> attributes = ti.getPrivateAttributes();\n                for (String name : attributes.keySet()) {\n                    tc.setAttribute(name, attributes.get(name));\n                }\n                attributes = ti.getPublicAttributes();\n                for (String name : attributes.keySet()) {\n                    tc.setAttribute(name, attributes.get(name));\n                }\n                updateSubject(tc, getAuthInfo(ti), null);\n            } else {\n                                log.debug(\"TokenProvider failed to create a login token for user \" + userId);\n                throw new LoginException(\"Failed to create login token for user \" + userId);\n            }\n        }\n    }\n        clearState();\n    return false;\n}", "lc": 0.7272727272727273, "pi": 1.5612244897959184, "ma": 0.6666666666666666, "nbd": 1.0, "ml": 0.5833333333333334, "d": 0.3905091448344044, "mi": -0.5357040435904793, "fo": 1.0833333333333333, "r": -0.028571428571428574, "e": 0.6894351146345956}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2494_0dc92ca1", "label": 1, "code": "public void addStat(long stat) {\n    if (stat > max)\n        max = stat;\n    if (stat < min)\n        min = stat;\n    sum += stat;\n    partialStdDev += stat * stat;\n    count++;\n}", "code_comment": NaN, "code_no_comment": "public void addStat(long stat) {\n    if (stat > max)\n        max = stat;\n    if (stat < min)\n        min = stat;\n    sum += stat;\n    partialStdDev += stat * stat;\n    count++;\n}", "lc": -0.22727272727272727, "pi": -0.17857142857142863, "ma": -0.16666666666666666, "nbd": -1.0, "ml": 0.0, "d": 0.8808699950568464, "mi": 0.3071408087180957, "fo": -0.5, "r": 0.6, "e": 0.09566517189835574}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3931_8fbdc68f", "label": 1, "code": "/**\n *  Detaches the component. This is called at the end of the request for all the pages that are\n *  touched in that request.\n */\npublic final void detach() {\n    // if the component has been previously attached via attach()\n    // detach it now\n    setFlag(FLAG_DETACHING, true);\n    onDetach();\n    if (getFlag(FLAG_DETACHING)) {\n        throw new IllegalStateException(Component.class.getName() + \" has not been properly detached. Something in the hierarchy of \" + getClass().getName() + \" has not called super.onDetach() in the override of onDetach() method\");\n    }\n    // always detach models because they can be attached without the\n    // component. eg component has a compoundpropertymodel and one of its\n    // children component's getmodelobject is called\n    detachModels();\n    // detach any behaviors\n    new Behaviors(this).detach();\n    // always detach children because components can be attached\n    // independently of their parents\n    detachChildren();\n    // The model will be created next time.\n    if (getFlag(FLAG_INHERITABLE_MODEL)) {\n        setModelImpl(null);\n        setFlag(FLAG_INHERITABLE_MODEL, false);\n    }\n    clearEnabledInHierarchyCache();\n    clearVisibleInHierarchyCache();\n    requestFlags = 0;\n    // notify any detach listener\n    IDetachListener detachListener = getApplication().getFrameworkSettings().getDetachListener();\n    if (detachListener != null) {\n        detachListener.onDetach(this);\n    }\n}", "code_comment": "/**\n *  Detaches the component. This is called at the end of the request for all the pages that are\n *  touched in that request.\n */\n", "code_no_comment": "public final void detach() {\n            setFlag(FLAG_DETACHING, true);\n    onDetach();\n    if (getFlag(FLAG_DETACHING)) {\n        throw new IllegalStateException(Component.class.getName() + \" has not been properly detached. Something in the hierarchy of \" + getClass().getName() + \" has not called super.onDetach() in the override of onDetach() method\");\n    }\n                detachModels();\n        new Behaviors(this).detach();\n            detachChildren();\n        if (getFlag(FLAG_INHERITABLE_MODEL)) {\n        setModelImpl(null);\n        setFlag(FLAG_INHERITABLE_MODEL, false);\n    }\n    clearEnabledInHierarchyCache();\n    clearVisibleInHierarchyCache();\n    requestFlags = 0;\n        IDetachListener detachListener = getApplication().getFrameworkSettings().getDetachListener();\n    if (detachListener != null) {\n        detachListener.onDetach(this);\n    }\n}", "lc": 0.3181818181818182, "pi": -0.4693877551020408, "ma": 0.16666666666666666, "nbd": -0.5, "ml": 0.08333333333333333, "d": -0.11566979733069695, "mi": -0.22110696874103844, "fo": 1.0, "r": -0.028571428571428574, "e": -0.0403887254209122}
{"project_name": "Closure", "project_version": 54, "label": 2, "code": "/**\n * Sets the prototype.\n * @param prototype the prototype. If this value is {@code null} it will\n *        silently be discarded.\n */\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    if (isConstructor() || isInterface()) {\n        FunctionType superClass = getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.addSubType(this);\n        }\n        if (isInterface()) {\n            for (ObjectType interfaceType : getExtendedInterfaces()) {\n                if (interfaceType.getConstructor() != null) {\n                    interfaceType.getConstructor().addSubType(this);\n                }\n            }\n        }\n    }\n    if (replacedPrototype) {\n        clearCachedValues();\n    }\n    return true;\n}", "code_comment": "/**\n * Sets the prototype.\n * @param prototype the prototype. If this value is {@code null} it will\n *        silently be discarded.\n */\n", "code_no_comment": "public boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n        if (isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    if (isConstructor() || isInterface()) {\n        FunctionType superClass = getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.addSubType(this);\n        }\n        if (isInterface()) {\n            for (ObjectType interfaceType : getExtendedInterfaces()) {\n                if (interfaceType.getConstructor() != null) {\n                    interfaceType.getConstructor().addSubType(this);\n                }\n            }\n        }\n    }\n    if (replacedPrototype) {\n        clearCachedValues();\n    }\n    return true;\n}", "lc": 0.6818181818181818, "pi": 0.8367346938775511, "ma": 0.8333333333333334, "nbd": 1.0, "ml": 0.9166666666666666, "d": 0.3924864063272369, "mi": -0.43102953828505897, "fo": 0.5833333333333334, "r": -0.028571428571428574, "e": 0.28696125166501774}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3428_ffc0cae9", "label": 1, "code": "/**\n *  Convenience method that processes the request and detaches the {@link RequestCycle}.\n *\n *  @return <code>true</code> if the request resolved to a Wicket request, <code>false</code>\n *          otherwise.\n */\npublic boolean processRequestAndDetach() {\n    boolean result;\n    try {\n        listeners.onBeginRequest(this);\n        onBeginRequest();\n        result = processRequest();\n    } finally {\n        detach();\n    }\n    return result;\n}", "code_comment": "/**\n *  Convenience method that processes the request and detaches the {@link RequestCycle}.\n *\n *  @return <code>true</code> if the request resolved to a Wicket request, <code>false</code>\n *          otherwise.\n */\n", "code_no_comment": "public boolean processRequestAndDetach() {\n    boolean result;\n    try {\n        listeners.onBeginRequest(this);\n        onBeginRequest();\n        result = processRequest();\n    } finally {\n        detach();\n    }\n    return result;\n}", "lc": -0.13636363636363635, "pi": -0.08163265306122457, "ma": -0.5, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.38514482363062796, "fo": -0.16666666666666666, "r": 1.6285714285714286, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-370_495f04bc", "label": 3, "code": "/**\n * Returns true iff both arguments are null or have same dimensions and all\n * their elements are equal as defined by\n * {@link #equals(double,double) this method}.\n *\n * @param x first array\n * @param y second array\n * @return true if the values are both null or have same dimension\n * and equal elements.\n * @deprecated This method considers that {@code NaN == NaN}. In release\n * 3.0, the semantics will change in order to comply with IEEE754 where it\n * is specified that {@code NaN != NaN}.\n * New methods have been added for those cases wher the old semantics is\n * useful (see e.g. {@link #equalsIncludingNaN(double[],double[])\n * equalsIncludingNaN}.\n */\npublic static boolean equals(double[] x, double[] y) {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!equals(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}", "code_comment": "/**\n * Returns true iff both arguments are null or have same dimensions and all\n * their elements are equal as defined by\n * {@link #equals(double,double) this method}.\n *\n * @param x first array\n * @param y second array\n * @return true if the values are both null or have same dimension\n * and equal elements.\n * @deprecated This method considers that {@code NaN == NaN}. In release\n * 3.0, the semantics will change in order to comply with IEEE754 where it\n * is specified that {@code NaN != NaN}.\n * New methods have been added for those cases wher the old semantics is\n * useful (see e.g. {@link #equalsIncludingNaN(double[],double[])\n * equalsIncludingNaN}.\n */\n", "code_no_comment": "public static boolean equals(double[] x, double[] y) {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!equals(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}", "lc": 0.0, "pi": 0.08163265306122457, "ma": 0.16666666666666666, "nbd": 0.0, "ml": 0.5, "d": 1.9920909540286704, "mi": -0.0020074562661315577, "fo": -0.4166666666666667, "r": 0.4285714285714286, "e": 0.7359057053893036}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5265_0eb596df", "label": 1, "code": "@Override\nprotected FeedbackMessagesModel newFeedbackMessagesModel() {\n    return new FeedbackMessagesModel(this) {\n\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        protected List<FeedbackMessage> collectMessages(Component panel, IFeedbackMessageFilter filter) {\n            if (fence == null) {\n                return new FeedbackCollector(panel.getPage()) {\n\n                    @Override\n                    protected boolean shouldRecurseInto(Component component) {\n                        return component.getMetaData(FENCE_KEY) == null;\n                    }\n                }.collect(filter);\n            } else {\n                return new FeedbackCollector(fence) {\n\n                    @Override\n                    protected boolean shouldRecurseInto(Component component) {\n                        return component.getMetaData(FENCE_KEY) == null;\n                    }\n                }.setIncludeSession(false).collect(filter);\n            }\n        }\n    };\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected FeedbackMessagesModel newFeedbackMessagesModel() {\n    return new FeedbackMessagesModel(this) {\n\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        protected List<FeedbackMessage> collectMessages(Component panel, IFeedbackMessageFilter filter) {\n            if (fence == null) {\n                return new FeedbackCollector(panel.getPage()) {\n\n                    @Override\n                    protected boolean shouldRecurseInto(Component component) {\n                        return component.getMetaData(FENCE_KEY) == null;\n                    }\n                }.collect(filter);\n            } else {\n                return new FeedbackCollector(fence) {\n\n                    @Override\n                    protected boolean shouldRecurseInto(Component component) {\n                        return component.getMetaData(FENCE_KEY) == null;\n                    }\n                }.setIncludeSession(false).collect(filter);\n            }\n        }\n    };\n}", "lc": 0.45454545454545453, "pi": 2.275510204081633, "ma": -0.3333333333333333, "nbd": 0.5, "ml": -0.25, "d": -0.01878398418190801, "mi": -0.27043303699455146, "fo": 0.0, "r": 0.0, "e": 0.012934671343706764}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5724_b92591f6", "label": 1, "code": "@Override\npublic Component newComponent(ComponentTag tag) {\n    String attributeName = getInlineEnclosureAttributeName(null);\n    String childId = tag.getAttribute(attributeName);\n    return new InlineEnclosure(tag.getId(), childId);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Component newComponent(ComponentTag tag) {\n    String attributeName = getInlineEnclosureAttributeName(null);\n    String childId = tag.getAttribute(attributeName);\n    return new InlineEnclosure(tag.getId(), childId);\n}", "lc": -0.36363636363636365, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.5311155721250359, "fo": -0.25, "r": 1.2857142857142858, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2246_dcadb0e1", "label": 1, "code": "@Override\npublic void startNode(NodeInfo nodeInfo, List<PropInfo> propInfos) throws RepositoryException {\n    Tree parent = parents.peek();\n    Tree tree = null;\n    String id = nodeInfo.getUUID();\n    String nodeName = nodeInfo.getName();\n    String ntName = nodeInfo.getPrimaryTypeName();\n    if (parent == null) {\n        log.debug(\"Skipping node: \" + nodeName);\n        // parent node was skipped, skip this child node too\n        // push null onto stack for skipped node\n        parents.push(null);\n        // notify the p-i-importer\n        if (pnImporter != null) {\n            pnImporter.startChildInfo(nodeInfo, propInfos);\n        }\n        return;\n    }\n    NodeDefinition parentDef = getDefinition(parent);\n    if (parentDef.isProtected()) {\n        // skip protected node\n        parents.push(null);\n        log.debug(\"Skipping protected node: \" + nodeName);\n        if (pnImporter != null) {\n            // pnImporter was already started (current nodeInfo is a sibling)\n            // notify it about this child node.\n            pnImporter.startChildInfo(nodeInfo, propInfos);\n        } else {\n            // potentially is able to deal with it, notify it about the child node.\n            for (ProtectedNodeImporter pni : getNodeImporters()) {\n                if (pni.start(parent)) {\n                    log.debug(\"Protected node -> delegated to ProtectedNodeImporter\");\n                    pnImporter = pni;\n                    pnImporter.startChildInfo(nodeInfo, propInfos);\n                    break;\n                }\n            /* else: p-i-Importer isn't able to deal with the protected tree.\n                     try next. and if none can handle the passed parent the\n                     tree below will be skipped */\n            }\n        }\n        return;\n    }\n    if (parent.hasChild(nodeName)) {\n        // a node with that name already exists...\n        Tree existing = parent.getChild(nodeName);\n        NodeDefinition def = getDefinition(existing);\n        if (!def.allowsSameNameSiblings()) {\n            // check for potential conflicts\n            if (def.isProtected() && isNodeType(existing, ntName)) {\n                /*\n                     use the existing node as parent for the possible subsequent\n                     import of a protected tree, that the protected node importer\n                     may or may not be able to deal with.\n                     -> upon the next 'startNode' the check for the parent being\n                        protected will notify the protected node importer.\n                     -> if the importer is able to deal with that node it needs\n                        to care of the complete subtree until it is notified\n                        during the 'endNode' call.\n                     -> if the import can't deal with that node or if that node\n                        is the a leaf in the tree to be imported 'end' will\n                        not have an effect on the importer, that was never started.\n                    */\n                log.debug(\"Skipping protected node: \" + existing);\n                parents.push(existing);\n                /**\n                 * let ProtectedPropertyImporters handle the properties\n                 * associated with the imported node. this may include overwriting,\n                 * merging or just adding missing properties.\n                 */\n                importProperties(existing, propInfos, true);\n                return;\n            }\n            if (def.isAutoCreated() && isNodeType(existing, ntName)) {\n                // this node has already been auto-created, no need to create it\n                tree = existing;\n            } else {\n                // edge case: colliding node does have same uuid\n                // (see http://issues.apache.org/jira/browse/JCR-1128)\n                String existingIdentifier = IdentifierManager.getIdentifier(existing);\n                if (!(existingIdentifier.equals(id) && (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING || uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING))) {\n                    throw new ItemExistsException(\"Node with the same UUID exists:\" + existing);\n                }\n            // fall through\n            }\n        }\n    }\n    if (tree == null) {\n        // create node\n        if (id == null) {\n            // no potential uuid conflict, always add new node\n            tree = createTree(parent, nodeInfo, null);\n        } else if (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {\n            // always create a new UUID even if no\n            // conflicting node exists. see OAK-1244\n            tree = createTree(parent, nodeInfo, UUID.randomUUID().toString());\n            // remember uuid mapping\n            if (isNodeType(tree, JcrConstants.MIX_REFERENCEABLE)) {\n                refTracker.put(nodeInfo.getUUID(), TreeUtil.getString(tree, JcrConstants.JCR_UUID));\n            }\n        } else {\n            // 1. First check from base state that tree corresponding to\n            // this id exist\n            Tree conflicting = baseStateIdManager.getTree(id);\n            if (conflicting == null) {\n                // 1.a. Check if id is found in newly created nodes\n                if (uuids.contains(id)) {\n                    conflicting = currentStateIdManager.getTree(id);\n                }\n            } else {\n                // 1.b Re obtain the conflicting tree from Id Manager\n                // associated with current root. Such that any operation\n                // on it gets reflected in later operations\n                // In case a tree with same id was removed earlier then it\n                // would return null\n                conflicting = currentStateIdManager.getTree(id);\n            }\n            if (conflicting != null && conflicting.exists()) {\n                // resolve uuid conflict\n                tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);\n                if (tree == null) {\n                    // no new node has been created, so skip this node\n                    // push null onto stack for skipped node\n                    parents.push(null);\n                    log.debug(\"Skipping existing node \" + nodeInfo.getName());\n                    return;\n                }\n            } else {\n                // create new with given uuid\n                tree = createTree(parent, nodeInfo, id);\n            }\n        }\n    }\n    // process properties\n    importProperties(tree, propInfos, false);\n    parents.push(tree);\n}", "code_comment": "/**\n * let ProtectedPropertyImporters handle the properties\n * associated with the imported node. this may include overwriting,\n * merging or just adding missing properties.\n */\n", "code_no_comment": "@Override\npublic void startNode(NodeInfo nodeInfo, List<PropInfo> propInfos) throws RepositoryException {\n    Tree parent = parents.peek();\n    Tree tree = null;\n    String id = nodeInfo.getUUID();\n    String nodeName = nodeInfo.getName();\n    String ntName = nodeInfo.getPrimaryTypeName();\n    if (parent == null) {\n        log.debug(\"Skipping node: \" + nodeName);\n                        parents.push(null);\n                if (pnImporter != null) {\n            pnImporter.startChildInfo(nodeInfo, propInfos);\n        }\n        return;\n    }\n    NodeDefinition parentDef = getDefinition(parent);\n    if (parentDef.isProtected()) {\n                parents.push(null);\n        log.debug(\"Skipping protected node: \" + nodeName);\n        if (pnImporter != null) {\n                                    pnImporter.startChildInfo(nodeInfo, propInfos);\n        } else {\n                        for (ProtectedNodeImporter pni : getNodeImporters()) {\n                if (pni.start(parent)) {\n                    log.debug(\"Protected node -> delegated to ProtectedNodeImporter\");\n                    pnImporter = pni;\n                    pnImporter.startChildInfo(nodeInfo, propInfos);\n                    break;\n                }\n                        }\n        }\n        return;\n    }\n    if (parent.hasChild(nodeName)) {\n                Tree existing = parent.getChild(nodeName);\n        NodeDefinition def = getDefinition(existing);\n        if (!def.allowsSameNameSiblings()) {\n                        if (def.isProtected() && isNodeType(existing, ntName)) {\n                                log.debug(\"Skipping protected node: \" + existing);\n                parents.push(existing);\n                /**\n                 * let ProtectedPropertyImporters handle the properties\n                 * associated with the imported node. this may include overwriting,\n                 * merging or just adding missing properties.\n                 */\n                importProperties(existing, propInfos, true);\n                return;\n            }\n            if (def.isAutoCreated() && isNodeType(existing, ntName)) {\n                                tree = existing;\n            } else {\n                                                String existingIdentifier = IdentifierManager.getIdentifier(existing);\n                if (!(existingIdentifier.equals(id) && (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING || uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING))) {\n                    throw new ItemExistsException(\"Node with the same UUID exists:\" + existing);\n                }\n                        }\n        }\n    }\n    if (tree == null) {\n                if (id == null) {\n                        tree = createTree(parent, nodeInfo, null);\n        } else if (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {\n                                    tree = createTree(parent, nodeInfo, UUID.randomUUID().toString());\n                        if (isNodeType(tree, JcrConstants.MIX_REFERENCEABLE)) {\n                refTracker.put(nodeInfo.getUUID(), TreeUtil.getString(tree, JcrConstants.JCR_UUID));\n            }\n        } else {\n                                    Tree conflicting = baseStateIdManager.getTree(id);\n            if (conflicting == null) {\n                                if (uuids.contains(id)) {\n                    conflicting = currentStateIdManager.getTree(id);\n                }\n            } else {\n                                                                                                conflicting = currentStateIdManager.getTree(id);\n            }\n            if (conflicting != null && conflicting.exists()) {\n                                tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);\n                if (tree == null) {\n                                                            parents.push(null);\n                    log.debug(\"Skipping existing node \" + nodeInfo.getName());\n                    return;\n                }\n            } else {\n                                tree = createTree(parent, nodeInfo, id);\n            }\n        }\n    }\n        importProperties(tree, propInfos, false);\n    parents.push(tree);\n}", "lc": 3.4545454545454546, "pi": 1.2448979591836735, "ma": 3.0, "nbd": 1.5, "ml": 3.1666666666666665, "d": 1.2189817103311915, "mi": -1.3117292801835392, "fo": 3.5833333333333335, "r": -0.028571428571428574, "e": 5.490536703200688}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7429_43956f93", "label": 1, "code": "public String parseUri(String text, Properties properties, String prefixToken, String suffixToken, String propertyPrefix, String propertySuffix, boolean fallbackToUnaugmentedProperty) throws IllegalArgumentException {\n    String answer = text;\n    boolean done = false;\n    // the placeholders can contain nested placeholders so we need to do recursive parsing\n    // we must therefore also do circular reference check and must keep a list of visited keys\n    List<String> visited = new ArrayList<String>();\n    while (!done) {\n        List<String> replaced = new ArrayList<String>();\n        answer = doParseUri(answer, properties, replaced, prefixToken, suffixToken, propertyPrefix, propertySuffix, fallbackToUnaugmentedProperty);\n        // check the replaced with the visited to avoid circular reference\n        for (String replace : replaced) {\n            if (visited.contains(replace)) {\n                throw new IllegalArgumentException(\"Circular reference detected with key [\" + replace + \"] from text: \" + text);\n            }\n        }\n        // okay all okay so add the replaced as visited\n        visited.addAll(replaced);\n        // we are done when we can no longer find any prefix tokens in the answer\n        done = findTokenPosition(answer, 0, prefixToken) == -1;\n    }\n    return answer;\n}", "code_comment": NaN, "code_no_comment": "public String parseUri(String text, Properties properties, String prefixToken, String suffixToken, String propertyPrefix, String propertySuffix, boolean fallbackToUnaugmentedProperty) throws IllegalArgumentException {\n    String answer = text;\n    boolean done = false;\n            List<String> visited = new ArrayList<String>();\n    while (!done) {\n        List<String> replaced = new ArrayList<String>();\n        answer = doParseUri(answer, properties, replaced, prefixToken, suffixToken, propertyPrefix, propertySuffix, fallbackToUnaugmentedProperty);\n                for (String replace : replaced) {\n            if (visited.contains(replace)) {\n                throw new IllegalArgumentException(\"Circular reference detected with key [\" + replace + \"] from text: \" + text);\n            }\n        }\n                visited.addAll(replaced);\n                done = findTokenPosition(answer, 0, prefixToken) == -1;\n    }\n    return answer;\n}", "lc": 0.13636363636363635, "pi": 0.5510204081632651, "ma": 0.16666666666666666, "nbd": 0.5, "ml": 0.0, "d": 0.5229856648541772, "mi": -0.2050473186119876, "fo": -0.16666666666666666, "r": -0.028571428571428574, "e": 0.5666456799482613}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1093_531aca78", "label": 1, "code": "@Override\npublic Value[] getValues() throws RepositoryException {\n    PropertyValue[] values = row.getValues();\n    int len = values.length;\n    Value[] v2 = new Value[values.length];\n    for (int i = 0; i < len; i++) {\n        if (values[i].isArray()) {\n            v2[i] = result.createValue(mvpToString(values[i]));\n        } else {\n            v2[i] = result.createValue(values[i]);\n        }\n    }\n    return v2;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Value[] getValues() throws RepositoryException {\n    PropertyValue[] values = row.getValues();\n    int len = values.length;\n    Value[] v2 = new Value[values.length];\n    for (int i = 0; i < len; i++) {\n        if (values[i].isArray()) {\n            v2[i] = result.createValue(mvpToString(values[i]));\n        } else {\n            v2[i] = result.createValue(values[i]);\n        }\n    }\n    return v2;\n}", "lc": 0.0, "pi": 0.413265306122449, "ma": -0.16666666666666666, "nbd": 0.0, "ml": 0.0, "d": 0.07217004448838364, "mi": -0.010897619730427174, "fo": -0.08333333333333333, "r": 0.17142857142857146, "e": 0.03536476201489629}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3620_1a2bc1bc", "label": 1, "code": "/**\n *  Runs the configured {@link IResponseFilter}s over the constructed Ajax response\n *\n *  @param contentResponse\n *             the Ajax {@link Response} body\n */\nprivate void invokeResponseFilters(final StringResponse contentResponse) {\n    AppendingStringBuffer responseBuffer = new AppendingStringBuffer(contentResponse.getBuffer());\n    List<IResponseFilter> responseFilters = Application.get().getRequestCycleSettings().getResponseFilters();\n    if (responseFilters != null) {\n        for (IResponseFilter filter : responseFilters) {\n            filter.filter(responseBuffer);\n        }\n    }\n}", "code_comment": "/**\n *  Runs the configured {@link IResponseFilter}s over the constructed Ajax response\n *\n *  @param contentResponse\n *             the Ajax {@link Response} body\n */\n", "code_no_comment": "private void invokeResponseFilters(final StringResponse contentResponse) {\n    AppendingStringBuffer responseBuffer = new AppendingStringBuffer(contentResponse.getBuffer());\n    List<IResponseFilter> responseFilters = Application.get().getRequestCycleSettings().getResponseFilters();\n    if (responseFilters != null) {\n        for (IResponseFilter filter : responseFilters) {\n            filter.filter(responseBuffer);\n        }\n    }\n}", "lc": -0.22727272727272727, "pi": 0.32653061224489804, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.25, "d": -0.08403361344537813, "mi": 0.28219099512474927, "fo": -0.08333333333333333, "r": 2.0285714285714285, "e": -0.09189612859290477}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-276_1bf5c550", "label": 1, "code": "public Id readHead() throws Exception {\n    Connection con = cp.getConnection();\n    try {\n        PreparedStatement stmt = con.prepareStatement(\"select * from HEAD\");\n        ResultSet rs = stmt.executeQuery();\n        byte[] rawId = null;\n        if (rs.next()) {\n            rawId = rs.getBytes(1);\n        }\n        stmt.close();\n        return rawId == null ? null : new Id(rawId);\n    } finally {\n        con.close();\n    }\n}", "code_comment": NaN, "code_no_comment": "public Id readHead() throws Exception {\n    Connection con = cp.getConnection();\n    try {\n        PreparedStatement stmt = con.prepareStatement(\"select * from HEAD\");\n        ResultSet rs = stmt.executeQuery();\n        byte[] rawId = null;\n        if (rs.next()) {\n            rawId = rs.getBytes(1);\n        }\n        stmt.close();\n        return rawId == null ? null : new Id(rawId);\n    } finally {\n        con.close();\n    }\n}", "lc": 0.045454545454545456, "pi": 0.10204081632653071, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.06030647553138898, "mi": -0.025810151993117463, "fo": 0.08333333333333333, "r": 0.7714285714285716, "e": -0.038756900989802175}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-442_246d53c5", "label": 1, "code": "/**\n *  Call this method when the current (ajax) request shouldn't merge\n *  the changes that are happening to the page with the previous version.\n *\n *  This is for example needed when you want to redirect to this\n *  page in an ajax request and then you do want to version normally..\n *\n *  This method doesn't do anything if the getRequest().mergeVersion\n *  doesn't return true.\n */\npublic final void ignoreVersionMerge() {\n    if (getRequest().mergeVersion()) {\n        mayTrackChangesFor(this, null);\n        if (versionManager != null) {\n            versionManager.ignoreVersionMerge();\n        }\n    }\n}", "code_comment": "/**\n *  Call this method when the current (ajax) request shouldn't merge\n *  the changes that are happening to the page with the previous version.\n *\n *  This is for example needed when you want to redirect to this\n *  page in an ajax request and then you do want to version normally..\n *\n *  This method doesn't do anything if the getRequest().mergeVersion\n *  doesn't return true.\n */\n", "code_no_comment": "public final void ignoreVersionMerge() {\n    if (getRequest().mergeVersion()) {\n        mayTrackChangesFor(this, null);\n        if (versionManager != null) {\n            versionManager.ignoreVersionMerge();\n        }\n    }\n}", "lc": -0.2727272727272727, "pi": 0.4846938775510205, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.3806228373702422, "mi": 0.5199311729280184, "fo": -0.16666666666666666, "r": 1.9428571428571428, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-393_d4b02f6a", "label": 3, "code": "/**\n * Get the result of the last run of the optimizer.\n *\n * @return the last result.\n * @throws IllegalStateException if there is no result available, either\n * because no result was yet computed or the last attempt failed.\n */\ndouble getResult();", "code_comment": "/**\n * Get the result of the last run of the optimizer.\n *\n * @return the last result.\n * @throws IllegalStateException if there is no result available, either\n * because no result was yet computed or the last attempt failed.\n */\n", "code_no_comment": "double getResult();", "lc": -0.5909090909090909, "pi": -1.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.9174075136220248, "fo": -0.5, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2330_408a566e", "label": 3, "code": "private boolean indexAggregates(final String path, final List<Field> fields, final NodeState state) throws CommitFailedException {\n    final AtomicBoolean dirtyFlag = new AtomicBoolean();\n    indexingRule.getAggregate().collectAggregates(state, new Aggregate.ResultCollector() {\n\n        @Override\n        public void onResult(Aggregate.NodeIncludeResult result) throws CommitFailedException {\n            boolean dirty = indexAggregatedNode(path, fields, result);\n            if (dirty) {\n                dirtyFlag.set(true);\n            }\n        }\n\n        @Override\n        public void onResult(Aggregate.PropertyIncludeResult result) throws CommitFailedException {\n            boolean dirty = false;\n            if (result.pd.ordered) {\n                dirty |= addTypedOrderedFields(fields, result.propertyState, result.propertyPath, result.pd);\n            }\n            dirty |= indexProperty(path, fields, state, result.propertyState, result.propertyPath, true, result.pd);\n            if (dirty) {\n                dirtyFlag.set(true);\n            }\n        }\n    });\n    return dirtyFlag.get();\n}", "code_comment": NaN, "code_no_comment": "private boolean indexAggregates(final String path, final List<Field> fields, final NodeState state) throws CommitFailedException {\n    final AtomicBoolean dirtyFlag = new AtomicBoolean();\n    indexingRule.getAggregate().collectAggregates(state, new Aggregate.ResultCollector() {\n\n        @Override\n        public void onResult(Aggregate.NodeIncludeResult result) throws CommitFailedException {\n            boolean dirty = indexAggregatedNode(path, fields, result);\n            if (dirty) {\n                dirtyFlag.set(true);\n            }\n        }\n\n        @Override\n        public void onResult(Aggregate.PropertyIncludeResult result) throws CommitFailedException {\n            boolean dirty = false;\n            if (result.pd.ordered) {\n                dirty |= addTypedOrderedFields(fields, result.propertyState, result.propertyPath, result.pd);\n            }\n            dirty |= indexProperty(path, fields, state, result.propertyState, result.propertyPath, true, result.pd);\n            if (dirty) {\n                dirtyFlag.set(true);\n            }\n        }\n    });\n    return dirtyFlag.get();\n}", "lc": 0.45454545454545453, "pi": 0.7755102040816326, "ma": 0.0, "nbd": 0.0, "ml": 0.0, "d": 0.03855659911023239, "mi": -0.36851161456839726, "fo": 0.16666666666666666, "r": -0.028571428571428574, "e": 0.196829720619665}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1310_c6318b63", "label": 1, "code": "/**\n * Looks up the value of the JNDI resource.\n * @param event The current LogEvent (is ignored by this StrLookup).\n * @param key  the JNDI resource name to be looked up, may be null\n * @return The value of the JNDI resource.\n */\n@Override\npublic String lookup(final LogEvent event, final String key) {\n    if (key == null) {\n        return null;\n    }\n    final String jndiName = convertJndiName(key);\n    final JndiManager jndiManager = JndiManager.getDefaultManager();\n    try {\n        return jndiManager.lookup(jndiName);\n    } catch (final NamingException e) {\n        LOGGER.warn(LOOKUP, \"Error looking up JNDI resource [{}].\", jndiName, e);\n        return null;\n    } finally {\n        jndiManager.release();\n    }\n}", "code_comment": "/**\n * Looks up the value of the JNDI resource.\n * @param event The current LogEvent (is ignored by this StrLookup).\n * @param key  the JNDI resource name to be looked up, may be null\n * @return The value of the JNDI resource.\n */\n", "code_no_comment": "@Override\npublic String lookup(final LogEvent event, final String key) {\n    if (key == null) {\n        return null;\n    }\n    final String jndiName = convertJndiName(key);\n    final JndiManager jndiManager = JndiManager.getDefaultManager();\n    try {\n        return jndiManager.lookup(jndiName);\n    } catch (final NamingException e) {\n        LOGGER.warn(LOOKUP, \"Error looking up JNDI resource [{}].\", jndiName, e);\n        return null;\n    } finally {\n        jndiManager.release();\n    }\n}", "lc": 0.09090909090909091, "pi": -0.12244897959183684, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.25, "d": -0.054374691052891735, "mi": -0.037854889589905585, "fo": -0.08333333333333333, "r": 0.39999999999999997, "e": -0.05077500952968336}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6779_f412d744", "label": 1, "code": "@Converter\npublic XMLStreamReader createXMLStreamReader(InputStream in, Exchange exchange) throws XMLStreamException {\n    XMLInputFactory factory = getInputFactory();\n    try {\n        return factory.createXMLStreamReader(IOHelper.buffered(in), IOHelper.getCharsetName(exchange));\n    } finally {\n        returnXMLInputFactory(factory);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Converter\npublic XMLStreamReader createXMLStreamReader(InputStream in, Exchange exchange) throws XMLStreamException {\n    XMLInputFactory factory = getInputFactory();\n    try {\n        return factory.createXMLStreamReader(IOHelper.buffered(in), IOHelper.getCharsetName(exchange));\n    } finally {\n        returnXMLInputFactory(factory);\n    }\n}", "lc": -0.22727272727272727, "pi": -0.035714285714285636, "ma": -0.5, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.3223401204473759, "fo": -0.08333333333333333, "r": 0.31428571428571433, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-434_133cbc2d", "label": 1, "code": "/**\n * Solves Phase 1 of the Simplex method.\n * @param tableau simple tableau for the problem\n * @exception OptimizationException if the maximal number of iterations is\n * exceeded, or if the problem is found not to have a bounded solution, or\n * if there is no feasible solution\n */\nprotected void solvePhase1(final SimplexTableau tableau) throws OptimizationException {\n    // make sure we're in Phase 1\n    if (tableau.getNumArtificialVariables() == 0) {\n        return;\n    }\n    while (!tableau.isOptimal()) {\n        doIteration(tableau);\n    }\n    // if W is not zero then we have no feasible solution\n    if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0, epsilon)) {\n        throw new NoFeasibleSolutionException();\n    }\n}", "code_comment": "/**\n * Solves Phase 1 of the Simplex method.\n * @param tableau simple tableau for the problem\n * @exception OptimizationException if the maximal number of iterations is\n * exceeded, or if the problem is found not to have a bounded solution, or\n * if there is no feasible solution\n */\n", "code_no_comment": "protected void solvePhase1(final SimplexTableau tableau) throws OptimizationException {\n        if (tableau.getNumArtificialVariables() == 0) {\n        return;\n    }\n    while (!tableau.isOptimal()) {\n        doIteration(tableau);\n    }\n        if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0, epsilon)) {\n        throw new NoFeasibleSolutionException();\n    }\n}", "lc": -0.13636363636363635, "pi": -0.17857142857142863, "ma": 0.16666666666666666, "nbd": -0.5, "ml": 0.3333333333333333, "d": -0.08996539792387542, "mi": 0.1901347863492973, "fo": 0.0, "r": 0.05714285714285714, "e": -0.10003811873343013}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5071_d3d42d42", "label": 1, "code": "/**\n *  Matches when the request url starts with\n *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\n *  or when the base url starts with\n *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\n *  and the request url with {@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\n *\n *  @param request\n *       the request to check\n *  @return {@code true} if the conditions match\n */\nprivate boolean matches(final Request request) {\n    boolean matches = false;\n    Url url = request.getUrl();\n    String namespace = getContext().getNamespace();\n    String pageIdentifier = getContext().getPageIdentifier();\n    if (urlStartsWith(url, namespace, pageIdentifier)) {\n        matches = true;\n    } else if (urlStartsWith(request.getClientUrl(), namespace, pageIdentifier) && urlStartsWith(url, pageIdentifier)) {\n        matches = true;\n    } else if (urlStartsWith(request.getClientUrl(), pageIdentifier) && urlStartsWith(url, pageIdentifier)) {\n        matches = true;\n    }\n    return matches;\n}", "code_comment": "/**\n *  Matches when the request url starts with\n *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\n *  or when the base url starts with\n *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\n *  and the request url with {@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\n *\n *  @param request\n *       the request to check\n *  @return {@code true} if the conditions match\n */\n", "code_no_comment": "private boolean matches(final Request request) {\n    boolean matches = false;\n    Url url = request.getUrl();\n    String namespace = getContext().getNamespace();\n    String pageIdentifier = getContext().getPageIdentifier();\n    if (urlStartsWith(url, namespace, pageIdentifier)) {\n        matches = true;\n    } else if (urlStartsWith(request.getClientUrl(), namespace, pageIdentifier) && urlStartsWith(url, pageIdentifier)) {\n        matches = true;\n    } else if (urlStartsWith(request.getClientUrl(), pageIdentifier) && urlStartsWith(url, pageIdentifier)) {\n        matches = true;\n    }\n    return matches;\n}", "lc": 0.0, "pi": -0.33163265306122447, "ma": 0.0, "nbd": 0.5, "ml": 0.6666666666666666, "d": 0.13148788927335642, "mi": -0.03297963865787227, "fo": 0.5, "r": -0.028571428571428574, "e": 0.0853516988534399}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1933_2e16a983", "label": 1, "code": "/**\n * The estimated number of entries. This value does not have to be\n * accurate.\n *\n * @return the estimated number of entries\n */\nlong getEstimatedEntryCount();", "code_comment": "/**\n * The estimated number of entries. This value does not have to be\n * accurate.\n *\n * @return the estimated number of entries\n */\n", "code_no_comment": "long getEstimatedEntryCount();", "lc": -0.5909090909090909, "pi": -1.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.9174075136220248, "fo": -0.5, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4505_a4caaa57", "label": 1, "code": "@Override\npublic final Object put(String key, Object value) {\n    return super.put(key, unescapeHtml(value));\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic final Object put(String key, Object value) {\n    return super.put(key, unescapeHtml(value));\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8422712933753946, "fo": -0.3333333333333333, "r": 0.39999999999999997, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-428_d906576c", "label": 3, "code": "public Iterator iterator() {\n    return new Iterator() {\n\n        public boolean hasNext() {\n            return index < MicroMap.this.size();\n        }\n\n        public Object next() {\n            index++;\n            return key;\n        }\n\n        public void remove() {\n            MicroMap.this.clear();\n        }\n\n        int index;\n    };\n}", "code_comment": NaN, "code_no_comment": "public Iterator iterator() {\n    return new Iterator() {\n\n        public boolean hasNext() {\n            return index < MicroMap.this.size();\n        }\n\n        public Object next() {\n            index++;\n            return key;\n        }\n\n        public void remove() {\n            MicroMap.this.clear();\n        }\n\n        int index;\n    };\n}", "lc": 0.045454545454545456, "pi": 0.413265306122449, "ma": -0.5, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.11764705882352938, "mi": 0.1322053340980786, "fo": -0.3333333333333333, "r": 2.342857142857143, "e": -0.12508940770341057}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5345_3fc7234e", "label": 1, "code": "/**\n *  Try to reduce url by eliminating '..' and '.' from the path where appropriate (this is\n *  somehow similar to {@link java.io.File#getCanonicalPath()}). Either by different / unexpected\n *  browser behavior or by malicious attacks it can happen that these kind of redundant urls are\n *  processed by wicket. These urls can cause some trouble when mapping the request.\n *  <p/>\n *  <strong>example:</strong>\n *\n *  the url\n *\n *  <pre>\n *  /example/..;jsessionid=234792?0\n *  </pre>\n *\n *  will not get normalized by the browser due to the ';jsessionid' string that gets appended by\n *  the servlet container. After wicket strips the jsessionid part the resulting internal url\n *  will be\n *\n *  <pre>\n *  /example/..\n *  </pre>\n *\n *  instead of\n *\n *  <pre>\n *  /\n *  </pre>\n *\n *  <p/>\n *\n *  This code correlates to <a\n *  href=\"https://issues.apache.org/jira/browse/WICKET-4303\">WICKET-4303</a>\n *\n *  @return canonical url\n */\npublic Url canonical() {\n    Url url = new Url(this);\n    url.segments.clear();\n    for (int i = 0; i < segments.size(); i++) {\n        final String segment = segments.get(i);\n        // drop '.' from path\n        if (\".\".equals(segment)) {\n            continue;\n        }\n        // skip segment if following segment is a '..'\n        if ((i + 1) < segments.size() && \"..\".equals(segments.get(i + 1))) {\n            i++;\n            continue;\n        }\n        url.segments.add(segment);\n    }\n    return url;\n}", "code_comment": "/**\n *  Try to reduce url by eliminating '..' and '.' from the path where appropriate (this is\n *  somehow similar to {@link java.io.File#getCanonicalPath()}). Either by different / unexpected\n *  browser behavior or by malicious attacks it can happen that these kind of redundant urls are\n *  processed by wicket. These urls can cause some trouble when mapping the request.\n *  <p/>\n *  <strong>example:</strong>\n *\n *  the url\n *\n *  <pre>\n *  /example/..;jsessionid=234792?0\n *  </pre>\n *\n *  will not get normalized by the browser due to the ';jsessionid' string that gets appended by\n *  the servlet container. After wicket strips the jsessionid part the resulting internal url\n *  will be\n *\n *  <pre>\n *  /example/..\n *  </pre>\n *\n *  instead of\n *\n *  <pre>\n *  /\n *  </pre>\n *\n *  <p/>\n *\n *  This code correlates to <a\n *  href=\"https://issues.apache.org/jira/browse/WICKET-4303\">WICKET-4303</a>\n *\n *  @return canonical url\n */\n", "code_no_comment": "public Url canonical() {\n    Url url = new Url(this);\n    url.segments.clear();\n    for (int i = 0; i < segments.size(); i++) {\n        final String segment = segments.get(i);\n                if (\".\".equals(segment)) {\n            continue;\n        }\n                if ((i + 1) < segments.size() && \"..\".equals(segments.get(i + 1))) {\n            i++;\n            continue;\n        }\n        url.segments.add(segment);\n    }\n    return url;\n}", "lc": 0.09090909090909091, "pi": 0.3520408163265306, "ma": 0.3333333333333333, "nbd": 0.0, "ml": 0.4166666666666667, "d": 0.5269401878398419, "mi": -0.10381416690564972, "fo": 0.16666666666666666, "r": 0.05714285714285714, "e": 0.26518217756476975}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-657_97b440fc", "label": 3, "code": "/**\n * Returns a {@code Complex} whose value is {@code (this / divisor)},\n * with {@code divisor} interpreted as a real number.\n *\n * @param  divisor Value by which this {@code Complex} is to be divided.\n * @return {@code this / divisor}.\n * @see #divide(Complex)\n */\npublic Complex divide(double divisor) {\n    if (isNaN || Double.isNaN(divisor)) {\n        return NaN;\n    }\n    if (divisor == 0d) {\n        return isZero ? NaN : INF;\n    }\n    if (Double.isInfinite(divisor)) {\n        return !isInfinite() ? ZERO : NaN;\n    }\n    return createComplex(real / divisor, imaginary / divisor);\n}", "code_comment": "/**\n * Returns a {@code Complex} whose value is {@code (this / divisor)},\n * with {@code divisor} interpreted as a real number.\n *\n * @param  divisor Value by which this {@code Complex} is to be divided.\n * @return {@code this / divisor}.\n * @see #divide(Complex)\n */\n", "code_no_comment": "public Complex divide(double divisor) {\n    if (isNaN || Double.isNaN(divisor)) {\n        return NaN;\n    }\n    if (divisor == 0d) {\n        return isZero ? NaN : INF;\n    }\n    if (Double.isInfinite(divisor)) {\n        return !isInfinite() ? ZERO : NaN;\n    }\n    return createComplex(real / divisor, imaginary / divisor);\n}", "lc": -0.09090909090909091, "pi": -0.2346938775510204, "ma": 0.3333333333333333, "nbd": -0.5, "ml": 0.5833333333333334, "d": 0.2778052397429561, "mi": 0.11041009463722384, "fo": -0.16666666666666666, "r": 0.3428571428571429, "e": 0.017710220531863417}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5359_61122bab", "label": 3, "code": "/**\n *  Convert to duration, returning default value if text is inconvertible.\n *\n *  @param defaultValue\n *             the default value\n *  @return the converted text as a duration or the default value if text is empty or inconvertible\n *  @see Duration#valueOf(String, java.util.Locale)\n */\npublic final Duration toDuration(final Duration defaultValue) {\n    if (text != null) {\n        try {\n            return toDuration();\n        } catch (Exception x) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(String.format(\"An error occurred while converting '%s' to a Duration: %s\", text, x.getMessage()), x);\n            }\n        }\n    }\n    return defaultValue;\n}", "code_comment": "/**\n *  Convert to duration, returning default value if text is inconvertible.\n *\n *  @param defaultValue\n *             the default value\n *  @return the converted text as a duration or the default value if text is empty or inconvertible\n *  @see Duration#valueOf(String, java.util.Locale)\n */\n", "code_no_comment": "public final Duration toDuration(final Duration defaultValue) {\n    if (text != null) {\n        try {\n            return toDuration();\n        } catch (Exception x) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(String.format(\"An error occurred while converting '%s' to a Duration: %s\", text, x.getMessage()), x);\n            }\n        }\n    }\n    return defaultValue;\n}", "lc": -0.09090909090909091, "pi": 0.933673469387755, "ma": 0.0, "nbd": 0.5, "ml": -0.08333333333333333, "d": -0.3806228373702422, "mi": 0.17206767995411534, "fo": -0.08333333333333333, "r": 0.7714285714285716, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-924_2836a6f9", "label": 0, "code": "/**\n * Computes the square-root of the weight matrix.\n *\n * @param m Symmetric, positive-definite (weight) matrix.\n * @return the square-root of the weight matrix.\n */\nprivate RealMatrix squareRoot(RealMatrix m) {\n    final EigenDecomposition dec = new EigenDecomposition(m);\n    return dec.getSquareRoot();\n}", "code_comment": "/**\n * Computes the square-root of the weight matrix.\n *\n * @param m Symmetric, positive-definite (weight) matrix.\n * @return the square-root of the weight matrix.\n */\n", "code_no_comment": "private RealMatrix squareRoot(RealMatrix m) {\n    final EigenDecomposition dec = new EigenDecomposition(m);\n    return dec.getSquareRoot();\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8422712933753946, "fo": -0.4166666666666667, "r": 2.7714285714285714, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5783_7b8b6767", "label": 1, "code": "@Override\nprotected void updateAjaxAttributes(AjaxRequestAttributes attributes) {\n    super.updateAjaxAttributes(attributes);\n    attributes.setEventNames(event);\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected void updateAjaxAttributes(AjaxRequestAttributes attributes) {\n    super.updateAjaxAttributes(attributes);\n    attributes.setEventNames(event);\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7757384571264698, "fo": -0.3333333333333333, "r": 0.4857142857142857, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5565_204849bc", "label": 1, "code": "/**\n *  @see IRequestMapper#getCompatibilityScore(Request)\n */\n@Override\npublic abstract int getCompatibilityScore(Request request);", "code_comment": "/**\n *  @see IRequestMapper#getCompatibilityScore(Request)\n */\n", "code_no_comment": "@Override\npublic abstract int getCompatibilityScore(Request request);", "lc": -0.5454545454545454, "pi": -1.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.332950960711213, "fo": -0.5, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3433_b76b31f7", "label": 0, "code": "void acquiring();", "code_comment": NaN, "code_no_comment": "void acquiring();", "lc": -0.5909090909090909, "pi": -1.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.9174075136220248, "fo": -0.5, "r": 2.428571428571429, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 144, "label": 2, "code": "/**\n * Builds the function type, and puts it in the registry.\n */\nFunctionType buildAndRegister() {\n    if (returnType == null) {\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode == null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (scope.isGlobal() && !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces != null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}", "code_comment": "/**\n * Builds the function type, and puts it in the registry.\n */\n", "code_no_comment": "FunctionType buildAndRegister() {\n    if (returnType == null) {\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode == null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (scope.isGlobal() && !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces != null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}", "lc": 0.5454545454545454, "pi": -0.1479591836734694, "ma": 0.6666666666666666, "nbd": 0.5, "ml": 0.75, "d": 0.2718734552644588, "mi": -0.4241468310868945, "fo": 1.0, "r": -0.028571428571428574, "e": 0.368839434472184}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1496_0a4c7694", "label": 1, "code": "public void updateInputChannel(PartitionInfo partitionInfo) throws IOException {\n    synchronized (requestLock) {\n        if (isReleased) {\n            // There was a race with a task failure/cancel\n            return;\n        }\n        final IntermediateResultPartitionID partitionId = partitionInfo.getPartitionId();\n        InputChannel current = inputChannels.get(partitionId);\n        if (current.getClass() == UnknownInputChannel.class) {\n            UnknownInputChannel unknownChannel = (UnknownInputChannel) current;\n            InputChannel newChannel;\n            if (partitionInfo.getProducerLocation() == PartitionLocation.REMOTE) {\n                newChannel = unknownChannel.toRemoteInputChannel(partitionInfo.getProducerAddress());\n            } else if (partitionInfo.getProducerLocation() == PartitionLocation.LOCAL) {\n                newChannel = unknownChannel.toLocalInputChannel();\n            } else {\n                throw new IllegalStateException(\"Tried to update unknown channel with unknown channel.\");\n            }\n            inputChannels.put(partitionId, newChannel);\n            newChannel.requestIntermediateResultPartition(queueToRequest);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "public void updateInputChannel(PartitionInfo partitionInfo) throws IOException {\n    synchronized (requestLock) {\n        if (isReleased) {\n                        return;\n        }\n        final IntermediateResultPartitionID partitionId = partitionInfo.getPartitionId();\n        InputChannel current = inputChannels.get(partitionId);\n        if (current.getClass() == UnknownInputChannel.class) {\n            UnknownInputChannel unknownChannel = (UnknownInputChannel) current;\n            InputChannel newChannel;\n            if (partitionInfo.getProducerLocation() == PartitionLocation.REMOTE) {\n                newChannel = unknownChannel.toRemoteInputChannel(partitionInfo.getProducerAddress());\n            } else if (partitionInfo.getProducerLocation() == PartitionLocation.LOCAL) {\n                newChannel = unknownChannel.toLocalInputChannel();\n            } else {\n                throw new IllegalStateException(\"Tried to update unknown channel with unknown channel.\");\n            }\n            inputChannels.put(partitionId, newChannel);\n            newChannel.requestIntermediateResultPartition(queueToRequest);\n        }\n    }\n}", "lc": 0.36363636363636365, "pi": 0.7346938775510204, "ma": 0.3333333333333333, "nbd": 1.0, "ml": 0.16666666666666666, "d": -0.05042016806722688, "mi": -0.293948953254947, "fo": 0.3333333333333333, "r": -0.028571428571428574, "e": 0.0427829245206248}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-3634_9339ecf8", "label": 3, "code": "private int updateAuthKeys(String path) throws KeeperException, InterruptedException {\n    int keysAdded = 0;\n    for (String child : zk.getChildren(path, this)) {\n        String childPath = path + \"/\" + child;\n        // Get the node data and reset the watcher\n        AuthenticationKey key = deserializeKey(zk.getData(childPath, this, null));\n        secretManager.addKey(key);\n        keysAdded++;\n    }\n    return keysAdded;\n}", "code_comment": NaN, "code_no_comment": "private int updateAuthKeys(String path) throws KeeperException, InterruptedException {\n    int keysAdded = 0;\n    for (String child : zk.getChildren(path, this)) {\n        String childPath = path + \"/\" + child;\n                AuthenticationKey key = deserializeKey(zk.getData(childPath, this, null));\n        secretManager.addKey(key);\n        keysAdded++;\n    }\n    return keysAdded;\n}", "lc": -0.18181818181818182, "pi": -0.015306122448979493, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.08403361344537813, "mi": 0.18898766848293677, "fo": -0.16666666666666666, "r": 0.37142857142857144, "e": -0.06251043982165572}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2603_77d2d3b0", "label": 1, "code": "private void collectDeletedDocuments(VersionGCStats stats, Revision headRevision, long oldestRevTimeStamp) {\n    List<String> docIdsToDelete = new ArrayList<String>();\n    Iterable<NodeDocument> itr = versionStore.getPossiblyDeletedDocs(oldestRevTimeStamp);\n    try {\n        for (NodeDocument doc : itr) {\n            // So deleting it is safe\n            if (doc.getNodeAtRevision(nodeStore, headRevision, null) == null) {\n                docIdsToDelete.add(doc.getId());\n                // Collect id of all previous docs also\n                for (NodeDocument prevDoc : ImmutableList.copyOf(doc.getAllPreviousDocs())) {\n                    docIdsToDelete.add(prevDoc.getId());\n                }\n            }\n        }\n    } finally {\n        Utils.closeIfCloseable(itr);\n    }\n    if (log.isDebugEnabled()) {\n        StringBuilder sb = new StringBuilder(\"Deleted document with following ids were deleted as part of GC \\n\");\n        Joiner.on(StandardSystemProperty.LINE_SEPARATOR.value()).appendTo(sb, docIdsToDelete);\n        log.debug(sb.toString());\n    }\n    nodeStore.getDocumentStore().remove(Collection.NODES, docIdsToDelete);\n    nodeStore.invalidateDocChildrenCache();\n    stats.deletedDocGCCount += docIdsToDelete.size();\n}", "code_comment": NaN, "code_no_comment": "private void collectDeletedDocuments(VersionGCStats stats, Revision headRevision, long oldestRevTimeStamp) {\n    List<String> docIdsToDelete = new ArrayList<String>();\n    Iterable<NodeDocument> itr = versionStore.getPossiblyDeletedDocs(oldestRevTimeStamp);\n    try {\n        for (NodeDocument doc : itr) {\n                        if (doc.getNodeAtRevision(nodeStore, headRevision, null) == null) {\n                docIdsToDelete.add(doc.getId());\n                                for (NodeDocument prevDoc : ImmutableList.copyOf(doc.getAllPreviousDocs())) {\n                    docIdsToDelete.add(prevDoc.getId());\n                }\n            }\n        }\n    } finally {\n        Utils.closeIfCloseable(itr);\n    }\n    if (log.isDebugEnabled()) {\n        StringBuilder sb = new StringBuilder(\"Deleted document with following ids were deleted as part of GC \\n\");\n        Joiner.on(StandardSystemProperty.LINE_SEPARATOR.value()).appendTo(sb, docIdsToDelete);\n        log.debug(sb.toString());\n    }\n    nodeStore.getDocumentStore().remove(Collection.NODES, docIdsToDelete);\n    nodeStore.invalidateDocChildrenCache();\n    stats.deletedDocGCCount += docIdsToDelete.size();\n}", "lc": 0.45454545454545453, "pi": 1.1122448979591837, "ma": 0.16666666666666666, "nbd": 1.0, "ml": 0.08333333333333333, "d": -0.07612456747404842, "mi": -0.3926010897619731, "fo": 1.0833333333333333, "r": -0.028571428571428574, "e": 0.1316638184691688}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4102_e743fd7e", "label": 1, "code": "@Override\npublic void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag) {\n    boolean storeLabelText = false;\n    // try and find some form of label content...\n    String labelText = null;\n    if (labeled instanceof ILabelProvider) {\n        ILabelProvider<String> provider = (ILabelProvider<String>) labeled;\n        if (provider.getLabel() != null) {\n            String text = provider.getLabel().getObject();\n            if (!Strings.isEmpty(text)) {\n                labelText = text;\n            }\n        }\n    }\n    if (labelText == null && labeled instanceof FormComponent) {\n        String text = ((FormComponent<?>) labeled).getDefaultLabel(\"wicket:unknown\");\n        if (!\"wicket:unknown\".equals(text) && !Strings.isEmpty(text)) {\n            labelText = text;\n        }\n    }\n    // check if wicket:label tag has a message key\n    if (labelText == null && openTag.getAttribute(\"key\") != null) {\n        String text = labeled.getString(openTag.getAttribute(\"key\"));\n        if (!Strings.isEmpty(text)) {\n            labelText = text;\n            storeLabelText = true;\n        }\n    }\n    // as last resort use the tag body\n    if (labelText == null) {\n        String text = new ResponseBufferZone(RequestCycle.get(), markupStream) {\n\n            @Override\n            protected void executeInsideBufferedZone() {\n                TextLabel.super.onComponentTagBody(markupStream, openTag);\n            }\n        }.execute().toString();\n        if (!Strings.isEmpty(text)) {\n            labelText = text;\n            storeLabelText = true;\n        }\n    }\n    // print the label text\n    replaceComponentTagBody(markupStream, openTag, labelText);\n    // store the label text in FormComponent's label model so its available to errors\n    if (labeled instanceof FormComponent) {\n        FormComponent<?> fc = (FormComponent<?>) labeled;\n        fc.setLabel(Model.of(labelText));\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag) {\n    boolean storeLabelText = false;\n        String labelText = null;\n    if (labeled instanceof ILabelProvider) {\n        ILabelProvider<String> provider = (ILabelProvider<String>) labeled;\n        if (provider.getLabel() != null) {\n            String text = provider.getLabel().getObject();\n            if (!Strings.isEmpty(text)) {\n                labelText = text;\n            }\n        }\n    }\n    if (labelText == null && labeled instanceof FormComponent) {\n        String text = ((FormComponent<?>) labeled).getDefaultLabel(\"wicket:unknown\");\n        if (!\"wicket:unknown\".equals(text) && !Strings.isEmpty(text)) {\n            labelText = text;\n        }\n    }\n        if (labelText == null && openTag.getAttribute(\"key\") != null) {\n        String text = labeled.getString(openTag.getAttribute(\"key\"));\n        if (!Strings.isEmpty(text)) {\n            labelText = text;\n            storeLabelText = true;\n        }\n    }\n        if (labelText == null) {\n        String text = new ResponseBufferZone(RequestCycle.get(), markupStream) {\n\n            @Override\n            protected void executeInsideBufferedZone() {\n                TextLabel.super.onComponentTagBody(markupStream, openTag);\n            }\n        }.execute().toString();\n        if (!Strings.isEmpty(text)) {\n            labelText = text;\n            storeLabelText = true;\n        }\n    }\n        replaceComponentTagBody(markupStream, openTag, labelText);\n        if (labeled instanceof FormComponent) {\n        FormComponent<?> fc = (FormComponent<?>) labeled;\n        fc.setLabel(Model.of(labelText));\n    }\n}", "lc": 1.3636363636363635, "pi": 0.4897959183673469, "ma": 1.1666666666666667, "nbd": 0.5, "ml": 1.25, "d": 0.6969846762234307, "mi": -0.7900774304559794, "fo": 1.0833333333333333, "r": -0.028571428571428574, "e": 1.5791948809539107}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-3475_7651b777", "label": 1, "code": "public int start() throws IOException {\n    if (configError)\n        return 1;\n    String input;\n    if (isVerbose())\n        printInfo();\n    if (execFile != null) {\n        java.util.Scanner scanner = new java.util.Scanner(new File(execFile), UTF_8.name());\n        try {\n            while (scanner.hasNextLine() && !hasExited()) {\n                execCommand(scanner.nextLine(), true, isVerbose());\n            }\n        } finally {\n            scanner.close();\n        }\n    } else if (execCommand != null) {\n        for (String command : execCommand.split(\"\\n\")) {\n            execCommand(command, true, isVerbose());\n        }\n        return exitCode;\n    }\n    while (true) {\n        if (hasExited())\n            return exitCode;\n        reader.setDefaultPrompt(getDefaultPrompt());\n        input = reader.readLine();\n        if (input == null) {\n            reader.printNewline();\n            return exitCode;\n        }\n        // user canceled\n        execCommand(input, false, false);\n    }\n}", "code_comment": NaN, "code_no_comment": "public int start() throws IOException {\n    if (configError)\n        return 1;\n    String input;\n    if (isVerbose())\n        printInfo();\n    if (execFile != null) {\n        java.util.Scanner scanner = new java.util.Scanner(new File(execFile), UTF_8.name());\n        try {\n            while (scanner.hasNextLine() && !hasExited()) {\n                execCommand(scanner.nextLine(), true, isVerbose());\n            }\n        } finally {\n            scanner.close();\n        }\n    } else if (execCommand != null) {\n        for (String command : execCommand.split(\"\\n\")) {\n            execCommand(command, true, isVerbose());\n        }\n        return exitCode;\n    }\n    while (true) {\n        if (hasExited())\n            return exitCode;\n        reader.setDefaultPrompt(getDefaultPrompt());\n        input = reader.readLine();\n        if (input == null) {\n            reader.printNewline();\n            return exitCode;\n        }\n                execCommand(input, false, false);\n    }\n}", "lc": 0.8636363636363636, "pi": 0.2959183673469388, "ma": 1.0, "nbd": 0.5, "ml": 0.9166666666666666, "d": 0.34107760751359373, "mi": -0.5428735302552341, "fo": 1.0, "r": -0.028571428571428574, "e": 0.4054377015688642}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5505_6cceff44", "label": 3, "code": "@Override\npublic Property resolveProperty(FormComponent<?> component) {\n    IModel<?> model = component.getModel();\n    while (true) {\n        if (model == null) {\n            return null;\n        }\n        if (model instanceof IPropertyReflectionAwareModel) {\n            break;\n        }\n        if (model instanceof IWrapModel<?>) {\n            model = ((IWrapModel<?>) model).getWrappedModel();\n            continue;\n        }\n        return null;\n    }\n    IPropertyReflectionAwareModel<?> delegate = (IPropertyReflectionAwareModel<?>) model;\n    Field field = delegate.getPropertyField();\n    if (field != null) {\n        return new Property(field.getDeclaringClass(), field.getName());\n    }\n    Method getter = delegate.getPropertyGetter();\n    if (getter != null) {\n        String name = getter.getName().substring(3, 4).toLowerCase() + getter.getName().substring(4);\n        return new Property(getter.getDeclaringClass(), name);\n    }\n    return null;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Property resolveProperty(FormComponent<?> component) {\n    IModel<?> model = component.getModel();\n    while (true) {\n        if (model == null) {\n            return null;\n        }\n        if (model instanceof IPropertyReflectionAwareModel) {\n            break;\n        }\n        if (model instanceof IWrapModel<?>) {\n            model = ((IWrapModel<?>) model).getWrappedModel();\n            continue;\n        }\n        return null;\n    }\n    IPropertyReflectionAwareModel<?> delegate = (IPropertyReflectionAwareModel<?>) model;\n    Field field = delegate.getPropertyField();\n    if (field != null) {\n        return new Property(field.getDeclaringClass(), field.getName());\n    }\n    Method getter = delegate.getPropertyGetter();\n    if (getter != null) {\n        String name = getter.getName().substring(3, 4).toLowerCase() + getter.getName().substring(4);\n        return new Property(getter.getDeclaringClass(), name);\n    }\n    return null;\n}", "lc": 0.6363636363636364, "pi": 0.22448979591836732, "ma": 0.8333333333333334, "nbd": 0.0, "ml": 0.3333333333333333, "d": 0.4518042511122097, "mi": -0.45712646974476634, "fo": 0.5, "r": -0.028571428571428574, "e": 0.48109696292203646}
{"project_name": "Codec", "project_version": 9, "label": 3, "code": "/**\n * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n *\n * @param binaryData\n *            Array containing binary data to encode.\n * @param isChunked\n *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n * @param urlSafe\n *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n * @param maxResultSize\n *            The maximum result size to accept.\n * @return Base64-encoded data.\n * @throws IllegalArgumentException\n *             Thrown when the input array needs an output array bigger than maxResultSize\n * @since 1.4\n */\npublic static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" + len + \") than the specified maxium size of \" + maxResultSize);\n    }\n    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    return b64.encode(binaryData);\n}", "code_comment": "/**\n * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n *\n * @param binaryData\n *            Array containing binary data to encode.\n * @param isChunked\n *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n * @param urlSafe\n *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n * @param maxResultSize\n *            The maximum result size to accept.\n * @return Base64-encoded data.\n * @throws IllegalArgumentException\n *             Thrown when the input array needs an output array bigger than maxResultSize\n * @since 1.4\n */\n", "code_no_comment": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" + len + \") than the specified maxium size of \" + maxResultSize);\n    }\n    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    return b64.encode(binaryData);\n}", "lc": -0.13636363636363635, "pi": -0.3112244897959183, "ma": 0.16666666666666666, "nbd": -0.5, "ml": 0.3333333333333333, "d": 0.36875926841324774, "mi": 0.09234298824204186, "fo": -0.3333333333333333, "r": 0.2285714285714286, "e": 0.1557599976015179}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2033_420ac965", "label": 3, "code": "/**\n *  @see org.apache.wicket.behavior.AbstractAjaxBehavior#onComponentTag(org.apache.wicket.markup.ComponentTag)\n */\n@Override\nprotected void onComponentTag(final ComponentTag tag) {\n    super.onComponentTag(tag);\n    // only add the event handler when the component is enabled.\n    Component myComponent = getComponent();\n    if (myComponent.isEnabledInHierarchy()) {\n        tag.put(event, getEventHandler());\n    }\n}", "code_comment": "/**\n *  @see org.apache.wicket.behavior.AbstractAjaxBehavior#onComponentTag(org.apache.wicket.markup.ComponentTag)\n */\n", "code_no_comment": "@Override\nprotected void onComponentTag(final ComponentTag tag) {\n    super.onComponentTag(tag);\n        Component myComponent = getComponent();\n    if (myComponent.isEnabledInHierarchy()) {\n        tag.put(event, getEventHandler());\n    }\n}", "lc": -0.2727272727272727, "pi": -0.1887755102040817, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.3806228373702422, "mi": 0.43045597935187824, "fo": -0.08333333333333333, "r": 1.1428571428571428, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-926_e1ae968c", "label": 1, "code": "@Override\n@Nonnull\nprotected Map<?, ?> transformAndSeal(@Nonnull Map<Object, Object> map, @Nullable String key, int level) {\n    if (level == 1) {\n        if (PREVIOUS.equals(key)) {\n            SortedMap<Revision, Range> transformed = new TreeMap<Revision, Range>(new Comparator<Revision>() {\n\n                @Override\n                public int compare(Revision o1, Revision o2) {\n                    // in reverse order!\n                    int c = o2.compareRevisionTime(o1);\n                    if (c == 0) {\n                        c = o1.getClusterId() < o2.getClusterId() ? -1 : (o1.getClusterId() == o2.getClusterId() ? 0 : 1);\n                    }\n                    return c;\n                }\n            });\n            for (Map.Entry<Object, Object> entry : map.entrySet()) {\n                Revision high = Revision.fromString(entry.getKey().toString());\n                Revision low = Revision.fromString(entry.getValue().toString());\n                transformed.put(high, new Range(high, low));\n            }\n            return Collections.unmodifiableSortedMap(transformed);\n        }\n    }\n    return super.transformAndSeal(map, key, level);\n}", "code_comment": NaN, "code_no_comment": "@Override\n@Nonnull\nprotected Map<?, ?> transformAndSeal(@Nonnull Map<Object, Object> map, @Nullable String key, int level) {\n    if (level == 1) {\n        if (PREVIOUS.equals(key)) {\n            SortedMap<Revision, Range> transformed = new TreeMap<Revision, Range>(new Comparator<Revision>() {\n\n                @Override\n                public int compare(Revision o1, Revision o2) {\n                                        int c = o2.compareRevisionTime(o1);\n                    if (c == 0) {\n                        c = o1.getClusterId() < o2.getClusterId() ? -1 : (o1.getClusterId() == o2.getClusterId() ? 0 : 1);\n                    }\n                    return c;\n                }\n            });\n            for (Map.Entry<Object, Object> entry : map.entrySet()) {\n                Revision high = Revision.fromString(entry.getKey().toString());\n                Revision low = Revision.fromString(entry.getValue().toString());\n                transformed.put(high, new Range(high, low));\n            }\n            return Collections.unmodifiableSortedMap(transformed);\n        }\n    }\n    return super.transformAndSeal(map, key, level);\n}", "lc": 0.5, "pi": 2.122448979591837, "ma": 0.5, "nbd": 1.0, "ml": 0.5, "d": 0.5012357884330204, "mi": -0.448809865213651, "fo": 0.8333333333333334, "r": -0.028571428571428574, "e": 0.8415588420471045}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-880_2a9cbbab", "label": 1, "code": "/**\n * Mark the outgoing edge as processed.\n */\npublic void outgoingProcessed() {\n    outgoingNeedsProcessing = false;\n}", "code_comment": "/**\n * Mark the outgoing edge as processed.\n */\n", "code_no_comment": "public void outgoingProcessed() {\n    outgoingNeedsProcessing = false;\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.144536851161457, "fo": -0.5, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-294_5c592d85", "label": 1, "code": "/**\n *  Checks if the specified path matches any mount, and if so returns the\n *  coding strategy for that mount. Returns null if the path doesnt match\n *  any mounts.\n *\n *  NOTE: path here is not the mount - it is the full url path\n *\n *  @param path\n *             non-null url path\n *  @return coding strategy or null\n */\npublic IRequestTargetUrlCodingStrategy strategyForPath(String path) {\n    if (path == null) {\n        throw new IllegalArgumentException(\"Argument [[path]] cannot be null\");\n    }\n    if (caseSensitiveMounts == false) {\n        path = path.toLowerCase();\n    }\n    for (final Iterator it = map.entrySet().iterator(); it.hasNext(); ) {\n        final Map.Entry entry = (Entry) it.next();\n        final String key = (String) entry.getKey();\n        if (path.startsWith(key)) {\n            return (IRequestTargetUrlCodingStrategy) entry.getValue();\n        }\n    }\n    return null;\n}", "code_comment": "/**\n *  Checks if the specified path matches any mount, and if so returns the\n *  coding strategy for that mount. Returns null if the path doesnt match\n *  any mounts.\n *\n *  NOTE: path here is not the mount - it is the full url path\n *\n *  @param path\n *             non-null url path\n *  @return coding strategy or null\n */\n", "code_no_comment": "public IRequestTargetUrlCodingStrategy strategyForPath(String path) {\n    if (path == null) {\n        throw new IllegalArgumentException(\"Argument [[path]] cannot be null\");\n    }\n    if (caseSensitiveMounts == false) {\n        path = path.toLowerCase();\n    }\n    for (final Iterator it = map.entrySet().iterator(); it.hasNext(); ) {\n        final Map.Entry entry = (Entry) it.next();\n        final String key = (String) entry.getKey();\n        if (path.startsWith(key)) {\n            return (IRequestTargetUrlCodingStrategy) entry.getValue();\n        }\n    }\n    return null;\n}", "lc": 0.09090909090909091, "pi": 0.051020408163265356, "ma": 0.3333333333333333, "nbd": 0.0, "ml": 0.3333333333333333, "d": -0.07217004448838356, "mi": -0.10065959277315761, "fo": 0.16666666666666666, "r": 0.0, "e": -0.02126511364950466}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-434_133cbc2d", "label": 1, "code": "/**\n * Create the tableau by itself.\n * @param maximize if true, goal is to maximize the objective function\n * @return created tableau\n */\nprotected RealMatrix createTableau(final boolean maximize) {\n    // create a matrix of the correct size\n    int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() + // + 1 is for RHS\n    1;\n    int height = constraints.size() + getNumObjectiveFunctions();\n    Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width);\n    // initialize the objective function rows\n    if (getNumObjectiveFunctions() == 2) {\n        matrix.setEntry(0, 0, -1);\n    }\n    int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\n    matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1);\n    RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\n    copyArray(objectiveCoefficients.getData(), matrix.getDataRef()[zIndex]);\n    matrix.setEntry(zIndex, width - 1, maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());\n    if (!restrictToNonNegative) {\n        matrix.setEntry(zIndex, getSlackVariableOffset() - 1, getInvertedCoeffiecientSum(objectiveCoefficients));\n    }\n    // initialize the constraint rows\n    int slackVar = 0;\n    int artificialVar = 0;\n    for (int i = 0; i < constraints.size(); i++) {\n        LinearConstraint constraint = constraints.get(i);\n        int row = getNumObjectiveFunctions() + i;\n        // decision variable coefficients\n        copyArray(constraint.getCoefficients().getData(), matrix.getDataRef()[row]);\n        // x-\n        if (!restrictToNonNegative) {\n            matrix.setEntry(row, getSlackVariableOffset() - 1, getInvertedCoeffiecientSum(constraint.getCoefficients()));\n        }\n        // RHS\n        matrix.setEntry(row, width - 1, constraint.getValue());\n        // slack variables\n        if (constraint.getRelationship() == Relationship.LEQ) {\n            // slack\n            matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);\n        } else if (constraint.getRelationship() == Relationship.GEQ) {\n            // excess\n            matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1);\n        }\n        // artificial variables\n        if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) {\n            matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);\n            matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);\n            matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row)));\n        }\n    }\n    return matrix;\n}", "code_comment": "/**\n * Create the tableau by itself.\n * @param maximize if true, goal is to maximize the objective function\n * @return created tableau\n */\n", "code_no_comment": "protected RealMatrix createTableau(final boolean maximize) {\n        int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() +     1;\n    int height = constraints.size() + getNumObjectiveFunctions();\n    Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width);\n        if (getNumObjectiveFunctions() == 2) {\n        matrix.setEntry(0, 0, -1);\n    }\n    int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\n    matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1);\n    RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\n    copyArray(objectiveCoefficients.getData(), matrix.getDataRef()[zIndex]);\n    matrix.setEntry(zIndex, width - 1, maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());\n    if (!restrictToNonNegative) {\n        matrix.setEntry(zIndex, getSlackVariableOffset() - 1, getInvertedCoeffiecientSum(objectiveCoefficients));\n    }\n        int slackVar = 0;\n    int artificialVar = 0;\n    for (int i = 0; i < constraints.size(); i++) {\n        LinearConstraint constraint = constraints.get(i);\n        int row = getNumObjectiveFunctions() + i;\n                copyArray(constraint.getCoefficients().getData(), matrix.getDataRef()[row]);\n                if (!restrictToNonNegative) {\n            matrix.setEntry(row, getSlackVariableOffset() - 1, getInvertedCoeffiecientSum(constraint.getCoefficients()));\n        }\n                matrix.setEntry(row, width - 1, constraint.getValue());\n                if (constraint.getRelationship() == Relationship.LEQ) {\n                        matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);\n        } else if (constraint.getRelationship() == Relationship.GEQ) {\n                        matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1);\n        }\n                if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) {\n            matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);\n            matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);\n            matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row)));\n        }\n    }\n    return matrix;\n}", "lc": 1.1363636363636365, "pi": 0.10714285714285712, "ma": 1.3333333333333333, "nbd": 0.5, "ml": 1.0833333333333333, "d": 2.322293623331686, "mi": -0.8107255520504733, "fo": 3.5, "r": -0.028571428571428574, "e": 6.834975865273834}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4379_7a162f77", "label": 3, "code": "/**\n *  @see org.apache.wicket.resource.loader.ComponentStringResourceLoader#loadStringResource(org.apache.wicket.Component,\n *       java.lang.String, java.util.Locale, java.lang.String, java.lang.String)\n */\n@Override\npublic String loadStringResource(final Component component, final String key, final Locale locale, final String style, final String variation) {\n    if (component == null || !(component instanceof FormComponent)) {\n        return null;\n    }\n    FormComponent<?> fc = (FormComponent<?>) component;\n    for (IValidator<?> validator : fc.getValidators()) {\n        String resource = loadStringResource(validator.getClass(), key, locale, style, variation);\n        if (resource != null) {\n            return resource;\n        }\n    }\n    // not found\n    return null;\n}", "code_comment": "/**\n *  @see org.apache.wicket.resource.loader.ComponentStringResourceLoader#loadStringResource(org.apache.wicket.Component,\n *       java.lang.String, java.util.Locale, java.lang.String, java.lang.String)\n */\n", "code_no_comment": "@Override\npublic String loadStringResource(final Component component, final String key, final Locale locale, final String style, final String variation) {\n    if (component == null || !(component instanceof FormComponent)) {\n        return null;\n    }\n    FormComponent<?> fc = (FormComponent<?>) component;\n    for (IValidator<?> validator : fc.getValidators()) {\n        String resource = loadStringResource(validator.getClass(), key, locale, style, variation);\n        if (resource != null) {\n            return resource;\n        }\n    }\n        return null;\n}", "lc": 0.0, "pi": 0.21428571428571425, "ma": 0.0, "nbd": 0.0, "ml": 0.0, "d": 0.4518042511122097, "mi": -0.023229136793805637, "fo": -0.25, "r": -0.028571428571428574, "e": 0.21611608653380787}
{"project_name": "Compress", "project_version": 7, "label": 1, "code": "/**\n * Parse an entry name from a buffer.\n * Parsing stops when a NUL is found\n * or the buffer length is reached.\n *\n * @param buffer The buffer from which to parse.\n * @param offset The offset into the buffer from which to parse.\n * @param length The maximum number of bytes to parse.\n * @return The entry name.\n */\npublic static String parseName(byte[] buffer, final int offset, final int length) {\n    StringBuffer result = new StringBuffer(length);\n    int end = offset + length;\n    for (int i = offset; i < end; ++i) {\n        if (buffer[i] == 0) {\n            break;\n        }\n        result.append((char) buffer[i]);\n    }\n    return result.toString();\n}", "code_comment": "/**\n * Parse an entry name from a buffer.\n * Parsing stops when a NUL is found\n * or the buffer length is reached.\n *\n * @param buffer The buffer from which to parse.\n * @param offset The offset into the buffer from which to parse.\n * @param length The maximum number of bytes to parse.\n * @return The entry name.\n */\n", "code_no_comment": "public static String parseName(byte[] buffer, final int offset, final int length) {\n    StringBuffer result = new StringBuffer(length);\n    int end = offset + length;\n    for (int i = offset; i < end; ++i) {\n        if (buffer[i] == 0) {\n            break;\n        }\n        result.append((char) buffer[i]);\n    }\n    return result.toString();\n}", "lc": -0.13636363636363635, "pi": 0.2193877551020409, "ma": 0.0, "nbd": 0.0, "ml": -0.08333333333333333, "d": 0.4399406821552152, "mi": 0.14797820476053908, "fo": -0.3333333333333333, "r": 0.6285714285714287, "e": 0.08800716118228034}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4138_7c89598a", "label": 1, "code": "@Override\npublic boolean shouldPreserveClientUrl() {\n    return errorAttributes != null && !Strings.isEmpty(errorAttributes.getRequestUri());\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean shouldPreserveClientUrl() {\n    return errorAttributes != null && !Strings.isEmpty(errorAttributes.getRequestUri());\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.15916955017301035, "mi": 0.8210496128477202, "fo": -0.3333333333333333, "r": 1.5428571428571431, "e": -0.14422586848608668}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-939_49444ee6", "label": 1, "code": "/**\n * Compute a covariance matrix from a rectangular array whose columns represent\n * covariates.\n * @param data input array (must have at least two columns and two rows)\n * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n * @return covariance matrix\n * @throws MathIllegalArgumentException if the data array does not contain sufficient\n * data\n */\nprotected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected) throws MathIllegalArgumentException {\n    return computeCovarianceMatrix(new BlockRealMatrix(data), biasCorrected);\n}", "code_comment": "/**\n * Compute a covariance matrix from a rectangular array whose columns represent\n * covariates.\n * @param data input array (must have at least two columns and two rows)\n * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n * @return covariance matrix\n * @throws MathIllegalArgumentException if the data array does not contain sufficient\n * data\n */\n", "code_no_comment": "protected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected) throws MathIllegalArgumentException {\n    return computeCovarianceMatrix(new BlockRealMatrix(data), biasCorrected);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.0129050759965588, "fo": -0.4166666666666667, "r": 2.8000000000000003, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-621_00b4b8a0", "label": 1, "code": "@Nonnull\nprotected synchronized NodeBuilder getNodeBuilder() {\n    if (nodeBuilder == null) {\n        nodeBuilder = parent.getNodeBuilder().child(name);\n    }\n    return nodeBuilder;\n}", "code_comment": NaN, "code_no_comment": "@Nonnull\nprotected synchronized NodeBuilder getNodeBuilder() {\n    if (nodeBuilder == null) {\n        nodeBuilder = parent.getNodeBuilder().child(name);\n    }\n    return nodeBuilder;\n}", "lc": -0.3181818181818182, "pi": -0.11224489795918377, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.11764705882352938, "mi": 0.5314023515916262, "fo": -0.3333333333333333, "r": 1.4000000000000001, "e": -0.13656785777001126}
{"project_name": "Closure", "project_version": 167, "label": 2, "code": "/**\n * @see maybeRestrictName\n */\nprivate FlowScope maybeRestrictTwoNames(FlowScope blindScope, Node left, boolean leftIsRefineable, JSType restrictedLeftType, Node right, boolean rightIsRefineable, JSType restrictedRightType) {\n    boolean shouldRefineLeft = leftIsRefineable && restrictedLeftType != null;\n    boolean shouldRefineRight = rightIsRefineable && restrictedRightType != null;\n    if (shouldRefineLeft || shouldRefineRight) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        if (shouldRefineLeft) {\n            declareNameInScope(informed, left, restrictedLeftType);\n        }\n        if (shouldRefineRight) {\n            declareNameInScope(informed, right, restrictedRightType);\n        }\n        return informed;\n    }\n    return blindScope;\n}", "code_comment": "/**\n * @see maybeRestrictName\n */\n", "code_no_comment": "private FlowScope maybeRestrictTwoNames(FlowScope blindScope, Node left, boolean leftIsRefineable, JSType restrictedLeftType, Node right, boolean rightIsRefineable, JSType restrictedRightType) {\n    boolean shouldRefineLeft = leftIsRefineable && restrictedLeftType != null;\n    boolean shouldRefineRight = rightIsRefineable && restrictedRightType != null;\n    if (shouldRefineLeft || shouldRefineRight) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        if (shouldRefineLeft) {\n            declareNameInScope(informed, left, restrictedLeftType);\n        }\n        if (shouldRefineRight) {\n            declareNameInScope(informed, right, restrictedRightType);\n        }\n        return informed;\n    }\n    return blindScope;\n}", "lc": 0.045454545454545456, "pi": 0.2653061224489796, "ma": 0.0, "nbd": 0.0, "ml": 0.08333333333333333, "d": 0.5210084033613446, "mi": -0.06051046745053054, "fo": -0.25, "r": -0.028571428571428574, "e": 0.2621198298790908}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5147_184e51e9", "label": 1, "code": "@Override\npublic IRequestHandler map(Exception e) {\n    try {\n        Response response = RequestCycle.get().getResponse();\n        if (response instanceof WebResponse) {\n            // we don't wan't to cache an exceptional reply in the browser\n            ((WebResponse) response).disableCaching();\n        }\n        return internalMap(e);\n    } catch (RuntimeException e2) {\n        if (logger.isDebugEnabled()) {\n            logger.error(\"An error occurred while handling a previous error: \" + e2.getMessage(), e2);\n        }\n        // hmmm, we were already handling an exception! give up\n        logger.error(\"unexpected exception when handling another exception: \" + e.getMessage(), e);\n        return new ErrorCodeRequestHandler(500);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic IRequestHandler map(Exception e) {\n    try {\n        Response response = RequestCycle.get().getResponse();\n        if (response instanceof WebResponse) {\n                        ((WebResponse) response).disableCaching();\n        }\n        return internalMap(e);\n    } catch (RuntimeException e2) {\n        if (logger.isDebugEnabled()) {\n            logger.error(\"An error occurred while handling a previous error: \" + e2.getMessage(), e2);\n        }\n                logger.error(\"unexpected exception when handling another exception: \" + e.getMessage(), e);\n        return new ErrorCodeRequestHandler(500);\n    }\n}", "lc": 0.09090909090909091, "pi": 0.3622448979591837, "ma": 0.0, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.08403361344537813, "mi": -0.06423860051620332, "fo": 0.25, "r": 0.0, "e": -0.046453458739683304}
{"project_name": "JxPath", "project_version": 7, "label": 1, "code": "public Object computeValue(EvalContext context) {\n    double l = InfoSetUtil.doubleValue(args[0].computeValue(context));\n    double r = InfoSetUtil.doubleValue(args[1].computeValue(context));\n    return l <= r ? Boolean.TRUE : Boolean.FALSE;\n}", "code_comment": NaN, "code_no_comment": "public Object computeValue(EvalContext context) {\n    double l = InfoSetUtil.doubleValue(args[0].computeValue(context));\n    double r = InfoSetUtil.doubleValue(args[1].computeValue(context));\n    return l <= r ? Boolean.TRUE : Boolean.FALSE;\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.3333333333333333, "nbd": -1.0, "ml": -0.16666666666666666, "d": -0.05042016806722688, "mi": 0.5595067393174648, "fo": -0.16666666666666666, "r": 0.20000000000000004, "e": -0.08252919937810786}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3511_4a875f46", "label": 1, "code": "/**\n *  Make a copy before returning an item from the cache as resource streams are not thread-safe.\n *\n *  @param key\n *             the cache key\n *  @return the cached File or Url resource stream\n */\nprivate IResourceStream getCopyFromCache(Key key) {\n    final IResourceStreamReference orig = cache.get(key);\n    if (NullResourceStreamReference.INSTANCE == orig) {\n        return null;\n    }\n    if (orig instanceof UrlResourceStreamReference) {\n        UrlResourceStreamReference resourceStreamReference = (UrlResourceStreamReference) orig;\n        String url = resourceStreamReference.getReference();\n        try {\n            return new UrlResourceStream(new URL(url));\n        } catch (MalformedURLException e) {\n            return null;\n        }\n    }\n    if (orig instanceof FileResourceStreamReference) {\n        FileResourceStreamReference resourceStreamReference = (FileResourceStreamReference) orig;\n        String absolutePath = resourceStreamReference.getReference();\n        return new FileResourceStream(new File(absolutePath));\n    }\n    return null;\n}", "code_comment": "/**\n *  Make a copy before returning an item from the cache as resource streams are not thread-safe.\n *\n *  @param key\n *             the cache key\n *  @return the cached File or Url resource stream\n */\n", "code_no_comment": "private IResourceStream getCopyFromCache(Key key) {\n    final IResourceStreamReference orig = cache.get(key);\n    if (NullResourceStreamReference.INSTANCE == orig) {\n        return null;\n    }\n    if (orig instanceof UrlResourceStreamReference) {\n        UrlResourceStreamReference resourceStreamReference = (UrlResourceStreamReference) orig;\n        String url = resourceStreamReference.getReference();\n        try {\n            return new UrlResourceStream(new URL(url));\n        } catch (MalformedURLException e) {\n            return null;\n        }\n    }\n    if (orig instanceof FileResourceStreamReference) {\n        FileResourceStreamReference resourceStreamReference = (FileResourceStreamReference) orig;\n        String absolutePath = resourceStreamReference.getReference();\n        return new FileResourceStream(new File(absolutePath));\n    }\n    return null;\n}", "lc": 0.3181818181818182, "pi": 0.08163265306122457, "ma": 0.16666666666666666, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.032624814631735014, "mi": -0.23601950100372832, "fo": -0.25, "r": -0.028571428571428574, "e": 0.014986230142923839}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3276_205420e2", "label": 3, "code": "/**\n * Copies the results of a message exchange from the source exchange to the result exchange\n * which will copy the out and fault message contents and the exception\n *\n * @param result the result exchange which will have the output and error state added\n * @param source the source exchange which is not modified\n */\npublic static void copyResults(Exchange result, Exchange source) {\n    if (result != source) {\n        result.setException(source.getException());\n        if (source.hasOut()) {\n            result.getOut().copyFrom(source.getOut());\n        } else if (result.getPattern() == ExchangePattern.InOptionalOut) {\n            // special case where the result is InOptionalOut and with no OUT response\n            // so we should return null to indicate this fact\n            result.setOut(null);\n        } else {\n            // so lets assume the last IN is the OUT\n            if (result.getPattern().isOutCapable()) {\n                // only set OUT if its OUT capable\n                result.getOut().copyFrom(source.getIn());\n            } else {\n                // if not replace IN instead to keep the MEP\n                result.getIn().copyFrom(source.getIn());\n            }\n        }\n        if (source.hasProperties()) {\n            result.getProperties().putAll(source.getProperties());\n        }\n    }\n}", "code_comment": "/**\n * Copies the results of a message exchange from the source exchange to the result exchange\n * which will copy the out and fault message contents and the exception\n *\n * @param result the result exchange which will have the output and error state added\n * @param source the source exchange which is not modified\n */\n", "code_no_comment": "public static void copyResults(Exchange result, Exchange source) {\n    if (result != source) {\n        result.setException(source.getException());\n        if (source.hasOut()) {\n            result.getOut().copyFrom(source.getOut());\n        } else if (result.getPattern() == ExchangePattern.InOptionalOut) {\n                                    result.setOut(null);\n        } else {\n                        if (result.getPattern().isOutCapable()) {\n                                result.getOut().copyFrom(source.getIn());\n            } else {\n                                result.getIn().copyFrom(source.getIn());\n            }\n        }\n        if (source.hasProperties()) {\n            result.getProperties().putAll(source.getProperties());\n        }\n    }\n}", "lc": 0.22727272727272727, "pi": 0.7142857142857143, "ma": 0.3333333333333333, "nbd": 1.0, "ml": 0.5833333333333334, "d": 0.07414730598121602, "mi": -0.18038428448523108, "fo": 1.1666666666666667, "r": -0.028571428571428574, "e": 0.046633344897443474}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2494_0dc92ca1", "label": 1, "code": "public String toString() {\n    return String.format(\"%,d %,d %,.2f %,d\", getMin(), getMax(), getAverage(), count);\n}", "code_comment": NaN, "code_no_comment": "public String toString() {\n    return String.format(\"%,d %,d %,.2f %,d\", getMin(), getMax(), getAverage(), count);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9948379696013767, "fo": -0.16666666666666666, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 75, "label": 2, "code": "static Double getStringNumberValue(String rawJsString) {\n    // vertical tab is not always whitespace\n    String s = trimJsWhiteSpace(rawJsString);\n    // return ScriptRuntime.toNumber(s);\n    if (s.length() == 0) {\n        return 0.0;\n    }\n    if (s.length() > 2 && s.charAt(0) == '0' && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {\n        // Attempt to convert hex numbers.\n        try {\n            return Double.valueOf(Integer.parseInt(s.substring(2), 16));\n        } catch (NumberFormatException e) {\n            return Double.NaN;\n        }\n    }\n    if (s.length() > 3 && (s.charAt(0) == '-' || s.charAt(0) == '+') && s.charAt(1) == '0' && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {\n        // hex numbers with explicit signs vary between browsers.\n        return null;\n    }\n    // insensitive, but IE treats \"infinity\" as NaN.  So leave it alone.\n    if (s.equals(\"infinity\") || s.equals(\"-infinity\") || s.equals(\"+infinity\")) {\n        return null;\n    }\n    try {\n        return Double.parseDouble(s);\n    } catch (NumberFormatException e) {\n        return Double.NaN;\n    }\n}", "code_comment": NaN, "code_no_comment": "static Double getStringNumberValue(String rawJsString) {\n        String s = trimJsWhiteSpace(rawJsString);\n        if (s.length() == 0) {\n        return 0.0;\n    }\n    if (s.length() > 2 && s.charAt(0) == '0' && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {\n                try {\n            return Double.valueOf(Integer.parseInt(s.substring(2), 16));\n        } catch (NumberFormatException e) {\n            return Double.NaN;\n        }\n    }\n    if (s.length() > 3 && (s.charAt(0) == '-' || s.charAt(0) == '+') && s.charAt(1) == '0' && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {\n                return null;\n    }\n        if (s.equals(\"infinity\") || s.equals(\"-infinity\") || s.equals(\"+infinity\")) {\n        return null;\n    }\n    try {\n        return Double.parseDouble(s);\n    } catch (NumberFormatException e) {\n        return Double.NaN;\n    }\n}", "lc": 0.45454545454545453, "pi": 0.01020408163265307, "ma": 0.5, "nbd": 0.0, "ml": 1.3333333333333333, "d": 0.6198714780029659, "mi": -0.4313163177516493, "fo": 1.0833333333333333, "r": -0.028571428571428574, "e": 0.9879133634000198}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7146_b6981cfd", "label": 3, "code": "protected Exchange onCompletion(final String key, final Exchange original, final Exchange aggregated, boolean fromTimeout) {\n    // store the correlation key as property before we remove so the repository has that information\n    if (original != null) {\n        original.setProperty(Exchange.AGGREGATED_CORRELATION_KEY, key);\n    }\n    aggregated.setProperty(Exchange.AGGREGATED_CORRELATION_KEY, key);\n    // remove from repository as its completed, we do this first as to trigger any OptimisticLockingException's\n    aggregationRepository.remove(aggregated.getContext(), key, original);\n    if (!fromTimeout && timeoutMap != null) {\n        // cleanup timeout map if it was a incoming exchange which triggered the timeout (and not the timeout checker)\n        timeoutMap.remove(key);\n    }\n    // this key has been closed so add it to the closed map\n    if (closedCorrelationKeys != null) {\n        closedCorrelationKeys.put(key, key);\n    }\n    if (fromTimeout) {\n        // to allow any custom processing before discarding the exchange\n        if (aggregationStrategy instanceof TimeoutAwareAggregationStrategy) {\n            long timeout = getCompletionTimeout() > 0 ? getCompletionTimeout() : -1;\n            ((TimeoutAwareAggregationStrategy) aggregationStrategy).timeout(aggregated, -1, -1, timeout);\n        }\n    }\n    Exchange answer;\n    if (fromTimeout && isDiscardOnCompletionTimeout()) {\n        // discard due timeout\n        LOG.debug(\"Aggregation for correlation key {} discarding aggregated exchange: {}\", key, aggregated);\n        // must confirm the discarded exchange\n        aggregationRepository.confirm(aggregated.getContext(), aggregated.getExchangeId());\n        // and remove redelivery state as well\n        redeliveryState.remove(aggregated.getExchangeId());\n        // the completion was from timeout and we should just discard it\n        answer = null;\n    } else {\n        // the aggregated exchange should be published (sent out)\n        answer = aggregated;\n    }\n    return answer;\n}", "code_comment": NaN, "code_no_comment": "protected Exchange onCompletion(final String key, final Exchange original, final Exchange aggregated, boolean fromTimeout) {\n        if (original != null) {\n        original.setProperty(Exchange.AGGREGATED_CORRELATION_KEY, key);\n    }\n    aggregated.setProperty(Exchange.AGGREGATED_CORRELATION_KEY, key);\n        aggregationRepository.remove(aggregated.getContext(), key, original);\n    if (!fromTimeout && timeoutMap != null) {\n                timeoutMap.remove(key);\n    }\n        if (closedCorrelationKeys != null) {\n        closedCorrelationKeys.put(key, key);\n    }\n    if (fromTimeout) {\n                if (aggregationStrategy instanceof TimeoutAwareAggregationStrategy) {\n            long timeout = getCompletionTimeout() > 0 ? getCompletionTimeout() : -1;\n            ((TimeoutAwareAggregationStrategy) aggregationStrategy).timeout(aggregated, -1, -1, timeout);\n        }\n    }\n    Exchange answer;\n    if (fromTimeout && isDiscardOnCompletionTimeout()) {\n                LOG.debug(\"Aggregation for correlation key {} discarding aggregated exchange: {}\", key, aggregated);\n                aggregationRepository.confirm(aggregated.getContext(), aggregated.getExchangeId());\n                redeliveryState.remove(aggregated.getExchangeId());\n                answer = null;\n    } else {\n                answer = aggregated;\n    }\n    return answer;\n}", "lc": 0.6818181818181818, "pi": -0.0714285714285715, "ma": 0.6666666666666666, "nbd": 0.0, "ml": 0.9166666666666666, "d": 1.1319822046465648, "mi": -0.5104674505305421, "fo": 0.8333333333333334, "r": -0.028571428571428574, "e": 1.4051036272758812}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-757_76b7413d", "label": 1, "code": "/**\n * Sets the <code>expansionMode</code>. The specified value must be one of\n * ADDITIVE_MODE, MULTIPLICATIVE_MODE.\n *\n * @param expansionMode The expansionMode to set.\n * @throws MathIllegalArgumentException if the specified mode value is not valid.\n * @deprecated As of 3.1. Please use {@link #setExpansionMode(ExpansionMode)} instead.\n */\n@Deprecated\npublic void setExpansionMode(int expansionMode) throws MathIllegalArgumentException {\n    if (expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE) {\n        throw new MathIllegalArgumentException(LocalizedFormats.UNSUPPORTED_EXPANSION_MODE, expansionMode, MULTIPLICATIVE_MODE, \"MULTIPLICATIVE_MODE\", ADDITIVE_MODE, \"ADDITIVE_MODE\");\n    }\n    synchronized (this) {\n        if (expansionMode == MULTIPLICATIVE_MODE) {\n            setExpansionMode(ExpansionMode.MULTIPLICATIVE);\n        } else if (expansionMode == ADDITIVE_MODE) {\n            setExpansionMode(ExpansionMode.ADDITIVE);\n        }\n    }\n}", "code_comment": "/**\n * Sets the <code>expansionMode</code>. The specified value must be one of\n * ADDITIVE_MODE, MULTIPLICATIVE_MODE.\n *\n * @param expansionMode The expansionMode to set.\n * @throws MathIllegalArgumentException if the specified mode value is not valid.\n * @deprecated As of 3.1. Please use {@link #setExpansionMode(ExpansionMode)} instead.\n */\n", "code_no_comment": "@Deprecated\npublic void setExpansionMode(int expansionMode) throws MathIllegalArgumentException {\n    if (expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE) {\n        throw new MathIllegalArgumentException(LocalizedFormats.UNSUPPORTED_EXPANSION_MODE, expansionMode, MULTIPLICATIVE_MODE, \"MULTIPLICATIVE_MODE\", ADDITIVE_MODE, \"ADDITIVE_MODE\");\n    }\n    synchronized (this) {\n        if (expansionMode == MULTIPLICATIVE_MODE) {\n            setExpansionMode(ExpansionMode.MULTIPLICATIVE);\n        } else if (expansionMode == ADDITIVE_MODE) {\n            setExpansionMode(ExpansionMode.ADDITIVE);\n        }\n    }\n}", "lc": -0.045454545454545456, "pi": 0.5051020408163264, "ma": 0.16666666666666666, "nbd": 0.5, "ml": 0.0, "d": 0.06426099851705393, "mi": 0.08259248637797523, "fo": -0.3333333333333333, "r": 0.0, "e": -0.043746600365768516}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4572_dfc56674", "label": 0, "code": "/**\n *  Splits the window with given index to two windows. First of those will have size specified by\n *  the argument, the other one will fill up the rest of the original window.\n *\n *  @param index\n *  @param size\n */\nprivate void splitWindow(int index, int size) {\n    PageWindowInternal window = windows.get(index);\n    int delta = window.filePartSize - size;\n    if (index == windows.size() - 1) {\n        // if this is last window\n        totalSize -= delta;\n        window.filePartSize = size;\n    } else if (window.filePartSize != size) {\n        PageWindowInternal newWindow = new PageWindowInternal();\n        newWindow.pageId = -1;\n        window.filePartSize = size;\n        windows.add(index + 1, newWindow);\n        newWindow.filePartOffset = getWindowFileOffset(index + 1);\n        newWindow.filePartSize = delta;\n    }\n    idToWindowIndex = null;\n}", "code_comment": "/**\n *  Splits the window with given index to two windows. First of those will have size specified by\n *  the argument, the other one will fill up the rest of the original window.\n *\n *  @param index\n *  @param size\n */\n", "code_no_comment": "private void splitWindow(int index, int size) {\n    PageWindowInternal window = windows.get(index);\n    int delta = window.filePartSize - size;\n    if (index == windows.size() - 1) {\n                totalSize -= delta;\n        window.filePartSize = size;\n    } else if (window.filePartSize != size) {\n        PageWindowInternal newWindow = new PageWindowInternal();\n        newWindow.pageId = -1;\n        window.filePartSize = size;\n        windows.add(index + 1, newWindow);\n        newWindow.filePartOffset = getWindowFileOffset(index + 1);\n        newWindow.filePartSize = delta;\n    }\n    idToWindowIndex = null;\n}", "lc": 0.09090909090909091, "pi": -0.12244897959183684, "ma": -0.16666666666666666, "nbd": 0.0, "ml": 0.08333333333333333, "d": 1.1497775580820566, "mi": -0.13449956983080008, "fo": -0.16666666666666666, "r": 0.08571428571428572, "e": 0.8514011846788391}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3448_b345dd82", "label": 0, "code": "public static ExceptionPolicyKey newInstance(Class exceptionClass, WhenDefinition when) {\n    return new ExceptionPolicyKey(exceptionClass, when);\n}", "code_comment": NaN, "code_no_comment": "public static ExceptionPolicyKey newInstance(Class exceptionClass, WhenDefinition when) {\n    return new ExceptionPolicyKey(exceptionClass, when);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.0129050759965588, "fo": -0.5, "r": 0.6285714285714287, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5", "label": 3, "code": "public void getResult() throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException {\n    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {\n        throw new IllegalStateException(\"Method call not finished!\");\n    }\n    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());\n    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);\n    (new Client(prot)).recv_update();\n}", "code_comment": NaN, "code_no_comment": "public void getResult() throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException {\n    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {\n        throw new IllegalStateException(\"Method call not finished!\");\n    }\n    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());\n    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);\n    (new Client(prot)).recv_update();\n}", "lc": -0.2727272727272727, "pi": -0.31632653061224497, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.25, "d": -0.07019278299555112, "mi": 0.22999713220533405, "fo": 0.0, "r": -0.028571428571428574, "e": -0.00900715689927659}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3989_6a8fc1cc", "label": 1, "code": "/**\n *  Will <b>replace</b> the respective component's method. However by returning null, the\n *  component's method will be called.\n *\n *  @see MarkupContainer#getMarkup(Component)\n *\n *  @param container\n *             The parent containing the child. (@TODO Is container ever != child.getParent()??)\n *  @param child\n *             The component to find the markup for.\n *  @return markup fragment\n */\nIMarkupFragment getMarkup(final MarkupContainer container, final Component child);", "code_comment": "/**\n *  Will <b>replace</b> the respective component's method. However by returning null, the\n *  component's method will be called.\n *\n *  @see MarkupContainer#getMarkup(Component)\n *\n *  @param container\n *             The parent containing the child. (@TODO Is container ever != child.getParent()??)\n *  @param child\n *             The component to find the markup for.\n *  @return markup fragment\n */\n", "code_no_comment": "IMarkupFragment getMarkup(final MarkupContainer container, final Component child);", "lc": -0.5909090909090909, "pi": -1.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.5764267278462867, "fo": -0.5, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7513_85ced066", "label": 1, "code": "protected AggregationStrategyMethodInfo createMethodInfo() {\n    Class<?>[] parameterTypes = method.getParameterTypes();\n    int size = parameterTypes.length;\n    if (LOG.isTraceEnabled()) {\n        LOG.trace(\"Creating MethodInfo for class: {} method: {} having {} parameters\", new Object[] { type, method, size });\n    }\n    // must have equal number of parameters\n    if (size < 2) {\n        throw new IllegalArgumentException(\"The method \" + method.getName() + \" must have at least two parameters, has: \" + size);\n    } else if (size % 2 != 0) {\n        throw new IllegalArgumentException(\"The method \" + method.getName() + \" must have equal number of parameters, has: \" + size);\n    }\n    // must not have annotations as they are not supported (yet)\n    for (int i = 0; i < size; i++) {\n        Class<?> type = parameterTypes[i];\n        if (type.getAnnotations().length > 0) {\n            throw new IllegalArgumentException(\"Parameter annotations at index \" + i + \" is not supported on method: \" + method);\n        }\n    }\n    List<ParameterInfo> oldParameters = new ArrayList<ParameterInfo>();\n    List<ParameterInfo> newParameters = new ArrayList<ParameterInfo>();\n    for (int i = 0; i < size / 2; i++) {\n        Class<?> oldType = parameterTypes[i];\n        if (oldParameters.size() == 0) {\n            // the first parameter is the body\n            Expression oldBody = ExpressionBuilder.mandatoryBodyExpression(oldType);\n            ParameterInfo info = new ParameterInfo(i, oldType, null, oldBody);\n            oldParameters.add(info);\n        } else if (oldParameters.size() == 1) {\n            // the 2nd parameter is the headers\n            Expression oldHeaders = ExpressionBuilder.headersExpression();\n            ParameterInfo info = new ParameterInfo(i, oldType, null, oldHeaders);\n            oldParameters.add(info);\n        } else if (oldParameters.size() == 2) {\n            // the 3rd parameter is the properties\n            Expression oldProperties = ExpressionBuilder.propertiesExpression();\n            ParameterInfo info = new ParameterInfo(i, oldType, null, oldProperties);\n            oldParameters.add(info);\n        }\n    }\n    for (int i = size / 2; i < size; i++) {\n        Class<?> newType = parameterTypes[i];\n        if (newParameters.size() == 0) {\n            // the first parameter is the body\n            Expression newBody = ExpressionBuilder.mandatoryBodyExpression(newType);\n            ParameterInfo info = new ParameterInfo(i, newType, null, newBody);\n            newParameters.add(info);\n        } else if (newParameters.size() == 1) {\n            // the 2nd parameter is the headers\n            Expression newHeaders = ExpressionBuilder.headersExpression();\n            ParameterInfo info = new ParameterInfo(i, newType, null, newHeaders);\n            newParameters.add(info);\n        } else if (newParameters.size() == 2) {\n            // the 3rd parameter is the properties\n            Expression newProperties = ExpressionBuilder.propertiesExpression();\n            ParameterInfo info = new ParameterInfo(i, newType, null, newProperties);\n            newParameters.add(info);\n        }\n    }\n    return new AggregationStrategyMethodInfo(camelContext, type, method, oldParameters, newParameters);\n}", "code_comment": NaN, "code_no_comment": "protected AggregationStrategyMethodInfo createMethodInfo() {\n    Class<?>[] parameterTypes = method.getParameterTypes();\n    int size = parameterTypes.length;\n    if (LOG.isTraceEnabled()) {\n        LOG.trace(\"Creating MethodInfo for class: {} method: {} having {} parameters\", new Object[] { type, method, size });\n    }\n        if (size < 2) {\n        throw new IllegalArgumentException(\"The method \" + method.getName() + \" must have at least two parameters, has: \" + size);\n    } else if (size % 2 != 0) {\n        throw new IllegalArgumentException(\"The method \" + method.getName() + \" must have equal number of parameters, has: \" + size);\n    }\n        for (int i = 0; i < size; i++) {\n        Class<?> type = parameterTypes[i];\n        if (type.getAnnotations().length > 0) {\n            throw new IllegalArgumentException(\"Parameter annotations at index \" + i + \" is not supported on method: \" + method);\n        }\n    }\n    List<ParameterInfo> oldParameters = new ArrayList<ParameterInfo>();\n    List<ParameterInfo> newParameters = new ArrayList<ParameterInfo>();\n    for (int i = 0; i < size / 2; i++) {\n        Class<?> oldType = parameterTypes[i];\n        if (oldParameters.size() == 0) {\n                        Expression oldBody = ExpressionBuilder.mandatoryBodyExpression(oldType);\n            ParameterInfo info = new ParameterInfo(i, oldType, null, oldBody);\n            oldParameters.add(info);\n        } else if (oldParameters.size() == 1) {\n                        Expression oldHeaders = ExpressionBuilder.headersExpression();\n            ParameterInfo info = new ParameterInfo(i, oldType, null, oldHeaders);\n            oldParameters.add(info);\n        } else if (oldParameters.size() == 2) {\n                        Expression oldProperties = ExpressionBuilder.propertiesExpression();\n            ParameterInfo info = new ParameterInfo(i, oldType, null, oldProperties);\n            oldParameters.add(info);\n        }\n    }\n    for (int i = size / 2; i < size; i++) {\n        Class<?> newType = parameterTypes[i];\n        if (newParameters.size() == 0) {\n                        Expression newBody = ExpressionBuilder.mandatoryBodyExpression(newType);\n            ParameterInfo info = new ParameterInfo(i, newType, null, newBody);\n            newParameters.add(info);\n        } else if (newParameters.size() == 1) {\n                        Expression newHeaders = ExpressionBuilder.headersExpression();\n            ParameterInfo info = new ParameterInfo(i, newType, null, newHeaders);\n            newParameters.add(info);\n        } else if (newParameters.size() == 2) {\n                        Expression newProperties = ExpressionBuilder.propertiesExpression();\n            ParameterInfo info = new ParameterInfo(i, newType, null, newProperties);\n            newParameters.add(info);\n        }\n    }\n    return new AggregationStrategyMethodInfo(camelContext, type, method, oldParameters, newParameters);\n}", "lc": 1.7727272727272727, "pi": 0.2959183673469388, "ma": 2.1666666666666665, "nbd": 1.0, "ml": 1.1666666666666667, "d": 2.7513593672763226, "mi": -1.008603383997706, "fo": 1.5, "r": -0.028571428571428574, "e": 9.252727202641758}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3297_71499e17", "label": 1, "code": "protected static String encodeResourceReferenceAttributes(ResourceReference.UrlAttributes attributes) {\n    if (attributes == null || (attributes.getLocale() == null && attributes.getStyle() == null && attributes.getVariation() == null)) {\n        return null;\n    } else {\n        StringBuilder res = new StringBuilder();\n        if (attributes.getLocale() != null) {\n            res.append(attributes.getLocale().toString());\n        }\n        if (!Strings.isEmpty(attributes.getStyle())) {\n            res.append(\"-\");\n            res.append(attributes.getStyle());\n        }\n        if (!Strings.isEmpty(attributes.getVariation())) {\n            res.append(\"-\");\n            res.append(attributes.getVariation());\n        }\n        return res.toString();\n    }\n}", "code_comment": NaN, "code_no_comment": "protected static String encodeResourceReferenceAttributes(ResourceReference.UrlAttributes attributes) {\n    if (attributes == null || (attributes.getLocale() == null && attributes.getStyle() == null && attributes.getVariation() == null)) {\n        return null;\n    } else {\n        StringBuilder res = new StringBuilder();\n        if (attributes.getLocale() != null) {\n            res.append(attributes.getLocale().toString());\n        }\n        if (!Strings.isEmpty(attributes.getStyle())) {\n            res.append(\"-\");\n            res.append(attributes.getStyle());\n        }\n        if (!Strings.isEmpty(attributes.getVariation())) {\n            res.append(\"-\");\n            res.append(attributes.getVariation());\n        }\n        return res.toString();\n    }\n}", "lc": 0.22727272727272727, "pi": 0.3214285714285714, "ma": 0.16666666666666666, "nbd": 0.0, "ml": 0.6666666666666666, "d": 1.4681166584280774, "mi": -0.21881273300831652, "fo": 1.0, "r": -0.028571428571428574, "e": 0.995502846055996}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3395_8433e6db", "label": 3, "code": "public Iterator iterator() {\n    return new Iterator() {\n\n        private int index;\n\n        private boolean closed;\n\n        public boolean hasNext() {\n            if (closed) {\n                return false;\n            }\n            boolean answer = iterator.hasNext();\n            if (!answer) {\n                // we are now closed\n                closed = true;\n                // nothing more so we need to close the expression value in case it needs to be\n                if (value instanceof Closeable) {\n                    IOHelper.close((Closeable) value, value.getClass().getName(), LOG);\n                } else if (value instanceof Scanner) {\n                    // special for Scanner as it does not implement Closeable\n                    ((Scanner) value).close();\n                }\n            }\n            return answer;\n        }\n\n        public Object next() {\n            Object part = iterator.next();\n            Exchange newExchange = exchange.copy();\n            if (part instanceof Message) {\n                newExchange.setIn((Message) part);\n            } else {\n                Message in = newExchange.getIn();\n                in.setBody(part);\n            }\n            return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);\n        }\n\n        public void remove() {\n            throw new UnsupportedOperationException(\"Remove is not supported by this iterator\");\n        }\n    };\n}", "code_comment": NaN, "code_no_comment": "public Iterator iterator() {\n    return new Iterator() {\n\n        private int index;\n\n        private boolean closed;\n\n        public boolean hasNext() {\n            if (closed) {\n                return false;\n            }\n            boolean answer = iterator.hasNext();\n            if (!answer) {\n                                closed = true;\n                                if (value instanceof Closeable) {\n                    IOHelper.close((Closeable) value, value.getClass().getName(), LOG);\n                } else if (value instanceof Scanner) {\n                                        ((Scanner) value).close();\n                }\n            }\n            return answer;\n        }\n\n        public Object next() {\n            Object part = iterator.next();\n            Exchange newExchange = exchange.copy();\n            if (part instanceof Message) {\n                newExchange.setIn((Message) part);\n            } else {\n                Message in = newExchange.getIn();\n                in.setBody(part);\n            }\n            return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);\n        }\n\n        public void remove() {\n            throw new UnsupportedOperationException(\"Remove is not supported by this iterator\");\n        }\n    };\n}", "lc": 0.9545454545454546, "pi": 0.872448979591837, "ma": 0.5, "nbd": 1.0, "ml": 0.3333333333333333, "d": -0.014829461196243152, "mi": -0.5503297963865789, "fo": 0.6666666666666666, "r": -0.028571428571428574, "e": 0.12517506777853446}
{"project_name": "Closure", "project_version": 169, "label": 2, "code": "JSType getGreatestSubtypeHelper(JSType that) {\n    if (that.isRecordType()) {\n        RecordType thatRecord = that.toMaybeRecordType();\n        RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n        builder.setSynthesized(true);\n        // is returned.\n        for (String property : properties.keySet()) {\n            if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isInvariant(getPropertyType(property))) {\n                return registry.getNativeObjectType(JSTypeNative.NO_TYPE);\n            }\n            builder.addProperty(property, getPropertyType(property), getPropertyNode(property));\n        }\n        for (String property : thatRecord.properties.keySet()) {\n            if (!hasProperty(property)) {\n                builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property));\n            }\n        }\n        return builder.build();\n    }\n    JSType greatestSubtype = registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE).getGreatestSubtype(that);\n    if (!thatRestrictedToObj.isEmptyType()) {\n        // 2) Take the intersection of all of these unions.\n        for (Map.Entry<String, JSType> entry : properties.entrySet()) {\n            String propName = entry.getKey();\n            JSType propType = entry.getValue();\n            UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n            for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) {\n                JSType altPropType = alt.getPropertyType(propName);\n                if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) {\n                    builder.addAlternate(alt);\n                }\n            }\n            greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());\n        }\n    }\n    return greatestSubtype;\n}", "code_comment": NaN, "code_no_comment": "JSType getGreatestSubtypeHelper(JSType that) {\n    if (that.isRecordType()) {\n        RecordType thatRecord = that.toMaybeRecordType();\n        RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n        builder.setSynthesized(true);\n                for (String property : properties.keySet()) {\n            if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isInvariant(getPropertyType(property))) {\n                return registry.getNativeObjectType(JSTypeNative.NO_TYPE);\n            }\n            builder.addProperty(property, getPropertyType(property), getPropertyNode(property));\n        }\n        for (String property : thatRecord.properties.keySet()) {\n            if (!hasProperty(property)) {\n                builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property));\n            }\n        }\n        return builder.build();\n    }\n    JSType greatestSubtype = registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE).getGreatestSubtype(that);\n    if (!thatRestrictedToObj.isEmptyType()) {\n                for (Map.Entry<String, JSType> entry : properties.entrySet()) {\n            String propName = entry.getKey();\n            JSType propType = entry.getValue();\n            UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n            for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) {\n                JSType altPropType = alt.getPropertyType(propName);\n                if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) {\n                    builder.addAlternate(alt);\n                }\n            }\n            greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());\n        }\n    }\n    return greatestSubtype;\n}", "lc": 1.0, "pi": 0.872448979591837, "ma": 1.0, "nbd": 1.0, "ml": 1.75, "d": 0.592189817103312, "mi": -0.7106395182104963, "fo": 2.4166666666666665, "r": -0.028571428571428574, "e": 1.643722615544734}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-4291_cdb34ffc", "label": 0, "code": "/**\n * Flush any pending changes on any {@link SegmentBufferWriter} managed by this instance.\n * This method <em>does not block</em> to wait for concurrent write operations. However, if\n * a write operation is currently in progress a call to this method ensures the respective\n * changes are properly flushed at the end of that call.\n * @throws IOException\n */\nvoid flush() throws IOException;", "code_comment": "/**\n * Flush any pending changes on any {@link SegmentBufferWriter} managed by this instance.\n * This method <em>does not block</em> to wait for concurrent write operations. However, if\n * a write operation is currently in progress a call to this method ensures the respective\n * changes are properly flushed at the end of that call.\n * @throws IOException\n */\n", "code_no_comment": "void flush() throws IOException;", "lc": -0.5909090909090909, "pi": -1.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.7880699741898483, "fo": -0.5, "r": 2.8000000000000003, "e": -0.16422749602751402}
{"project_name": "Lang", "project_version": 24, "label": 1, "code": "/**\n * <p>Checks whether the String a valid Java number.</p>\n *\n * <p>Valid numbers include hexadecimal marked with the <code>0x</code>\n * qualifier, scientific notation and numbers marked with a type\n * qualifier (e.g. 123L).</p>\n *\n * <p><code>Null</code> and empty String will return\n * <code>false</code>.</p>\n *\n * @param str  the <code>String</code> to check\n * @return <code>true</code> if the string is a correctly formatted number\n */\npublic static boolean isNumber(String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    char[] chars = str.toCharArray();\n    int sz = chars.length;\n    boolean hasExp = false;\n    boolean hasDecPoint = false;\n    boolean allowSigns = false;\n    boolean foundDigit = false;\n    // deal with any possible sign up front\n    int start = (chars[0] == '-') ? 1 : 0;\n    if (sz > start + 1) {\n        if (chars[start] == '0' && chars[start + 1] == 'x') {\n            int i = start + 2;\n            if (i == sz) {\n                // str == \"0x\"\n                return false;\n            }\n            // checking hex (it can't be anything else)\n            for (; i < chars.length; i++) {\n                if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    // don't want to loop to the last char, check it afterwords\n    sz--;\n    // for type qualifiers\n    int i = start;\n    // make a valid number (e.g. chars[0..5] = \"1234E\")\n    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            foundDigit = true;\n            allowSigns = false;\n        } else if (chars[i] == '.') {\n            if (hasDecPoint || hasExp) {\n                // two decimal points or dec in exponent\n                return false;\n            }\n            hasDecPoint = true;\n        } else if (chars[i] == 'e' || chars[i] == 'E') {\n            // we've already taken care of hex.\n            if (hasExp) {\n                // two E's\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp = true;\n            allowSigns = true;\n        } else if (chars[i] == '+' || chars[i] == '-') {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns = false;\n            // we need a digit after the E\n            foundDigit = false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i < chars.length) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            // no type qualifier, OK\n            return true;\n        }\n        if (chars[i] == 'e' || chars[i] == 'E') {\n            // can't have an E at the last byte\n            return false;\n        }\n        if (chars[i] == '.') {\n            if (hasDecPoint || hasExp) {\n                // two decimal points or dec in exponent\n                return false;\n            }\n            // single trailing decimal point after non-exponent is ok\n            return foundDigit;\n        }\n        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {\n            return foundDigit;\n        }\n        if (chars[i] == 'l' || chars[i] == 'L') {\n            // not allowing L with an exponent or decimal point\n            return foundDigit && !hasExp;\n        }\n        // last character is illegal\n        return false;\n    }\n    // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n    return !allowSigns && foundDigit;\n}", "code_comment": "/**\n * <p>Checks whether the String a valid Java number.</p>\n *\n * <p>Valid numbers include hexadecimal marked with the <code>0x</code>\n * qualifier, scientific notation and numbers marked with a type\n * qualifier (e.g. 123L).</p>\n *\n * <p><code>Null</code> and empty String will return\n * <code>false</code>.</p>\n *\n * @param str  the <code>String</code> to check\n * @return <code>true</code> if the string is a correctly formatted number\n */\n", "code_no_comment": "public static boolean isNumber(String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    char[] chars = str.toCharArray();\n    int sz = chars.length;\n    boolean hasExp = false;\n    boolean hasDecPoint = false;\n    boolean allowSigns = false;\n    boolean foundDigit = false;\n        int start = (chars[0] == '-') ? 1 : 0;\n    if (sz > start + 1) {\n        if (chars[start] == '0' && chars[start + 1] == 'x') {\n            int i = start + 2;\n            if (i == sz) {\n                                return false;\n            }\n                        for (; i < chars.length; i++) {\n                if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n        sz--;\n        int i = start;\n        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            foundDigit = true;\n            allowSigns = false;\n        } else if (chars[i] == '.') {\n            if (hasDecPoint || hasExp) {\n                                return false;\n            }\n            hasDecPoint = true;\n        } else if (chars[i] == 'e' || chars[i] == 'E') {\n                        if (hasExp) {\n                                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp = true;\n            allowSigns = true;\n        } else if (chars[i] == '+' || chars[i] == '-') {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns = false;\n                        foundDigit = false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i < chars.length) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n                        return true;\n        }\n        if (chars[i] == 'e' || chars[i] == 'E') {\n                        return false;\n        }\n        if (chars[i] == '.') {\n            if (hasDecPoint || hasExp) {\n                                return false;\n            }\n                        return foundDigit;\n        }\n        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {\n            return foundDigit;\n        }\n        if (chars[i] == 'l' || chars[i] == 'L') {\n                        return foundDigit && !hasExp;\n        }\n                return false;\n    }\n        return !allowSigns && foundDigit;\n}", "lc": 2.9545454545454546, "pi": 0.6071428571428571, "ma": 3.3333333333333335, "nbd": 2.0, "ml": 4.083333333333333, "d": 5.319822046465646, "mi": -1.2449096644680246, "fo": -0.3333333333333333, "r": -0.028571428571428574, "e": 17.561197699170382}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3280_295e73bd", "label": 1, "code": "/**\n *  @see org.apache.wicket.request.handler.IPageRequestHandler#respond(org.apache.wicket.request.IRequestCycle)\n */\npublic final void respond(final IRequestCycle requestCycle) {\n    // do not increment page id during ajax processing\n    boolean frozen = page.setFreezePageId(true);\n    try {\n        RequestCycle rc = (RequestCycle) requestCycle;\n        final WebResponse response = (WebResponse) requestCycle.getResponse();\n        if (markupIdToComponent.values().contains(page)) {\n            // the page itself has been added to the request target, we simply issue a redirect\n            // back to the page\n            IRequestHandler handler = new RenderPageRequestHandler(new PageProvider(page));\n            final String url = rc.urlFor(handler).toString();\n            response.sendRedirect(url);\n            return;\n        }\n        for (ITargetRespondListener listener : respondListeners) {\n            listener.onTargetRespond(this);\n        }\n        final Application app = Application.get();\n        page.send(app, Broadcast.BREADTH, this);\n        // Determine encoding\n        final String encoding = app.getRequestCycleSettings().getResponseRequestEncoding();\n        // Set content type based on markup type for page\n        response.setContentType(\"text/xml; charset=\" + encoding);\n        // Make sure it is not cached by a client\n        response.disableCaching();\n        response.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\n        response.write(encoding);\n        response.write(\"\\\"?>\");\n        response.write(\"<ajax-response>\");\n        // invoke onbeforerespond event on listeners\n        fireOnBeforeRespondListeners();\n        // normal behavior\n        Iterator<CharSequence> it = prependJavaScripts.iterator();\n        while (it.hasNext()) {\n            CharSequence js = it.next();\n            respondInvocation(response, js);\n        }\n        // process added components\n        respondComponents(response);\n        fireOnAfterRespondListeners(response);\n        // execute the dom ready javascripts as first javascripts\n        // after component replacement\n        it = domReadyJavaScripts.iterator();\n        while (it.hasNext()) {\n            CharSequence js = it.next();\n            respondInvocation(response, js);\n        }\n        it = appendJavaScripts.iterator();\n        while (it.hasNext()) {\n            CharSequence js = it.next();\n            respondInvocation(response, js);\n        }\n        response.write(\"</ajax-response>\");\n    } finally {\n        page.setFreezePageId(frozen);\n    }\n}", "code_comment": "/**\n *  @see org.apache.wicket.request.handler.IPageRequestHandler#respond(org.apache.wicket.request.IRequestCycle)\n */\n", "code_no_comment": "public final void respond(final IRequestCycle requestCycle) {\n        boolean frozen = page.setFreezePageId(true);\n    try {\n        RequestCycle rc = (RequestCycle) requestCycle;\n        final WebResponse response = (WebResponse) requestCycle.getResponse();\n        if (markupIdToComponent.values().contains(page)) {\n                                    IRequestHandler handler = new RenderPageRequestHandler(new PageProvider(page));\n            final String url = rc.urlFor(handler).toString();\n            response.sendRedirect(url);\n            return;\n        }\n        for (ITargetRespondListener listener : respondListeners) {\n            listener.onTargetRespond(this);\n        }\n        final Application app = Application.get();\n        page.send(app, Broadcast.BREADTH, this);\n                final String encoding = app.getRequestCycleSettings().getResponseRequestEncoding();\n                response.setContentType(\"text/xml; charset=\" + encoding);\n                response.disableCaching();\n        response.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\n        response.write(encoding);\n        response.write(\"\\\"?>\");\n        response.write(\"<ajax-response>\");\n                fireOnBeforeRespondListeners();\n                Iterator<CharSequence> it = prependJavaScripts.iterator();\n        while (it.hasNext()) {\n            CharSequence js = it.next();\n            respondInvocation(response, js);\n        }\n                respondComponents(response);\n        fireOnAfterRespondListeners(response);\n                        it = domReadyJavaScripts.iterator();\n        while (it.hasNext()) {\n            CharSequence js = it.next();\n            respondInvocation(response, js);\n        }\n        it = appendJavaScripts.iterator();\n        while (it.hasNext()) {\n            CharSequence js = it.next();\n            respondInvocation(response, js);\n        }\n        response.write(\"</ajax-response>\");\n    } finally {\n        page.setFreezePageId(frozen);\n    }\n}", "lc": 1.4545454545454546, "pi": -0.10204081632653071, "ma": 0.3333333333333333, "nbd": 0.0, "ml": 0.16666666666666666, "d": 0.0187839841819081, "mi": -0.7886435331230286, "fo": 2.4166666666666665, "r": -0.028571428571428574, "e": 0.5300602618628496}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1761_380ef878", "label": 1, "code": "private boolean decodeBufferOrEvent(RemoteInputChannel inputChannel, NettyMessage.BufferResponse bufferOrEvent) throws Throwable {\n    boolean releaseNettyBuffer = true;\n    try {\n        if (bufferOrEvent.isBuffer()) {\n            // ---- Buffer ------------------------------------------------\n            BufferProvider bufferProvider = inputChannel.getBufferProvider();\n            if (bufferProvider == null) {\n                // receiver has been cancelled/failed\n                return false;\n            }\n            while (true) {\n                Buffer buffer = bufferProvider.requestBuffer();\n                if (buffer != null) {\n                    buffer.setSize(bufferOrEvent.getSize());\n                    bufferOrEvent.getNettyBuffer().readBytes(buffer.getNioBuffer());\n                    inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber);\n                    return true;\n                } else if (bufferListener.waitForBuffer(bufferProvider, bufferOrEvent)) {\n                    releaseNettyBuffer = false;\n                    return false;\n                } else if (bufferProvider.isDestroyed()) {\n                    return false;\n                }\n            }\n        } else {\n            // ---- Event -------------------------------------------------\n            // TODO We can just keep the serialized data in the Netty buffer and release it later at the reader\n            byte[] byteArray = new byte[bufferOrEvent.getSize()];\n            bufferOrEvent.getNettyBuffer().readBytes(byteArray);\n            Buffer buffer = new Buffer(new MemorySegment(byteArray), EventSerializer.RECYCLER, false);\n            inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber);\n            return true;\n        }\n    } finally {\n        if (releaseNettyBuffer) {\n            bufferOrEvent.releaseBuffer();\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private boolean decodeBufferOrEvent(RemoteInputChannel inputChannel, NettyMessage.BufferResponse bufferOrEvent) throws Throwable {\n    boolean releaseNettyBuffer = true;\n    try {\n        if (bufferOrEvent.isBuffer()) {\n                        BufferProvider bufferProvider = inputChannel.getBufferProvider();\n            if (bufferProvider == null) {\n                                return false;\n            }\n            while (true) {\n                Buffer buffer = bufferProvider.requestBuffer();\n                if (buffer != null) {\n                    buffer.setSize(bufferOrEvent.getSize());\n                    bufferOrEvent.getNettyBuffer().readBytes(buffer.getNioBuffer());\n                    inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber);\n                    return true;\n                } else if (bufferListener.waitForBuffer(bufferProvider, bufferOrEvent)) {\n                    releaseNettyBuffer = false;\n                    return false;\n                } else if (bufferProvider.isDestroyed()) {\n                    return false;\n                }\n            }\n        } else {\n                                    byte[] byteArray = new byte[bufferOrEvent.getSize()];\n            bufferOrEvent.getNettyBuffer().readBytes(byteArray);\n            Buffer buffer = new Buffer(new MemorySegment(byteArray), EventSerializer.RECYCLER, false);\n            inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber);\n            return true;\n        }\n    } finally {\n        if (releaseNettyBuffer) {\n            bufferOrEvent.releaseBuffer();\n        }\n    }\n}", "lc": 0.9545454545454546, "pi": 1.4081632653061227, "ma": 0.6666666666666666, "nbd": 2.0, "ml": 0.75, "d": 0.056351952545724206, "mi": -0.5824490966446805, "fo": 0.8333333333333334, "r": -0.028571428571428574, "e": 0.24428111923454154}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1153_9f924f10", "label": 1, "code": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\nprivate void processRemainingProperties(ComponentBuilder<?> builder, String name, Properties properties) {\n    while (properties.size() > 0) {\n        String propertyName = properties.stringPropertyNames().iterator().next();\n        int index = propertyName.indexOf('.');\n        if (index > 0) {\n            String prefix = propertyName.substring(0, index);\n            Properties componentProperties = PropertiesUtil.extractSubset(properties, prefix);\n            builder.addComponent(createComponent(builder, prefix, componentProperties));\n        } else {\n            builder.addAttribute(propertyName, properties.getProperty(propertyName));\n            properties.remove(propertyName);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\nprivate void processRemainingProperties(ComponentBuilder<?> builder, String name, Properties properties) {\n    while (properties.size() > 0) {\n        String propertyName = properties.stringPropertyNames().iterator().next();\n        int index = propertyName.indexOf('.');\n        if (index > 0) {\n            String prefix = propertyName.substring(0, index);\n            Properties componentProperties = PropertiesUtil.extractSubset(properties, prefix);\n            builder.addComponent(createComponent(builder, prefix, componentProperties));\n        } else {\n            builder.addAttribute(propertyName, properties.getProperty(propertyName));\n            properties.remove(propertyName);\n        }\n    }\n}", "lc": 0.045454545454545456, "pi": 0.7193877551020407, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.030647553138902585, "mi": -0.09865213650702606, "fo": 0.5, "r": -0.028571428571428574, "e": 0.058989810734064}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2172_ea4a3f8a", "label": 3, "code": "// //\n// // getAs convenience methods\n// //\n/**\n *  @see IValueMap#getAsBoolean(String)\n */\npublic Boolean getAsBoolean(String key) {\n    if (!containsKey(key))\n        return null;\n    try {\n        return getBoolean(key);\n    } catch (StringValueConversionException ignored) {\n        return null;\n    }\n}", "code_comment": "/**\n *  @see IValueMap#getAsBoolean(String)\n */\n", "code_no_comment": "public Boolean getAsBoolean(String key) {\n    if (!containsKey(key))\n        return null;\n    try {\n        return getBoolean(key);\n    } catch (StringValueConversionException ignored) {\n        return null;\n    }\n}", "lc": -0.22727272727272727, "pi": -0.035714285714285636, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.16666666666666666, "d": -0.3806228373702422, "mi": 0.40808718095784363, "fo": -0.3333333333333333, "r": 2.8000000000000003, "e": -0.16422749602751402}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2121_03340919", "label": 3, "code": "/**\n *  Computes the input splits for the file. By default, one file block is one split. If more splits\n *  are requested than blocks are available, then a split may be a fraction of a block and splits may cross\n *  block boundaries.\n *\n *  @param minNumSplits The minimum desired number of file splits.\n *  @return The computed file splits.\n *\n *  @see org.apache.flink.api.common.io.InputFormat#createInputSplits(int)\n */\n@Override\npublic FileInputSplit[] createInputSplits(int minNumSplits) throws IOException {\n    if (minNumSplits < 1) {\n        throw new IllegalArgumentException(\"Number of input splits has to be at least 1.\");\n    }\n    // take the desired number of splits into account\n    minNumSplits = Math.max(minNumSplits, this.numSplits);\n    final Path path = this.filePath;\n    final List<FileInputSplit> inputSplits = new ArrayList<FileInputSplit>(minNumSplits);\n    // get all the files that are involved in the splits\n    List<FileStatus> files = new ArrayList<FileStatus>();\n    long totalLength = 0;\n    final FileSystem fs = path.getFileSystem();\n    final FileStatus pathFile = fs.getFileStatus(path);\n    if (pathFile.isDir()) {\n        totalLength += addFilesInDir(path, files, totalLength, true);\n    } else {\n        testForUnsplittable(pathFile);\n        files.add(pathFile);\n        totalLength += pathFile.getLen();\n    }\n    // returns if unsplittable\n    if (unsplittable) {\n        int splitNum = 0;\n        for (final FileStatus file : files) {\n            final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, file.getLen());\n            Set<String> hosts = new HashSet<String>();\n            for (BlockLocation block : blocks) {\n                hosts.addAll(Arrays.asList(block.getHosts()));\n            }\n            long len = file.getLen();\n            if (testForUnsplittable(file)) {\n                len = READ_WHOLE_SPLIT_FLAG;\n            }\n            FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), 0, len, hosts.toArray(new String[hosts.size()]));\n            inputSplits.add(fis);\n        }\n        return inputSplits.toArray(new FileInputSplit[inputSplits.size()]);\n    }\n    final long maxSplitSize = (minNumSplits < 1) ? Long.MAX_VALUE : (totalLength / minNumSplits + (totalLength % minNumSplits == 0 ? 0 : 1));\n    // now that we have the files, generate the splits\n    int splitNum = 0;\n    for (final FileStatus file : files) {\n        final long len = file.getLen();\n        final long blockSize = file.getBlockSize();\n        final long minSplitSize;\n        if (this.minSplitSize <= blockSize) {\n            minSplitSize = this.minSplitSize;\n        } else {\n            if (LOG.isWarnEnabled()) {\n                LOG.warn(\"Minimal split size of \" + this.minSplitSize + \" is larger than the block size of \" + blockSize + \". Decreasing minimal split size to block size.\");\n            }\n            minSplitSize = blockSize;\n        }\n        final long splitSize = Math.max(minSplitSize, Math.min(maxSplitSize, blockSize));\n        final long halfSplit = splitSize >>> 1;\n        final long maxBytesForLastSplit = (long) (splitSize * MAX_SPLIT_SIZE_DISCREPANCY);\n        if (len > 0) {\n            // get the block locations and make sure they are in order with respect to their offset\n            final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, len);\n            Arrays.sort(blocks);\n            long bytesUnassigned = len;\n            long position = 0;\n            int blockIndex = 0;\n            while (bytesUnassigned > maxBytesForLastSplit) {\n                // get the block containing the majority of the data\n                blockIndex = getBlockIndexForPosition(blocks, position, halfSplit, blockIndex);\n                // create a new split\n                FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), position, splitSize, blocks[blockIndex].getHosts());\n                inputSplits.add(fis);\n                // adjust the positions\n                position += splitSize;\n                bytesUnassigned -= splitSize;\n            }\n            // assign the last split\n            if (bytesUnassigned > 0) {\n                blockIndex = getBlockIndexForPosition(blocks, position, halfSplit, blockIndex);\n                final FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), position, bytesUnassigned, blocks[blockIndex].getHosts());\n                inputSplits.add(fis);\n            }\n        } else {\n            // special case with a file of zero bytes size\n            final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, 0);\n            String[] hosts;\n            if (blocks.length > 0) {\n                hosts = blocks[0].getHosts();\n            } else {\n                hosts = new String[0];\n            }\n            final FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), 0, 0, hosts);\n            inputSplits.add(fis);\n        }\n    }\n    return inputSplits.toArray(new FileInputSplit[inputSplits.size()]);\n}", "code_comment": "/**\n *  Computes the input splits for the file. By default, one file block is one split. If more splits\n *  are requested than blocks are available, then a split may be a fraction of a block and splits may cross\n *  block boundaries.\n *\n *  @param minNumSplits The minimum desired number of file splits.\n *  @return The computed file splits.\n *\n *  @see org.apache.flink.api.common.io.InputFormat#createInputSplits(int)\n */\n", "code_no_comment": "@Override\npublic FileInputSplit[] createInputSplits(int minNumSplits) throws IOException {\n    if (minNumSplits < 1) {\n        throw new IllegalArgumentException(\"Number of input splits has to be at least 1.\");\n    }\n        minNumSplits = Math.max(minNumSplits, this.numSplits);\n    final Path path = this.filePath;\n    final List<FileInputSplit> inputSplits = new ArrayList<FileInputSplit>(minNumSplits);\n        List<FileStatus> files = new ArrayList<FileStatus>();\n    long totalLength = 0;\n    final FileSystem fs = path.getFileSystem();\n    final FileStatus pathFile = fs.getFileStatus(path);\n    if (pathFile.isDir()) {\n        totalLength += addFilesInDir(path, files, totalLength, true);\n    } else {\n        testForUnsplittable(pathFile);\n        files.add(pathFile);\n        totalLength += pathFile.getLen();\n    }\n        if (unsplittable) {\n        int splitNum = 0;\n        for (final FileStatus file : files) {\n            final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, file.getLen());\n            Set<String> hosts = new HashSet<String>();\n            for (BlockLocation block : blocks) {\n                hosts.addAll(Arrays.asList(block.getHosts()));\n            }\n            long len = file.getLen();\n            if (testForUnsplittable(file)) {\n                len = READ_WHOLE_SPLIT_FLAG;\n            }\n            FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), 0, len, hosts.toArray(new String[hosts.size()]));\n            inputSplits.add(fis);\n        }\n        return inputSplits.toArray(new FileInputSplit[inputSplits.size()]);\n    }\n    final long maxSplitSize = (minNumSplits < 1) ? Long.MAX_VALUE : (totalLength / minNumSplits + (totalLength % minNumSplits == 0 ? 0 : 1));\n        int splitNum = 0;\n    for (final FileStatus file : files) {\n        final long len = file.getLen();\n        final long blockSize = file.getBlockSize();\n        final long minSplitSize;\n        if (this.minSplitSize <= blockSize) {\n            minSplitSize = this.minSplitSize;\n        } else {\n            if (LOG.isWarnEnabled()) {\n                LOG.warn(\"Minimal split size of \" + this.minSplitSize + \" is larger than the block size of \" + blockSize + \". Decreasing minimal split size to block size.\");\n            }\n            minSplitSize = blockSize;\n        }\n        final long splitSize = Math.max(minSplitSize, Math.min(maxSplitSize, blockSize));\n        final long halfSplit = splitSize >>> 1;\n        final long maxBytesForLastSplit = (long) (splitSize * MAX_SPLIT_SIZE_DISCREPANCY);\n        if (len > 0) {\n                        final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, len);\n            Arrays.sort(blocks);\n            long bytesUnassigned = len;\n            long position = 0;\n            int blockIndex = 0;\n            while (bytesUnassigned > maxBytesForLastSplit) {\n                                blockIndex = getBlockIndexForPosition(blocks, position, halfSplit, blockIndex);\n                                FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), position, splitSize, blocks[blockIndex].getHosts());\n                inputSplits.add(fis);\n                                position += splitSize;\n                bytesUnassigned -= splitSize;\n            }\n                        if (bytesUnassigned > 0) {\n                blockIndex = getBlockIndexForPosition(blocks, position, halfSplit, blockIndex);\n                final FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), position, bytesUnassigned, blocks[blockIndex].getHosts());\n                inputSplits.add(fis);\n            }\n        } else {\n                        final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, 0);\n            String[] hosts;\n            if (blocks.length > 0) {\n                hosts = blocks[0].getHosts();\n            } else {\n                hosts = new String[0];\n            }\n            final FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), 0, 0, hosts);\n            inputSplits.add(fis);\n        }\n    }\n    return inputSplits.toArray(new FileInputSplit[inputSplits.size()]);\n}", "lc": 3.227272727272727, "pi": 0.6887755102040817, "ma": 2.1666666666666665, "nbd": 0.5, "ml": 1.6666666666666667, "d": 3.734058329214039, "mi": -1.2893604817895044, "fo": 3.0833333333333335, "r": -0.028571428571428574, "e": 18.520701898655567}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_add180fb", "label": 1, "code": "@Override\npublic Map<String, Set<Text>> getLocalityGroups(String tableName) throws AccumuloException, TableNotFoundException {\n    return null;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Map<String, Set<Text>> getLocalityGroups(String tableName) throws AccumuloException, TableNotFoundException {\n    return null;\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8210496128477202, "fo": -0.5, "r": 0.2285714285714286, "e": -0.16422749602751402}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3534_734ba01d", "label": 0, "code": "public void fail(Throwable t) {\n    while (true) {\n        JobStatus current = state;\n        if (current == JobStatus.FAILED || current == JobStatus.FAILING) {\n            return;\n        } else if (transitionState(current, JobStatus.FAILING, t)) {\n            this.failureCause = t;\n            if (!verticesInCreationOrder.isEmpty()) {\n                // cancel all. what is failed will not cancel but stay failed\n                for (ExecutionJobVertex ejv : verticesInCreationOrder) {\n                    ejv.cancel();\n                }\n            } else {\n                // set the state of the job to failed\n                transitionState(JobStatus.FAILING, JobStatus.FAILED, t);\n            }\n            return;\n        }\n    // no need to treat other states\n    }\n}", "code_comment": NaN, "code_no_comment": "public void fail(Throwable t) {\n    while (true) {\n        JobStatus current = state;\n        if (current == JobStatus.FAILED || current == JobStatus.FAILING) {\n            return;\n        } else if (transitionState(current, JobStatus.FAILING, t)) {\n            this.failureCause = t;\n            if (!verticesInCreationOrder.isEmpty()) {\n                                for (ExecutionJobVertex ejv : verticesInCreationOrder) {\n                    ejv.cancel();\n                }\n            } else {\n                                transitionState(JobStatus.FAILING, JobStatus.FAILED, t);\n            }\n            return;\n        }\n        }\n}", "lc": 0.18181818181818182, "pi": 1.1989795918367347, "ma": 0.3333333333333333, "nbd": 1.5, "ml": 0.3333333333333333, "d": 0.41028175976272874, "mi": -0.1258961858330944, "fo": -0.16666666666666666, "r": 0.028571428571428574, "e": 0.1367691589465524}
{"project_name": "Closure", "project_version": 90, "label": 2, "code": "@Override\npublic boolean apply(JSType type) {\n    // union types can also be object types, etc.\n    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n        return false;\n    }\n    return true;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean apply(JSType type) {\n        if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n        return false;\n    }\n    return true;\n}", "lc": -0.2727272727272727, "pi": 0.051020408163265356, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.16666666666666666, "d": -0.3806228373702422, "mi": 0.4221393748207629, "fo": -0.16666666666666666, "r": 0.7714285714285716, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1369_ce0b0955", "label": 1, "code": "private Expression parsePropertyOrFunction() throws ParseException {\n    StringBuilder buff = new StringBuilder();\n    boolean isPath = false;\n    while (true) {\n        if (currentTokenType == IDENTIFIER) {\n            String name = readPathSegment();\n            buff.append(name);\n        } else if (readIf(\"*\")) {\n            // any node\n            buff.append('*');\n            isPath = true;\n        } else if (readIf(\".\")) {\n            buff.append('.');\n            if (readIf(\".\")) {\n                buff.append('.');\n            }\n            isPath = true;\n        } else if (readIf(\"@\")) {\n            if (readIf(\"*\")) {\n                // xpath supports @*, even thought jackrabbit may not\n                buff.append('*');\n            } else {\n                buff.append(readPathSegment());\n            }\n            return new Expression.Property(currentSelector, buff.toString(), false);\n        } else {\n            break;\n        }\n        if (readIf(\"/\")) {\n            isPath = true;\n            buff.append('/');\n        } else {\n            break;\n        }\n    }\n    if (!isPath && readIf(\"(\")) {\n        return parseFunction(buff.toString());\n    } else if (buff.length() > 0) {\n        // jcr:contains(jcr:content, 'x')\n        if (buff.toString().equals(\".\")) {\n            buff = new StringBuilder(\"*\");\n        } else {\n            buff.append(\"/*\");\n        }\n        return new Expression.Property(currentSelector, buff.toString(), true);\n    }\n    throw getSyntaxError();\n}", "code_comment": NaN, "code_no_comment": "private Expression parsePropertyOrFunction() throws ParseException {\n    StringBuilder buff = new StringBuilder();\n    boolean isPath = false;\n    while (true) {\n        if (currentTokenType == IDENTIFIER) {\n            String name = readPathSegment();\n            buff.append(name);\n        } else if (readIf(\"*\")) {\n                        buff.append('*');\n            isPath = true;\n        } else if (readIf(\".\")) {\n            buff.append('.');\n            if (readIf(\".\")) {\n                buff.append('.');\n            }\n            isPath = true;\n        } else if (readIf(\"@\")) {\n            if (readIf(\"*\")) {\n                                buff.append('*');\n            } else {\n                buff.append(readPathSegment());\n            }\n            return new Expression.Property(currentSelector, buff.toString(), false);\n        } else {\n            break;\n        }\n        if (readIf(\"/\")) {\n            isPath = true;\n            buff.append('/');\n        } else {\n            break;\n        }\n    }\n    if (!isPath && readIf(\"(\")) {\n        return parseFunction(buff.toString());\n    } else if (buff.length() > 0) {\n                if (buff.toString().equals(\".\")) {\n            buff = new StringBuilder(\"*\");\n        } else {\n            buff.append(\"/*\");\n        }\n        return new Expression.Property(currentSelector, buff.toString(), true);\n    }\n    throw getSyntaxError();\n}", "lc": 1.4090909090909092, "pi": 0.44897959183673464, "ma": 1.8333333333333333, "nbd": 2.0, "ml": 1.3333333333333333, "d": 0.7523479980227388, "mi": -0.7662747347289935, "fo": 1.5833333333333333, "r": -0.028571428571428574, "e": 1.0575293064532019}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "public void getResult() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\n    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {\n        throw new IllegalStateException(\"Method call not finished!\");\n    }\n    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());\n    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);\n    (new Client(prot)).recv_removeTableProperty();\n}", "code_comment": NaN, "code_no_comment": "public void getResult() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\n    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {\n        throw new IllegalStateException(\"Method call not finished!\");\n    }\n    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());\n    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);\n    (new Client(prot)).recv_removeTableProperty();\n}", "lc": -0.2727272727272727, "pi": -0.31632653061224497, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.25, "d": -0.07019278299555112, "mi": 0.22999713220533405, "fo": 0.0, "r": -0.028571428571428574, "e": -0.00900715689927659}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2899_31aea2ad", "label": 0, "code": "// TODO Remove deprecation warning suppression when Hadoop1 support is dropped\n@SuppressWarnings(\"deprecation\")\n/**\n * Scans write-ahead log directories for logs. The maps passed in are\n * populated with scan information.\n *\n * @param walDirs write-ahead log directories\n * @param fileToServerMap map of file paths to servers\n * @param nameToFileMap map of file names to paths\n * @return number of servers located (including those with no logs present)\n */\nint scanServers(String[] walDirs, Map<Path, String> fileToServerMap, Map<String, Path> nameToFileMap) throws Exception {\n    Set<String> servers = new HashSet<String>();\n    for (String walDir : walDirs) {\n        Path walRoot = new Path(walDir);\n        FileStatus[] listing = null;\n        try {\n            listing = fs.listStatus(walRoot);\n        } catch (FileNotFoundException e) {\n        // ignore dir\n        }\n        if (listing == null)\n            continue;\n        for (FileStatus status : listing) {\n            String server = status.getPath().getName();\n            servers.add(server);\n            if (status.isDir()) {\n                for (FileStatus file : fs.listStatus(new Path(walRoot, server))) {\n                    if (isUUID(file.getPath().getName())) {\n                        fileToServerMap.put(file.getPath(), server);\n                        nameToFileMap.put(file.getPath().getName(), file.getPath());\n                    } else {\n                        log.info(\"Ignoring file \" + file.getPath() + \" because it doesn't look like a uuid\");\n                    }\n                }\n            } else if (isUUID(server)) {\n                // old-style WAL are not under a directory\n                fileToServerMap.put(status.getPath(), \"\");\n            } else {\n                log.info(\"Ignoring file \" + status.getPath() + \" because it doesn't look like a uuid\");\n            }\n        }\n    }\n    return servers.size();\n}", "code_comment": "/**\n * Scans write-ahead log directories for logs. The maps passed in are\n * populated with scan information.\n *\n * @param walDirs write-ahead log directories\n * @param fileToServerMap map of file paths to servers\n * @param nameToFileMap map of file names to paths\n * @return number of servers located (including those with no logs present)\n */\n", "code_no_comment": "@SuppressWarnings(\"deprecation\")\nint scanServers(String[] walDirs, Map<Path, String> fileToServerMap, Map<String, Path> nameToFileMap) throws Exception {\n    Set<String> servers = new HashSet<String>();\n    for (String walDir : walDirs) {\n        Path walRoot = new Path(walDir);\n        FileStatus[] listing = null;\n        try {\n            listing = fs.listStatus(walRoot);\n        } catch (FileNotFoundException e) {\n                }\n        if (listing == null)\n            continue;\n        for (FileStatus status : listing) {\n            String server = status.getPath().getName();\n            servers.add(server);\n            if (status.isDir()) {\n                for (FileStatus file : fs.listStatus(new Path(walRoot, server))) {\n                    if (isUUID(file.getPath().getName())) {\n                        fileToServerMap.put(file.getPath(), server);\n                        nameToFileMap.put(file.getPath().getName(), file.getPath());\n                    } else {\n                        log.info(\"Ignoring file \" + file.getPath() + \" because it doesn't look like a uuid\");\n                    }\n                }\n            } else if (isUUID(server)) {\n                                fileToServerMap.put(status.getPath(), \"\");\n            } else {\n                log.info(\"Ignoring file \" + status.getPath() + \" because it doesn't look like a uuid\");\n            }\n        }\n    }\n    return servers.size();\n}", "lc": 0.8636363636363636, "pi": 1.8826530612244898, "ma": 1.0, "nbd": 1.5, "ml": 0.4166666666666667, "d": 0.11369253583786461, "mi": -0.6045311155721251, "fo": 1.4166666666666667, "r": -0.028571428571428574, "e": 0.4266428531657822}
{"project_name": "Closure", "project_version": 112, "label": 2, "code": "/**\n * For functions with function(this: T, ...) and T as parameters, type\n * inference will set the type of this on a function literal argument to the\n * the actual type of T.\n */\nprivate boolean inferTemplatedTypesForCall(Node n, FunctionType fnType) {\n    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap().getTemplateKeys();\n    if (keys.isEmpty()) {\n        return false;\n    }\n    // Try to infer the template types\n    Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n);\n    // Replace all template types. If we couldn't find a replacement, we\n    // replace it with UNKNOWN.\n    TemplateTypeReplacer replacer = new TemplateTypeReplacer(registry, inferred);\n    Node callTarget = n.getFirstChild();\n    FunctionType replacementFnType = fnType.visit(replacer).toMaybeFunctionType();\n    Preconditions.checkNotNull(replacementFnType);\n    callTarget.setJSType(replacementFnType);\n    n.setJSType(replacementFnType.getReturnType());\n    return replacer.madeChanges;\n}", "code_comment": "/**\n * For functions with function(this: T, ...) and T as parameters, type\n * inference will set the type of this on a function literal argument to the\n * the actual type of T.\n */\n", "code_no_comment": "private boolean inferTemplatedTypesForCall(Node n, FunctionType fnType) {\n    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap().getTemplateKeys();\n    if (keys.isEmpty()) {\n        return false;\n    }\n        Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n);\n            TemplateTypeReplacer replacer = new TemplateTypeReplacer(registry, inferred);\n    Node callTarget = n.getFirstChild();\n    FunctionType replacementFnType = fnType.visit(replacer).toMaybeFunctionType();\n    Preconditions.checkNotNull(replacementFnType);\n    callTarget.setJSType(replacementFnType);\n    n.setJSType(replacementFnType.getReturnType());\n    return replacer.madeChanges;\n}", "lc": 0.0, "pi": -0.6071428571428571, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.3806228373702422, "mi": -0.04559793518784066, "fo": 0.4166666666666667, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5226_8e518d88", "label": 1, "code": "@Override\npublic void onInstantiation(Component component) {\n    Class<? extends Component> componentClass = component.getClass();\n    if (componentClass.isMemberClass() && Modifier.isStatic(componentClass.getModifiers()) == false) {\n        LOG.debug(\"Skipping non-static inner class '{}' \", componentClass);\n    } else {\n        inject(component);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void onInstantiation(Component component) {\n    Class<? extends Component> componentClass = component.getClass();\n    if (componentClass.isMemberClass() && Modifier.isStatic(componentClass.getModifiers()) == false) {\n        LOG.debug(\"Skipping non-static inner class '{}' \", componentClass);\n    } else {\n        inject(component);\n    }\n}", "lc": -0.22727272727272727, "pi": -0.035714285714285636, "ma": -0.3333333333333333, "nbd": -0.5, "ml": 0.0, "d": -0.11369253583786453, "mi": 0.2890737023229137, "fo": 0.0, "r": 0.2571428571428572, "e": -0.09911298992209217}
{"project_name": "Cli", "project_version": 22, "label": 1, "code": "/**\n * Add the special token \"<b>--</b>\" and the current <code>value</code>\n * to the processed tokens list. Then add all the remaining\n * <code>argument</code> values to the processed tokens list.\n *\n * @param value The current token\n */\nprivate void processNonOptionToken(String value) {\n    eatTheRest = true;\n    tokens.add(\"--\");\n    tokens.add(value);\n}", "code_comment": "/**\n * Add the special token \"<b>--</b>\" and the current <code>value</code>\n * to the processed tokens list. Then add all the remaining\n * <code>argument</code> values to the processed tokens list.\n *\n * @param value The current token\n */\n", "code_no_comment": "private void processNonOptionToken(String value) {\n    eatTheRest = true;\n    tokens.add(\"--\");\n    tokens.add(value);\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7114998566102669, "fo": -0.3333333333333333, "r": 2.4571428571428573, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1308_69ba2a54", "label": 1, "code": "private Expression parsePropertyOrFunction() throws ParseException {\n    StringBuilder buff = new StringBuilder();\n    boolean isPath = false;\n    while (true) {\n        if (currentTokenType == IDENTIFIER) {\n            String name = readIdentifier();\n            buff.append(name);\n        } else if (readIf(\"*\")) {\n            // any node\n            buff.append('*');\n            isPath = true;\n        } else if (readIf(\".\")) {\n            buff.append('.');\n            if (readIf(\".\")) {\n                buff.append('.');\n            }\n            isPath = true;\n        } else if (readIf(\"@\")) {\n            if (readIf(\"*\")) {\n                // xpath supports @*, even thought jackrabbit may not\n                buff.append('*');\n            } else {\n                buff.append(readIdentifier());\n            }\n            return new Expression.Property(currentSelector, buff.toString());\n        } else {\n            break;\n        }\n        if (readIf(\"/\")) {\n            isPath = true;\n            buff.append('/');\n        } else {\n            break;\n        }\n    }\n    if (!isPath && readIf(\"(\")) {\n        return parseFunction(buff.toString());\n    } else if (buff.length() > 0) {\n        // jcr:contains(jcr:content, 'x')\n        if (buff.toString().equals(\".\")) {\n            buff = new StringBuilder(\"*\");\n        } else {\n            buff.append(\"/*\");\n        }\n        return new Expression.Property(currentSelector, buff.toString());\n    }\n    throw getSyntaxError();\n}", "code_comment": NaN, "code_no_comment": "private Expression parsePropertyOrFunction() throws ParseException {\n    StringBuilder buff = new StringBuilder();\n    boolean isPath = false;\n    while (true) {\n        if (currentTokenType == IDENTIFIER) {\n            String name = readIdentifier();\n            buff.append(name);\n        } else if (readIf(\"*\")) {\n                        buff.append('*');\n            isPath = true;\n        } else if (readIf(\".\")) {\n            buff.append('.');\n            if (readIf(\".\")) {\n                buff.append('.');\n            }\n            isPath = true;\n        } else if (readIf(\"@\")) {\n            if (readIf(\"*\")) {\n                                buff.append('*');\n            } else {\n                buff.append(readIdentifier());\n            }\n            return new Expression.Property(currentSelector, buff.toString());\n        } else {\n            break;\n        }\n        if (readIf(\"/\")) {\n            isPath = true;\n            buff.append('/');\n        } else {\n            break;\n        }\n    }\n    if (!isPath && readIf(\"(\")) {\n        return parseFunction(buff.toString());\n    } else if (buff.length() > 0) {\n                if (buff.toString().equals(\".\")) {\n            buff = new StringBuilder(\"*\");\n        } else {\n            buff.append(\"/*\");\n        }\n        return new Expression.Property(currentSelector, buff.toString());\n    }\n    throw getSyntaxError();\n}", "lc": 1.4090909090909092, "pi": 0.44897959183673464, "ma": 1.8333333333333333, "nbd": 2.0, "ml": 1.3333333333333333, "d": 0.726643598615917, "mi": -0.7631201605965015, "fo": 1.5833333333333333, "r": -0.028571428571428574, "e": 1.0045100029552727}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1174_342809f7", "label": 3, "code": "public static boolean parse(String jcrPath, Listener listener) {\n    // check for length\n    int len = jcrPath == null ? 0 : jcrPath.length();\n    // shortcut for root path\n    if (len == 1 && jcrPath.charAt(0) == '/') {\n        listener.root();\n        return true;\n    }\n    // short cut for empty path\n    if (len == 0) {\n        return true;\n    }\n    // check if absolute path\n    int pos = 0;\n    if (jcrPath.charAt(0) == '/') {\n        if (!listener.root()) {\n            return false;\n        }\n        pos++;\n    }\n    // parse the path\n    int state = STATE_PREFIX_START;\n    int lastPos = pos;\n    String name = null;\n    int index = 0;\n    boolean wasSlash = false;\n    while (pos <= len) {\n        char c = pos == len ? EOF : jcrPath.charAt(pos);\n        pos++;\n        // special check for whitespace\n        if (c != ' ' && Character.isWhitespace(c)) {\n            c = '\\t';\n        }\n        switch(c) {\n            case '/':\n            case EOF:\n                if (state == STATE_PREFIX_START && c != EOF) {\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. \" + \"double slash '//' not allowed.\");\n                    return false;\n                }\n                if (state == STATE_PREFIX || state == STATE_NAME || state == STATE_INDEX_END || state == STATE_URI_END) {\n                    // eof path element\n                    if (name == null) {\n                        if (wasSlash) {\n                            listener.error('\\'' + jcrPath + \"' is not a valid path: \" + \"Trailing slashes not allowed in prefixes and names.\");\n                            return false;\n                        }\n                        name = jcrPath.substring(lastPos, pos - 1);\n                    }\n                    if (!JcrNameParser.parse(name, listener, index)) {\n                        return false;\n                    }\n                    state = STATE_PREFIX_START;\n                    lastPos = pos;\n                    name = null;\n                    index = 0;\n                } else if (state == STATE_DOT) {\n                    if (!listener.current()) {\n                        return false;\n                    }\n                    lastPos = pos;\n                    state = STATE_PREFIX_START;\n                } else if (state == STATE_DOTDOT) {\n                    if (!listener.parent()) {\n                        return false;\n                    }\n                    lastPos = pos;\n                    state = STATE_PREFIX_START;\n                } else if (state != STATE_URI && !(state == STATE_PREFIX_START && c == EOF)) {\n                    // ignore trailing slash\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not a valid name character.\");\n                    return false;\n                }\n                break;\n            case '.':\n                if (state == STATE_PREFIX_START) {\n                    state = STATE_DOT;\n                } else if (state == STATE_DOT) {\n                    state = STATE_DOTDOT;\n                } else if (state == STATE_DOTDOT) {\n                    state = STATE_PREFIX;\n                } else if (state == STATE_INDEX_END) {\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not valid after index. '/' expected.\");\n                    return false;\n                }\n                break;\n            case ':':\n                if (state == STATE_PREFIX_START) {\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. Prefix \" + \"must not be empty\");\n                    return false;\n                } else if (state == STATE_PREFIX) {\n                    if (wasSlash) {\n                        listener.error('\\'' + jcrPath + \"' is not a valid path: \" + \"Trailing slashes not allowed in prefixes and names.\");\n                        return false;\n                    }\n                    state = STATE_NAME_START;\n                // don't reset the lastPos/pos since prefix+name are passed together to the NameResolver\n                } else if (state != STATE_URI) {\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not valid name character\");\n                    return false;\n                }\n                break;\n            case '[':\n                if (state == STATE_PREFIX || state == STATE_NAME) {\n                    if (wasSlash) {\n                        listener.error('\\'' + jcrPath + \"' is not a valid path: \" + \"Trailing slashes not allowed in prefixes and names.\");\n                        return false;\n                    }\n                    state = STATE_INDEX;\n                    name = jcrPath.substring(lastPos, pos - 1);\n                    lastPos = pos;\n                }\n                break;\n            case ']':\n                if (state == STATE_INDEX) {\n                    try {\n                        index = Integer.parseInt(jcrPath.substring(lastPos, pos - 1));\n                    } catch (NumberFormatException e) {\n                        listener.error('\\'' + jcrPath + \"' is not a valid path. \" + \"NumberFormatException in index: \" + jcrPath.substring(lastPos, pos - 1));\n                        return false;\n                    }\n                    if (index < 0) {\n                        listener.error('\\'' + jcrPath + \"' is not a valid path. \" + \"Index number invalid: \" + index);\n                        return false;\n                    }\n                    state = STATE_INDEX_END;\n                } else {\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not a valid name character.\");\n                    return false;\n                }\n                break;\n            case ' ':\n                if (state == STATE_PREFIX_START || state == STATE_NAME_START) {\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not valid name start\");\n                    return false;\n                } else if (state == STATE_INDEX_END) {\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not valid after index. '/' expected.\");\n                    return false;\n                } else if (state == STATE_DOT || state == STATE_DOTDOT) {\n                    state = STATE_PREFIX;\n                }\n                break;\n            case '\\t':\n                listener.error('\\'' + jcrPath + \"' is not a valid path. \" + \"Whitespace not a allowed in name.\");\n                return false;\n            case '*':\n            case '|':\n                listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not a valid name character.\");\n                return false;\n            case '{':\n                if (state == STATE_PREFIX_START && lastPos == pos - 1) {\n                    // '{' marks the start of a uri enclosed in an expanded name\n                    // instead of the usual namespace prefix, if it is\n                    // located at the beginning of a new segment.\n                    state = STATE_URI;\n                } else if (state == STATE_NAME_START || state == STATE_DOT || state == STATE_DOTDOT) {\n                    // otherwise it's part of the local name\n                    state = STATE_NAME;\n                }\n                break;\n            case '}':\n                if (state == STATE_URI) {\n                    state = STATE_URI_END;\n                }\n                break;\n            default:\n                if (state == STATE_PREFIX_START || state == STATE_DOT || state == STATE_DOTDOT) {\n                    state = STATE_PREFIX;\n                } else if (state == STATE_NAME_START) {\n                    state = STATE_NAME;\n                } else if (state == STATE_INDEX_END) {\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not valid after index. '/' expected.\");\n                    return false;\n                }\n        }\n        wasSlash = c == ' ';\n    }\n    return true;\n}", "code_comment": NaN, "code_no_comment": "public static boolean parse(String jcrPath, Listener listener) {\n        int len = jcrPath == null ? 0 : jcrPath.length();\n        if (len == 1 && jcrPath.charAt(0) == '/') {\n        listener.root();\n        return true;\n    }\n        if (len == 0) {\n        return true;\n    }\n        int pos = 0;\n    if (jcrPath.charAt(0) == '/') {\n        if (!listener.root()) {\n            return false;\n        }\n        pos++;\n    }\n        int state = STATE_PREFIX_START;\n    int lastPos = pos;\n    String name = null;\n    int index = 0;\n    boolean wasSlash = false;\n    while (pos <= len) {\n        char c = pos == len ? EOF : jcrPath.charAt(pos);\n        pos++;\n                if (c != ' ' && Character.isWhitespace(c)) {\n            c = '\\t';\n        }\n        switch(c) {\n            case '/':\n            case EOF:\n                if (state == STATE_PREFIX_START && c != EOF) {\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. \" + \"double slash '//' not allowed.\");\n                    return false;\n                }\n                if (state == STATE_PREFIX || state == STATE_NAME || state == STATE_INDEX_END || state == STATE_URI_END) {\n                                        if (name == null) {\n                        if (wasSlash) {\n                            listener.error('\\'' + jcrPath + \"' is not a valid path: \" + \"Trailing slashes not allowed in prefixes and names.\");\n                            return false;\n                        }\n                        name = jcrPath.substring(lastPos, pos - 1);\n                    }\n                    if (!JcrNameParser.parse(name, listener, index)) {\n                        return false;\n                    }\n                    state = STATE_PREFIX_START;\n                    lastPos = pos;\n                    name = null;\n                    index = 0;\n                } else if (state == STATE_DOT) {\n                    if (!listener.current()) {\n                        return false;\n                    }\n                    lastPos = pos;\n                    state = STATE_PREFIX_START;\n                } else if (state == STATE_DOTDOT) {\n                    if (!listener.parent()) {\n                        return false;\n                    }\n                    lastPos = pos;\n                    state = STATE_PREFIX_START;\n                } else if (state != STATE_URI && !(state == STATE_PREFIX_START && c == EOF)) {\n                                        listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not a valid name character.\");\n                    return false;\n                }\n                break;\n            case '.':\n                if (state == STATE_PREFIX_START) {\n                    state = STATE_DOT;\n                } else if (state == STATE_DOT) {\n                    state = STATE_DOTDOT;\n                } else if (state == STATE_DOTDOT) {\n                    state = STATE_PREFIX;\n                } else if (state == STATE_INDEX_END) {\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not valid after index. '/' expected.\");\n                    return false;\n                }\n                break;\n            case ':':\n                if (state == STATE_PREFIX_START) {\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. Prefix \" + \"must not be empty\");\n                    return false;\n                } else if (state == STATE_PREFIX) {\n                    if (wasSlash) {\n                        listener.error('\\'' + jcrPath + \"' is not a valid path: \" + \"Trailing slashes not allowed in prefixes and names.\");\n                        return false;\n                    }\n                    state = STATE_NAME_START;\n                                } else if (state != STATE_URI) {\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not valid name character\");\n                    return false;\n                }\n                break;\n            case '[':\n                if (state == STATE_PREFIX || state == STATE_NAME) {\n                    if (wasSlash) {\n                        listener.error('\\'' + jcrPath + \"' is not a valid path: \" + \"Trailing slashes not allowed in prefixes and names.\");\n                        return false;\n                    }\n                    state = STATE_INDEX;\n                    name = jcrPath.substring(lastPos, pos - 1);\n                    lastPos = pos;\n                }\n                break;\n            case ']':\n                if (state == STATE_INDEX) {\n                    try {\n                        index = Integer.parseInt(jcrPath.substring(lastPos, pos - 1));\n                    } catch (NumberFormatException e) {\n                        listener.error('\\'' + jcrPath + \"' is not a valid path. \" + \"NumberFormatException in index: \" + jcrPath.substring(lastPos, pos - 1));\n                        return false;\n                    }\n                    if (index < 0) {\n                        listener.error('\\'' + jcrPath + \"' is not a valid path. \" + \"Index number invalid: \" + index);\n                        return false;\n                    }\n                    state = STATE_INDEX_END;\n                } else {\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not a valid name character.\");\n                    return false;\n                }\n                break;\n            case ' ':\n                if (state == STATE_PREFIX_START || state == STATE_NAME_START) {\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not valid name start\");\n                    return false;\n                } else if (state == STATE_INDEX_END) {\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not valid after index. '/' expected.\");\n                    return false;\n                } else if (state == STATE_DOT || state == STATE_DOTDOT) {\n                    state = STATE_PREFIX;\n                }\n                break;\n            case '\\t':\n                listener.error('\\'' + jcrPath + \"' is not a valid path. \" + \"Whitespace not a allowed in name.\");\n                return false;\n            case '*':\n            case '|':\n                listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not a valid name character.\");\n                return false;\n            case '{':\n                if (state == STATE_PREFIX_START && lastPos == pos - 1) {\n                                                                                state = STATE_URI;\n                } else if (state == STATE_NAME_START || state == STATE_DOT || state == STATE_DOTDOT) {\n                                        state = STATE_NAME;\n                }\n                break;\n            case '}':\n                if (state == STATE_URI) {\n                    state = STATE_URI_END;\n                }\n                break;\n            default:\n                if (state == STATE_PREFIX_START || state == STATE_DOT || state == STATE_DOTDOT) {\n                    state = STATE_PREFIX;\n                } else if (state == STATE_NAME_START) {\n                    state = STATE_NAME;\n                } else if (state == STATE_INDEX_END) {\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not valid after index. '/' expected.\");\n                    return false;\n                }\n        }\n        wasSlash = c == ' ';\n    }\n    return true;\n}", "lc": 6.909090909090909, "pi": 1.5408163265306123, "ma": 9.666666666666666, "nbd": 2.5, "ml": 6.5, "d": 4.746416213544242, "mi": -1.9555491826785207, "fo": 2.0833333333333335, "r": -0.028571428571428574, "e": 34.26401720054309}
{"project_name": "Closure", "project_version": 166, "label": 2, "code": "@Override\npublic void matchConstraint(JSType constraint) {\n    // We only want to match constraints on anonymous types.\n    if (hasReferenceName()) {\n        return;\n    }\n    // properties on this object.\n    if (constraint.isRecordType()) {\n        matchRecordTypeConstraint(constraint.toObjectType());\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void matchConstraint(JSType constraint) {\n        if (hasReferenceName()) {\n        return;\n    }\n        if (constraint.isRecordType()) {\n        matchRecordTypeConstraint(constraint.toObjectType());\n    }\n}", "lc": -0.22727272727272727, "pi": -0.035714285714285636, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.3806228373702422, "mi": 0.45712646974476634, "fo": -0.16666666666666666, "r": 2.085714285714286, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-395_962315ba", "label": 1, "code": "/**\n * Find the minimum of the function {@code f} within the interval {@code (a, b)}.\n *\n * If the function {@code f} is defined on the interval {@code (a, b)}, then\n * this method finds an approximation {@code x} to the point at which {@code f}\n * attains its minimum.<br/>\n * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t} and\n * {@code f} is never evaluated at two points closer together than {@code tol}.\n * {@code eps} should be no smaller than <em>2 macheps</em> and preferable not\n * much less than <em>sqrt(macheps)</em>, where <em>macheps</em> is the relative\n * machine precision. {@code t} should be positive.\n * @param f the function to solve.\n * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n * or {@link GoalType#MINIMIZE}.\n * @param lo Lower bound of the interval.\n * @param mid Point inside the interval {@code [lo, hi]}.\n * @param hi Higher bound of the interval.\n * @param eps Relative accuracy.\n * @param t Absolute accuracy.\n * @return the optimum point.\n * @throws MaxIterationsExceededException if the maximum iteration count\n * is exceeded.\n * @throws FunctionEvaluationException if an error occurs evaluating\n * the function.\n */\nprivate double localMin(UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\n    if (eps <= 0) {\n        throw new NotStrictlyPositiveException(eps);\n    }\n    if (t <= 0) {\n        throw new NotStrictlyPositiveException(t);\n    }\n    double a, b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n    double x = mid;\n    double v = x;\n    double w = x;\n    double e = 0;\n    double fx = computeObjectiveValue(f, x);\n    if (goalType == GoalType.MAXIMIZE) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n    int count = 0;\n    while (count < maximalIterationCount) {\n        double m = 0.5 * (a + b);\n        final double tol1 = eps * Math.abs(x) + t;\n        final double tol2 = 2 * tol1;\n        // Check stopping criterion.\n        if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double d = 0;\n            double u = 0;\n            if (Math.abs(e) > tol1) {\n                // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n            // Update by at least \"tol1\".\n            if (Math.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                u = x + d;\n            }\n            double fu = computeObjectiveValue(f, u);\n            if (goalType == GoalType.MAXIMIZE) {\n                fu = -fu;\n            }\n            // Update a, b, v, w and x.\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw || w == x) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || v == x || v == w) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else {\n            // termination\n            setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n            return x;\n        }\n        ++count;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}", "code_comment": "/**\n * Find the minimum of the function {@code f} within the interval {@code (a, b)}.\n *\n * If the function {@code f} is defined on the interval {@code (a, b)}, then\n * this method finds an approximation {@code x} to the point at which {@code f}\n * attains its minimum.<br/>\n * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t} and\n * {@code f} is never evaluated at two points closer together than {@code tol}.\n * {@code eps} should be no smaller than <em>2 macheps</em> and preferable not\n * much less than <em>sqrt(macheps)</em>, where <em>macheps</em> is the relative\n * machine precision. {@code t} should be positive.\n * @param f the function to solve.\n * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n * or {@link GoalType#MINIMIZE}.\n * @param lo Lower bound of the interval.\n * @param mid Point inside the interval {@code [lo, hi]}.\n * @param hi Higher bound of the interval.\n * @param eps Relative accuracy.\n * @param t Absolute accuracy.\n * @return the optimum point.\n * @throws MaxIterationsExceededException if the maximum iteration count\n * is exceeded.\n * @throws FunctionEvaluationException if an error occurs evaluating\n * the function.\n */\n", "code_no_comment": "private double localMin(UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\n    if (eps <= 0) {\n        throw new NotStrictlyPositiveException(eps);\n    }\n    if (t <= 0) {\n        throw new NotStrictlyPositiveException(t);\n    }\n    double a, b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n    double x = mid;\n    double v = x;\n    double w = x;\n    double e = 0;\n    double fx = computeObjectiveValue(f, x);\n    if (goalType == GoalType.MAXIMIZE) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n    int count = 0;\n    while (count < maximalIterationCount) {\n        double m = 0.5 * (a + b);\n        final double tol1 = eps * Math.abs(x) + t;\n        final double tol2 = 2 * tol1;\n                if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double d = 0;\n            double u = 0;\n            if (Math.abs(e) > tol1) {\n                                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                                        d = p / q;\n                    u = x + d;\n                                        if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                    }\n                } else {\n                                        if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n                        if (Math.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                u = x + d;\n            }\n            double fu = computeObjectiveValue(f, u);\n            if (goalType == GoalType.MAXIMIZE) {\n                fu = -fu;\n            }\n                        if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw || w == x) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || v == x || v == w) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else {\n                        setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n            return x;\n        }\n        ++count;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}", "lc": 4.954545454545454, "pi": 1.693877551020408, "ma": 3.6666666666666665, "nbd": 2.0, "ml": 4.416666666666667, "d": 6.903608502224421, "mi": -1.5377114998566108, "fo": 0.25, "r": -0.028571428571428574, "e": 36.94385838676381}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2246_dcadb0e1", "label": 1, "code": "@Override\npublic void endNode(NodeInfo nodeInfo) throws RepositoryException {\n    Tree parent = parents.pop();\n    if (parent == null) {\n        if (pnImporter != null) {\n            pnImporter.endChildInfo();\n        }\n    } else if (getDefinition(parent).isProtected()) {\n        if (pnImporter != null) {\n            pnImporter.end(parent);\n            // and reset the pnImporter field waiting for the next protected\n            // parent -> selecting again from available importers\n            pnImporter = null;\n        }\n    }\n    collectUUIDs(parent);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void endNode(NodeInfo nodeInfo) throws RepositoryException {\n    Tree parent = parents.pop();\n    if (parent == null) {\n        if (pnImporter != null) {\n            pnImporter.endChildInfo();\n        }\n    } else if (getDefinition(parent).isProtected()) {\n        if (pnImporter != null) {\n            pnImporter.end(parent);\n                                    pnImporter = null;\n        }\n    }\n    collectUUIDs(parent);\n}", "lc": 0.045454545454545456, "pi": 0.5510204081632651, "ma": 0.16666666666666666, "nbd": 0.5, "ml": 0.16666666666666666, "d": -0.054374691052891735, "mi": -0.003441353599082437, "fo": 0.0, "r": 0.4285714285714286, "e": -0.06361545479075385}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6964_6b2ffb30", "label": 1, "code": "/**\n * Strategy when the file was processed and a commit should be executed.\n *\n * @param processStrategy the strategy to perform the commit\n * @param exchange        the exchange\n * @param file            the file processed\n */\nprotected void processStrategyCommit(GenericFileProcessStrategy<T> processStrategy, Exchange exchange, GenericFile<T> file) {\n    if (endpoint.isIdempotent()) {\n        // use absolute file path as default key, but evaluate if an expression key was configured\n        String key = absoluteFileName;\n        if (endpoint.getIdempotentKey() != null) {\n            Exchange dummy = endpoint.createExchange(file);\n            key = endpoint.getIdempotentKey().evaluate(dummy, String.class);\n        }\n        // only add to idempotent repository if we could process the file\n        if (key != null) {\n            endpoint.getIdempotentRepository().add(key);\n        }\n    }\n    // must be last in batch to delete the done file name\n    // delete done file if used (and not noop=true)\n    boolean complete = exchange.getProperty(Exchange.BATCH_COMPLETE, false, Boolean.class);\n    if (endpoint.getDoneFileName() != null && !endpoint.isNoop()) {\n        // done file must be in same path as the original input file\n        String doneFileName = endpoint.createDoneFileName(absoluteFileName);\n        ObjectHelper.notEmpty(doneFileName, \"doneFileName\", endpoint);\n        // we should delete the dynamic done file\n        if (endpoint.getDoneFileName().indexOf(\"{file:name\") > 0 || complete) {\n            try {\n                // delete done file\n                boolean deleted = operations.deleteFile(doneFileName);\n                log.trace(\"Done file: {} was deleted: {}\", doneFileName, deleted);\n                if (!deleted) {\n                    log.warn(\"Done file: \" + doneFileName + \" could not be deleted\");\n                }\n            } catch (Exception e) {\n                handleException(\"Error deleting done file: \" + doneFileName, exchange, e);\n            }\n        }\n    }\n    try {\n        log.trace(\"Commit file strategy: {} for file: {}\", processStrategy, file);\n        processStrategy.commit(operations, endpoint, exchange, file);\n    } catch (Exception e) {\n        handleException(\"Error during commit\", exchange, e);\n    }\n}", "code_comment": "/**\n * Strategy when the file was processed and a commit should be executed.\n *\n * @param processStrategy the strategy to perform the commit\n * @param exchange        the exchange\n * @param file            the file processed\n */\n", "code_no_comment": "protected void processStrategyCommit(GenericFileProcessStrategy<T> processStrategy, Exchange exchange, GenericFile<T> file) {\n    if (endpoint.isIdempotent()) {\n                String key = absoluteFileName;\n        if (endpoint.getIdempotentKey() != null) {\n            Exchange dummy = endpoint.createExchange(file);\n            key = endpoint.getIdempotentKey().evaluate(dummy, String.class);\n        }\n                if (key != null) {\n            endpoint.getIdempotentRepository().add(key);\n        }\n    }\n            boolean complete = exchange.getProperty(Exchange.BATCH_COMPLETE, false, Boolean.class);\n    if (endpoint.getDoneFileName() != null && !endpoint.isNoop()) {\n                String doneFileName = endpoint.createDoneFileName(absoluteFileName);\n        ObjectHelper.notEmpty(doneFileName, \"doneFileName\", endpoint);\n                if (endpoint.getDoneFileName().indexOf(\"{file:name\") > 0 || complete) {\n            try {\n                                boolean deleted = operations.deleteFile(doneFileName);\n                log.trace(\"Done file: {} was deleted: {}\", doneFileName, deleted);\n                if (!deleted) {\n                    log.warn(\"Done file: \" + doneFileName + \" could not be deleted\");\n                }\n            } catch (Exception e) {\n                handleException(\"Error deleting done file: \" + doneFileName, exchange, e);\n            }\n        }\n    }\n    try {\n        log.trace(\"Commit file strategy: {} for file: {}\", processStrategy, file);\n        processStrategy.commit(operations, endpoint, exchange, file);\n    } catch (Exception e) {\n        handleException(\"Error during commit\", exchange, e);\n    }\n}", "lc": 0.9090909090909091, "pi": 0.9234693877551021, "ma": 0.8333333333333334, "nbd": 1.0, "ml": 0.9166666666666666, "d": 0.8057340583292142, "mi": -0.6455405792945228, "fo": 1.25, "r": -0.028571428571428574, "e": 1.6121268968352884}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5783_7b8b6767", "label": 1, "code": "/**\n *  @return event\n *       the event this behavior is attached to\n */\npublic final String getEvent() {\n    return event;\n}", "code_comment": "/**\n *  @return event\n *       the event this behavior is attached to\n */\n", "code_no_comment": "public final String getEvent() {\n    return event;\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.2001720676799543, "fo": -0.5, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-9238_169b981e", "label": 1, "code": "/**\n * Changes the name of this remote file. This method alters the absolute and\n * relative names as well.\n *\n * @param newName the new name\n */\npublic void changeFileName(String newName) {\n    LOG.trace(\"Changing name to: {}\", newName);\n    // Make sure the names is normalized.\n    String newFileName = FileUtil.normalizePath(newName);\n    String newEndpointPath = FileUtil.normalizePath(endpointPath);\n    LOG.trace(\"Normalized endpointPath: {}\", newEndpointPath);\n    LOG.trace(\"Normalized newFileName: ()\", newFileName);\n    File file = new File(newFileName);\n    if (!absolute) {\n        // for relative then we should avoid having the endpoint path duplicated so clip it\n        if (ObjectHelper.isNotEmpty(newEndpointPath) && newFileName.startsWith(newEndpointPath)) {\n            // in this logic here\n            if (newEndpointPath.endsWith(\"\" + File.separatorChar)) {\n                newFileName = ObjectHelper.after(newFileName, newEndpointPath);\n            } else {\n                newFileName = ObjectHelper.after(newFileName, newEndpointPath + File.separatorChar);\n            }\n            // reconstruct file with clipped name\n            file = new File(newFileName);\n        }\n    }\n    // store the file name only\n    setFileNameOnly(file.getName());\n    setFileName(file.getName());\n    // relative path\n    if (file.getParent() != null) {\n        setRelativeFilePath(file.getParent() + getFileSeparator() + file.getName());\n    } else {\n        setRelativeFilePath(file.getName());\n    }\n    // absolute path\n    if (isAbsolute(newFileName)) {\n        setAbsolute(true);\n        setAbsoluteFilePath(newFileName);\n    } else {\n        setAbsolute(false);\n        // construct a pseudo absolute filename that the file operations uses even for relative only\n        String path = ObjectHelper.isEmpty(endpointPath) ? \"\" : endpointPath + getFileSeparator();\n        setAbsoluteFilePath(path + getRelativeFilePath());\n    }\n    if (LOG.isTraceEnabled()) {\n        LOG.trace(\"FileNameOnly: {}\", getFileNameOnly());\n        LOG.trace(\"FileName: {}\", getFileName());\n        LOG.trace(\"Absolute: {}\", isAbsolute());\n        LOG.trace(\"Relative path: {}\", getRelativeFilePath());\n        LOG.trace(\"Absolute path: {}\", getAbsoluteFilePath());\n        LOG.trace(\"Name changed to: {}\", this);\n    }\n}", "code_comment": "/**\n * Changes the name of this remote file. This method alters the absolute and\n * relative names as well.\n *\n * @param newName the new name\n */\n", "code_no_comment": "public void changeFileName(String newName) {\n    LOG.trace(\"Changing name to: {}\", newName);\n        String newFileName = FileUtil.normalizePath(newName);\n    String newEndpointPath = FileUtil.normalizePath(endpointPath);\n    LOG.trace(\"Normalized endpointPath: {}\", newEndpointPath);\n    LOG.trace(\"Normalized newFileName: ()\", newFileName);\n    File file = new File(newFileName);\n    if (!absolute) {\n                if (ObjectHelper.isNotEmpty(newEndpointPath) && newFileName.startsWith(newEndpointPath)) {\n                        if (newEndpointPath.endsWith(\"\" + File.separatorChar)) {\n                newFileName = ObjectHelper.after(newFileName, newEndpointPath);\n            } else {\n                newFileName = ObjectHelper.after(newFileName, newEndpointPath + File.separatorChar);\n            }\n                        file = new File(newFileName);\n        }\n    }\n        setFileNameOnly(file.getName());\n    setFileName(file.getName());\n        if (file.getParent() != null) {\n        setRelativeFilePath(file.getParent() + getFileSeparator() + file.getName());\n    } else {\n        setRelativeFilePath(file.getName());\n    }\n        if (isAbsolute(newFileName)) {\n        setAbsolute(true);\n        setAbsoluteFilePath(newFileName);\n    } else {\n        setAbsolute(false);\n                String path = ObjectHelper.isEmpty(endpointPath) ? \"\" : endpointPath + getFileSeparator();\n        setAbsoluteFilePath(path + getRelativeFilePath());\n    }\n    if (LOG.isTraceEnabled()) {\n        LOG.trace(\"FileNameOnly: {}\", getFileNameOnly());\n        LOG.trace(\"FileName: {}\", getFileName());\n        LOG.trace(\"Absolute: {}\", isAbsolute());\n        LOG.trace(\"Relative path: {}\", getRelativeFilePath());\n        LOG.trace(\"Absolute path: {}\", getAbsoluteFilePath());\n        LOG.trace(\"Name changed to: {}\", this);\n    }\n}", "lc": 1.2272727272727273, "pi": 0.2959183673469388, "ma": 0.6666666666666666, "nbd": 0.5, "ml": 1.25, "d": 0.5803262481463175, "mi": -0.7421852595354174, "fo": 2.9166666666666665, "r": -0.028571428571428574, "e": 1.4400186738963772}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5215_033eb6fe", "label": 3, "code": "@Converter\npublic static InputStream genericFileToInputStream(GenericFile<?> file, Exchange exchange) throws IOException {\n    if (exchange != null) {\n        // use a file input stream if its a java.io.File\n        if (file.getFile() instanceof java.io.File) {\n            return IOHelper.buffered(new FileInputStream((File) file.getFile()));\n        }\n        // otherwise ensure the body is loaded as we want the input stream of the body\n        file.getBinding().loadContent(exchange, file);\n        return exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, file.getBody());\n    } else {\n        // should revert to fallback converter if we don't have an exchange\n        return null;\n    }\n}", "code_comment": NaN, "code_no_comment": "@Converter\npublic static InputStream genericFileToInputStream(GenericFile<?> file, Exchange exchange) throws IOException {\n    if (exchange != null) {\n                if (file.getFile() instanceof java.io.File) {\n            return IOHelper.buffered(new FileInputStream((File) file.getFile()));\n        }\n                file.getBinding().loadContent(exchange, file);\n        return exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, file.getBody());\n    } else {\n                return null;\n    }\n}", "lc": -0.09090909090909091, "pi": 0.3826530612244898, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.3806228373702422, "mi": 0.08746773731000855, "fo": 0.25, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3021_494da6de", "label": 1, "code": "@Override\npublic Validator childNodeChanged(String name, NodeState before, NodeState after) throws CommitFailedException {\n    Tree treeAfter = checkNotNull(parentAfter.getChild(name));\n    checkValidTree(parentAfter, treeAfter, after);\n    return new AccessControlValidator(this, treeAfter);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Validator childNodeChanged(String name, NodeState before, NodeState after) throws CommitFailedException {\n    Tree treeAfter = checkNotNull(parentAfter.getChild(name));\n    checkValidTree(parentAfter, treeAfter, after);\n    return new AccessControlValidator(this, treeAfter);\n}", "lc": -0.36363636363636365, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.5012905075996561, "fo": -0.25, "r": 0.0, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3394_18e1a142", "label": 3, "code": "public void done(boolean doneSync) {\n    // we are done with the exchange pair\n    pair.done();\n    // we only have to handle async completion of the routing slip\n    if (doneSync) {\n        return;\n    }\n    // continue processing the multicast asynchronously\n    Exchange subExchange = exchange;\n    // Decide whether to continue with the multicast or not; similar logic to the Pipeline\n    // remember to test for stop on exception and aggregate before copying back results\n    boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Sequential processing failed for number \" + total.get(), LOG);\n    if (stopOnException && !continueProcessing) {\n        if (subExchange.getException() != null) {\n            // wrap in exception to explain where it failed\n            subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, subExchange.getException()));\n        } else {\n            // we want to stop on exception, and the exception was handled by the error handler\n            // this is similar to what the pipeline does, so we should do the same to not surprise end users\n            // so we should set the failed exchange as the result and be done\n            result.set(subExchange);\n        }\n        // and do the done work\n        doDone(original, subExchange, callback, false);\n        return;\n    }\n    try {\n        doAggregate(getAggregationStrategy(subExchange), result, subExchange);\n    } catch (Throwable e) {\n        // wrap in exception to explain where it failed\n        subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, e));\n        // and do the done work\n        doDone(original, subExchange, callback, false);\n        return;\n    }\n    total.incrementAndGet();\n    // maybe there are more processors to multicast\n    while (it.hasNext()) {\n        // prepare and run the next\n        ProcessorExchangePair pair = it.next();\n        subExchange = pair.getExchange();\n        updateNewExchange(subExchange, total.get(), pairs, it);\n        boolean sync = doProcessSequential(original, result, pairs, it, pair, callback, total);\n        if (!sync) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchangeId: \" + original.getExchangeId() + \" is continued being processed asynchronously\");\n            }\n            return;\n        }\n        // Decide whether to continue with the multicast or not; similar logic to the Pipeline\n        // remember to test for stop on exception and aggregate before copying back results\n        continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Sequential processing failed for number \" + total.get(), LOG);\n        if (stopOnException && !continueProcessing) {\n            if (subExchange.getException() != null) {\n                // wrap in exception to explain where it failed\n                subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, subExchange.getException()));\n            } else {\n                // we want to stop on exception, and the exception was handled by the error handler\n                // this is similar to what the pipeline does, so we should do the same to not surprise end users\n                // so we should set the failed exchange as the result and be done\n                result.set(subExchange);\n            }\n            // and do the done work\n            doDone(original, subExchange, callback, false);\n            return;\n        }\n        try {\n            doAggregate(getAggregationStrategy(subExchange), result, subExchange);\n        } catch (Throwable e) {\n            // wrap in exception to explain where it failed\n            subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, e));\n            // and do the done work\n            doDone(original, subExchange, callback, false);\n            return;\n        }\n        total.incrementAndGet();\n    }\n    // do the done work\n    subExchange = result.get() != null ? result.get() : null;\n    doDone(original, subExchange, callback, false);\n}", "code_comment": NaN, "code_no_comment": "public void done(boolean doneSync) {\n        pair.done();\n        if (doneSync) {\n        return;\n    }\n        Exchange subExchange = exchange;\n            boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Sequential processing failed for number \" + total.get(), LOG);\n    if (stopOnException && !continueProcessing) {\n        if (subExchange.getException() != null) {\n                        subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, subExchange.getException()));\n        } else {\n                                                result.set(subExchange);\n        }\n                doDone(original, subExchange, callback, false);\n        return;\n    }\n    try {\n        doAggregate(getAggregationStrategy(subExchange), result, subExchange);\n    } catch (Throwable e) {\n                subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, e));\n                doDone(original, subExchange, callback, false);\n        return;\n    }\n    total.incrementAndGet();\n        while (it.hasNext()) {\n                ProcessorExchangePair pair = it.next();\n        subExchange = pair.getExchange();\n        updateNewExchange(subExchange, total.get(), pairs, it);\n        boolean sync = doProcessSequential(original, result, pairs, it, pair, callback, total);\n        if (!sync) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchangeId: \" + original.getExchangeId() + \" is continued being processed asynchronously\");\n            }\n            return;\n        }\n                        continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Sequential processing failed for number \" + total.get(), LOG);\n        if (stopOnException && !continueProcessing) {\n            if (subExchange.getException() != null) {\n                                subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, subExchange.getException()));\n            } else {\n                                                                result.set(subExchange);\n            }\n                        doDone(original, subExchange, callback, false);\n            return;\n        }\n        try {\n            doAggregate(getAggregationStrategy(subExchange), result, subExchange);\n        } catch (Throwable e) {\n                        subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, e));\n                        doDone(original, subExchange, callback, false);\n            return;\n        }\n        total.incrementAndGet();\n    }\n        subExchange = result.get() != null ? result.get() : null;\n    doDone(original, subExchange, callback, false);\n}", "lc": 1.9545454545454546, "pi": 0.3520408163265306, "ma": 1.3333333333333333, "nbd": 0.5, "ml": 1.1666666666666667, "d": 1.0350963914977758, "mi": -0.9578434184112422, "fo": 2.5833333333333335, "r": -0.028571428571428574, "e": 2.8513026755924464}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3156_786b3d76", "label": 0, "code": "@Override\npublic IndexRow next() {\n    final IndexRow pathRow = pathCursor.next();\n    return new IndexRow() {\n\n        @Override\n        public boolean isVirtualRow() {\n            return getPath() == null;\n        }\n\n        @Override\n        public String getPath() {\n            return pathRow.getPath();\n        }\n\n        @Override\n        public PropertyValue getValue(String columnName) {\n            // overlay the score\n            if (QueryImpl.JCR_SCORE.equals(columnName)) {\n                return PropertyValues.newDouble(currentRow.score);\n            }\n            if (QueryImpl.REP_SPELLCHECK.equals(columnName) || QueryImpl.REP_SUGGEST.equals(columnName)) {\n                return PropertyValues.newString(Iterables.toString(currentRow.suggestWords));\n            }\n            return pathRow.getValue(columnName);\n        }\n    };\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic IndexRow next() {\n    final IndexRow pathRow = pathCursor.next();\n    return new IndexRow() {\n\n        @Override\n        public boolean isVirtualRow() {\n            return getPath() == null;\n        }\n\n        @Override\n        public String getPath() {\n            return pathRow.getPath();\n        }\n\n        @Override\n        public PropertyValue getValue(String columnName) {\n                        if (QueryImpl.JCR_SCORE.equals(columnName)) {\n                return PropertyValues.newDouble(currentRow.score);\n            }\n            if (QueryImpl.REP_SPELLCHECK.equals(columnName) || QueryImpl.REP_SUGGEST.equals(columnName)) {\n                return PropertyValues.newString(Iterables.toString(currentRow.suggestWords));\n            }\n            return pathRow.getValue(columnName);\n        }\n    };\n}", "lc": 0.45454545454545453, "pi": 0.7346938775510204, "ma": -0.16666666666666666, "nbd": 0.0, "ml": 0.16666666666666666, "d": -0.014829461196243152, "mi": -0.29108115858904526, "fo": 0.3333333333333333, "r": 0.08571428571428572, "e": 0.03167709578081299}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4000_38e928c1", "label": 1, "code": "/**\n *  Render the child hierarchy headers.\n *\n *  @param headerContainer\n *  @param rootComponent\n */\n@Override\nprotected void renderChildHeaders(final HtmlHeaderContainer headerContainer, final Component rootComponent) {\n    Args.notNull(headerContainer, \"headerContainer\");\n    Args.notNull(rootComponent, \"rootComponent\");\n    if (rootComponent instanceof MarkupContainer) {\n        new DeepChildFirstVisitor() {\n\n            @Override\n            public void component(final Component component, final IVisit<Void> visit) {\n                component.renderHead(headerContainer);\n            }\n\n            @Override\n            public boolean preCheck(Component component) {\n                return component.isVisibleInHierarchy();\n            }\n        }.visit(rootComponent);\n    }\n}", "code_comment": "/**\n *  Render the child hierarchy headers.\n *\n *  @param headerContainer\n *  @param rootComponent\n */\n", "code_no_comment": "@Override\nprotected void renderChildHeaders(final HtmlHeaderContainer headerContainer, final Component rootComponent) {\n    Args.notNull(headerContainer, \"headerContainer\");\n    Args.notNull(rootComponent, \"rootComponent\");\n    if (rootComponent instanceof MarkupContainer) {\n        new DeepChildFirstVisitor() {\n\n            @Override\n            public void component(final Component component, final IVisit<Void> visit) {\n                component.renderHead(headerContainer);\n            }\n\n            @Override\n            public boolean preCheck(Component component) {\n                return component.isVisibleInHierarchy();\n            }\n        }.visit(rootComponent);\n    }\n}", "lc": 0.13636363636363635, "pi": 1.1683673469387754, "ma": -0.3333333333333333, "nbd": 0.0, "ml": -0.25, "d": -0.3806228373702422, "mi": -0.04961284772010337, "fo": -0.08333333333333333, "r": 0.2285714285714286, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-757_76b7413d", "label": 1, "code": "/**\n * Returns the internal storage array.  Note that this method returns\n * a reference to the internal storage array, not a copy, and to correctly\n * address elements of the array, the <code>startIndex</code> is\n * required (available via the {@link #start} method).  This method should\n * only be used in cases where copying the internal array is not practical.\n * The {@link #getElements} method should be used in all other cases.\n *\n * @return the internal storage array used by this object\n * @since 2.0\n * @deprecated As of 3.1.\n */\n@Deprecated\npublic synchronized double[] getInternalValues() {\n    return internalArray;\n}", "code_comment": "/**\n * Returns the internal storage array.  Note that this method returns\n * a reference to the internal storage array, not a copy, and to correctly\n * address elements of the array, the <code>startIndex</code> is\n * required (available via the {@link #start} method).  This method should\n * only be used in cases where copying the internal array is not practical.\n * The {@link #getElements} method should be used in all other cases.\n *\n * @return the internal storage array used by this object\n * @since 2.0\n * @deprecated As of 3.1.\n */\n", "code_no_comment": "@Deprecated\npublic synchronized double[] getInternalValues() {\n    return internalArray;\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.0665328362489248, "fo": -0.5, "r": 1.2, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2021_004db804", "label": 1, "code": "@Override\npublic String toString() {\n    return s1 + \" union \" + s2;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic String toString() {\n    return s1 + \" union \" + s2;\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9027817608259249, "fo": -0.5, "r": 2.7142857142857144, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3310_4416a9f8", "label": 1, "code": "@Override\npublic void remove() throws RepositoryException {\n    sessionDelegate.performVoid(new ItemWriteOperation(\"remove\") {\n\n        @Override\n        public void performVoid() {\n            dlg.remove();\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"Removing property [%s/%s] \", dlg.getPath(), dlg.getName());\n        }\n    });\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void remove() throws RepositoryException {\n    sessionDelegate.performVoid(new ItemWriteOperation(\"remove\") {\n\n        @Override\n        public void performVoid() {\n            dlg.remove();\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"Removing property [%s/%s] \", dlg.getPath(), dlg.getName());\n        }\n    });\n}", "lc": -0.045454545454545456, "pi": 0.5204081632653061, "ma": -0.5, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.16862632635503289, "fo": -0.08333333333333333, "r": 0.5142857142857143, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4594_556a2236", "label": 1, "code": "private void resolvePageInstance(Integer pageId, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters, Integer renderCount) {\n    IRequestablePage page = null;\n    boolean freshCreated = false;\n    if (pageId != null) {\n        page = getStoredPage(pageId);\n    }\n    if (page == null) {\n        if (pageClass != null) {\n            page = getPageSource().newPageInstance(pageClass, pageParameters);\n            freshCreated = true;\n        }\n    }\n    if (page != null && !freshCreated) {\n        if (renderCount != null && page.getRenderCount() != renderCount) {\n            throw new StalePageException(page);\n        }\n    }\n    pageInstanceIsFresh = freshCreated;\n    pageInstance = page;\n}", "code_comment": NaN, "code_no_comment": "private void resolvePageInstance(Integer pageId, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters, Integer renderCount) {\n    IRequestablePage page = null;\n    boolean freshCreated = false;\n    if (pageId != null) {\n        page = getStoredPage(pageId);\n    }\n    if (page == null) {\n        if (pageClass != null) {\n            page = getPageSource().newPageInstance(pageClass, pageParameters);\n            freshCreated = true;\n        }\n    }\n    if (page != null && !freshCreated) {\n        if (renderCount != null && page.getRenderCount() != renderCount) {\n            throw new StalePageException(page);\n        }\n    }\n    pageInstanceIsFresh = freshCreated;\n    pageInstance = page;\n}", "lc": 0.2727272727272727, "pi": 0.22448979591836732, "ma": 0.5, "nbd": 0.0, "ml": 0.6666666666666666, "d": 0.4458724666337124, "mi": -0.25867507886435326, "fo": -0.16666666666666666, "r": -0.028571428571428574, "e": 0.3637854900398747}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2345_a0dc4c89", "label": 1, "code": "/**\n * Perform a background read and make external changes visible.\n *\n * @param dispatchChange whether to dispatch external changes\n *                       to {@link #dispatcher}.\n */\nvoid backgroundRead(boolean dispatchChange) {\n    String id = Utils.getIdFromPath(\"/\");\n    NodeDocument doc = store.find(Collection.NODES, id, asyncDelay);\n    if (doc == null) {\n        return;\n    }\n    Map<Integer, Revision> lastRevMap = doc.getLastRev();\n    Revision.RevisionComparator revisionComparator = getRevisionComparator();\n    // the (old) head occurred first\n    Revision headSeen = Revision.newRevision(0);\n    // then we saw this new revision (from another cluster node)\n    Revision otherSeen = Revision.newRevision(0);\n    Map<Revision, Revision> externalChanges = Maps.newHashMap();\n    for (Map.Entry<Integer, Revision> e : lastRevMap.entrySet()) {\n        int machineId = e.getKey();\n        if (machineId == clusterId) {\n            // ignore own lastRev\n            continue;\n        }\n        Revision r = e.getValue();\n        Revision last = lastKnownRevision.get(machineId);\n        if (last == null || r.compareRevisionTime(last) > 0) {\n            lastKnownRevision.put(machineId, r);\n            externalChanges.put(r, otherSeen);\n        }\n    }\n    if (!externalChanges.isEmpty()) {\n        // invalidate caches\n        store.invalidateCache();\n        // TODO only invalidate affected items\n        docChildrenCache.invalidateAll();\n        // make sure update to revision comparator is atomic\n        // and no local commit is in progress\n        backgroundOperationLock.writeLock().lock();\n        try {\n            // the latest revisions of the current cluster node\n            // happened before the latest revisions of other cluster nodes\n            revisionComparator.add(newRevision(), headSeen);\n            // then we saw other revisions\n            for (Map.Entry<Revision, Revision> e : externalChanges.entrySet()) {\n                revisionComparator.add(e.getKey(), e.getValue());\n            }\n            // the new head revision is after other revisions\n            setHeadRevision(newRevision());\n            if (dispatchChange) {\n                dispatcher.contentChanged(getRoot(), null);\n            }\n        } finally {\n            backgroundOperationLock.writeLock().unlock();\n        }\n    }\n    revisionComparator.purge(Revision.getCurrentTimestamp() - REMEMBER_REVISION_ORDER_MILLIS);\n}", "code_comment": "/**\n * Perform a background read and make external changes visible.\n *\n * @param dispatchChange whether to dispatch external changes\n *                       to {@link #dispatcher}.\n */\n", "code_no_comment": "void backgroundRead(boolean dispatchChange) {\n    String id = Utils.getIdFromPath(\"/\");\n    NodeDocument doc = store.find(Collection.NODES, id, asyncDelay);\n    if (doc == null) {\n        return;\n    }\n    Map<Integer, Revision> lastRevMap = doc.getLastRev();\n    Revision.RevisionComparator revisionComparator = getRevisionComparator();\n        Revision headSeen = Revision.newRevision(0);\n        Revision otherSeen = Revision.newRevision(0);\n    Map<Revision, Revision> externalChanges = Maps.newHashMap();\n    for (Map.Entry<Integer, Revision> e : lastRevMap.entrySet()) {\n        int machineId = e.getKey();\n        if (machineId == clusterId) {\n                        continue;\n        }\n        Revision r = e.getValue();\n        Revision last = lastKnownRevision.get(machineId);\n        if (last == null || r.compareRevisionTime(last) > 0) {\n            lastKnownRevision.put(machineId, r);\n            externalChanges.put(r, otherSeen);\n        }\n    }\n    if (!externalChanges.isEmpty()) {\n                store.invalidateCache();\n                docChildrenCache.invalidateAll();\n                        backgroundOperationLock.writeLock().lock();\n        try {\n                                    revisionComparator.add(newRevision(), headSeen);\n                        for (Map.Entry<Revision, Revision> e : externalChanges.entrySet()) {\n                revisionComparator.add(e.getKey(), e.getValue());\n            }\n                        setHeadRevision(newRevision());\n            if (dispatchChange) {\n                dispatcher.contentChanged(getRoot(), null);\n            }\n        } finally {\n            backgroundOperationLock.writeLock().unlock();\n        }\n    }\n    revisionComparator.purge(Revision.getCurrentTimestamp() - REMEMBER_REVISION_ORDER_MILLIS);\n}", "lc": 1.2727272727272727, "pi": 0.43877551020408156, "ma": 0.8333333333333334, "nbd": 0.5, "ml": 0.6666666666666666, "d": 0.8057340583292142, "mi": -0.7705764267278467, "fo": 2.25, "r": -0.028571428571428574, "e": 1.963778637233865}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-412_5594b2e0", "label": 1, "code": "@Override\npublic void run() {\n    ClientService.Iface client = null;\n    try {\n        client = ServerClient.getConnection(HdfsZooInstance.getInstance());\n        List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);\n        attempt.removeAll(fail);\n        filesToLoad.removeAll(attempt);\n    } catch (Exception ex) {\n        log.error(ex, ex);\n    } finally {\n        ServerClient.close(client);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void run() {\n    ClientService.Iface client = null;\n    try {\n        client = ServerClient.getConnection(HdfsZooInstance.getInstance());\n        List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);\n        attempt.removeAll(fail);\n        filesToLoad.removeAll(attempt);\n    } catch (Exception ex) {\n        log.error(ex, ex);\n    } finally {\n        ServerClient.close(client);\n    }\n}", "lc": 0.0, "pi": 0.035714285714285636, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": -0.010037281330656973, "fo": 0.16666666666666666, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-395_4ed7bc8e", "label": 1, "code": "@Override\npublic PropertyImpl perform() throws RepositoryException {\n    String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n    if (value == null) {\n        dlg.removeProperty(oakName);\n        return null;\n    } else {\n        int targetType = getTargetType(value, type);\n        Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());\n        return new PropertyImpl(dlg.setProperty(oakName, targetValue));\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic PropertyImpl perform() throws RepositoryException {\n    String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n    if (value == null) {\n        dlg.removeProperty(oakName);\n        return null;\n    } else {\n        int targetType = getTargetType(value, type);\n        Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());\n        return new PropertyImpl(dlg.setProperty(oakName, targetValue));\n    }\n}", "lc": -0.09090909090909091, "pi": 0.09183673469387764, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.10578348986653485, "mi": 0.09635790077430458, "fo": 0.0, "r": 0.05714285714285714, "e": -0.06460482865843474}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1820_39d526e6", "label": 0, "code": "@Override\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, IntValue reusable) {\n    long val = 0;\n    boolean neg = false;\n    final int delimLimit = limit - delimiter.length + 1;\n    this.result = reusable;\n    if (bytes[startPos] == '-') {\n        neg = true;\n        startPos++;\n        // check for empty field with only the sign\n        if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\n            return -1;\n        }\n    }\n    for (int i = startPos; i < limit; i++) {\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n            reusable.setValue((int) (neg ? -val : val));\n            return i + delimiter.length;\n        }\n        if (bytes[i] < 48 || bytes[i] > 57) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);\n            return -1;\n        }\n        val *= 10;\n        val += bytes[i] - 48;\n        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\n            return -1;\n        }\n    }\n    reusable.setValue((int) (neg ? -val : val));\n    return limit;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, IntValue reusable) {\n    long val = 0;\n    boolean neg = false;\n    final int delimLimit = limit - delimiter.length + 1;\n    this.result = reusable;\n    if (bytes[startPos] == '-') {\n        neg = true;\n        startPos++;\n                if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\n            return -1;\n        }\n    }\n    for (int i = startPos; i < limit; i++) {\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n            reusable.setValue((int) (neg ? -val : val));\n            return i + delimiter.length;\n        }\n        if (bytes[i] < 48 || bytes[i] > 57) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);\n            return -1;\n        }\n        val *= 10;\n        val += bytes[i] - 48;\n        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\n            return -1;\n        }\n    }\n    reusable.setValue((int) (neg ? -val : val));\n    return limit;\n}", "lc": 0.8636363636363636, "pi": 0.34183673469387754, "ma": 0.8333333333333334, "nbd": 0.0, "ml": 1.5833333333333333, "d": 2.881858625803263, "mi": -0.6271866934327505, "fo": 0.08333333333333333, "r": -0.028571428571428574, "e": 4.581306401805715}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1932_c215b267", "label": 1, "code": "public SegmentNodeState compact(NodeState before, NodeState after) {\n    after.compareAgainstBaseState(before, new CompactDiff(builder));\n    return builder.getNodeState();\n}", "code_comment": NaN, "code_no_comment": "public SegmentNodeState compact(NodeState before, NodeState after) {\n    after.compareAgainstBaseState(before, new CompactDiff(builder));\n    return builder.getNodeState();\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8041296243188988, "fo": -0.3333333333333333, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-4138_eb0f9b41", "label": 1, "code": "/**\n * Starts a full major compaction of the tablets in the range (start, end]. The compaction is preformed even for tablets that have only one file.\n *\n * @param tableName\n *          the table to compact\n * @param start\n *          first tablet to be compacted contains the row after this row, null means the first tablet in table\n * @param end\n *          last tablet to be merged contains this row, null means the last tablet in table\n * @param iterators\n *          A set of iterators that will be applied to each tablet compacted\n * @param flush\n *          when true, table memory is flushed before compaction starts\n * @param wait\n *          when true, the call will not return until compactions are finished\n * @since 1.5.0\n */\nvoid compact(String tableName, Text start, Text end, List<IteratorSetting> iterators, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException;", "code_comment": "/**\n * Starts a full major compaction of the tablets in the range (start, end]. The compaction is preformed even for tablets that have only one file.\n *\n * @param tableName\n *          the table to compact\n * @param start\n *          first tablet to be compacted contains the row after this row, null means the first tablet in table\n * @param end\n *          last tablet to be merged contains this row, null means the last tablet in table\n * @param iterators\n *          A set of iterators that will be applied to each tablet compacted\n * @param flush\n *          when true, table memory is flushed before compaction starts\n * @param wait\n *          when true, the call will not return until compactions are finished\n * @since 1.5.0\n */\n", "code_no_comment": "void compact(String tableName, Text start, Text end, List<IteratorSetting> iterators, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException;", "lc": -0.5909090909090909, "pi": -1.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.4040722684255813, "fo": -0.5, "r": 0.3428571428571429, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd", "label": 1, "code": "private Set<String> getValues(PropertyRestriction restriction) {\n    if (restriction.firstIncluding && restriction.lastIncluding && restriction.first != null && restriction.first.equals(restriction.last)) {\n        // \"[property] = $value\"\n        return encode(restriction.first);\n    } else if (restriction.list != null) {\n        // \"[property] IN (...)\n        // keep order for testing\n        Set<String> values = newLinkedHashSet();\n        for (PropertyValue value : restriction.list) {\n            values.addAll(encode(value));\n        }\n        return values;\n    } else {\n        // processed as \"[property] is not null\"\n        return null;\n    }\n}", "code_comment": NaN, "code_no_comment": "private Set<String> getValues(PropertyRestriction restriction) {\n    if (restriction.firstIncluding && restriction.lastIncluding && restriction.first != null && restriction.first.equals(restriction.last)) {\n                return encode(restriction.first);\n    } else if (restriction.list != null) {\n                        Set<String> values = newLinkedHashSet();\n        for (PropertyValue value : restriction.list) {\n            values.addAll(encode(value));\n        }\n        return values;\n    } else {\n                return null;\n    }\n}", "lc": -0.045454545454545456, "pi": 0.17857142857142863, "ma": 0.0, "nbd": 0.5, "ml": 0.5, "d": 0.01482946119624324, "mi": 0.025523372526527123, "fo": -0.08333333333333333, "r": 0.0, "e": 2.998102629335714e-05}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1655_01a8b283", "label": 1, "code": "@Override\npublic Iterator<String> getAllChunkIds(long maxLastModifiedTime) throws Exception {\n    // TODO Ignores the maxLastModifiedTime currently.\n    return Iterators.transform(delegate.getAllIdentifiers(), new Function<DataIdentifier, String>() {\n\n        @Nullable\n        @Override\n        public String apply(@Nullable DataIdentifier input) {\n            return input.toString();\n        }\n    });\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Iterator<String> getAllChunkIds(long maxLastModifiedTime) throws Exception {\n        return Iterators.transform(delegate.getAllIdentifiers(), new Function<DataIdentifier, String>() {\n\n        @Nullable\n        @Override\n        public String apply(@Nullable DataIdentifier input) {\n            return input.toString();\n        }\n    });\n}", "lc": -0.18181818181818182, "pi": 0.5102040816326529, "ma": -0.5, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.2733008316604532, "fo": -0.25, "r": 0.6, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd", "label": 1, "code": "/**\n * retrieve the cost for the query.\n *\n * !!! for now we want to skip the use-case of NON range-queries !!!\n */\npublic double getCost(Filter filter, NodeState root) {\n    throw new UnsupportedOperationException(\"Not supported as implementing AdvancedQueryIndex\");\n}", "code_comment": "/**\n * retrieve the cost for the query.\n *\n * !!! for now we want to skip the use-case of NON range-queries !!!\n */\n", "code_no_comment": "public double getCost(Filter filter, NodeState root) {\n    throw new UnsupportedOperationException(\"Not supported as implementing AdvancedQueryIndex\");\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.3333333333333333, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.0298250645253801, "fo": -0.5, "r": 2.8000000000000003, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-621_00b4b8a0", "label": 1, "code": "// ------------------------------------------------------------< private >---\nprivate TreeImpl internalGetChild(String childName) {\n    return getNodeBuilder().hasChildNode(childName) ? new TreeImpl(root, this, childName) : null;\n}", "code_comment": NaN, "code_no_comment": "private TreeImpl internalGetChild(String childName) {\n    return getNodeBuilder().hasChildNode(childName) ? new TreeImpl(root, this, childName) : null;\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.3333333333333333, "nbd": -1.0, "ml": -0.16666666666666666, "d": -0.3806228373702422, "mi": 0.9609979925437339, "fo": -0.3333333333333333, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1081_4ce4e3c9", "label": 3, "code": "/**\n * Returns an iterator for traversing all the children of this node.\n * If the node is orderable then the iterator will return child nodes in the\n * specified order. Otherwise the ordering of the iterator is undefined.\n *\n * @return child nodes of the node\n */\n@Nonnull\npublic Iterator<NodeDelegate> getChildren() throws InvalidItemStateException {\n    Iterator<Tree> iterator = getTree().getChildren().iterator();\n    return transform(filter(iterator, new Predicate<Tree>() {\n\n        @Override\n        public boolean apply(Tree tree) {\n            return !tree.getName().startsWith(\":\");\n        }\n    }), new Function<Tree, NodeDelegate>() {\n\n        @Override\n        public NodeDelegate apply(Tree tree) {\n            return new NodeDelegate(sessionDelegate, tree);\n        }\n    });\n}", "code_comment": "/**\n * Returns an iterator for traversing all the children of this node.\n * If the node is orderable then the iterator will return child nodes in the\n * specified order. Otherwise the ordering of the iterator is undefined.\n *\n * @return child nodes of the node\n */\n", "code_no_comment": "@Nonnull\npublic Iterator<NodeDelegate> getChildren() throws InvalidItemStateException {\n    Iterator<Tree> iterator = getTree().getChildren().iterator();\n    return transform(filter(iterator, new Predicate<Tree>() {\n\n        @Override\n        public boolean apply(Tree tree) {\n            return !tree.getName().startsWith(\":\");\n        }\n    }), new Function<Tree, NodeDelegate>() {\n\n        @Override\n        public NodeDelegate apply(Tree tree) {\n            return new NodeDelegate(sessionDelegate, tree);\n        }\n    });\n}", "lc": 0.045454545454545456, "pi": 0.413265306122449, "ma": -0.5, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.0247157686604053, "mi": -0.0028677946659021666, "fo": 0.08333333333333333, "r": 0.0, "e": -0.03358303245231947}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1178_84fb6b29", "label": 1, "code": "@Override\npublic boolean isNew() {\n    return !isRoot() && !parent.base().hasChildNode(name) && parent.hasChildNode(name);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean isNew() {\n    return !isRoot() && !parent.base().hasChildNode(name) && parent.hasChildNode(name);\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.10776075135936727, "mi": 0.8041296243188988, "fo": -0.16666666666666666, "r": 1.3142857142857143, "e": -0.1368376870066515}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-559_fc409e88", "label": 3, "code": "/**\n * Returns true if both arguments are equal or within the range of allowed\n * error (inclusive).\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n * (or fewer) floating point numbers between them, i.e. two adjacent floating\n * point numbers are considered equal.\n * Adapted from <a\n * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n * Bruce Dawson</a>\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return {@code true} if there are fewer than {@code maxUlps} floating\n * point values between {@code x} and {@code y}.\n */\npublic static boolean equals(double x, double y, int maxUlps) {\n    // NaN won't compare as equal to anything (except another NaN).\n    assert maxUlps > 0 && maxUlps < NAN_GAP;\n    long xInt = Double.doubleToLongBits(x);\n    long yInt = Double.doubleToLongBits(y);\n    // Make lexicographically ordered as a two's-complement integer.\n    if (xInt < 0) {\n        xInt = SGN_MASK - xInt;\n    }\n    if (yInt < 0) {\n        yInt = SGN_MASK - yInt;\n    }\n    final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n    return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n}", "code_comment": "/**\n * Returns true if both arguments are equal or within the range of allowed\n * error (inclusive).\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n * (or fewer) floating point numbers between them, i.e. two adjacent floating\n * point numbers are considered equal.\n * Adapted from <a\n * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n * Bruce Dawson</a>\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return {@code true} if there are fewer than {@code maxUlps} floating\n * point values between {@code x} and {@code y}.\n */\n", "code_no_comment": "public static boolean equals(double x, double y, int maxUlps) {\n        assert maxUlps > 0 && maxUlps < NAN_GAP;\n    long xInt = Double.doubleToLongBits(x);\n    long yInt = Double.doubleToLongBits(y);\n        if (xInt < 0) {\n        xInt = SGN_MASK - xInt;\n    }\n    if (yInt < 0) {\n        yInt = SGN_MASK - yInt;\n    }\n    final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n    return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n}", "lc": -0.045454545454545456, "pi": -0.40816326530612235, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.3806228373702422, "mi": 0.45024376254660187, "fo": -0.08333333333333333, "r": 0.14285714285714285, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-939_49444ee6", "label": 1, "code": "/**\n * Compute a covariance matrix from a matrix whose columns represent\n * covariates.\n * @param matrix input matrix (must have at least two columns and two rows)\n * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n * @return covariance matrix\n * @throws MathIllegalArgumentException if the matrix does not contain sufficient data\n */\nprotected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected) throws MathIllegalArgumentException {\n    int dimension = matrix.getColumnDimension();\n    Variance variance = new Variance(biasCorrected);\n    RealMatrix outMatrix = new BlockRealMatrix(dimension, dimension);\n    for (int i = 0; i < dimension; i++) {\n        for (int j = 0; j < i; j++) {\n            double cov = covariance(matrix.getColumn(i), matrix.getColumn(j), biasCorrected);\n            outMatrix.setEntry(i, j, cov);\n            outMatrix.setEntry(j, i, cov);\n        }\n        outMatrix.setEntry(i, i, variance.evaluate(matrix.getColumn(i)));\n    }\n    return outMatrix;\n}", "code_comment": "/**\n * Compute a covariance matrix from a matrix whose columns represent\n * covariates.\n * @param matrix input matrix (must have at least two columns and two rows)\n * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n * @return covariance matrix\n * @throws MathIllegalArgumentException if the matrix does not contain sufficient data\n */\n", "code_no_comment": "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected) throws MathIllegalArgumentException {\n    int dimension = matrix.getColumnDimension();\n    Variance variance = new Variance(biasCorrected);\n    RealMatrix outMatrix = new BlockRealMatrix(dimension, dimension);\n    for (int i = 0; i < dimension; i++) {\n        for (int j = 0; j < i; j++) {\n            double cov = covariance(matrix.getColumn(i), matrix.getColumn(j), biasCorrected);\n            outMatrix.setEntry(i, j, cov);\n            outMatrix.setEntry(j, i, cov);\n        }\n        outMatrix.setEntry(i, i, variance.evaluate(matrix.getColumn(i)));\n    }\n    return outMatrix;\n}", "lc": 0.0, "pi": 0.46428571428571436, "ma": -0.16666666666666666, "nbd": 0.0, "ml": 0.0, "d": 0.19278299555116168, "mi": -0.072841984513909, "fo": 0.25, "r": -0.028571428571428574, "e": 0.217837854043798}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-127_029e79da", "label": 1, "code": "/**\n * Logs a message with the specific Marker at the {@link Level#ERROR ERROR} level.\n *\n * @param marker the marker data specific to this log statement\n * @param msg    the message string to be logged\n */\npublic void error(Marker marker, Message msg) {\n    if (isEnabled(Level.ERROR, marker, msg, null)) {\n        log(null, FQCN, Level.ERROR, msg, null);\n    }\n}", "code_comment": "/**\n * Logs a message with the specific Marker at the {@link Level#ERROR ERROR} level.\n *\n * @param marker the marker data specific to this log statement\n * @param msg    the message string to be logged\n */\n", "code_no_comment": "public void error(Marker marker, Message msg) {\n    if (isEnabled(Level.ERROR, marker, msg, null)) {\n        log(null, FQCN, Level.ERROR, msg, null);\n    }\n}", "lc": -0.4090909090909091, "pi": -0.015306122448979493, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.3806228373702422, "mi": 0.6369371952968167, "fo": -0.3333333333333333, "r": 0.9714285714285714, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-757_76b7413d", "label": 1, "code": "/**\n * Checks the expansion factor and the contraction criterion and throws an\n * IllegalArgumentException if the contractionCriteria is less than the\n * expansionCriteria\n *\n * @param expansion factor to be checked\n * @param contraction criteria to be checked\n * @throws MathIllegalArgumentException if the contractionCriteria is less than\n * the expansionCriteria.\n * @deprecated As of 3.1. Please use\n * {@link #checkContractExpand(double,double)} instead.\n */\n@Deprecated\nprotected void checkContractExpand(float contraction, float expansion) throws MathIllegalArgumentException {\n    checkContractExpand((double) contraction, (double) expansion);\n}", "code_comment": "/**\n * Checks the expansion factor and the contraction criterion and throws an\n * IllegalArgumentException if the contractionCriteria is less than the\n * expansionCriteria\n *\n * @param expansion factor to be checked\n * @param contraction criteria to be checked\n * @throws MathIllegalArgumentException if the contractionCriteria is less than\n * the expansionCriteria.\n * @deprecated As of 3.1. Please use\n * {@link #checkContractExpand(double,double)} instead.\n */\n", "code_no_comment": "@Deprecated\nprotected void checkContractExpand(float contraction, float expansion) throws MathIllegalArgumentException {\n    checkContractExpand((double) contraction, (double) expansion);\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9073702322913678, "fo": -0.4166666666666667, "r": 2.685714285714286, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-640_98556fed", "label": 1, "code": "/**\n * Returns the next pseudorandom, uniformly distributed {@code long}\n * value from this random number generator's sequence.  All\n * 2<font size=\"-1\"><sup>64</sup></font> possible {@code long} values\n * should be produced with (approximately) equal probability.\n * <p>\n * The default implementation returns\n * <pre>\n * <code>(long) (nextDouble() * Long.MAX_VALUE)</code>\n * </pre></p>\n *\n * @return  the next pseudorandom, uniformly distributed {@code long}\n *value from this random number generator's sequence\n */\npublic long nextLong() {\n    return (long) (nextDouble() * Long.MAX_VALUE);\n}", "code_comment": "/**\n * Returns the next pseudorandom, uniformly distributed {@code long}\n * value from this random number generator's sequence.  All\n * 2<font size=\"-1\"><sup>64</sup></font> possible {@code long} values\n * should be produced with (approximately) equal probability.\n * <p>\n * The default implementation returns\n * <pre>\n * <code>(long) (nextDouble() * Long.MAX_VALUE)</code>\n * </pre></p>\n *\n * @return  the next pseudorandom, uniformly distributed {@code long}\n *value from this random number generator's sequence\n */\n", "code_no_comment": "public long nextLong() {\n    return (long) (nextDouble() * Long.MAX_VALUE);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.1015199311729282, "fo": -0.4166666666666667, "r": 2.2285714285714286, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1300_1d635088", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic void nextBytes(byte[] bytes) {\n    int i = 0;\n    final int iEnd = bytes.length - 3;\n    while (i < iEnd) {\n        final int random = next(32);\n        bytes[i] = (byte) (random & 0xff);\n        bytes[i + 1] = (byte) ((random >> 8) & 0xff);\n        bytes[i + 2] = (byte) ((random >> 16) & 0xff);\n        bytes[i + 3] = (byte) ((random >> 24) & 0xff);\n        i += 4;\n    }\n    int random = next(32);\n    while (i < bytes.length) {\n        bytes[i++] = (byte) (random & 0xff);\n        random >>= 8;\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic void nextBytes(byte[] bytes) {\n    int i = 0;\n    final int iEnd = bytes.length - 3;\n    while (i < iEnd) {\n        final int random = next(32);\n        bytes[i] = (byte) (random & 0xff);\n        bytes[i + 1] = (byte) ((random >> 8) & 0xff);\n        bytes[i + 2] = (byte) ((random >> 16) & 0xff);\n        bytes[i + 3] = (byte) ((random >> 24) & 0xff);\n        i += 4;\n    }\n    int random = next(32);\n    while (i < bytes.length) {\n        bytes[i++] = (byte) (random & 0xff);\n        random >>= 8;\n    }\n}", "lc": 0.18181818181818182, "pi": -0.051020408163265356, "ma": -0.16666666666666666, "nbd": -0.5, "ml": 0.0, "d": 1.742956005931785, "mi": -0.21737883567536564, "fo": -0.3333333333333333, "r": 0.31428571428571433, "e": 1.5380180828418586}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4572_dfc56674", "label": 0, "code": "/**\n *  @param pageId\n */\nprivate void removeWindowIndex(int pageId) {\n    idToWindowIndex.remove(pageId);\n}", "code_comment": "/**\n *  @param pageId\n */\n", "code_no_comment": "private void removeWindowIndex(int pageId) {\n    idToWindowIndex.remove(pageId);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.1172928018353891, "fo": -0.4166666666666667, "r": 2.8000000000000003, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 163, "label": 1, "code": "@Override\npublic void enterScope(NodeTraversal t) {\n    symbolStack.peek().scope = t.getScope();\n// NOTE(nicksantos): We use the same anonymous node for all\n// functions that do not have reasonable names. I can't remember\n// at the moment why we do this. I think it's because anonymous\n// nodes can never have in-edges. They're just there as a placeholder\n// for scope information, and do not matter in the edge propagation.\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void enterScope(NodeTraversal t) {\n    symbolStack.peek().scope = t.getScope();\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8399770576426728, "fo": -0.3333333333333333, "r": 0.7714285714285716, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5853_b80f6640", "label": 3, "code": "/**\n *  @param locale\n *  @return Returns the numberFormat.\n */\npublic abstract NumberFormat getNumberFormat(Locale locale);", "code_comment": "/**\n *  @param locale\n *  @return Returns the numberFormat.\n */\n", "code_no_comment": "public abstract NumberFormat getNumberFormat(Locale locale);", "lc": -0.5909090909090909, "pi": -1.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.6550043016919995, "fo": -0.5, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-4915_1c3abfba", "label": 1, "code": "private boolean validateVersion(String fieldName, ModelProblemCollector problems, Severity severity, String string, String sourceHint, InputLocationTracker tracker) {\n    if (string == null || string.length() <= 0) {\n        return true;\n    }\n    if (!hasExpression(string)) {\n        return true;\n    }\n    addViolation(problems, severity, fieldName, sourceHint, \"must be a valid version but is '\" + string + \"'.\", tracker);\n    return false;\n}", "code_comment": NaN, "code_no_comment": "private boolean validateVersion(String fieldName, ModelProblemCollector problems, Severity severity, String string, String sourceHint, InputLocationTracker tracker) {\n    if (string == null || string.length() <= 0) {\n        return true;\n    }\n    if (!hasExpression(string)) {\n        return true;\n    }\n    addViolation(problems, severity, fieldName, sourceHint, \"must be a valid version but is '\" + string + \"'.\", tracker);\n    return false;\n}", "lc": -0.18181818181818182, "pi": -0.2500000000000001, "ma": -0.16666666666666666, "nbd": -0.5, "ml": 0.08333333333333333, "d": 0.24023727137914, "mi": 0.16432463435618025, "fo": -0.25, "r": -0.028571428571428574, "e": 0.07620748583396508}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1103_a6f96306", "label": 1, "code": "/**\n * {@inheritDoc}\n */\npublic Optimum optimize(final LeastSquaresProblem problem) {\n    // pull in relevant data from the problem as locals\n    // Number of observed data.\n    final int nR = problem.getObservationSize();\n    // Number of parameters.\n    final int nC = problem.getParameterSize();\n    final double[] currentPoint = problem.getStart().toArray();\n    // counters\n    final Incrementor iterationCounter = problem.getIterationCounter();\n    final Incrementor evaluationCounter = problem.getEvaluationCounter();\n    // convergence criterion\n    final ConvergenceChecker<Evaluation> checker = problem.getConvergenceChecker();\n    // arrays shared with the other private methods\n    final int solvedCols = FastMath.min(nR, nC);\n    /* Parameters evolution direction associated with lmPar. */\n    double[] lmDir = new double[nC];\n    /* Levenberg-Marquardt parameter. */\n    double lmPar = 0;\n    // local point\n    double delta = 0;\n    double xNorm = 0;\n    double[] diag = new double[nC];\n    double[] oldX = new double[nC];\n    double[] oldRes = new double[nR];\n    double[] qtf = new double[nR];\n    double[] work1 = new double[nC];\n    double[] work2 = new double[nC];\n    double[] work3 = new double[nC];\n    // Evaluate the function at the starting point and calculate its norm.\n    evaluationCounter.incrementCount();\n    // value will be reassigned in the loop\n    Evaluation current = problem.evaluate(new ArrayRealVector(currentPoint, false));\n    double[] currentResiduals = current.getResiduals().toArray();\n    double currentCost = current.getCost();\n    // Outer loop.\n    boolean firstIteration = true;\n    while (true) {\n        iterationCounter.incrementCount();\n        final Evaluation previous = current;\n        // QR decomposition of the jacobian matrix\n        final InternalData internalData = qrDecomposition(current.getJacobian(), solvedCols);\n        final double[][] weightedJacobian = internalData.weightedJacobian;\n        final int[] permutation = internalData.permutation;\n        final double[] diagR = internalData.diagR;\n        final double[] jacNorm = internalData.jacNorm;\n        // residuals already have weights applied\n        double[] weightedResidual = currentResiduals;\n        for (int i = 0; i < nR; i++) {\n            qtf[i] = weightedResidual[i];\n        }\n        // compute Qt.res\n        qTy(qtf, internalData);\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            weightedJacobian[k][pk] = diagR[pk];\n        }\n        if (firstIteration) {\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < nC; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * currentPoint[k];\n                xNorm += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = FastMath.sqrt(xNorm);\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n        }\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (currentCost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += weightedJacobian[i][pj] * qtf[i];\n                    }\n                    maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // Convergence has been reached.\n            return new OptimumImpl(current, evaluationCounter.getCount(), iterationCounter.getCount());\n        }\n        // rescale if necessary\n        for (int j = 0; j < nC; ++j) {\n            diag[j] = FastMath.max(diag[j], jacNorm[j]);\n        }\n        // Inner loop.\n        for (double ratio = 0; ratio < 1.0e-4; ) {\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = currentPoint[pj];\n            }\n            final double previousCost = currentCost;\n            double[] tmpVec = weightedResidual;\n            weightedResidual = oldRes;\n            oldRes = tmpVec;\n            // determine the Levenberg-Marquardt parameter\n            lmPar = determineLMParameter(qtf, delta, diag, internalData, solvedCols, work1, work2, work3, lmDir, lmPar);\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                currentPoint[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm += s * s;\n            }\n            lmNorm = FastMath.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = FastMath.min(delta, lmNorm);\n            }\n            // Evaluate the function at x + p and calculate its norm.\n            evaluationCounter.incrementCount();\n            current = problem.evaluate(new ArrayRealVector(currentPoint, false));\n            currentResiduals = current.getResiduals().toArray();\n            currentCost = current.getCost();\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * currentCost < previousCost) {\n                double r = currentCost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += weightedJacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 /= pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {\n                    tmp = 0.1;\n                }\n                delta = tmp * FastMath.min(delta, 10.0 * lmNorm);\n                lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < nC; ++k) {\n                    double xK = diag[k] * currentPoint[k];\n                    xNorm += xK * xK;\n                }\n                xNorm = FastMath.sqrt(xNorm);\n                // tests for convergence.\n                if (checker != null && checker.converged(iterationCounter.getCount(), previous, current)) {\n                    return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());\n                }\n            } else {\n                // failed iteration, reset the previous values\n                currentCost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    currentPoint[pj] = oldX[pj];\n                }\n                tmpVec = weightedResidual;\n                weightedResidual = oldRes;\n                oldRes = tmpVec;\n                // Reset \"current\" to previous values.\n                current = previous;\n            }\n            // Default convergence criteria.\n            if ((FastMath.abs(actRed) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0) || delta <= parRelativeTolerance * xNorm) {\n                return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());\n            }\n            // tests for termination and stringent tolerances\n            if (FastMath.abs(actRed) <= TWO_EPS && preRed <= TWO_EPS && ratio <= 2.0) {\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);\n            } else if (delta <= TWO_EPS * xNorm) {\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);\n            } else if (maxCosine <= TWO_EPS) {\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\n            }\n        }\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public Optimum optimize(final LeastSquaresProblem problem) {\n            final int nR = problem.getObservationSize();\n        final int nC = problem.getParameterSize();\n    final double[] currentPoint = problem.getStart().toArray();\n        final Incrementor iterationCounter = problem.getIterationCounter();\n    final Incrementor evaluationCounter = problem.getEvaluationCounter();\n        final ConvergenceChecker<Evaluation> checker = problem.getConvergenceChecker();\n        final int solvedCols = FastMath.min(nR, nC);\n        double[] lmDir = new double[nC];\n        double lmPar = 0;\n        double delta = 0;\n    double xNorm = 0;\n    double[] diag = new double[nC];\n    double[] oldX = new double[nC];\n    double[] oldRes = new double[nR];\n    double[] qtf = new double[nR];\n    double[] work1 = new double[nC];\n    double[] work2 = new double[nC];\n    double[] work3 = new double[nC];\n        evaluationCounter.incrementCount();\n        Evaluation current = problem.evaluate(new ArrayRealVector(currentPoint, false));\n    double[] currentResiduals = current.getResiduals().toArray();\n    double currentCost = current.getCost();\n        boolean firstIteration = true;\n    while (true) {\n        iterationCounter.incrementCount();\n        final Evaluation previous = current;\n                final InternalData internalData = qrDecomposition(current.getJacobian(), solvedCols);\n        final double[][] weightedJacobian = internalData.weightedJacobian;\n        final int[] permutation = internalData.permutation;\n        final double[] diagR = internalData.diagR;\n        final double[] jacNorm = internalData.jacNorm;\n                double[] weightedResidual = currentResiduals;\n        for (int i = 0; i < nR; i++) {\n            qtf[i] = weightedResidual[i];\n        }\n                qTy(qtf, internalData);\n                for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            weightedJacobian[k][pk] = diagR[pk];\n        }\n        if (firstIteration) {\n                                    xNorm = 0;\n            for (int k = 0; k < nC; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * currentPoint[k];\n                xNorm += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = FastMath.sqrt(xNorm);\n                        delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n        }\n                double maxCosine = 0;\n        if (currentCost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += weightedJacobian[i][pj] * qtf[i];\n                    }\n                    maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n                        return new OptimumImpl(current, evaluationCounter.getCount(), iterationCounter.getCount());\n        }\n                for (int j = 0; j < nC; ++j) {\n            diag[j] = FastMath.max(diag[j], jacNorm[j]);\n        }\n                for (double ratio = 0; ratio < 1.0e-4; ) {\n                        for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = currentPoint[pj];\n            }\n            final double previousCost = currentCost;\n            double[] tmpVec = weightedResidual;\n            weightedResidual = oldRes;\n            oldRes = tmpVec;\n                        lmPar = determineLMParameter(qtf, delta, diag, internalData, solvedCols, work1, work2, work3, lmDir, lmPar);\n                        double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                currentPoint[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm += s * s;\n            }\n            lmNorm = FastMath.sqrt(lmNorm);\n                        if (firstIteration) {\n                delta = FastMath.min(delta, lmNorm);\n            }\n                        evaluationCounter.incrementCount();\n            current = problem.evaluate(new ArrayRealVector(currentPoint, false));\n            currentResiduals = current.getResiduals().toArray();\n            currentCost = current.getCost();\n                        double actRed = -1.0;\n            if (0.1 * currentCost < previousCost) {\n                double r = currentCost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n                        for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += weightedJacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 /= pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n                        ratio = (preRed == 0) ? 0 : (actRed / preRed);\n                        if (ratio <= 0.25) {\n                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {\n                    tmp = 0.1;\n                }\n                delta = tmp * FastMath.min(delta, 10.0 * lmNorm);\n                lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n                        if (ratio >= 1.0e-4) {\n                                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < nC; ++k) {\n                    double xK = diag[k] * currentPoint[k];\n                    xNorm += xK * xK;\n                }\n                xNorm = FastMath.sqrt(xNorm);\n                                if (checker != null && checker.converged(iterationCounter.getCount(), previous, current)) {\n                    return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());\n                }\n            } else {\n                                currentCost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    currentPoint[pj] = oldX[pj];\n                }\n                tmpVec = weightedResidual;\n                weightedResidual = oldRes;\n                oldRes = tmpVec;\n                                current = previous;\n            }\n                        if ((FastMath.abs(actRed) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0) || delta <= parRelativeTolerance * xNorm) {\n                return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());\n            }\n                        if (FastMath.abs(actRed) <= TWO_EPS && preRed <= TWO_EPS && ratio <= 2.0) {\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);\n            } else if (delta <= TWO_EPS * xNorm) {\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);\n            } else if (maxCosine <= TWO_EPS) {\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\n            }\n        }\n    }\n}", "lc": 7.090909090909091, "pi": 0.933673469387755, "ma": 5.666666666666667, "nbd": 1.5, "ml": 5.416666666666667, "d": 7.121107266435987, "mi": -1.880986521365071, "fo": 2.9166666666666665, "r": -0.028571428571428574, "e": 81.91069937168335}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-373_bfe4623c", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic double getResult() {\n    if (n > 0) {\n        return value;\n    } else {\n        return Double.NaN;\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic double getResult() {\n    if (n > 0) {\n        return value;\n    } else {\n        return Double.NaN;\n    }\n}", "lc": -0.2727272727272727, "pi": 0.051020408163265356, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.3806228373702422, "mi": 0.5483223401204477, "fo": -0.5, "r": 2.742857142857143, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5138_e8dab4a0", "label": 1, "code": "/**\n *  Process the request cycle\n *\n *  @param requestCycle\n *  @param webResponse\n *  @param httpServletRequest\n *  @param httpServletResponse\n *  @param chain\n *  @return false, if the request could not be processed\n *  @throws IOException\n *  @throws ServletException\n */\nprotected boolean processRequestCycle(RequestCycle requestCycle, WebResponse webResponse, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, final FilterChain chain) throws IOException, ServletException {\n    // Assume we are able to handle the request\n    boolean res = true;\n    if (!requestCycle.processRequestAndDetach()) {\n        if (chain != null) {\n            chain.doFilter(httpServletRequest, httpServletResponse);\n        }\n        res = false;\n    } else {\n        webResponse.flush();\n    }\n    return res;\n}", "code_comment": "/**\n *  Process the request cycle\n *\n *  @param requestCycle\n *  @param webResponse\n *  @param httpServletRequest\n *  @param httpServletResponse\n *  @param chain\n *  @return false, if the request could not be processed\n *  @throws IOException\n *  @throws ServletException\n */\n", "code_no_comment": "protected boolean processRequestCycle(RequestCycle requestCycle, WebResponse webResponse, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, final FilterChain chain) throws IOException, ServletException {\n        boolean res = true;\n    if (!requestCycle.processRequestAndDetach()) {\n        if (chain != null) {\n            chain.doFilter(httpServletRequest, httpServletResponse);\n        }\n        res = false;\n    } else {\n        webResponse.flush();\n    }\n    return res;\n}", "lc": -0.09090909090909091, "pi": 0.1938775510204081, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.10776075135936727, "mi": 0.10438772583882998, "fo": -0.25, "r": 0.31428571428571433, "e": -0.07473841554559044}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1093_7cfbc0da", "label": 1, "code": "/**\n * Compute the relative position of the instance with respect\n * to an arc.\n * <p>\n * The {@link Side#MINUS} side of the arc is the one covered by the arc.\n * </p>\n * @param arc arc to check instance against\n * @return one of {@link Side#PLUS}, {@link Side#MINUS}, {@link Side#BOTH}\n * or {@link Side#HYPER}\n */\npublic Side side(final Arc arc) {\n    final double reference = FastMath.PI + arc.getInf();\n    final double arcLength = arc.getSup() - arc.getInf();\n    boolean inMinus = false;\n    boolean inPlus = false;\n    for (final double[] a : this) {\n        final double syncedStart = MathUtils.normalizeAngle(a[0], reference) - arc.getInf();\n        final double arcOffset = a[0] - syncedStart;\n        final double syncedEnd = a[1] - arcOffset;\n        if (syncedStart < arcLength || syncedEnd > MathUtils.TWO_PI) {\n            inMinus = true;\n        }\n        if (syncedEnd > arcLength) {\n            inPlus = true;\n        }\n    }\n    if (inMinus) {\n        if (inPlus) {\n            return Side.BOTH;\n        } else {\n            return Side.MINUS;\n        }\n    } else {\n        if (inPlus) {\n            return Side.PLUS;\n        } else {\n            return Side.HYPER;\n        }\n    }\n}", "code_comment": "/**\n * Compute the relative position of the instance with respect\n * to an arc.\n * <p>\n * The {@link Side#MINUS} side of the arc is the one covered by the arc.\n * </p>\n * @param arc arc to check instance against\n * @return one of {@link Side#PLUS}, {@link Side#MINUS}, {@link Side#BOTH}\n * or {@link Side#HYPER}\n */\n", "code_no_comment": "public Side side(final Arc arc) {\n    final double reference = FastMath.PI + arc.getInf();\n    final double arcLength = arc.getSup() - arc.getInf();\n    boolean inMinus = false;\n    boolean inPlus = false;\n    for (final double[] a : this) {\n        final double syncedStart = MathUtils.normalizeAngle(a[0], reference) - arc.getInf();\n        final double arcOffset = a[0] - syncedStart;\n        final double syncedEnd = a[1] - arcOffset;\n        if (syncedStart < arcLength || syncedEnd > MathUtils.TWO_PI) {\n            inMinus = true;\n        }\n        if (syncedEnd > arcLength) {\n            inPlus = true;\n        }\n    }\n    if (inMinus) {\n        if (inPlus) {\n            return Side.BOTH;\n        } else {\n            return Side.MINUS;\n        }\n    } else {\n        if (inPlus) {\n            return Side.PLUS;\n        } else {\n            return Side.HYPER;\n        }\n    }\n}", "lc": 0.7272727272727273, "pi": 0.18367346938775503, "ma": 0.5, "nbd": 0.0, "ml": 0.5, "d": 0.8472565496786951, "mi": -0.48752509320332676, "fo": -0.08333333333333333, "r": -0.028571428571428574, "e": 0.8648669484883137}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3510_01f5a26f", "label": 1, "code": "/**\n * Escapes the given string and appends it to the builder.\n * @param builder the builder\n * @param str the string\n */\nprivate void escape(StringBuilder builder, CharSequence str) {\n    final int len = str.length();\n    for (int i = 0; i < len; i++) {\n        char c = str.charAt(i);\n        if (c == '%') {\n            builder.append(\"%25\");\n        } else if (c == ';') {\n            builder.append(\"%3b\");\n        } else {\n            builder.append(c);\n        }\n    }\n}", "code_comment": "/**\n * Escapes the given string and appends it to the builder.\n * @param builder the builder\n * @param str the string\n */\n", "code_no_comment": "private void escape(StringBuilder builder, CharSequence str) {\n    final int len = str.length();\n    for (int i = 0; i < len; i++) {\n        char c = str.charAt(i);\n        if (c == '%') {\n            builder.append(\"%25\");\n        } else if (c == ';') {\n            builder.append(\"%3b\");\n        } else {\n            builder.append(c);\n        }\n    }\n}", "lc": -0.045454545454545456, "pi": 0.47959183673469385, "ma": 0.0, "nbd": 0.5, "ml": 0.08333333333333333, "d": 0.34107760751359373, "mi": 0.04617149412102093, "fo": -0.08333333333333333, "r": 0.9714285714285714, "e": 0.09648750861954507}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3156_786b3d76", "label": 0, "code": "@Override\npublic boolean isVirtualRow() {\n    return getPath() == null;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean isVirtualRow() {\n    return getPath() == null;\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9678806997418987, "fo": -0.4166666666666667, "r": 2.6, "e": -0.16422749602751402}
{"project_name": "Cli", "project_version": 22, "label": 1, "code": "/**\n * Breaks <code>token</code> into its constituent parts\n * using the following algorithm.\n *\n * <ul>\n *  <li>ignore the first character (\"<b>-</b>\")</li>\n *  <li>foreach remaining character check if an {@link Option}\n *  exists with that id.</li>\n *  <li>if an {@link Option} does exist then add that character\n *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n *  <li>if the {@link Option} can have an argument value and there\n *  are remaining characters in the token then add the remaining\n *  characters as a token to the list of processed tokens.</li>\n *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n *  \"<b>--</b>\" followed by the remaining characters and also\n *  the remaining tokens directly to the processed tokens list.</li>\n *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n *  character prepended with \"<b>-</b>\".</li>\n * </ul>\n *\n * @param token The current token to be <b>burst</b>\n * @param stopAtNonOption Specifies whether to stop processing\n * at the first non-Option encountered.\n */\nprotected void burstToken(String token, boolean stopAtNonOption) {\n    Option currentOption;\n    for (int i = 1; i < token.length(); i++) {\n        String ch = String.valueOf(token.charAt(i));\n        if (options.hasOption(ch)) {\n            tokens.add(\"-\" + ch);\n            currentOption = options.getOption(ch);\n            if (currentOption.hasArg() && (token.length() != (i + 1))) {\n                tokens.add(token.substring(i + 1));\n                break;\n            }\n        } else if (stopAtNonOption) {\n            processNonOptionToken(token.substring(i));\n            break;\n        } else {\n            tokens.add(token);\n            break;\n        }\n    }\n}", "code_comment": "/**\n * Breaks <code>token</code> into its constituent parts\n * using the following algorithm.\n *\n * <ul>\n *  <li>ignore the first character (\"<b>-</b>\")</li>\n *  <li>foreach remaining character check if an {@link Option}\n *  exists with that id.</li>\n *  <li>if an {@link Option} does exist then add that character\n *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n *  <li>if the {@link Option} can have an argument value and there\n *  are remaining characters in the token then add the remaining\n *  characters as a token to the list of processed tokens.</li>\n *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n *  \"<b>--</b>\" followed by the remaining characters and also\n *  the remaining tokens directly to the processed tokens list.</li>\n *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n *  character prepended with \"<b>-</b>\".</li>\n * </ul>\n *\n * @param token The current token to be <b>burst</b>\n * @param stopAtNonOption Specifies whether to stop processing\n * at the first non-Option encountered.\n */\n", "code_no_comment": "protected void burstToken(String token, boolean stopAtNonOption) {\n    Option currentOption;\n    for (int i = 1; i < token.length(); i++) {\n        String ch = String.valueOf(token.charAt(i));\n        if (options.hasOption(ch)) {\n            tokens.add(\"-\" + ch);\n            currentOption = options.getOption(ch);\n            if (currentOption.hasArg() && (token.length() != (i + 1))) {\n                tokens.add(token.substring(i + 1));\n                break;\n            }\n        } else if (stopAtNonOption) {\n            processNonOptionToken(token.substring(i));\n            break;\n        } else {\n            tokens.add(token);\n            break;\n        }\n    }\n}", "lc": 0.2727272727272727, "pi": 0.7755102040816326, "ma": 0.6666666666666666, "nbd": 0.5, "ml": 0.5, "d": 0.9935739001482948, "mi": -0.2644106681961572, "fo": 0.5833333333333334, "r": -0.028571428571428574, "e": 0.7092525730145066}
{"project_name": "Closure", "project_version": 153, "label": 2, "code": "private void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n        // Bleed the function name into the scope, if it hasn't\n        // been declared in the outer scope.\n        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        }\n        // Args: Declare function variables\n        Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n        // Body\n        scanVars(body, n);\n    } else {\n        // It's the global block\n        Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}", "code_comment": NaN, "code_no_comment": "private void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n                        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        }\n                Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n                scanVars(body, n);\n    } else {\n                Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}", "lc": 0.3181818181818182, "pi": 0.08163265306122457, "ma": 0.0, "nbd": 0.0, "ml": 0.3333333333333333, "d": 0.6258032624814632, "mi": -0.344422139374821, "fo": 1.25, "r": -0.028571428571428574, "e": 0.9571656794343008}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2437_a41bc8cc", "label": 3, "code": "/**\n *  Checks if the given field is a valid pojo field:\n *  - it is public\n *  OR\n *   - there are getter and setter methods for the field.\n *\n *  @param f field to check\n *  @param clazz class of field\n *  @param typeHierarchy type hierarchy for materializing generic types\n */\nprivate boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {\n    if (Modifier.isPublic(f.getModifiers())) {\n        return true;\n    } else {\n        boolean hasGetter = false, hasSetter = false;\n        final String fieldNameLow = f.getName().toLowerCase();\n        Type fieldType = f.getGenericType();\n        TypeVariable<?> fieldTypeGeneric = null;\n        if (fieldType instanceof TypeVariable) {\n            fieldTypeGeneric = (TypeVariable<?>) fieldType;\n            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);\n        }\n        for (Method m : clazz.getMethods()) {\n            // check for getter\n            if (// The name should be \"get<FieldName>\" or \"<fieldName>\" (for scala) or \"is<fieldName>\" for boolean fields.\n            (m.getName().toLowerCase().equals(\"get\" + fieldNameLow) || m.getName().toLowerCase().equals(\"is\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) && // no arguments for the getter\n            m.getParameterTypes().length == 0 && // return type is same as field type (or the generic variant of it)\n            (m.getGenericReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)))) {\n                if (hasGetter) {\n                    throw new IllegalStateException(\"Detected more than one getter\");\n                }\n                hasGetter = true;\n            }\n            // check for setters (<FieldName>_$eq for scala)\n            if ((m.getName().toLowerCase().equals(\"set\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + \"_$eq\")) && // one parameter of the field's type\n            m.getParameterTypes().length == 1 && (m.getGenericParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) && // return type is void.\n            m.getReturnType().equals(Void.TYPE)) {\n                if (hasSetter) {\n                    throw new IllegalStateException(\"Detected more than one setter\");\n                }\n                hasSetter = true;\n            }\n        }\n        if (hasGetter && hasSetter) {\n            return true;\n        } else {\n            if (!hasGetter) {\n                LOG.debug(\"Class \" + clazz + \" does not contain a getter for field \" + f.getName());\n            }\n            if (!hasSetter) {\n                LOG.debug(\"Class \" + clazz + \" does not contain a setter for field \" + f.getName());\n            }\n            return false;\n        }\n    }\n}", "code_comment": "/**\n *  Checks if the given field is a valid pojo field:\n *  - it is public\n *  OR\n *   - there are getter and setter methods for the field.\n *\n *  @param f field to check\n *  @param clazz class of field\n *  @param typeHierarchy type hierarchy for materializing generic types\n */\n", "code_no_comment": "private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {\n    if (Modifier.isPublic(f.getModifiers())) {\n        return true;\n    } else {\n        boolean hasGetter = false, hasSetter = false;\n        final String fieldNameLow = f.getName().toLowerCase();\n        Type fieldType = f.getGenericType();\n        TypeVariable<?> fieldTypeGeneric = null;\n        if (fieldType instanceof TypeVariable) {\n            fieldTypeGeneric = (TypeVariable<?>) fieldType;\n            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);\n        }\n        for (Method m : clazz.getMethods()) {\n                        if (            (m.getName().toLowerCase().equals(\"get\" + fieldNameLow) || m.getName().toLowerCase().equals(\"is\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) &&             m.getParameterTypes().length == 0 &&             (m.getGenericReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)))) {\n                if (hasGetter) {\n                    throw new IllegalStateException(\"Detected more than one getter\");\n                }\n                hasGetter = true;\n            }\n                        if ((m.getName().toLowerCase().equals(\"set\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + \"_$eq\")) &&             m.getParameterTypes().length == 1 && (m.getGenericParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) &&             m.getReturnType().equals(Void.TYPE)) {\n                if (hasSetter) {\n                    throw new IllegalStateException(\"Detected more than one setter\");\n                }\n                hasSetter = true;\n            }\n        }\n        if (hasGetter && hasSetter) {\n            return true;\n        } else {\n            if (!hasGetter) {\n                LOG.debug(\"Class \" + clazz + \" does not contain a getter for field \" + f.getName());\n            }\n            if (!hasSetter) {\n                LOG.debug(\"Class \" + clazz + \" does not contain a setter for field \" + f.getName());\n            }\n            return false;\n        }\n    }\n}", "lc": 1.3636363636363635, "pi": 0.7346938775510204, "ma": 1.5, "nbd": 1.0, "ml": 2.9166666666666665, "d": 1.2249134948096887, "mi": -0.8468597648408377, "fo": 2.6666666666666665, "r": -0.028571428571428574, "e": 3.31852698934817}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-334_9d8cc45d", "label": 1, "code": "@Override\npublic SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {\n    RegExFilter result = new RegExFilter();\n    result.setSource(getSource().deepCopy(env));\n    result.rowMatcher = copyMatcher(rowMatcher);\n    result.colfMatcher = copyMatcher(colfMatcher);\n    result.colqMatcher = copyMatcher(colqMatcher);\n    result.valueMatcher = copyMatcher(valueMatcher);\n    result.orFields = orFields;\n    return result;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {\n    RegExFilter result = new RegExFilter();\n    result.setSource(getSource().deepCopy(env));\n    result.rowMatcher = copyMatcher(rowMatcher);\n    result.colfMatcher = copyMatcher(colfMatcher);\n    result.colqMatcher = copyMatcher(colqMatcher);\n    result.valueMatcher = copyMatcher(valueMatcher);\n    result.orFields = orFields;\n    return result;\n}", "lc": -0.13636363636363635, "pi": -0.6326530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.1336392314310295, "fo": 0.08333333333333333, "r": 0.0, "e": -0.16422749602751402}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-4761_8cdb461f", "label": 1, "code": "public List<Artifact> resolve(Plugin plugin, Artifact pluginArtifact, ArtifactResolutionRequest request, ArtifactFilter dependencyFilter) throws PluginResolutionException {\n    if (pluginArtifact == null) {\n        pluginArtifact = repositorySystem.createPluginArtifact(plugin);\n    }\n    Set<Artifact> overrideArtifacts = new LinkedHashSet<Artifact>();\n    for (Dependency dependency : plugin.getDependencies()) {\n        dependency.setScope(Artifact.SCOPE_RUNTIME);\n        overrideArtifacts.add(repositorySystem.createDependencyArtifact(dependency));\n    }\n    ArtifactFilter collectionFilter = new ScopeArtifactFilter(Artifact.SCOPE_RUNTIME_PLUS_SYSTEM);\n    ArtifactFilter resolutionFilter = artifactFilterManager.getCoreArtifactFilter();\n    PluginDependencyResolutionListener listener = new PluginDependencyResolutionListener(resolutionFilter);\n    if (dependencyFilter != null) {\n        resolutionFilter = new AndArtifactFilter(Arrays.asList(resolutionFilter, dependencyFilter));\n    }\n    request.setArtifact(pluginArtifact);\n    request.setArtifactDependencies(overrideArtifacts);\n    request.setCollectionFilter(collectionFilter);\n    request.setResolutionFilter(resolutionFilter);\n    request.setResolveRoot(true);\n    request.setResolveTransitively(true);\n    request.addListener(listener);\n    ArtifactResolutionResult result = repositorySystem.resolve(request);\n    try {\n        resolutionErrorHandler.throwErrors(request, result);\n    } catch (ArtifactResolutionException e) {\n        throw new PluginResolutionException(plugin, e);\n    }\n    List<Artifact> pluginArtifacts = new ArrayList<Artifact>(result.getArtifacts());\n    listener.removeBannedDependencies(pluginArtifacts);\n    addPlexusUtils(pluginArtifacts, plugin, request);\n    return pluginArtifacts;\n}", "code_comment": NaN, "code_no_comment": "public List<Artifact> resolve(Plugin plugin, Artifact pluginArtifact, ArtifactResolutionRequest request, ArtifactFilter dependencyFilter) throws PluginResolutionException {\n    if (pluginArtifact == null) {\n        pluginArtifact = repositorySystem.createPluginArtifact(plugin);\n    }\n    Set<Artifact> overrideArtifacts = new LinkedHashSet<Artifact>();\n    for (Dependency dependency : plugin.getDependencies()) {\n        dependency.setScope(Artifact.SCOPE_RUNTIME);\n        overrideArtifacts.add(repositorySystem.createDependencyArtifact(dependency));\n    }\n    ArtifactFilter collectionFilter = new ScopeArtifactFilter(Artifact.SCOPE_RUNTIME_PLUS_SYSTEM);\n    ArtifactFilter resolutionFilter = artifactFilterManager.getCoreArtifactFilter();\n    PluginDependencyResolutionListener listener = new PluginDependencyResolutionListener(resolutionFilter);\n    if (dependencyFilter != null) {\n        resolutionFilter = new AndArtifactFilter(Arrays.asList(resolutionFilter, dependencyFilter));\n    }\n    request.setArtifact(pluginArtifact);\n    request.setArtifactDependencies(overrideArtifacts);\n    request.setCollectionFilter(collectionFilter);\n    request.setResolutionFilter(resolutionFilter);\n    request.setResolveRoot(true);\n    request.setResolveTransitively(true);\n    request.addListener(listener);\n    ArtifactResolutionResult result = repositorySystem.resolve(request);\n    try {\n        resolutionErrorHandler.throwErrors(request, result);\n    } catch (ArtifactResolutionException e) {\n        throw new PluginResolutionException(plugin, e);\n    }\n    List<Artifact> pluginArtifacts = new ArrayList<Artifact>(result.getArtifacts());\n    listener.removeBannedDependencies(pluginArtifacts);\n    addPlexusUtils(pluginArtifacts, plugin, request);\n    return pluginArtifacts;\n}", "lc": 0.8636363636363636, "pi": -0.5663265306122449, "ma": 0.3333333333333333, "nbd": -0.5, "ml": -0.08333333333333333, "d": 0.006920415224913524, "mi": -0.6117006022368799, "fo": 1.0833333333333333, "r": -0.028571428571428574, "e": 0.41712601881951844}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2062_5c4589bd", "label": 1, "code": "private PropertyValue currentOakProperty(String oakPropertyName, Integer propertyType) {\n    boolean asterisk = oakPropertyName.indexOf('*') >= 0;\n    if (asterisk) {\n        Tree t = currentTree();\n        ArrayList<PropertyValue> list = new ArrayList<PropertyValue>();\n        readOakProperties(list, t, oakPropertyName, propertyType);\n        if (list.size() == 0) {\n            return null;\n        } else if (list.size() == 1) {\n            return list.get(0);\n        }\n        Type<?> type = list.get(0).getType();\n        for (int i = 1; i < list.size(); i++) {\n            Type<?> t2 = list.get(i).getType();\n            if (t2 != type) {\n                // types don't match\n                type = Type.STRING;\n                break;\n            }\n        }\n        if (type == Type.STRING) {\n            ArrayList<String> strings = new ArrayList<String>();\n            for (PropertyValue p : list) {\n                Iterables.addAll(strings, p.getValue(Type.STRINGS));\n            }\n            return PropertyValues.newString(strings);\n        }\n        @SuppressWarnings(\"unchecked\")\n        PropertyBuilder<Object> builder = (PropertyBuilder<Object>) PropertyBuilder.array(type);\n        builder.setName(\"\");\n        for (PropertyValue v : list) {\n            builder.addValue(v.getValue(type));\n        }\n        PropertyState s = builder.getPropertyState();\n        return PropertyValues.create(s);\n    }\n    boolean relative = oakPropertyName.indexOf('/') >= 0;\n    Tree t = currentTree();\n    if (relative) {\n        for (String p : PathUtils.elements(PathUtils.getParentPath(oakPropertyName))) {\n            if (t == null) {\n                return null;\n            }\n            if (p.equals(\"..\")) {\n                t = t.isRoot() ? null : t.getParent();\n            } else if (p.equals(\".\")) {\n            // same node\n            } else {\n                t = t.getChild(p);\n            }\n        }\n        oakPropertyName = PathUtils.getName(oakPropertyName);\n    }\n    return currentOakProperty(t, oakPropertyName, propertyType);\n}", "code_comment": NaN, "code_no_comment": "private PropertyValue currentOakProperty(String oakPropertyName, Integer propertyType) {\n    boolean asterisk = oakPropertyName.indexOf('*') >= 0;\n    if (asterisk) {\n        Tree t = currentTree();\n        ArrayList<PropertyValue> list = new ArrayList<PropertyValue>();\n        readOakProperties(list, t, oakPropertyName, propertyType);\n        if (list.size() == 0) {\n            return null;\n        } else if (list.size() == 1) {\n            return list.get(0);\n        }\n        Type<?> type = list.get(0).getType();\n        for (int i = 1; i < list.size(); i++) {\n            Type<?> t2 = list.get(i).getType();\n            if (t2 != type) {\n                                type = Type.STRING;\n                break;\n            }\n        }\n        if (type == Type.STRING) {\n            ArrayList<String> strings = new ArrayList<String>();\n            for (PropertyValue p : list) {\n                Iterables.addAll(strings, p.getValue(Type.STRINGS));\n            }\n            return PropertyValues.newString(strings);\n        }\n        @SuppressWarnings(\"unchecked\")\n        PropertyBuilder<Object> builder = (PropertyBuilder<Object>) PropertyBuilder.array(type);\n        builder.setName(\"\");\n        for (PropertyValue v : list) {\n            builder.addValue(v.getValue(type));\n        }\n        PropertyState s = builder.getPropertyState();\n        return PropertyValues.create(s);\n    }\n    boolean relative = oakPropertyName.indexOf('/') >= 0;\n    Tree t = currentTree();\n    if (relative) {\n        for (String p : PathUtils.elements(PathUtils.getParentPath(oakPropertyName))) {\n            if (t == null) {\n                return null;\n            }\n            if (p.equals(\"..\")) {\n                t = t.isRoot() ? null : t.getParent();\n            } else if (p.equals(\".\")) {\n                        } else {\n                t = t.getChild(p);\n            }\n        }\n        oakPropertyName = PathUtils.getName(oakPropertyName);\n    }\n    return currentOakProperty(t, oakPropertyName, propertyType);\n}", "lc": 1.7727272727272727, "pi": 0.46428571428571436, "ma": 2.0, "nbd": 1.0, "ml": 1.3333333333333333, "d": 1.0884824518042513, "mi": -0.9618583309435049, "fo": 2.0833333333333335, "r": -0.028571428571428574, "e": 3.2122485341419647}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-343_f6dd42b4", "label": 0, "code": "/**\n * Find a zero in the given interval with an initial guess.\n * <p>Throws <code>IllegalArgumentException</code> if the values of the\n * function at the three points have the same sign (note that it is\n * allowed to have endpoints with the same sign if the initial point has\n * opposite sign function-wise).</p>\n *\n * @param f function to solve.\n * @param min the lower bound for the interval.\n * @param max the upper bound for the interval.\n * @param initial the start value to use (must be set to min if no\n * initial point is known).\n * @return the value where the function is zero\n * @throws MaxIterationsExceededException the maximum iteration count\n * is exceeded\n * @throws FunctionEvaluationException if an error occurs evaluating\n *  the function\n * @throws IllegalArgumentException if initial is not between min and max\n * (even if it <em>is</em> a root)\n */\npublic double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    // return the initial guess if it is good enough\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    // return the first endpoint if it is good enough\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    // reduce interval if min and initial bracket the root\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    // return the second endpoint if it is good enough\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    // reduce interval if initial and max bracket the root\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    // full Brent algorithm starting with provided initial guess\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}", "code_comment": "/**\n * Find a zero in the given interval with an initial guess.\n * <p>Throws <code>IllegalArgumentException</code> if the values of the\n * function at the three points have the same sign (note that it is\n * allowed to have endpoints with the same sign if the initial point has\n * opposite sign function-wise).</p>\n *\n * @param f function to solve.\n * @param min the lower bound for the interval.\n * @param max the upper bound for the interval.\n * @param initial the start value to use (must be set to min if no\n * initial point is known).\n * @return the value where the function is zero\n * @throws MaxIterationsExceededException the maximum iteration count\n * is exceeded\n * @throws FunctionEvaluationException if an error occurs evaluating\n *  the function\n * @throws IllegalArgumentException if initial is not between min and max\n * (even if it <em>is</em> a root)\n */\n", "code_no_comment": "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n        double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n        double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n        if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n        double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n        if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n        return solve(f, min, yMin, max, yMax, initial, yInitial);\n}", "lc": 0.5454545454545454, "pi": -0.36734693877551033, "ma": 0.3333333333333333, "nbd": -0.5, "ml": 0.5833333333333334, "d": 1.1260504201680674, "mi": -0.42615428735302563, "fo": 0.6666666666666666, "r": -0.028571428571428574, "e": 1.1996350880799722}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4816_66bfc885", "label": 1, "code": "/**\n *  Strip any jsessionid and possibly other redundant info that might be in our way.\n *\n *  @param url\n *             The url to strip\n *  @return The stripped url\n */\npublic static String stripJSessionId(final String url) {\n    if (url == null) {\n        return null;\n    }\n    // http://.../abc;jsessionid=...?param=...\n    int ixSemiColon = url.indexOf(\";\");\n    if (ixSemiColon == -1) {\n        return url;\n    }\n    int ixQuestionMark = url.indexOf(\"?\");\n    if (ixQuestionMark == -1) {\n        // http://.../abc;jsession=...\n        return url.substring(0, ixSemiColon);\n    }\n    if (ixQuestionMark <= ixSemiColon) {\n        // ? is before ; - no jsessionid in the url\n        return url;\n    }\n    return url.substring(0, ixSemiColon) + url.substring(ixQuestionMark);\n}", "code_comment": "/**\n *  Strip any jsessionid and possibly other redundant info that might be in our way.\n *\n *  @param url\n *             The url to strip\n *  @return The stripped url\n */\n", "code_no_comment": "public static String stripJSessionId(final String url) {\n    if (url == null) {\n        return null;\n    }\n        int ixSemiColon = url.indexOf(\";\");\n    if (ixSemiColon == -1) {\n        return url;\n    }\n    int ixQuestionMark = url.indexOf(\"?\");\n    if (ixQuestionMark == -1) {\n                return url.substring(0, ixSemiColon);\n    }\n    if (ixQuestionMark <= ixSemiColon) {\n                return url;\n    }\n    return url.substring(0, ixSemiColon) + url.substring(ixQuestionMark);\n}", "lc": 0.13636363636363635, "pi": -0.3520408163265306, "ma": 0.16666666666666666, "nbd": -0.5, "ml": 0.16666666666666666, "d": 0.6831438457736037, "mi": -0.09922569544020673, "fo": -0.08333333333333333, "r": -0.028571428571428574, "e": 0.25891186006570127}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4923_d78132be", "label": 1, "code": "private Url decryptUrl(final Request request, final Url encryptedUrl) {\n    /*\n\t\t * If the encrypted URL has no segments it is the home page URL,\n\t\t * and does not need decrypting.\n\t\t */\n    if (encryptedUrl.getSegments().isEmpty()) {\n        return encryptedUrl;\n    }\n    List<String> encryptedSegments = encryptedUrl.getSegments();\n    Url url = new Url(request.getCharset());\n    try {\n        /*\n\t\t\t * The first encrypted segment contains an encrypted version of the\n\t\t\t * entire plain text url.\n\t\t\t */\n        String encryptedUrlString = encryptedSegments.get(0);\n        if (Strings.isEmpty(encryptedUrlString)) {\n            return null;\n        }\n        String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);\n        if (decryptedUrl == null) {\n            return null;\n        }\n        Url originalUrl = Url.parse(decryptedUrl, request.getCharset());\n        int originalNumberOfSegments = originalUrl.getSegments().size();\n        int encryptedNumberOfSegments = encryptedUrl.getSegments().size();\n        HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);\n        int segNo = 1;\n        for (; segNo < encryptedNumberOfSegments; segNo++) {\n            if (segNo > originalNumberOfSegments) {\n                break;\n            }\n            String next = generator.next();\n            String encryptedSegment = encryptedSegments.get(segNo);\n            if (!next.equals(encryptedSegment)) {\n                /*\n\t\t\t\t\t * This segment received from the browser is not the same as the\n\t\t\t\t\t * expected segment generated by the HashSegmentGenerator. Hence it,\n\t\t\t\t\t * and all subsequent segments are considered plain text siblings of the\n\t\t\t\t\t * original encrypted url.\n\t\t\t\t\t */\n                break;\n            }\n            /*\n\t\t\t\t * This segments matches the expected checksum, so we add the corresponding\n\t\t\t\t * segment from the original URL.\n\t\t\t\t */\n            url.getSegments().add(originalUrl.getSegments().get(segNo - 1));\n        }\n        /*\n\t\t\t * Add all remaining segments from the encrypted url as plain text segments.\n\t\t\t */\n        for (; segNo < encryptedNumberOfSegments; segNo++) {\n            // modified or additional segment\n            url.getSegments().add(encryptedUrl.getSegments().get(segNo));\n        }\n        url.getQueryParameters().addAll(originalUrl.getQueryParameters());\n    } catch (Exception e) {\n        log.error(\"Error decrypting URL\", e);\n        url = null;\n    }\n    return url;\n}", "code_comment": NaN, "code_no_comment": "private Url decryptUrl(final Request request, final Url encryptedUrl) {\n        if (encryptedUrl.getSegments().isEmpty()) {\n        return encryptedUrl;\n    }\n    List<String> encryptedSegments = encryptedUrl.getSegments();\n    Url url = new Url(request.getCharset());\n    try {\n                String encryptedUrlString = encryptedSegments.get(0);\n        if (Strings.isEmpty(encryptedUrlString)) {\n            return null;\n        }\n        String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);\n        if (decryptedUrl == null) {\n            return null;\n        }\n        Url originalUrl = Url.parse(decryptedUrl, request.getCharset());\n        int originalNumberOfSegments = originalUrl.getSegments().size();\n        int encryptedNumberOfSegments = encryptedUrl.getSegments().size();\n        HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);\n        int segNo = 1;\n        for (; segNo < encryptedNumberOfSegments; segNo++) {\n            if (segNo > originalNumberOfSegments) {\n                break;\n            }\n            String next = generator.next();\n            String encryptedSegment = encryptedSegments.get(segNo);\n            if (!next.equals(encryptedSegment)) {\n                                break;\n            }\n                        url.getSegments().add(originalUrl.getSegments().get(segNo - 1));\n        }\n                for (; segNo < encryptedNumberOfSegments; segNo++) {\n                        url.getSegments().add(encryptedUrl.getSegments().get(segNo));\n        }\n        url.getQueryParameters().addAll(originalUrl.getQueryParameters());\n    } catch (Exception e) {\n        log.error(\"Error decrypting URL\", e);\n        url = null;\n    }\n    return url;\n}", "lc": 1.2272727272727273, "pi": 0.31632653061224497, "ma": 1.1666666666666667, "nbd": 0.5, "ml": 0.9166666666666666, "d": 1.1814137419673754, "mi": -0.7505018640665331, "fo": 1.9166666666666667, "r": -0.028571428571428574, "e": 2.255352683944304}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-1856_faa5cf27", "label": 3, "code": "private void assembleDistributionInheritence(Model child, Model parent, String childPathAdjustment, boolean appendPaths) {\n    if (parent.getDistributionManagement() != null) {\n        DistributionManagement parentDistMgmt = parent.getDistributionManagement();\n        DistributionManagement childDistMgmt = child.getDistributionManagement();\n        if (childDistMgmt == null) {\n            childDistMgmt = new DistributionManagement();\n            child.setDistributionManagement(childDistMgmt);\n        }\n        if (childDistMgmt.getSite() == null) {\n            if (parentDistMgmt.getSite() != null) {\n                Site site = new Site();\n                childDistMgmt.setSite(site);\n                site.setId(parentDistMgmt.getSite().getId());\n                site.setName(parentDistMgmt.getSite().getName());\n                site.setUrl(parentDistMgmt.getSite().getUrl());\n                if (site.getUrl() != null) {\n                    site.setUrl(appendPath(site.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths));\n                }\n            }\n        }\n        if (childDistMgmt.getRepository() == null) {\n            if (parentDistMgmt.getRepository() != null) {\n                DeploymentRepository repository = new DeploymentRepository();\n                childDistMgmt.setRepository(repository);\n                repository.setId(parentDistMgmt.getRepository().getId());\n                repository.setName(parentDistMgmt.getRepository().getName());\n                repository.setUrl(parentDistMgmt.getRepository().getUrl());\n                repository.setUniqueVersion(parentDistMgmt.getRepository().isUniqueVersion());\n            }\n        }\n        if (childDistMgmt.getSnapshotRepository() == null) {\n            if (parentDistMgmt.getSnapshotRepository() != null) {\n                DeploymentRepository repository = new DeploymentRepository();\n                childDistMgmt.setSnapshotRepository(repository);\n                repository.setId(parentDistMgmt.getSnapshotRepository().getId());\n                repository.setName(parentDistMgmt.getSnapshotRepository().getName());\n                repository.setUrl(parentDistMgmt.getSnapshotRepository().getUrl());\n                repository.setUniqueVersion(parentDistMgmt.getSnapshotRepository().isUniqueVersion());\n            }\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private void assembleDistributionInheritence(Model child, Model parent, String childPathAdjustment, boolean appendPaths) {\n    if (parent.getDistributionManagement() != null) {\n        DistributionManagement parentDistMgmt = parent.getDistributionManagement();\n        DistributionManagement childDistMgmt = child.getDistributionManagement();\n        if (childDistMgmt == null) {\n            childDistMgmt = new DistributionManagement();\n            child.setDistributionManagement(childDistMgmt);\n        }\n        if (childDistMgmt.getSite() == null) {\n            if (parentDistMgmt.getSite() != null) {\n                Site site = new Site();\n                childDistMgmt.setSite(site);\n                site.setId(parentDistMgmt.getSite().getId());\n                site.setName(parentDistMgmt.getSite().getName());\n                site.setUrl(parentDistMgmt.getSite().getUrl());\n                if (site.getUrl() != null) {\n                    site.setUrl(appendPath(site.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths));\n                }\n            }\n        }\n        if (childDistMgmt.getRepository() == null) {\n            if (parentDistMgmt.getRepository() != null) {\n                DeploymentRepository repository = new DeploymentRepository();\n                childDistMgmt.setRepository(repository);\n                repository.setId(parentDistMgmt.getRepository().getId());\n                repository.setName(parentDistMgmt.getRepository().getName());\n                repository.setUrl(parentDistMgmt.getRepository().getUrl());\n                repository.setUniqueVersion(parentDistMgmt.getRepository().isUniqueVersion());\n            }\n        }\n        if (childDistMgmt.getSnapshotRepository() == null) {\n            if (parentDistMgmt.getSnapshotRepository() != null) {\n                DeploymentRepository repository = new DeploymentRepository();\n                childDistMgmt.setSnapshotRepository(repository);\n                repository.setId(parentDistMgmt.getSnapshotRepository().getId());\n                repository.setName(parentDistMgmt.getSnapshotRepository().getName());\n                repository.setUrl(parentDistMgmt.getSnapshotRepository().getUrl());\n                repository.setUniqueVersion(parentDistMgmt.getSnapshotRepository().isUniqueVersion());\n            }\n        }\n    }\n}", "lc": 1.2727272727272727, "pi": 0.8775510204081634, "ma": 1.0, "nbd": 1.0, "ml": 1.0833333333333333, "d": 0.374691052891745, "mi": -0.7634069400630918, "fo": 3.75, "r": -0.028571428571428574, "e": 1.0727810828290096}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4997_ee02c883", "label": 1, "code": "/**\n *  Gets a URL for the listener interface (e.g. ILinkListener).\n *\n *  @see RequestCycle#urlFor(IRequestHandler)\n *\n *  @param listener\n *             The listener interface that the URL should call\n *  @param parameters\n *             The parameters that should be rendered into the urls\n *  @return The URL\n */\npublic final CharSequence urlFor(final RequestListenerInterface listener, final PageParameters parameters) {\n    Page page = getPage();\n    PageAndComponentProvider provider = new PageAndComponentProvider(page, this, parameters);\n    IRequestHandler handler;\n    if (page.isBookmarkable()) {\n        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener);\n    } else {\n        handler = new ListenerInterfaceRequestHandler(provider, listener);\n    }\n    return getRequestCycle().urlFor(handler);\n}", "code_comment": "/**\n *  Gets a URL for the listener interface (e.g. ILinkListener).\n *\n *  @see RequestCycle#urlFor(IRequestHandler)\n *\n *  @param listener\n *             The listener interface that the URL should call\n *  @param parameters\n *             The parameters that should be rendered into the urls\n *  @return The URL\n */\n", "code_no_comment": "public final CharSequence urlFor(final RequestListenerInterface listener, final PageParameters parameters) {\n    Page page = getPage();\n    PageAndComponentProvider provider = new PageAndComponentProvider(page, this, parameters);\n    IRequestHandler handler;\n    if (page.isBookmarkable()) {\n        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener);\n    } else {\n        handler = new ListenerInterfaceRequestHandler(provider, listener);\n    }\n    return getRequestCycle().urlFor(handler);\n}", "lc": -0.13636363636363635, "pi": -0.3112244897959183, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.3806228373702422, "mi": 0.15858904502437632, "fo": -0.16666666666666666, "r": 0.31428571428571433, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5751_bcea89fc", "label": 1, "code": "/**\n *  Reconstitute the <tt>HashMap</tt> instance from a stream (i.e., deserialize it).\n *\n *  @param s\n *  @throws IOException\n *  @throws ClassNotFoundException\n */\n@SuppressWarnings(\"unchecked\")\nprivate void readObject(final java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {\n    // Read in the threshold, loadfactor, and any hidden stuff\n    s.defaultReadObject();\n    // Read in number of buckets and allocate the bucket array;\n    int numBuckets = s.readInt();\n    table = new Entry[numBuckets];\n    // Give subclass a chance to do its thing.\n    init();\n    // Read in size (number of Mappings)\n    int size = s.readInt();\n    // Read the keys and values, and put the mappings in the HashMap\n    for (int i = 0; i < size; i++) {\n        int key = s.readInt();\n        V value = (V) s.readObject();\n        putForCreate(key, value);\n    }\n}", "code_comment": "/**\n *  Reconstitute the <tt>HashMap</tt> instance from a stream (i.e., deserialize it).\n *\n *  @param s\n *  @throws IOException\n *  @throws ClassNotFoundException\n */\n", "code_no_comment": "@SuppressWarnings(\"unchecked\")\nprivate void readObject(final java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {\n        s.defaultReadObject();\n        int numBuckets = s.readInt();\n    table = new Entry[numBuckets];\n        init();\n        int size = s.readInt();\n        for (int i = 0; i < size; i++) {\n        int key = s.readInt();\n        V value = (V) s.readObject();\n        putForCreate(key, value);\n    }\n}", "lc": -0.045454545454545456, "pi": -0.15306122448979584, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.16666666666666666, "d": -0.054374691052891735, "mi": 0.020648121594493807, "fo": 0.08333333333333333, "r": 0.5428571428571429, "e": -0.011225752844985237}
{"project_name": "Closure", "project_version": 153, "label": 2, "code": "void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber);", "code_comment": NaN, "code_no_comment": "void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber);", "lc": -0.5909090909090909, "pi": -1.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.4419271580154864, "fo": -0.5, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "Math", "project_version": 101, "label": 1, "code": "/**\n * Parses a string to produce a {@link Complex} object.\n *\n * @param source the string to parse\n * @param pos input/ouput parsing parameter.\n * @return the parsed {@link Complex} object.\n */\npublic Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse real\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse sign\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch(c) {\n        case 0:\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-':\n            sign = -1;\n            break;\n        case '+':\n            sign = 1;\n            break;\n        default:\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n    }\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse imaginary\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse imaginary character\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n        // set index back to initial, error index should be the start index\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n}", "code_comment": "/**\n * Parses a string to produce a {@link Complex} object.\n *\n * @param source the string to parse\n * @param pos input/ouput parsing parameter.\n * @return the parsed {@link Complex} object.\n */\n", "code_no_comment": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n        parseAndIgnoreWhitespace(source, pos);\n        Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n                                pos.setIndex(initialIndex);\n        return null;\n    }\n        int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch(c) {\n        case 0:\n                        return new Complex(re.doubleValue(), 0.0);\n        case '-':\n            sign = -1;\n            break;\n        case '+':\n            sign = 1;\n            break;\n        default:\n                                                pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n    }\n        parseAndIgnoreWhitespace(source, pos);\n        Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n                                pos.setIndex(initialIndex);\n        return null;\n    }\n        int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n                        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n}", "lc": 1.2727272727272727, "pi": 0.1887755102040817, "ma": 1.0, "nbd": 0.0, "ml": 0.5, "d": 1.3633217993079587, "mi": -0.7347289934040726, "fo": 1.5833333333333333, "r": -0.028571428571428574, "e": 2.1889018806669496}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1372_1d12bf0e", "label": 3, "code": "@Override\nprotected PrettyPrinter newPrettyPrinter() {\n    return new DefaultXmlPrettyPrinter();\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected PrettyPrinter newPrettyPrinter() {\n    return new DefaultXmlPrettyPrinter();\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.0108976197304276, "fo": -0.5, "r": 1.5714285714285716, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-442_246d53c5", "label": 1, "code": "/**\n *  Removes any rendered feedback messages as well as compacts memory. This\n *  method is usually called at the end of the request cycle processing.\n */\nfinal void cleanupFeedbackMessages() {\n    int size = feedbackMessages.size();\n    feedbackMessages.clearRendered();\n    // the session is dirty when the list of feedback messages was changed\n    if (size != feedbackMessages.size()) {\n        dirty();\n    }\n}", "code_comment": "/**\n *  Removes any rendered feedback messages as well as compacts memory. This\n *  method is usually called at the end of the request cycle processing.\n */\n", "code_no_comment": "final void cleanupFeedbackMessages() {\n    int size = feedbackMessages.size();\n    feedbackMessages.clearRendered();\n        if (size != feedbackMessages.size()) {\n        dirty();\n    }\n}", "lc": -0.3181818181818182, "pi": -0.2346938775510204, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.16666666666666666, "d": -0.01878398418190801, "mi": 0.5638084313163179, "fo": -0.16666666666666666, "r": 2.314285714285714, "e": -0.1336040191707248}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7429_43956f93", "label": 1, "code": "private String createPlaceholderPart(String key, Properties properties, List<String> replaced, String prefixToken, String suffixToken) {\n    // keep track of which parts we have replaced\n    replaced.add(key);\n    String propertyValue = System.getProperty(key);\n    if (propertyValue != null) {\n        log.debug(\"Found a JVM system property: {} with value: {} to be used.\", key, propertyValue);\n    } else if (properties != null) {\n        propertyValue = properties.getProperty(key);\n    }\n    // we need to check if the propertyValue is nested\n    // we need to check if there is cycle dependency of the nested properties\n    List<String> visited = new ArrayList<String>();\n    while (isNestProperty(propertyValue, prefixToken, suffixToken)) {\n        visited.add(key);\n        // need to take off the token first\n        String value = takeOffNestTokes(propertyValue, prefixToken, suffixToken);\n        key = parseUri(value, properties, prefixToken, suffixToken);\n        if (visited.contains(key)) {\n            throw new IllegalArgumentException(\"Circular reference detected with key [\" + key + \"] from text: \" + propertyValue);\n        }\n        propertyValue = System.getProperty(key);\n        if (propertyValue != null) {\n            log.debug(\"Found a JVM system property: {} with value: {} to be used.\", key, propertyValue);\n        } else if (properties != null) {\n            propertyValue = properties.getProperty(key);\n        }\n    }\n    return parseProperty(key, propertyValue, properties);\n}", "code_comment": NaN, "code_no_comment": "private String createPlaceholderPart(String key, Properties properties, List<String> replaced, String prefixToken, String suffixToken) {\n        replaced.add(key);\n    String propertyValue = System.getProperty(key);\n    if (propertyValue != null) {\n        log.debug(\"Found a JVM system property: {} with value: {} to be used.\", key, propertyValue);\n    } else if (properties != null) {\n        propertyValue = properties.getProperty(key);\n    }\n            List<String> visited = new ArrayList<String>();\n    while (isNestProperty(propertyValue, prefixToken, suffixToken)) {\n        visited.add(key);\n                String value = takeOffNestTokes(propertyValue, prefixToken, suffixToken);\n        key = parseUri(value, properties, prefixToken, suffixToken);\n        if (visited.contains(key)) {\n            throw new IllegalArgumentException(\"Circular reference detected with key [\" + key + \"] from text: \" + propertyValue);\n        }\n        propertyValue = System.getProperty(key);\n        if (propertyValue != null) {\n            log.debug(\"Found a JVM system property: {} with value: {} to be used.\", key, propertyValue);\n        } else if (properties != null) {\n            propertyValue = properties.getProperty(key);\n        }\n    }\n    return parseProperty(key, propertyValue, properties);\n}", "lc": 0.5, "pi": 0.09183673469387764, "ma": 0.6666666666666666, "nbd": 0.5, "ml": 0.6666666666666666, "d": 0.21848739495798322, "mi": -0.44766274734729006, "fo": 0.5833333333333334, "r": -0.028571428571428574, "e": 0.48560696587730906}
{"project_name": "Cli", "project_version": 1, "label": 1, "code": "/**\n * Returns an array of the processed {@link Option}s.\n *\n * @return an array of the processed {@link Option}s.\n */\npublic Option[] getOptions() {\n    Collection processed = options.values();\n    // reinitialise array\n    Option[] optionsArray = new Option[processed.size()];\n    // return the array\n    return (Option[]) processed.toArray(optionsArray);\n}", "code_comment": "/**\n * Returns an array of the processed {@link Option}s.\n *\n * @return an array of the processed {@link Option}s.\n */\n", "code_no_comment": "public Option[] getOptions() {\n    Collection processed = options.values();\n        Option[] optionsArray = new Option[processed.size()];\n        return (Option[]) processed.toArray(optionsArray);\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.65672497849154, "fo": -0.25, "r": 2.742857142857143, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1877_716e1237", "label": 0, "code": "private static NodeBuilder postAsyncRunNodeStatus(NodeBuilder builder, String name) {\n    String now = now();\n    builder.getChildNode(INDEX_DEFINITIONS_NAME).setProperty(name + \"-status\", STATUS_DONE).setProperty(name + \"-done\", now, Type.DATE).removeProperty(name + \"-start\");\n    return builder;\n}", "code_comment": NaN, "code_no_comment": "private static NodeBuilder postAsyncRunNodeStatus(NodeBuilder builder, String name) {\n    String now = now();\n    builder.getChildNode(INDEX_DEFINITIONS_NAME).setProperty(name + \"-status\", STATUS_DONE).setProperty(name + \"-done\", now, Type.DATE).removeProperty(name + \"-start\");\n    return builder;\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.06623826000988627, "mi": 0.5451677659879551, "fo": -0.08333333333333333, "r": 0.0, "e": -0.07464847246671036}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3278_60d07288", "label": 1, "code": "/**\n *  The localizer will be ask for the property to display Depending on if null is allowed or not\n *  it will ask for:\n *\n *  <ul>\n *  <li>nullValid: when null is valid and by default it will show an empty string as a choice.</li>\n *  <li>null: when null is not a valid choice and it will make a choice with \"Choose One\"</li>\n *  </ul>\n *\n *  The choice for null is valid will always be returned. The choice when null is not valid will\n *  only be returned if the selected object is null.\n *\n *  @see org.apache.wicket.markup.html.form.AbstractChoice#getDefaultChoice(Object)\n */\n@Override\nprotected CharSequence getDefaultChoice(final Object selected) {\n    // Is null a valid selection value?\n    if (isNullValid()) {\n        // Null is valid, so look up the value for it\n        String option = getLocalizer().getStringIgnoreSettings(getNullValidKey(), this, null, null);\n        if (Strings.isEmpty(option)) {\n            option = getLocalizer().getString(\"nullValid\", this, \"\");\n        }\n        // The <option> tag buffer\n        final AppendingStringBuffer buffer = new AppendingStringBuffer(64 + option.length());\n        // Add option tag\n        buffer.append(\"\\n<option\");\n        // If null is selected, indicate that\n        if (selected == null) {\n            buffer.append(\" selected=\\\"selected\\\"\");\n        }\n        // Add body of option tag\n        buffer.append(\" value=\\\"\\\">\").append(option).append(\"</option>\");\n        return buffer;\n    } else {\n        // Null is not valid. Is it selected anyway?\n        if ((selected == null) || getNoSelectionValue().equals(selected) || selected.equals(EMPTY_STRING)) {\n            // Force the user to pick a non-null value\n            String option = getLocalizer().getStringIgnoreSettings(getNullKey(), this, null, null);\n            if (Strings.isEmpty(option)) {\n                option = getLocalizer().getString(\"null\", this, CHOOSE_ONE);\n            }\n            return \"\\n<option selected=\\\"selected\\\" value=\\\"\\\">\" + option + \"</option>\";\n        }\n    }\n    return \"\";\n}", "code_comment": "/**\n *  The localizer will be ask for the property to display Depending on if null is allowed or not\n *  it will ask for:\n *\n *  <ul>\n *  <li>nullValid: when null is valid and by default it will show an empty string as a choice.</li>\n *  <li>null: when null is not a valid choice and it will make a choice with \"Choose One\"</li>\n *  </ul>\n *\n *  The choice for null is valid will always be returned. The choice when null is not valid will\n *  only be returned if the selected object is null.\n *\n *  @see org.apache.wicket.markup.html.form.AbstractChoice#getDefaultChoice(Object)\n */\n", "code_no_comment": "@Override\nprotected CharSequence getDefaultChoice(final Object selected) {\n        if (isNullValid()) {\n                String option = getLocalizer().getStringIgnoreSettings(getNullValidKey(), this, null, null);\n        if (Strings.isEmpty(option)) {\n            option = getLocalizer().getString(\"nullValid\", this, \"\");\n        }\n                final AppendingStringBuffer buffer = new AppendingStringBuffer(64 + option.length());\n                buffer.append(\"\\n<option\");\n                if (selected == null) {\n            buffer.append(\" selected=\\\"selected\\\"\");\n        }\n                buffer.append(\" value=\\\"\\\">\").append(option).append(\"</option>\");\n        return buffer;\n    } else {\n                if ((selected == null) || getNoSelectionValue().equals(selected) || selected.equals(EMPTY_STRING)) {\n                        String option = getLocalizer().getStringIgnoreSettings(getNullKey(), this, null, null);\n            if (Strings.isEmpty(option)) {\n                option = getLocalizer().getString(\"null\", this, CHOOSE_ONE);\n            }\n            return \"\\n<option selected=\\\"selected\\\" value=\\\"\\\">\" + option + \"</option>\";\n        }\n    }\n    return \"\";\n}", "lc": 0.5, "pi": 0.5357142857142858, "ma": 0.3333333333333333, "nbd": 0.5, "ml": 0.6666666666666666, "d": 0.4695996045477015, "mi": -0.4092342988242042, "fo": 1.3333333333333333, "r": -0.028571428571428574, "e": 0.6134503449959525}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-4695_bb39b480", "label": 1, "code": "public void validateRawModel(Model model, ModelBuildingRequest request, ModelProblemCollector problems) {\n    Parent parent = model.getParent();\n    if (parent != null) {\n        validateStringNotEmpty(\"parent.groupId\", problems, Severity.FATAL, parent.getGroupId(), parent);\n        validateStringNotEmpty(\"parent.artifactId\", problems, Severity.FATAL, parent.getArtifactId(), parent);\n        validateStringNotEmpty(\"parent.version\", problems, Severity.FATAL, parent.getVersion(), parent);\n        if (equals(parent.getGroupId(), model.getGroupId()) && equals(parent.getArtifactId(), model.getArtifactId())) {\n            addViolation(problems, Severity.FATAL, \"parent.artifactId\", null, \"must be changed\" + \", the parent element cannot have the same groupId:artifactId as the project.\", parent);\n        }\n    }\n    if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\n        Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);\n        validateEnum(\"modelVersion\", problems, Severity.ERROR, model.getModelVersion(), null, model, \"4.0.0\");\n        validateStringNoExpression(\"groupId\", problems, Severity.WARNING, model.getGroupId(), model);\n        validateStringNoExpression(\"artifactId\", problems, Severity.WARNING, model.getArtifactId(), model);\n        validateStringNoExpression(\"version\", problems, Severity.WARNING, model.getVersion(), model);\n        validateRawDependencies(problems, model.getDependencies(), \"dependencies.dependency\", request);\n        if (model.getDependencyManagement() != null) {\n            validateRawDependencies(problems, model.getDependencyManagement().getDependencies(), \"dependencyManagement.dependencies.dependency\", request);\n        }\n        validateRepositories(problems, model.getRepositories(), \"repositories.repository\", request);\n        validateRepositories(problems, model.getPluginRepositories(), \"pluginRepositories.pluginRepository\", request);\n        Build build = model.getBuild();\n        if (build != null) {\n            validateRawPlugins(problems, build.getPlugins(), false, request);\n            PluginManagement mngt = build.getPluginManagement();\n            if (mngt != null) {\n                validateRawPlugins(problems, mngt.getPlugins(), true, request);\n            }\n        }\n        Set<String> profileIds = new HashSet<String>();\n        for (Profile profile : model.getProfiles()) {\n            if (!profileIds.add(profile.getId())) {\n                addViolation(problems, errOn30, \"profiles.profile.id\", null, \"must be unique but found duplicate profile with id \" + profile.getId(), profile);\n            }\n            validateRawDependencies(problems, profile.getDependencies(), \"profiles.profile[\" + profile.getId() + \"].dependencies.dependency\", request);\n            if (profile.getDependencyManagement() != null) {\n                validateRawDependencies(problems, profile.getDependencyManagement().getDependencies(), \"profiles.profile[\" + profile.getId() + \"].dependencyManagement.dependencies.dependency\", request);\n            }\n            validateRepositories(problems, profile.getRepositories(), \"profiles.profile[\" + profile.getId() + \"].repositories.repository\", request);\n            validateRepositories(problems, profile.getPluginRepositories(), \"profiles.profile[\" + profile.getId() + \"].pluginRepositories.pluginRepository\", request);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "public void validateRawModel(Model model, ModelBuildingRequest request, ModelProblemCollector problems) {\n    Parent parent = model.getParent();\n    if (parent != null) {\n        validateStringNotEmpty(\"parent.groupId\", problems, Severity.FATAL, parent.getGroupId(), parent);\n        validateStringNotEmpty(\"parent.artifactId\", problems, Severity.FATAL, parent.getArtifactId(), parent);\n        validateStringNotEmpty(\"parent.version\", problems, Severity.FATAL, parent.getVersion(), parent);\n        if (equals(parent.getGroupId(), model.getGroupId()) && equals(parent.getArtifactId(), model.getArtifactId())) {\n            addViolation(problems, Severity.FATAL, \"parent.artifactId\", null, \"must be changed\" + \", the parent element cannot have the same groupId:artifactId as the project.\", parent);\n        }\n    }\n    if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\n        Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);\n        validateEnum(\"modelVersion\", problems, Severity.ERROR, model.getModelVersion(), null, model, \"4.0.0\");\n        validateStringNoExpression(\"groupId\", problems, Severity.WARNING, model.getGroupId(), model);\n        validateStringNoExpression(\"artifactId\", problems, Severity.WARNING, model.getArtifactId(), model);\n        validateStringNoExpression(\"version\", problems, Severity.WARNING, model.getVersion(), model);\n        validateRawDependencies(problems, model.getDependencies(), \"dependencies.dependency\", request);\n        if (model.getDependencyManagement() != null) {\n            validateRawDependencies(problems, model.getDependencyManagement().getDependencies(), \"dependencyManagement.dependencies.dependency\", request);\n        }\n        validateRepositories(problems, model.getRepositories(), \"repositories.repository\", request);\n        validateRepositories(problems, model.getPluginRepositories(), \"pluginRepositories.pluginRepository\", request);\n        Build build = model.getBuild();\n        if (build != null) {\n            validateRawPlugins(problems, build.getPlugins(), false, request);\n            PluginManagement mngt = build.getPluginManagement();\n            if (mngt != null) {\n                validateRawPlugins(problems, mngt.getPlugins(), true, request);\n            }\n        }\n        Set<String> profileIds = new HashSet<String>();\n        for (Profile profile : model.getProfiles()) {\n            if (!profileIds.add(profile.getId())) {\n                addViolation(problems, errOn30, \"profiles.profile.id\", null, \"must be unique but found duplicate profile with id \" + profile.getId(), profile);\n            }\n            validateRawDependencies(problems, profile.getDependencies(), \"profiles.profile[\" + profile.getId() + \"].dependencies.dependency\", request);\n            if (profile.getDependencyManagement() != null) {\n                validateRawDependencies(problems, profile.getDependencyManagement().getDependencies(), \"profiles.profile[\" + profile.getId() + \"].dependencyManagement.dependencies.dependency\", request);\n            }\n            validateRepositories(problems, profile.getRepositories(), \"profiles.profile[\" + profile.getId() + \"].repositories.repository\", request);\n            validateRepositories(problems, profile.getPluginRepositories(), \"profiles.profile[\" + profile.getId() + \"].pluginRepositories.pluginRepository\", request);\n        }\n    }\n}", "lc": 1.3636363636363635, "pi": 0.2959183673469388, "ma": 1.0, "nbd": 0.5, "ml": 1.5, "d": 1.2980721700444886, "mi": -0.8861485517636941, "fo": 4.416666666666667, "r": -0.028571428571428574, "e": 5.243321726393154}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7100_00a9b02b", "label": 1, "code": "@Override\npublic void close() throws IOException {\n    if (value instanceof Closeable) {\n        IOHelper.close((Closeable) value, value.getClass().getName(), LOG);\n    } else if (value instanceof Scanner) {\n        // special for Scanner as it does not implement Closeable\n        Scanner scanner = (Scanner) value;\n        scanner.close();\n        IOException ioException = scanner.ioException();\n        if (ioException != null) {\n            throw ioException;\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void close() throws IOException {\n    if (value instanceof Closeable) {\n        IOHelper.close((Closeable) value, value.getClass().getName(), LOG);\n    } else if (value instanceof Scanner) {\n                Scanner scanner = (Scanner) value;\n        scanner.close();\n        IOException ioException = scanner.ioException();\n        if (ioException != null) {\n            throw ioException;\n        }\n    }\n}", "lc": -0.045454545454545456, "pi": 0.34183673469387754, "ma": 0.16666666666666666, "nbd": 0.5, "ml": 0.0, "d": 0.0286702916460702, "mi": 0.0791511327788928, "fo": -0.08333333333333333, "r": 0.14285714285714285, "e": -0.05066793443577851}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2439_beaca1a4", "label": 1, "code": "private IndexPlan.Builder getPlanBuilder() {\n    log.trace(\"Evaluating plan with index definition {}\", defn);\n    FullTextExpression ft = filter.getFullTextConstraint();\n    if (!defn.getVersion().isAtLeast(IndexFormatVersion.V2)) {\n        log.trace(\"Index is old format. Not supported\");\n        return null;\n    }\n    // Query Fulltext and Index does not support fulltext\n    if (ft != null && !defn.isFullTextEnabled()) {\n        return null;\n    }\n    IndexingRule indexingRule = getApplicableRule();\n    if (indexingRule == null) {\n        return null;\n    }\n    // Query Fulltext and indexing rule does not support fulltext\n    if (ft != null && !indexingRule.isFulltextEnabled()) {\n        return null;\n    }\n    result = new PlanResult(indexPath, defn, indexingRule);\n    if (defn.hasFunctionDefined() && filter.getPropertyRestriction(defn.getFunctionName()) != null) {\n        // that lowest cost if returned\n        return defaultPlan().setEstimatedEntryCount(1);\n    }\n    List<String> indexedProps = newArrayListWithCapacity(filter.getPropertyRestrictions().size());\n    // for property index\n    if (indexingRule.propertyIndexEnabled) {\n        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n            PropertyDefinition pd = indexingRule.getConfig(pr.propertyName);\n            if (pd != null && pd.propertyIndexEnabled()) {\n                indexedProps.add(pr.propertyName);\n                result.propDefns.put(pr.propertyName, pd);\n            }\n        }\n    }\n    boolean evalPathRestrictions = canEvalPathRestrictions(indexingRule);\n    boolean canEvalAlFullText = canEvalAllFullText(indexingRule, ft);\n    if (ft != null && !canEvalAlFullText) {\n        return null;\n    }\n    // Fulltext expression can also be like jcr:contains(jcr:content/metadata/@format, 'image')\n    List<OrderEntry> sortOrder = createSortOrder(indexingRule);\n    if (!indexedProps.isEmpty() || !sortOrder.isEmpty() || ft != null || evalPathRestrictions) {\n        // TODO Need a way to have better cost estimate to indicate that\n        // this index can evaluate more propertyRestrictions natively (if more props are indexed)\n        // For now we reduce cost per entry\n        int costPerEntryFactor = indexedProps.size();\n        costPerEntryFactor += sortOrder.size();\n        // this index can evaluate more propertyRestrictions natively (if more props are indexed)\n        // For now we reduce cost per entry\n        IndexPlan.Builder plan = defaultPlan();\n        if (!sortOrder.isEmpty()) {\n            plan.setSortOrder(sortOrder);\n        }\n        if (costPerEntryFactor == 0) {\n            costPerEntryFactor = 1;\n        }\n        if (ft == null) {\n            result.enableNonFullTextConstraints();\n        }\n        return plan.setCostPerEntry(defn.getCostPerEntry() / costPerEntryFactor);\n    }\n    return null;\n}", "code_comment": NaN, "code_no_comment": "private IndexPlan.Builder getPlanBuilder() {\n    log.trace(\"Evaluating plan with index definition {}\", defn);\n    FullTextExpression ft = filter.getFullTextConstraint();\n    if (!defn.getVersion().isAtLeast(IndexFormatVersion.V2)) {\n        log.trace(\"Index is old format. Not supported\");\n        return null;\n    }\n        if (ft != null && !defn.isFullTextEnabled()) {\n        return null;\n    }\n    IndexingRule indexingRule = getApplicableRule();\n    if (indexingRule == null) {\n        return null;\n    }\n        if (ft != null && !indexingRule.isFulltextEnabled()) {\n        return null;\n    }\n    result = new PlanResult(indexPath, defn, indexingRule);\n    if (defn.hasFunctionDefined() && filter.getPropertyRestriction(defn.getFunctionName()) != null) {\n                return defaultPlan().setEstimatedEntryCount(1);\n    }\n    List<String> indexedProps = newArrayListWithCapacity(filter.getPropertyRestrictions().size());\n        if (indexingRule.propertyIndexEnabled) {\n        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n            PropertyDefinition pd = indexingRule.getConfig(pr.propertyName);\n            if (pd != null && pd.propertyIndexEnabled()) {\n                indexedProps.add(pr.propertyName);\n                result.propDefns.put(pr.propertyName, pd);\n            }\n        }\n    }\n    boolean evalPathRestrictions = canEvalPathRestrictions(indexingRule);\n    boolean canEvalAlFullText = canEvalAllFullText(indexingRule, ft);\n    if (ft != null && !canEvalAlFullText) {\n        return null;\n    }\n        List<OrderEntry> sortOrder = createSortOrder(indexingRule);\n    if (!indexedProps.isEmpty() || !sortOrder.isEmpty() || ft != null || evalPathRestrictions) {\n                                int costPerEntryFactor = indexedProps.size();\n        costPerEntryFactor += sortOrder.size();\n                        IndexPlan.Builder plan = defaultPlan();\n        if (!sortOrder.isEmpty()) {\n            plan.setSortOrder(sortOrder);\n        }\n        if (costPerEntryFactor == 0) {\n            costPerEntryFactor = 1;\n        }\n        if (ft == null) {\n            result.enableNonFullTextConstraints();\n        }\n        return plan.setCostPerEntry(defn.getCostPerEntry() / costPerEntryFactor);\n    }\n    return null;\n}", "lc": 1.8181818181818181, "pi": 0.22448979591836732, "ma": 1.6666666666666667, "nbd": 0.5, "ml": 2.5833333333333335, "d": 1.3395946613939695, "mi": -0.9575566389446518, "fo": 2.3333333333333335, "r": -0.028571428571428574, "e": 3.799392670067371}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2839_15477252", "label": 1, "code": "/**\n *  @see org.apache.wicket.util.watch.IModifiable#lastModifiedTime()\n *  @return The last time this resource was modified\n */\n@Override\npublic Time lastModifiedTime() {\n    if (file != null) {\n        // in case the file has been removed by now\n        if (file.exists() == false) {\n            return null;\n        }\n        long lastModified = file.lastModified();\n        // if last modified changed update content length and last modified date\n        if (lastModified != this.lastModified) {\n            this.lastModified = lastModified;\n            contentLength = (int) file.length();\n        }\n    } else {\n        try {\n            long lastModified = Connections.getLastModified(url);\n            // if last modified changed update content length and last modified date\n            if (lastModified != this.lastModified) {\n                this.lastModified = lastModified;\n                URLConnection connection = url.openConnection();\n                contentLength = connection.getContentLength();\n                Connections.close(connection);\n            }\n        } catch (IOException e) {\n            if (url.toString().indexOf(\".jar!\") >= 0) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"getLastModified for \" + url + \" failed: \" + e.getMessage());\n                }\n            } else {\n                log.warn(\"getLastModified for \" + url + \" failed: \" + e.getMessage());\n            }\n            // allow modification watcher to detect the problem\n            return null;\n        }\n    }\n    return Time.milliseconds(lastModified);\n}", "code_comment": "/**\n *  @see org.apache.wicket.util.watch.IModifiable#lastModifiedTime()\n *  @return The last time this resource was modified\n */\n", "code_no_comment": "@Override\npublic Time lastModifiedTime() {\n    if (file != null) {\n                if (file.exists() == false) {\n            return null;\n        }\n        long lastModified = file.lastModified();\n                if (lastModified != this.lastModified) {\n            this.lastModified = lastModified;\n            contentLength = (int) file.length();\n        }\n    } else {\n        try {\n            long lastModified = Connections.getLastModified(url);\n                        if (lastModified != this.lastModified) {\n                this.lastModified = lastModified;\n                URLConnection connection = url.openConnection();\n                contentLength = connection.getContentLength();\n                Connections.close(connection);\n            }\n        } catch (IOException e) {\n            if (url.toString().indexOf(\".jar!\") >= 0) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"getLastModified for \" + url + \" failed: \" + e.getMessage());\n                }\n            } else {\n                log.warn(\"getLastModified for \" + url + \" failed: \" + e.getMessage());\n            }\n                        return null;\n        }\n    }\n    return Time.milliseconds(lastModified);\n}", "lc": 0.8636363636363636, "pi": 1.0765306122448979, "ma": 0.6666666666666666, "nbd": 1.0, "ml": 0.5833333333333334, "d": 0.39841819080573415, "mi": -0.5488958990536279, "fo": 0.75, "r": -0.028571428571428574, "e": 0.5352812434416505}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1959_93c1aa40", "label": 1, "code": "private void mergeWithConcurrencyCheck(NodeBuilder builder, final String checkpoint, final long lease) throws CommitFailedException {\n    CommitHook concurrentUpdateCheck = new CommitHook() {\n\n        @Override\n        @Nonnull\n        public NodeState processCommit(NodeState before, NodeState after, CommitInfo info) throws CommitFailedException {\n            // check for concurrent updates by this async task\n            NodeState async = before.getChildNode(ASYNC);\n            if (Objects.equal(checkpoint, async.getString(name)) && lease == async.getLong(name + \"-lease\")) {\n                return after;\n            } else {\n                throw CONCURRENT_UPDATE;\n            }\n        }\n    };\n    CompositeHook hooks = new CompositeHook(new ConflictHook(new AnnotatingConflictHandler()), new EditorHook(new ConflictValidatorProvider()), concurrentUpdateCheck);\n    store.merge(builder, hooks, CommitInfo.EMPTY);\n}", "code_comment": NaN, "code_no_comment": "private void mergeWithConcurrencyCheck(NodeBuilder builder, final String checkpoint, final long lease) throws CommitFailedException {\n    CommitHook concurrentUpdateCheck = new CommitHook() {\n\n        @Override\n        @Nonnull\n        public NodeState processCommit(NodeState before, NodeState after, CommitInfo info) throws CommitFailedException {\n                        NodeState async = before.getChildNode(ASYNC);\n            if (Objects.equal(checkpoint, async.getString(name)) && lease == async.getLong(name + \"-lease\")) {\n                return after;\n            } else {\n                throw CONCURRENT_UPDATE;\n            }\n        }\n    };\n    CompositeHook hooks = new CompositeHook(new ConflictHook(new AnnotatingConflictHandler()), new EditorHook(new ConflictValidatorProvider()), concurrentUpdateCheck);\n    store.merge(builder, hooks, CommitInfo.EMPTY);\n}", "lc": 0.09090909090909091, "pi": 0.9591836734693879, "ma": -0.16666666666666666, "nbd": 0.0, "ml": 0.25, "d": 0.19673751853682656, "mi": -0.14138227702896497, "fo": -0.08333333333333333, "r": -0.028571428571428574, "e": 0.23764674641619657}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-722_95d15eff", "label": 3, "code": "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/Tangent.html\" TARGET=\"_top\">\n * tangent</a> of this complex number.\n * Implements the formula:\n * <pre>\n *  <code>\n *   tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i\n *  </code>\n * </pre>\n * where the (real) functions on the right-hand side are\n * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n * {@link FastMath#cosh} and {@link FastMath#sinh}.\n * <br/>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * <br/>\n * Infinite (or critical) values in real or imaginary parts of the input may\n * result in infinite or NaN values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   tan(1 &plusmn; INFINITY i) = 0 + NaN i\n *   tan(&plusmn;INFINITY + i) = NaN + NaN i\n *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i\n *  </code>\n * </pre>\n *\n * @return the tangent of {@code this}.\n * @since 1.2\n */\npublic Complex tan() {\n    if (isNaN) {\n        return NaN;\n    }\n    double real2 = 2.0 * real;\n    double imaginary2 = 2.0 * imaginary;\n    double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);\n    return createComplex(FastMath.sin(real2) / d, FastMath.sinh(imaginary2) / d);\n}", "code_comment": "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/Tangent.html\" TARGET=\"_top\">\n * tangent</a> of this complex number.\n * Implements the formula:\n * <pre>\n *  <code>\n *   tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i\n *  </code>\n * </pre>\n * where the (real) functions on the right-hand side are\n * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n * {@link FastMath#cosh} and {@link FastMath#sinh}.\n * <br/>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * <br/>\n * Infinite (or critical) values in real or imaginary parts of the input may\n * result in infinite or NaN values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   tan(1 &plusmn; INFINITY i) = 0 + NaN i\n *   tan(&plusmn;INFINITY + i) = NaN + NaN i\n *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i\n *  </code>\n * </pre>\n *\n * @return the tangent of {@code this}.\n * @since 1.2\n */\n", "code_no_comment": "public Complex tan() {\n    if (isNaN) {\n        return NaN;\n    }\n    double real2 = 2.0 * real;\n    double imaginary2 = 2.0 * imaginary;\n    double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);\n    return createComplex(FastMath.sin(real2) / d, FastMath.sinh(imaginary2) / d);\n}", "lc": -0.22727272727272727, "pi": -0.3826530612244898, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": 0.24814631735046971, "mi": 0.2423286492687125, "fo": -0.08333333333333333, "r": 0.2571428571428572, "e": 0.04492014339496576}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2864_f51ea2a2", "label": 1, "code": "private Expression parseExpression() throws ParseException {\n    if (readIf(\"@\")) {\n        return readProperty();\n    } else if (readIf(\"true\")) {\n        return Expression.Literal.newBoolean(true);\n    } else if (readIf(\"false\")) {\n        return Expression.Literal.newBoolean(false);\n    } else if (currentTokenType == VALUE_NUMBER) {\n        Expression.Literal l = Expression.Literal.newNumber(currentToken);\n        read();\n        return l;\n    } else if (currentTokenType == VALUE_STRING) {\n        Expression.Literal l = Expression.Literal.newString(currentToken);\n        read();\n        return l;\n    } else if (readIf(\"-\")) {\n        if (currentTokenType != VALUE_NUMBER) {\n            throw getSyntaxError();\n        }\n        Expression.Literal l = Expression.Literal.newNumber('-' + currentToken);\n        read();\n        return l;\n    } else if (readIf(\"+\")) {\n        if (currentTokenType != VALUE_NUMBER) {\n            throw getSyntaxError();\n        }\n        return parseExpression();\n    } else {\n        return parsePropertyOrFunction();\n    }\n}", "code_comment": NaN, "code_no_comment": "private Expression parseExpression() throws ParseException {\n    if (readIf(\"@\")) {\n        return readProperty();\n    } else if (readIf(\"true\")) {\n        return Expression.Literal.newBoolean(true);\n    } else if (readIf(\"false\")) {\n        return Expression.Literal.newBoolean(false);\n    } else if (currentTokenType == VALUE_NUMBER) {\n        Expression.Literal l = Expression.Literal.newNumber(currentToken);\n        read();\n        return l;\n    } else if (currentTokenType == VALUE_STRING) {\n        Expression.Literal l = Expression.Literal.newString(currentToken);\n        read();\n        return l;\n    } else if (readIf(\"-\")) {\n        if (currentTokenType != VALUE_NUMBER) {\n            throw getSyntaxError();\n        }\n        Expression.Literal l = Expression.Literal.newNumber('-' + currentToken);\n        read();\n        return l;\n    } else if (readIf(\"+\")) {\n        if (currentTokenType != VALUE_NUMBER) {\n            throw getSyntaxError();\n        }\n        return parseExpression();\n    } else {\n        return parsePropertyOrFunction();\n    }\n}", "lc": 0.7727272727272727, "pi": -0.1173469387755102, "ma": 1.3333333333333333, "nbd": 3.0, "ml": 0.8333333333333334, "d": 0.702916460701928, "mi": -0.5153427014625754, "fo": 1.0, "r": -0.028571428571428574, "e": 0.6278883506580836}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-320_c06cc933", "label": 1, "code": "/**\n * Get the pseudo-inverse of the decomposed matrix.\n * @return inverse matrix\n * @throws InvalidMatrixException if decomposed matrix is singular\n */\npublic RealMatrix getInverse() throws InvalidMatrixException {\n    if (!isNonSingular()) {\n        throw new SingularMatrixException();\n    }\n    return solve(MatrixUtils.createRealIdentityMatrix(singularValues.length));\n}", "code_comment": "/**\n * Get the pseudo-inverse of the decomposed matrix.\n * @return inverse matrix\n * @throws InvalidMatrixException if decomposed matrix is singular\n */\n", "code_no_comment": "public RealMatrix getInverse() throws InvalidMatrixException {\n    if (!isNonSingular()) {\n        throw new SingularMatrixException();\n    }\n    return solve(MatrixUtils.createRealIdentityMatrix(singularValues.length));\n}", "lc": -0.36363636363636365, "pi": -0.13775510204081634, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.25, "d": -0.3806228373702422, "mi": 0.6139948379696014, "fo": -0.25, "r": 2.7714285714285714, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8584_dd0f74c0", "label": 1, "code": "private boolean rejectExchange(final Exchange exchange, final AsyncCallback callback) {\n    exchange.setException(new RejectedExecutionException(\"CircuitBreaker Open: failures: \" + failures + \", lastFailure: \" + lastFailure));\n    /*\n         * If the circuit opens, we have to prevent the execution of any\n         * processor. The failures count can be set to 0.\n         */\n    failures.set(0);\n    callback.done(true);\n    return true;\n}", "code_comment": NaN, "code_no_comment": "private boolean rejectExchange(final Exchange exchange, final AsyncCallback callback) {\n    exchange.setException(new RejectedExecutionException(\"CircuitBreaker Open: failures: \" + failures + \", lastFailure: \" + lastFailure));\n        failures.set(0);\n    callback.done(true);\n    return true;\n}", "lc": -0.36363636363636365, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.5242328649268714, "fo": -0.25, "r": 1.342857142857143, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1959_93c1aa40", "label": 1, "code": "@Override\n@Nonnull\npublic NodeState processCommit(NodeState before, NodeState after, CommitInfo info) throws CommitFailedException {\n    // check for concurrent updates by this async task\n    NodeState async = before.getChildNode(ASYNC);\n    if (Objects.equal(checkpoint, async.getString(name)) && lease == async.getLong(name + \"-lease\")) {\n        return after;\n    } else {\n        throw CONCURRENT_UPDATE;\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\n@Nonnull\npublic NodeState processCommit(NodeState before, NodeState after, CommitInfo info) throws CommitFailedException {\n        NodeState async = before.getChildNode(ASYNC);\n    if (Objects.equal(checkpoint, async.getString(name)) && lease == async.getLong(name + \"-lease\")) {\n        return after;\n    } else {\n        throw CONCURRENT_UPDATE;\n    }\n}", "lc": -0.18181818181818182, "pi": -0.015306122448979493, "ma": -0.16666666666666666, "nbd": -0.5, "ml": 0.25, "d": 0.15916955017301043, "mi": 0.18095784341841137, "fo": -0.16666666666666666, "r": 0.05714285714285714, "e": 0.022451505689970497}
{"project_name": "Closure", "project_version": 138, "label": 2, "code": "@Override\npublic FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {\n    if (condition.getType() == CALL && condition.getChildCount() == 2) {\n        Node callee = condition.getFirstChild();\n        Node param = condition.getLastChild();\n        if (callee.getType() == GETPROP && param.isQualifiedName()) {\n            JSType paramType = getTypeIfRefinable(param, blindScope);\n            if (paramType != null) {\n                Node left = callee.getFirstChild();\n                Node right = callee.getLastChild();\n                if (left.getType() == NAME && \"goog\".equals(left.getString()) && right.getType() == STRING) {\n                    Function<TypeRestriction, JSType> restricter = restricters.get(right.getString());\n                    if (restricter != null) {\n                        return restrictParameter(param, paramType, blindScope, restricter, outcome);\n                    }\n                }\n            }\n        }\n    }\n    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {\n    if (condition.getType() == CALL && condition.getChildCount() == 2) {\n        Node callee = condition.getFirstChild();\n        Node param = condition.getLastChild();\n        if (callee.getType() == GETPROP && param.isQualifiedName()) {\n            JSType paramType = getTypeIfRefinable(param, blindScope);\n            if (paramType != null) {\n                Node left = callee.getFirstChild();\n                Node right = callee.getLastChild();\n                if (left.getType() == NAME && \"goog\".equals(left.getString()) && right.getType() == STRING) {\n                    Function<TypeRestriction, JSType> restricter = restricters.get(right.getString());\n                    if (restricter != null) {\n                        return restrictParameter(param, paramType, blindScope, restricter, outcome);\n                    }\n                }\n            }\n        }\n    }\n    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);\n}", "lc": 0.3181818181818182, "pi": 2.086734693877551, "ma": 0.3333333333333333, "nbd": 1.5, "ml": 1.1666666666666667, "d": 0.4221453287197232, "mi": -0.34700315457413283, "fo": 0.9166666666666666, "r": -0.028571428571428574, "e": 0.6677459836132276}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2707_3e233a38", "label": 1, "code": "@SuppressWarnings(\"unchecked\")\n@Override\npublic <S, C extends Serializable> OperatorState<S> getOperatorState(String name, S defaultState, boolean partitioned, StateCheckpointer<S, C> checkpointer) throws IOException {\n    if (defaultState == null) {\n        throw new RuntimeException(\"Cannot set default state to null.\");\n    }\n    StreamOperatorState<S, C> state = (StreamOperatorState<S, C>) getState(name, partitioned);\n    state.setDefaultState(defaultState);\n    state.setCheckpointer(checkpointer);\n    return (OperatorState<S>) state;\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings(\"unchecked\")\n@Override\npublic <S, C extends Serializable> OperatorState<S> getOperatorState(String name, S defaultState, boolean partitioned, StateCheckpointer<S, C> checkpointer) throws IOException {\n    if (defaultState == null) {\n        throw new RuntimeException(\"Cannot set default state to null.\");\n    }\n    StreamOperatorState<S, C> state = (StreamOperatorState<S, C>) getState(name, partitioned);\n    state.setDefaultState(defaultState);\n    state.setCheckpointer(checkpointer);\n    return (OperatorState<S>) state;\n}", "lc": -0.13636363636363635, "pi": -0.2806122448979591, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.25, "d": -0.026693030153237728, "mi": 0.0949240034413537, "fo": -0.25, "r": -0.028571428571428574, "e": -0.0019145026790188368}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2713_63d9800e", "label": 1, "code": "public StateHandle<Serializable> snapshotState(long checkpointId, long checkpointTimestamp) throws Exception {\n    return provider.createStateHandle(checkpointer.snapshotState(value(), checkpointId, checkpointTimestamp));\n}", "code_comment": NaN, "code_no_comment": "public StateHandle<Serializable> snapshotState(long checkpointId, long checkpointTimestamp) throws Exception {\n    return provider.createStateHandle(checkpointer.snapshotState(value(), checkpointId, checkpointTimestamp));\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9317464869515348, "fo": -0.25, "r": 0.0, "e": -0.16422749602751402}
{"project_name": "Compress", "project_version": 43, "label": 3, "code": "private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    // At crc offset\n    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}", "code_comment": NaN, "code_no_comment": "private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}", "lc": -0.045454545454545456, "pi": -0.5714285714285715, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.06228373702422141, "mi": -0.025810151993117463, "fo": 0.4166666666666667, "r": -0.028571428571428574, "e": 0.03960921873728484}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-843_65390f8c", "label": 3, "code": "@Override\npublic void compact(String tableName, Text start, Text end, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException {\n    throw new NotImplementedException();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void compact(String tableName, Text start, Text end, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException {\n    throw new NotImplementedException();\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.3333333333333333, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7668482936621739, "fo": -0.5, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-412_be2fdba7", "label": 1, "code": "/**\n * Iterates over the source until an acceptable key/value pair is found.\n */\nprotected void findTop() {\n    while (getSource().hasTop() && (negate == accept(getSource().getTopKey(), getSource().getTopValue()))) {\n        try {\n            getSource().next();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}", "code_comment": "/**\n * Iterates over the source until an acceptable key/value pair is found.\n */\n", "code_no_comment": "protected void findTop() {\n    while (getSource().hasTop() && (negate == accept(getSource().getTopKey(), getSource().getTopValue()))) {\n        try {\n            getSource().next();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}", "lc": -0.22727272727272727, "pi": 0.6326530612244897, "ma": 0.0, "nbd": 0.0, "ml": 0.16666666666666666, "d": -0.11764705882352938, "mi": 0.34958416977344425, "fo": 0.25, "r": 1.4285714285714286, "e": -0.12508940770341057}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-9444_baece126", "label": 1, "code": "@Override\npublic Processor createProcessor(RouteContext routeContext) throws Exception {\n    Processor childProcessor = this.createChildProcessor(routeContext, true);\n    aggregationStrategy = createAggregationStrategy(routeContext);\n    boolean isParallelProcessing = getParallelProcessing() != null && getParallelProcessing();\n    boolean isStreaming = getStreaming() != null && getStreaming();\n    boolean isShareUnitOfWork = getShareUnitOfWork() != null && getShareUnitOfWork();\n    boolean isParallelAggregate = getParallelAggregate() != null && getParallelAggregate();\n    boolean shutdownThreadPool = ProcessorDefinitionHelper.willCreateNewThreadPool(routeContext, this, isParallelProcessing);\n    ExecutorService threadPool = ProcessorDefinitionHelper.getConfiguredExecutorService(routeContext, \"Split\", this, isParallelProcessing);\n    long timeout = getTimeout() != null ? getTimeout() : 0;\n    if (timeout > 0 && !isParallelProcessing) {\n        throw new IllegalArgumentException(\"Timeout is used but ParallelProcessing has not been enabled.\");\n    }\n    if (onPrepareRef != null) {\n        onPrepare = CamelContextHelper.mandatoryLookup(routeContext.getCamelContext(), onPrepareRef, Processor.class);\n    }\n    Expression exp = getExpression().createExpression(routeContext);\n    Splitter answer = new Splitter(routeContext.getCamelContext(), exp, childProcessor, aggregationStrategy, isParallelProcessing, threadPool, shutdownThreadPool, isStreaming, isStopOnException(), timeout, onPrepare, isShareUnitOfWork, isParallelAggregate);\n    return answer;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Processor createProcessor(RouteContext routeContext) throws Exception {\n    Processor childProcessor = this.createChildProcessor(routeContext, true);\n    aggregationStrategy = createAggregationStrategy(routeContext);\n    boolean isParallelProcessing = getParallelProcessing() != null && getParallelProcessing();\n    boolean isStreaming = getStreaming() != null && getStreaming();\n    boolean isShareUnitOfWork = getShareUnitOfWork() != null && getShareUnitOfWork();\n    boolean isParallelAggregate = getParallelAggregate() != null && getParallelAggregate();\n    boolean shutdownThreadPool = ProcessorDefinitionHelper.willCreateNewThreadPool(routeContext, this, isParallelProcessing);\n    ExecutorService threadPool = ProcessorDefinitionHelper.getConfiguredExecutorService(routeContext, \"Split\", this, isParallelProcessing);\n    long timeout = getTimeout() != null ? getTimeout() : 0;\n    if (timeout > 0 && !isParallelProcessing) {\n        throw new IllegalArgumentException(\"Timeout is used but ParallelProcessing has not been enabled.\");\n    }\n    if (onPrepareRef != null) {\n        onPrepare = CamelContextHelper.mandatoryLookup(routeContext.getCamelContext(), onPrepareRef, Processor.class);\n    }\n    Expression exp = getExpression().createExpression(routeContext);\n    Splitter answer = new Splitter(routeContext.getCamelContext(), exp, childProcessor, aggregationStrategy, isParallelProcessing, threadPool, shutdownThreadPool, isStreaming, isStopOnException(), timeout, onPrepare, isShareUnitOfWork, isParallelAggregate);\n    return answer;\n}", "lc": 0.3181818181818182, "pi": -0.5510204081632654, "ma": 0.16666666666666666, "nbd": -0.5, "ml": 0.25, "d": 0.3667820069204153, "mi": -0.37912245483223406, "fo": 1.1666666666666667, "r": -0.028571428571428574, "e": 0.8402825069277586}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1648_fdc54465", "label": 3, "code": "public Revision create(long lifetimeInMillis, Map<String, String> info) {\n    Revision r = nodeStore.getHeadRevision();\n    createCounter.getAndIncrement();\n    performCleanupIfRequired();\n    UpdateOp op = new UpdateOp(ID, false);\n    long endTime = BigInteger.valueOf(nodeStore.getClock().getTime()).add(BigInteger.valueOf(lifetimeInMillis)).min(BigInteger.valueOf(Long.MAX_VALUE)).longValue();\n    op.setMapEntry(PROP_CHECKPOINT, r, new Info(endTime, info).toString());\n    store.createOrUpdate(Collection.SETTINGS, op);\n    return r;\n}", "code_comment": NaN, "code_no_comment": "public Revision create(long lifetimeInMillis, Map<String, String> info) {\n    Revision r = nodeStore.getHeadRevision();\n    createCounter.getAndIncrement();\n    performCleanupIfRequired();\n    UpdateOp op = new UpdateOp(ID, false);\n    long endTime = BigInteger.valueOf(nodeStore.getClock().getTime()).add(BigInteger.valueOf(lifetimeInMillis)).min(BigInteger.valueOf(Long.MAX_VALUE)).longValue();\n    op.setMapEntry(PROP_CHECKPOINT, r, new Info(endTime, info).toString());\n    store.createOrUpdate(Collection.SETTINGS, op);\n    return r;\n}", "lc": -0.18181818181818182, "pi": -0.7244897959183674, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.11385144823630627, "fo": 0.6666666666666666, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-843_65390f8c", "label": 3, "code": "@Override\npublic void clearLocatorCache(String tableName) throws TableNotFoundException {\n    throw new NotImplementedException();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void clearLocatorCache(String tableName) throws TableNotFoundException {\n    throw new NotImplementedException();\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.3333333333333333, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9260108976197304, "fo": -0.5, "r": 2.142857142857143, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3897_94c6c575", "label": 1, "code": "@Override\npublic boolean childNodeAdded(String name, NodeState after) {\n    String p = PathUtils.concat(path, name);\n    ResetDiff diff = new ResetDiff(revision, p, operations);\n    UpdateOp op = diff.getUpdateOp();\n    NodeDocument.removeDeleted(op, revision);\n    return after.compareAgainstBaseState(EMPTY_NODE, diff);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean childNodeAdded(String name, NodeState after) {\n    String p = PathUtils.concat(path, name);\n    ResetDiff diff = new ResetDiff(revision, p, operations);\n    UpdateOp op = diff.getUpdateOp();\n    NodeDocument.removeDeleted(op, revision);\n    return after.compareAgainstBaseState(EMPTY_NODE, diff);\n}", "lc": -0.2727272727272727, "pi": -0.5510204081632654, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.30369945511901364, "fo": -0.16666666666666666, "r": 0.0, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5071_a2f848f2", "label": 1, "code": "/**\n *  @see org.apache.wicket.request.IRequestMapper#mapRequest(org.apache.wicket.request.Request)\n */\n@Override\npublic IRequestHandler mapRequest(Request request) {\n    Url url = request.getUrl();\n    if (matches(url)) {\n        PageComponentInfo info = getPageComponentInfo(url);\n        if (info != null && info.getPageInfo().getPageId() != null) {\n            Integer renderCount = info.getComponentInfo() != null ? info.getComponentInfo().getRenderCount() : null;\n            if (info.getComponentInfo() == null) {\n                PageProvider provider = new PageProvider(info.getPageInfo().getPageId(), renderCount);\n                provider.setPageSource(getContext());\n                // render page\n                return new RenderPageRequestHandler(provider);\n            } else {\n                ComponentInfo componentInfo = info.getComponentInfo();\n                PageAndComponentProvider provider = new PageAndComponentProvider(info.getPageInfo().getPageId(), renderCount, componentInfo.getComponentPath());\n                provider.setPageSource(getContext());\n                // listener interface\n                RequestListenerInterface listenerInterface = requestListenerInterfaceFromString(componentInfo.getListenerInterface());\n                return new ListenerInterfaceRequestHandler(provider, listenerInterface, componentInfo.getBehaviorId());\n            }\n        }\n    }\n    return null;\n}", "code_comment": "/**\n *  @see org.apache.wicket.request.IRequestMapper#mapRequest(org.apache.wicket.request.Request)\n */\n", "code_no_comment": "@Override\npublic IRequestHandler mapRequest(Request request) {\n    Url url = request.getUrl();\n    if (matches(url)) {\n        PageComponentInfo info = getPageComponentInfo(url);\n        if (info != null && info.getPageInfo().getPageId() != null) {\n            Integer renderCount = info.getComponentInfo() != null ? info.getComponentInfo().getRenderCount() : null;\n            if (info.getComponentInfo() == null) {\n                PageProvider provider = new PageProvider(info.getPageInfo().getPageId(), renderCount);\n                provider.setPageSource(getContext());\n                                return new RenderPageRequestHandler(provider);\n            } else {\n                ComponentInfo componentInfo = info.getComponentInfo();\n                PageAndComponentProvider provider = new PageAndComponentProvider(info.getPageInfo().getPageId(), renderCount, componentInfo.getComponentPath());\n                provider.setPageSource(getContext());\n                                RequestListenerInterface listenerInterface = requestListenerInterfaceFromString(componentInfo.getListenerInterface());\n                return new ListenerInterfaceRequestHandler(provider, listenerInterface, componentInfo.getBehaviorId());\n            }\n        }\n    }\n    return null;\n}", "lc": 0.36363636363636365, "pi": 1.4540816326530612, "ma": 0.16666666666666666, "nbd": 0.5, "ml": 0.4166666666666667, "d": 0.44389520514088, "mi": -0.3524519644393464, "fo": 1.3333333333333333, "r": -0.028571428571428574, "e": 0.6384288229020777}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-618_2123f780", "label": 1, "code": "/**\n * Return the sum of this complex number and the given complex number.\n * <p>\n * Uses the definitional formula\n * <pre>\n * (a + bi) + (c + di) = (a+c) + (b+d)i\n * </pre></p>\n * <p>\n * If either this or <code>rhs</code> has a NaN value in either part,\n * {@link #NaN} is returned; otherwise Infinite and NaN values are\n * returned in the parts of the result according to the rules for\n * {@link java.lang.Double} arithmetic.</p>\n *\n * @param rhs the other complex number\n * @return the complex number sum\n * @throws NullArgumentException if <code>rhs</code> is null\n */\npublic Complex add(Complex rhs) throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n}", "code_comment": "/**\n * Return the sum of this complex number and the given complex number.\n * <p>\n * Uses the definitional formula\n * <pre>\n * (a + bi) + (c + di) = (a+c) + (b+d)i\n * </pre></p>\n * <p>\n * If either this or <code>rhs</code> has a NaN value in either part,\n * {@link #NaN} is returned; otherwise Infinite and NaN values are\n * returned in the parts of the result according to the rules for\n * {@link java.lang.Double} arithmetic.</p>\n *\n * @param rhs the other complex number\n * @return the complex number sum\n * @throws NullArgumentException if <code>rhs</code> is null\n */\n", "code_no_comment": "public Complex add(Complex rhs) throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7505018640665331, "fo": -0.16666666666666666, "r": 1.2571428571428573, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-537_a8493efc", "label": 3, "code": "/**\n * Searches for a given value within this index.\n *\n * @param name the property name\n * @param value the property value (null to check for property existence)\n * @return the set of matched paths\n */\npublic Set<String> find(String name, PropertyValue value) {\n    Set<String> paths = Sets.newHashSet();\n    NodeState state = getIndexDefinitionNode(name);\n    if (state != null && state.getChildNode(\":index\") != null) {\n        state = state.getChildNode(\":index\");\n        if (value == null) {\n            paths.addAll(store.find(state, null));\n        } else {\n            paths.addAll(store.find(state, Property2Index.encode(value)));\n        }\n    } else {\n        // No index available, so first check this node for a match\n        PropertyState property = root.getProperty(name);\n        if (property != null) {\n            if (value == null || value.isArray()) {\n                // let query engine handle property existence and\n                // multi-valued look ups;\n                // simply return all nodes that have this property\n                paths.add(\"\");\n            } else {\n                // does it match any of the values of this property?\n                for (int i = 0; i < property.count(); i++) {\n                    if (property.getValue(value.getType(), i).equals(value.getValue(value.getType()))) {\n                        paths.add(\"\");\n                        // no need to check for more matches in this property\n                        break;\n                    }\n                }\n            }\n        }\n        // ... and then recursively look up from the rest of the tree\n        for (ChildNodeEntry entry : root.getChildNodeEntries()) {\n            String base = entry.getName();\n            Property2IndexLookup lookup = new Property2IndexLookup(entry.getNodeState());\n            for (String path : lookup.find(name, value)) {\n                if (path.isEmpty()) {\n                    paths.add(base);\n                } else {\n                    paths.add(base + \"/\" + path);\n                }\n            }\n        }\n    }\n    return paths;\n}", "code_comment": "/**\n * Searches for a given value within this index.\n *\n * @param name the property name\n * @param value the property value (null to check for property existence)\n * @return the set of matched paths\n */\n", "code_no_comment": "public Set<String> find(String name, PropertyValue value) {\n    Set<String> paths = Sets.newHashSet();\n    NodeState state = getIndexDefinitionNode(name);\n    if (state != null && state.getChildNode(\":index\") != null) {\n        state = state.getChildNode(\":index\");\n        if (value == null) {\n            paths.addAll(store.find(state, null));\n        } else {\n            paths.addAll(store.find(state, Property2Index.encode(value)));\n        }\n    } else {\n                PropertyState property = root.getProperty(name);\n        if (property != null) {\n            if (value == null || value.isArray()) {\n                                                                paths.add(\"\");\n            } else {\n                                for (int i = 0; i < property.count(); i++) {\n                    if (property.getValue(value.getType(), i).equals(value.getValue(value.getType()))) {\n                        paths.add(\"\");\n                                                break;\n                    }\n                }\n            }\n        }\n                for (ChildNodeEntry entry : root.getChildNodeEntries()) {\n            String base = entry.getName();\n            Property2IndexLookup lookup = new Property2IndexLookup(entry.getNodeState());\n            for (String path : lookup.find(name, value)) {\n                if (path.isEmpty()) {\n                    paths.add(base);\n                } else {\n                    paths.add(base + \"/\" + path);\n                }\n            }\n        }\n    }\n    return paths;\n}", "lc": 1.0909090909090908, "pi": 1.5969387755102042, "ma": 1.1666666666666667, "nbd": 1.5, "ml": 1.25, "d": 1.525457241720218, "mi": -0.7123601950100376, "fo": 1.6666666666666667, "r": -0.028571428571428574, "e": 2.7296182558752107}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-492_a759d8ae", "label": 3, "code": "/**\n * Either returns the specified name as is, or returns a quoted value\n * containing the specified name with the special characters (comma, equals,\n * colon, quote, asterisk, or question mark) preceded with a backslash.\n *\n * @param name\n *            the name to escape so it can be used as a value in an\n *            {@link ObjectName}.\n * @return the escaped name\n */\npublic static String escape(final String name) {\n    final StringBuilder sb = new StringBuilder(name.length() * 2);\n    boolean needsQuotes = false;\n    for (int i = 0; i < name.length(); i++) {\n        final char c = name.charAt(i);\n        switch(c) {\n            case ',':\n            case '=':\n            case ':':\n            case '\\\\':\n            case '*':\n            case '?':\n                sb.append('\\\\');\n                needsQuotes = true;\n        }\n        sb.append(c);\n    }\n    if (needsQuotes) {\n        sb.insert(0, '\\\"');\n        sb.append('\\\"');\n    }\n    return sb.toString();\n}", "code_comment": "/**\n * Either returns the specified name as is, or returns a quoted value\n * containing the specified name with the special characters (comma, equals,\n * colon, quote, asterisk, or question mark) preceded with a backslash.\n *\n * @param name\n *            the name to escape so it can be used as a value in an\n *            {@link ObjectName}.\n * @return the escaped name\n */\n", "code_no_comment": "public static String escape(final String name) {\n    final StringBuilder sb = new StringBuilder(name.length() * 2);\n    boolean needsQuotes = false;\n    for (int i = 0; i < name.length(); i++) {\n        final char c = name.charAt(i);\n        switch(c) {\n            case ',':\n            case '=':\n            case ':':\n            case '\\\\':\n            case '*':\n            case '?':\n                sb.append('\\\\');\n                needsQuotes = true;\n        }\n        sb.append(c);\n    }\n    if (needsQuotes) {\n        sb.insert(0, '\\\"');\n        sb.append('\\\"');\n    }\n    return sb.toString();\n}", "lc": 0.4090909090909091, "pi": 0.7500000000000001, "ma": 0.8333333333333334, "nbd": 0.5, "ml": 0.5833333333333334, "d": 0.3786455758774099, "mi": -0.32492113564668773, "fo": 0.16666666666666666, "r": 0.0, "e": 0.28320077436707913}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-43_668f08f2", "label": 1, "code": "void apply() throws Exception {\n    setProperty(nodePath, propName, propValue);\n}", "code_comment": NaN, "code_no_comment": "void apply() throws Exception {\n    setProperty(nodePath, propName, propValue);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.0662460567823349, "fo": -0.4166666666666667, "r": 0.5714285714285714, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-448_999097e1", "label": 1, "code": "@Override\npublic boolean isModified() {\n    if (writeState == null) {\n        return false;\n    } else {\n        NodeState baseState = getBaseState();\n        for (Entry<String, MutableNodeState> n : writeState.nodes.entrySet()) {\n            if (n.getValue() == null) {\n                return true;\n            }\n            if (baseState == null || !baseState.hasChildNode(n.getKey())) {\n                return true;\n            }\n        }\n        for (Entry<String, PropertyState> p : writeState.properties.entrySet()) {\n            PropertyState pState = p.getValue();\n            if (pState == null) {\n                return true;\n            }\n            if (baseState == null || !pState.equals(baseState.getProperty(p.getKey()))) {\n                return true;\n            }\n        }\n        return false;\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean isModified() {\n    if (writeState == null) {\n        return false;\n    } else {\n        NodeState baseState = getBaseState();\n        for (Entry<String, MutableNodeState> n : writeState.nodes.entrySet()) {\n            if (n.getValue() == null) {\n                return true;\n            }\n            if (baseState == null || !baseState.hasChildNode(n.getKey())) {\n                return true;\n            }\n        }\n        for (Entry<String, PropertyState> p : writeState.properties.entrySet()) {\n            PropertyState pState = p.getValue();\n            if (pState == null) {\n                return true;\n            }\n            if (baseState == null || !pState.equals(baseState.getProperty(p.getKey()))) {\n                return true;\n            }\n        }\n        return false;\n    }\n}", "lc": 0.5454545454545454, "pi": 0.9132653061224488, "ma": 0.6666666666666666, "nbd": 0.5, "ml": 0.9166666666666666, "d": 0.42609985170538817, "mi": -0.3903068540292516, "fo": 0.3333333333333333, "r": -0.028571428571428574, "e": 0.36209798655993414}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-290_b01fcc31", "label": 1, "code": "/**\n * Create the tableau by itself.\n * @param maximize if true, goal is to maximize the objective function\n * @return created tableau\n */\nprotected double[][] createTableau(final boolean maximize) {\n    // create a matrix of the correct size\n    List<LinearConstraint> constraints = getNormalizedConstraints();\n    int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() + // + 1 is for RHS\n    1;\n    int height = constraints.size() + getNumObjectiveFunctions();\n    double[][] matrix = new double[height][width];\n    // initialize the objective function rows\n    if (getNumObjectiveFunctions() == 2) {\n        matrix[0][0] = -1;\n    }\n    int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\n    matrix[zIndex][zIndex] = maximize ? 1 : -1;\n    RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\n    copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());\n    matrix[zIndex][width - 1] = maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();\n    if (!restrictToNonNegative) {\n        matrix[zIndex][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(objectiveCoefficients);\n    }\n    // initialize the constraint rows\n    int slackVar = 0;\n    int artificialVar = 0;\n    for (int i = 0; i < constraints.size(); i++) {\n        LinearConstraint constraint = constraints.get(i);\n        int row = getNumObjectiveFunctions() + i;\n        // decision variable coefficients\n        copyArray(constraint.getCoefficients().getData(), matrix[row], 1);\n        // x-\n        if (!restrictToNonNegative) {\n            matrix[row][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(constraint.getCoefficients());\n        }\n        // RHS\n        matrix[row][width - 1] = constraint.getValue();\n        // slack variables\n        if (constraint.getRelationship() == Relationship.LEQ) {\n            // slack\n            matrix[row][getSlackVariableOffset() + slackVar++] = 1;\n        } else if (constraint.getRelationship() == Relationship.GEQ) {\n            // excess\n            matrix[row][getSlackVariableOffset() + slackVar++] = -1;\n        }\n        // artificial variables\n        if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) {\n            matrix[0][getArtificialVariableOffset() + artificialVar] = 1;\n            matrix[row][getArtificialVariableOffset() + artificialVar++] = 1;\n        }\n    }\n    return matrix;\n}", "code_comment": "/**\n * Create the tableau by itself.\n * @param maximize if true, goal is to maximize the objective function\n * @return created tableau\n */\n", "code_no_comment": "protected double[][] createTableau(final boolean maximize) {\n        List<LinearConstraint> constraints = getNormalizedConstraints();\n    int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() +     1;\n    int height = constraints.size() + getNumObjectiveFunctions();\n    double[][] matrix = new double[height][width];\n        if (getNumObjectiveFunctions() == 2) {\n        matrix[0][0] = -1;\n    }\n    int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\n    matrix[zIndex][zIndex] = maximize ? 1 : -1;\n    RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\n    copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());\n    matrix[zIndex][width - 1] = maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();\n    if (!restrictToNonNegative) {\n        matrix[zIndex][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(objectiveCoefficients);\n    }\n        int slackVar = 0;\n    int artificialVar = 0;\n    for (int i = 0; i < constraints.size(); i++) {\n        LinearConstraint constraint = constraints.get(i);\n        int row = getNumObjectiveFunctions() + i;\n                copyArray(constraint.getCoefficients().getData(), matrix[row], 1);\n                if (!restrictToNonNegative) {\n            matrix[row][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(constraint.getCoefficients());\n        }\n                matrix[row][width - 1] = constraint.getValue();\n                if (constraint.getRelationship() == Relationship.LEQ) {\n                        matrix[row][getSlackVariableOffset() + slackVar++] = 1;\n        } else if (constraint.getRelationship() == Relationship.GEQ) {\n                        matrix[row][getSlackVariableOffset() + slackVar++] = -1;\n        }\n                if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) {\n            matrix[0][getArtificialVariableOffset() + artificialVar] = 1;\n            matrix[row][getArtificialVariableOffset() + artificialVar++] = 1;\n        }\n    }\n    return matrix;\n}", "lc": 1.1363636363636365, "pi": 0.051020408163265356, "ma": 1.3333333333333333, "nbd": 0.5, "ml": 1.0833333333333333, "d": 2.2867029164607025, "mi": -0.801261829652997, "fo": 2.3333333333333335, "r": -0.028571428571428574, "e": 6.323349651577645}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "public boolean equals(removeConstraint_result that) {\n    if (that == null)\n        return false;\n    boolean this_present_ouch1 = true && this.isSetOuch1();\n    boolean that_present_ouch1 = true && that.isSetOuch1();\n    if (this_present_ouch1 || that_present_ouch1) {\n        if (!(this_present_ouch1 && that_present_ouch1))\n            return false;\n        if (!this.ouch1.equals(that.ouch1))\n            return false;\n    }\n    boolean this_present_ouch2 = true && this.isSetOuch2();\n    boolean that_present_ouch2 = true && that.isSetOuch2();\n    if (this_present_ouch2 || that_present_ouch2) {\n        if (!(this_present_ouch2 && that_present_ouch2))\n            return false;\n        if (!this.ouch2.equals(that.ouch2))\n            return false;\n    }\n    return true;\n}", "code_comment": NaN, "code_no_comment": "public boolean equals(removeConstraint_result that) {\n    if (that == null)\n        return false;\n    boolean this_present_ouch1 = true && this.isSetOuch1();\n    boolean that_present_ouch1 = true && that.isSetOuch1();\n    if (this_present_ouch1 || that_present_ouch1) {\n        if (!(this_present_ouch1 && that_present_ouch1))\n            return false;\n        if (!this.ouch1.equals(that.ouch1))\n            return false;\n    }\n    boolean this_present_ouch2 = true && this.isSetOuch2();\n    boolean that_present_ouch2 = true && that.isSetOuch2();\n    if (this_present_ouch2 || that_present_ouch2) {\n        if (!(this_present_ouch2 && that_present_ouch2))\n            return false;\n        if (!this.ouch2.equals(that.ouch2))\n            return false;\n    }\n    return true;\n}", "lc": 0.3181818181818182, "pi": 0.3061224489795919, "ma": 0.6666666666666666, "nbd": -0.5, "ml": 1.25, "d": 0.726643598615917, "mi": -0.26641812446228874, "fo": 0.0, "r": -0.028571428571428574, "e": 0.4473725913457626}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-276_1bf5c550", "label": 1, "code": "@Override\npublic boolean markNode(Id id) throws Exception {\n    return touch(id, gcStart);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean markNode(Id id) throws Exception {\n    return touch(id, gcStart);\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8850014338973328, "fo": -0.4166666666666667, "r": 1.9428571428571428, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 134, "label": 2, "code": "/**\n * Adds the node to the sub graph, adding all of its types to the set of\n * types in the sub graph and all of its related types to the related types\n * for the sub graph.\n */\npublic void addNode(Property prop) {\n    typesInSet.or(prop.typesSet);\n    typesRelatedToSet.or(getRelated(prop.type));\n}", "code_comment": "/**\n * Adds the node to the sub graph, adding all of its types to the set of\n * types in the sub graph and all of its related types to the related types\n * for the sub graph.\n */\n", "code_no_comment": "public void addNode(Property prop) {\n    typesInSet.or(prop.typesSet);\n    typesRelatedToSet.or(getRelated(prop.type));\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8150272440493259, "fo": -0.25, "r": 1.4857142857142858, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6447_020c451a", "label": 1, "code": "public boolean process(Exchange exchange, AsyncCallback callback) {\n    Iterator<Processor> processors = next().iterator();\n    exchange.setProperty(Exchange.FILTER_MATCHED, false);\n    while (continueRouting(processors, exchange)) {\n        // get the next processor\n        Processor processor = processors.next();\n        AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);\n        boolean sync = process(exchange, callback, processors, async);\n        // continue as long its being processed synchronously\n        if (!sync) {\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n            // so we break out now, then the callback will be invoked which then continue routing from where we left here\n            return false;\n        }\n        LOG.trace(\"Processing exchangeId: {} is continued being processed synchronously\", exchange.getExchangeId());\n        // check for error if so we should break out\n        if (!continueProcessing(exchange, \"so breaking out of content based router\", LOG)) {\n            break;\n        }\n    }\n    LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n    callback.done(true);\n    return true;\n}", "code_comment": NaN, "code_no_comment": "public boolean process(Exchange exchange, AsyncCallback callback) {\n    Iterator<Processor> processors = next().iterator();\n    exchange.setProperty(Exchange.FILTER_MATCHED, false);\n    while (continueRouting(processors, exchange)) {\n                Processor processor = processors.next();\n        AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);\n        boolean sync = process(exchange, callback, processors, async);\n                if (!sync) {\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n                        return false;\n        }\n        LOG.trace(\"Processing exchangeId: {} is continued being processed synchronously\", exchange.getExchangeId());\n                if (!continueProcessing(exchange, \"so breaking out of content based router\", LOG)) {\n            break;\n        }\n    }\n    LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n    callback.done(true);\n    return true;\n}", "lc": 0.2727272727272727, "pi": 0.21428571428571425, "ma": 0.16666666666666666, "nbd": 0.0, "ml": 0.25, "d": 0.0029658922392486655, "mi": -0.2635503297963866, "fo": 0.75, "r": -0.028571428571428574, "e": 0.11176070001413392}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-358_061f5017", "label": 0, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n        System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\n        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n        rki.reinitialize(this, yTmp, yDotK, forward);\n        interpolator = rki;\n    } else {\n        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n    // set up integration control objects\n    stepStart = t0;\n    double hNew = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n    // main integration loop\n    while (!lastStep) {\n        interpolator.shift();\n        double error = 0;\n        for (boolean loop = true; loop; ) {\n            if (firstTime || !fsal) {\n                // first stage\n                computeDerivatives(stepStart, y, yDotK[0]);\n            }\n            if (firstTime) {\n                final double[] scale = new double[y0.length];\n                if (vecAbsoluteTolerance == null) {\n                    for (int i = 0; i < scale.length; ++i) {\n                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n                    }\n                } else {\n                    for (int i = 0; i < scale.length; ++i) {\n                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n                    }\n                }\n                hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);\n                firstTime = false;\n            }\n            stepSize = hNew;\n            // next stages\n            for (int k = 1; k < stages; ++k) {\n                for (int j = 0; j < y0.length; ++j) {\n                    double sum = a[k - 1][0] * yDotK[0][j];\n                    for (int l = 1; l < k; ++l) {\n                        sum += a[k - 1][l] * yDotK[l][j];\n                    }\n                    yTmp[j] = y[j] + stepSize * sum;\n                }\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n            }\n            // estimate the state at the end of the step\n            for (int j = 0; j < y0.length; ++j) {\n                double sum = b[0] * yDotK[0][j];\n                for (int l = 1; l < stages; ++l) {\n                    sum += b[l] * yDotK[l][j];\n                }\n                yTmp[j] = y[j] + stepSize * sum;\n            }\n            // estimate the error at the end of the step\n            error = estimateError(yDotK, y, yTmp, stepSize);\n            if (error <= 1.0) {\n                // discrete events handling\n                interpolator.storeTime(stepStart + stepSize);\n                if (manager.evaluateStep(interpolator)) {\n                    final double dt = manager.getEventTime() - stepStart;\n                    if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                        // rejecting the step would lead to a too small next step, we accept it\n                        loop = false;\n                    } else {\n                        // reject the step to match exactly the next switch time\n                        hNew = dt;\n                    }\n                } else {\n                    // accept the step\n                    loop = false;\n                }\n            } else {\n                // reject the step and attempt to reduce error by stepsize control\n                final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\n                hNew = filterStep(stepSize * factor, forward, false);\n            }\n        }\n        // the step has been accepted\n        final double nextStep = stepStart + stepSize;\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\n        manager.stepAccepted(nextStep, y);\n        lastStep = manager.stop();\n        // provide the step data to the step handler\n        interpolator.storeTime(nextStep);\n        for (StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, lastStep);\n        }\n        stepStart = nextStep;\n        if (fsal) {\n            // save the last evaluation for the next step\n            System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n        }\n        if (manager.reset(stepStart, y) && !lastStep) {\n            // some event handler has triggered changes that\n            // invalidate the derivatives, we need to recompute them\n            computeDerivatives(stepStart, y, yDotK[0]);\n        }\n        if (!lastStep) {\n            // in some rare cases we may get here with stepSize = 0, for example\n            // when an event occurs at integration start, reducing the first step\n            // to zero; we have to reset the step to some safe non zero value\n            stepSize = filterStep(stepSize, forward, true);\n            // stepsize control for next step\n            final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\n            final double scaledH = stepSize * factor;\n            final double nextT = stepStart + scaledH;\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n            hNew = filterStep(scaledH, forward, nextIsLast);\n        }\n    }\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n        final int stages = c.length + 1;\n    if (y != y0) {\n        System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n        AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\n        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n        rki.reinitialize(this, yTmp, yDotK, forward);\n        interpolator = rki;\n    } else {\n        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n        stepStart = t0;\n    double hNew = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n        while (!lastStep) {\n        interpolator.shift();\n        double error = 0;\n        for (boolean loop = true; loop; ) {\n            if (firstTime || !fsal) {\n                                computeDerivatives(stepStart, y, yDotK[0]);\n            }\n            if (firstTime) {\n                final double[] scale = new double[y0.length];\n                if (vecAbsoluteTolerance == null) {\n                    for (int i = 0; i < scale.length; ++i) {\n                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n                    }\n                } else {\n                    for (int i = 0; i < scale.length; ++i) {\n                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n                    }\n                }\n                hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);\n                firstTime = false;\n            }\n            stepSize = hNew;\n                        for (int k = 1; k < stages; ++k) {\n                for (int j = 0; j < y0.length; ++j) {\n                    double sum = a[k - 1][0] * yDotK[0][j];\n                    for (int l = 1; l < k; ++l) {\n                        sum += a[k - 1][l] * yDotK[l][j];\n                    }\n                    yTmp[j] = y[j] + stepSize * sum;\n                }\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n            }\n                        for (int j = 0; j < y0.length; ++j) {\n                double sum = b[0] * yDotK[0][j];\n                for (int l = 1; l < stages; ++l) {\n                    sum += b[l] * yDotK[l][j];\n                }\n                yTmp[j] = y[j] + stepSize * sum;\n            }\n                        error = estimateError(yDotK, y, yTmp, stepSize);\n            if (error <= 1.0) {\n                                interpolator.storeTime(stepStart + stepSize);\n                if (manager.evaluateStep(interpolator)) {\n                    final double dt = manager.getEventTime() - stepStart;\n                    if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                                                loop = false;\n                    } else {\n                                                hNew = dt;\n                    }\n                } else {\n                                        loop = false;\n                }\n            } else {\n                                final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\n                hNew = filterStep(stepSize * factor, forward, false);\n            }\n        }\n                final double nextStep = stepStart + stepSize;\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\n        manager.stepAccepted(nextStep, y);\n        lastStep = manager.stop();\n                interpolator.storeTime(nextStep);\n        for (StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, lastStep);\n        }\n        stepStart = nextStep;\n        if (fsal) {\n                        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n        }\n        if (manager.reset(stepStart, y) && !lastStep) {\n                                    computeDerivatives(stepStart, y, yDotK[0]);\n        }\n        if (!lastStep) {\n                                                stepSize = filterStep(stepSize, forward, true);\n                        final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\n            final double scaledH = stepSize * factor;\n            final double nextT = stepStart + scaledH;\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n            hNew = filterStep(scaledH, forward, nextIsLast);\n        }\n    }\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n}", "lc": 4.545454545454546, "pi": 1.6122448979591835, "ma": 3.3333333333333335, "nbd": 1.5, "ml": 3.6666666666666665, "d": 5.011369253583787, "mi": -1.537998279323201, "fo": 3.0, "r": -0.028571428571428574, "e": 38.00769655774988}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2359_b3071839", "label": 0, "code": "@Override\npublic boolean containsKey(Object key) {\n    // the values map does not have null values\n    return get(key) != null;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean containsKey(Object key) {\n        return get(key) != null;\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8850014338973328, "fo": -0.4166666666666667, "r": 2.7714285714285714, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1348_ef0f6ddc", "label": 1, "code": "public int start() throws IOException {\n    if (configError)\n        return 1;\n    String input;\n    if (isVerbose())\n        printInfo();\n    if (execFile != null) {\n        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));\n        while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());\n    } else if (execCommand != null) {\n        for (String command : execCommand.split(\"\\n\")) {\n            execCommand(command, true, isVerbose());\n        }\n        return exitCode;\n    }\n    while (true) {\n        if (hasExited())\n            return exitCode;\n        reader.setDefaultPrompt(getDefaultPrompt());\n        input = reader.readLine();\n        if (input == null) {\n            reader.printNewline();\n            return exitCode;\n        }\n        // user canceled\n        execCommand(input, false, false);\n    }\n}", "code_comment": NaN, "code_no_comment": "public int start() throws IOException {\n    if (configError)\n        return 1;\n    String input;\n    if (isVerbose())\n        printInfo();\n    if (execFile != null) {\n        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));\n        while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());\n    } else if (execCommand != null) {\n        for (String command : execCommand.split(\"\\n\")) {\n            execCommand(command, true, isVerbose());\n        }\n        return exitCode;\n    }\n    while (true) {\n        if (hasExited())\n            return exitCode;\n        reader.setDefaultPrompt(getDefaultPrompt());\n        input = reader.readLine();\n        if (input == null) {\n            reader.printNewline();\n            return exitCode;\n        }\n                execCommand(input, false, false);\n    }\n}", "lc": 0.5909090909090909, "pi": 0.10714285714285712, "ma": 1.0, "nbd": 0.5, "ml": 0.8333333333333334, "d": -0.01680672268907558, "mi": -0.4278749641525668, "fo": 0.75, "r": -0.028571428571428574, "e": 0.08417387282048648}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4", "label": 1, "code": "private final Component<?> children_get(int index) {\n    if (index == 0) {\n        if (children instanceof Component) {\n            return (Component) children;\n        } else {\n            return ((Component[]) children)[index];\n        }\n    } else {\n        return ((Component[]) children)[index];\n    }\n}", "code_comment": NaN, "code_no_comment": "private final Component<?> children_get(int index) {\n    if (index == 0) {\n        if (children instanceof Component) {\n            return (Component) children;\n        } else {\n            return ((Component[]) children)[index];\n        }\n    } else {\n        return ((Component[]) children)[index];\n    }\n}", "lc": -0.13636363636363635, "pi": 0.47448979591836743, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.3806228373702422, "mi": 0.3168913105821623, "fo": -0.5, "r": 0.7428571428571429, "e": -0.16422749602751402}
{"project_name": "Math", "project_version": 68, "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\nprotected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n    // arrays shared with the other private methods\n    solvedCols = Math.min(rows, cols);\n    diagR = new double[cols];\n    jacNorm = new double[cols];\n    beta = new double[cols];\n    permutation = new int[cols];\n    lmDir = new double[cols];\n    // local point\n    double delta = 0;\n    double xNorm = 0;\n    double[] diag = new double[cols];\n    double[] oldX = new double[cols];\n    double[] oldRes = new double[rows];\n    double[] work1 = new double[cols];\n    double[] work2 = new double[cols];\n    double[] work3 = new double[cols];\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    while (true) {\n        incrementIterationsCounter();\n        // compute the Q.R. decomposition of the jacobian matrix\n        updateJacobian();\n        qrDecomposition();\n        // compute Qt.res\n        qTy(residuals);\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n        if (firstIteration) {\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n        }\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return new VectorialPointValuePair(point, objective);\n        }\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4; ) {\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes = tmpVec;\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                    tmp = 0.1;\n                }\n                delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec = residuals;\n                residuals = oldRes;\n                oldRes = tmpVec;\n            }\n            // we use the Levenberg-Marquardt specific convergence parameters\n            if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) {\n                return new VectorialPointValuePair(point, objective);\n            }\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" + \" no further reduction in the\" + \" sum of squares is possible\", costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(\"parameters relative tolerance is too small\" + \" ({0}), no further improvement in\" + \" the approximate solution is possible\", parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16) {\n                throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" + \" solution is orthogonal to the jacobian\", orthoTolerance);\n            }\n        }\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\nprotected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n        solvedCols = Math.min(rows, cols);\n    diagR = new double[cols];\n    jacNorm = new double[cols];\n    beta = new double[cols];\n    permutation = new int[cols];\n    lmDir = new double[cols];\n        double delta = 0;\n    double xNorm = 0;\n    double[] diag = new double[cols];\n    double[] oldX = new double[cols];\n    double[] oldRes = new double[rows];\n    double[] work1 = new double[cols];\n    double[] work2 = new double[cols];\n    double[] work3 = new double[cols];\n        updateResidualsAndCost();\n        lmPar = 0;\n    boolean firstIteration = true;\n    while (true) {\n        incrementIterationsCounter();\n                updateJacobian();\n        qrDecomposition();\n                qTy(residuals);\n                for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n        if (firstIteration) {\n                                    xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n                        delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n        }\n                double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n                        return new VectorialPointValuePair(point, objective);\n        }\n                for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n                for (double ratio = 0; ratio < 1.0e-4; ) {\n                        for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes = tmpVec;\n                        determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n                        double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n                        if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n                        updateResidualsAndCost();\n                        double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n                        for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n                        ratio = (preRed == 0) ? 0 : (actRed / preRed);\n                        if (ratio <= 0.25) {\n                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                    tmp = 0.1;\n                }\n                delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n                        if (ratio >= 1.0e-4) {\n                                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n            } else {\n                                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec = residuals;\n                residuals = oldRes;\n                oldRes = tmpVec;\n            }\n                        if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) {\n                return new VectorialPointValuePair(point, objective);\n            }\n                        if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" + \" no further reduction in the\" + \" sum of squares is possible\", costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(\"parameters relative tolerance is too small\" + \" ({0}), no further improvement in\" + \" the approximate solution is possible\", parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16) {\n                throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" + \" solution is orthogonal to the jacobian\", orthoTolerance);\n            }\n        }\n    }\n}", "lc": 6.181818181818182, "pi": 0.933673469387755, "ma": 5.333333333333333, "nbd": 1.5, "ml": 4.666666666666667, "d": 6.949085516559567, "mi": -1.776885574992831, "fo": 1.0, "r": -0.028571428571428574, "e": 64.24234091853299}
{"project_name": "Closure", "project_version": 54, "label": 2, "code": "/**\n * Sets the prototype, creating the prototype object from the given\n * base type.\n * @param baseType The base type.\n */\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n}", "code_comment": "/**\n * Sets the prototype, creating the prototype object from the given\n * base type.\n * @param baseType The base type.\n */\n", "code_no_comment": "public void setPrototypeBasedOn(ObjectType baseType) {\n        if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n}", "lc": -0.36363636363636365, "pi": -0.13775510204081634, "ma": -0.3333333333333333, "nbd": -0.5, "ml": 0.4166666666666667, "d": 0.2876915472071182, "mi": 0.4858044164037856, "fo": 0.0, "r": 0.05714285714285714, "e": -0.010167850917205259}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-395_e6c31270", "label": 1, "code": "private Property internalSetProperty(final String jcrName, final Value value, final int type, final boolean exactTypeMatch) throws RepositoryException {\n    checkStatus();\n    checkProtected();\n    return sessionDelegate.perform(new SessionOperation<Property>() {\n\n        @Override\n        public Property perform() throws RepositoryException {\n            if (value == null) {\n                Property property = getProperty(jcrName);\n                property.remove();\n                return property;\n            } else {\n                String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n                PropertyDefinition definition;\n                if (hasProperty(jcrName)) {\n                    definition = getProperty(jcrName).getDefinition();\n                } else {\n                    definition = dlg.sessionDelegate.getDefinitionProvider().getDefinition(NodeImpl.this, oakName, false, type, exactTypeMatch);\n                }\n                checkProtected(definition);\n                if (definition.isMultiple()) {\n                    throw new ValueFormatException(\"Cannot set single value to multivalued property\");\n                }\n                int targetType = getTargetType(value, definition);\n                Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());\n                return new PropertyImpl(dlg.setProperty(oakName, targetValue));\n            }\n        }\n    });\n}", "code_comment": NaN, "code_no_comment": "private Property internalSetProperty(final String jcrName, final Value value, final int type, final boolean exactTypeMatch) throws RepositoryException {\n    checkStatus();\n    checkProtected();\n    return sessionDelegate.perform(new SessionOperation<Property>() {\n\n        @Override\n        public Property perform() throws RepositoryException {\n            if (value == null) {\n                Property property = getProperty(jcrName);\n                property.remove();\n                return property;\n            } else {\n                String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n                PropertyDefinition definition;\n                if (hasProperty(jcrName)) {\n                    definition = getProperty(jcrName).getDefinition();\n                } else {\n                    definition = dlg.sessionDelegate.getDefinitionProvider().getDefinition(NodeImpl.this, oakName, false, type, exactTypeMatch);\n                }\n                checkProtected(definition);\n                if (definition.isMultiple()) {\n                    throw new ValueFormatException(\"Cannot set single value to multivalued property\");\n                }\n                int targetType = getTargetType(value, definition);\n                Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());\n                return new PropertyImpl(dlg.setProperty(oakName, targetValue));\n            }\n        }\n    });\n}", "lc": 0.6818181818181818, "pi": 1.4591836734693877, "ma": 0.16666666666666666, "nbd": 0.5, "ml": 0.16666666666666666, "d": -0.0247157686604053, "mi": -0.47777459133926015, "fo": 0.9166666666666666, "r": -0.028571428571428574, "e": 0.17553890894762314}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-705_645d642b", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {\n    sanityChecks(equations, t);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > equations.getTime();\n    // create some internal working arrays\n    final double[] y0 = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][y.length];\n    final double[] yTmp = new double[y.length];\n    final double[] yDotTmp = new double[y.length];\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n    // set up integration control objects\n    stepStart = equations.getTime();\n    double hNew = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    setStateInitialized(false);\n    // main integration loop\n    isLastStep = false;\n    do {\n        interpolator.shift();\n        // iterate over step size, ensuring local normalized error is smaller than 1\n        double error = 10;\n        while (error >= 1.0) {\n            if (firstTime || !fsal) {\n                // first stage\n                computeDerivatives(stepStart, y, yDotK[0]);\n            }\n            if (firstTime) {\n                final double[] scale = new double[mainSetDimension];\n                if (vecAbsoluteTolerance == null) {\n                    for (int i = 0; i < scale.length; ++i) {\n                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n                    }\n                } else {\n                    for (int i = 0; i < scale.length; ++i) {\n                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n                    }\n                }\n                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);\n                firstTime = false;\n            }\n            stepSize = hNew;\n            // next stages\n            for (int k = 1; k < stages; ++k) {\n                for (int j = 0; j < y0.length; ++j) {\n                    double sum = a[k - 1][0] * yDotK[0][j];\n                    for (int l = 1; l < k; ++l) {\n                        sum += a[k - 1][l] * yDotK[l][j];\n                    }\n                    yTmp[j] = y[j] + stepSize * sum;\n                }\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n            }\n            // estimate the state at the end of the step\n            for (int j = 0; j < y0.length; ++j) {\n                double sum = b[0] * yDotK[0][j];\n                for (int l = 1; l < stages; ++l) {\n                    sum += b[l] * yDotK[l][j];\n                }\n                yTmp[j] = y[j] + stepSize * sum;\n            }\n            // estimate the error at the end of the step\n            error = estimateError(yDotK, y, yTmp, stepSize);\n            if (error >= 1.0) {\n                // reject the step and attempt to reduce error by stepsize control\n                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n                hNew = filterStep(stepSize * factor, forward, false);\n            }\n        }\n        // local error is small enough: accept the step, trigger events and step handlers\n        interpolator.storeTime(stepStart + stepSize);\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\n        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n        stepStart = acceptStep(interpolator, y, yDotTmp, t);\n        if (!isLastStep) {\n            // prepare next step\n            interpolator.storeTime(stepStart);\n            if (fsal) {\n                // save the last evaluation for the next step\n                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n            }\n            // stepsize control for next step\n            final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n            final double scaledH = stepSize * factor;\n            final double nextT = stepStart + scaledH;\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n            hNew = filterStep(scaledH, forward, nextIsLast);\n            final double filteredNextT = stepStart + hNew;\n            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n            if (filteredNextIsLast) {\n                hNew = t - stepStart;\n            }\n        }\n    } while (!isLastStep);\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n    resetInternalState();\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {\n    sanityChecks(equations, t);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > equations.getTime();\n        final double[] y0 = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][y.length];\n    final double[] yTmp = new double[y.length];\n    final double[] yDotTmp = new double[y.length];\n        final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n        stepStart = equations.getTime();\n    double hNew = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    setStateInitialized(false);\n        isLastStep = false;\n    do {\n        interpolator.shift();\n                double error = 10;\n        while (error >= 1.0) {\n            if (firstTime || !fsal) {\n                                computeDerivatives(stepStart, y, yDotK[0]);\n            }\n            if (firstTime) {\n                final double[] scale = new double[mainSetDimension];\n                if (vecAbsoluteTolerance == null) {\n                    for (int i = 0; i < scale.length; ++i) {\n                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n                    }\n                } else {\n                    for (int i = 0; i < scale.length; ++i) {\n                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n                    }\n                }\n                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);\n                firstTime = false;\n            }\n            stepSize = hNew;\n                        for (int k = 1; k < stages; ++k) {\n                for (int j = 0; j < y0.length; ++j) {\n                    double sum = a[k - 1][0] * yDotK[0][j];\n                    for (int l = 1; l < k; ++l) {\n                        sum += a[k - 1][l] * yDotK[l][j];\n                    }\n                    yTmp[j] = y[j] + stepSize * sum;\n                }\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n            }\n                        for (int j = 0; j < y0.length; ++j) {\n                double sum = b[0] * yDotK[0][j];\n                for (int l = 1; l < stages; ++l) {\n                    sum += b[l] * yDotK[l][j];\n                }\n                yTmp[j] = y[j] + stepSize * sum;\n            }\n                        error = estimateError(yDotK, y, yTmp, stepSize);\n            if (error >= 1.0) {\n                                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n                hNew = filterStep(stepSize * factor, forward, false);\n            }\n        }\n                interpolator.storeTime(stepStart + stepSize);\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\n        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n        stepStart = acceptStep(interpolator, y, yDotTmp, t);\n        if (!isLastStep) {\n                        interpolator.storeTime(stepStart);\n            if (fsal) {\n                                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n            }\n                        final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n            final double scaledH = stepSize * factor;\n            final double nextT = stepStart + scaledH;\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n            hNew = filterStep(scaledH, forward, nextIsLast);\n            final double filteredNextT = stepStart + hNew;\n            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n            if (filteredNextIsLast) {\n                hNew = t - stepStart;\n            }\n        }\n    } while (!isLastStep);\n        equations.setTime(stepStart);\n    equations.setCompleteState(y);\n    resetInternalState();\n}", "lc": 3.590909090909091, "pi": 1.5408163265306123, "ma": 2.6666666666666665, "nbd": 1.5, "ml": 2.3333333333333335, "d": 3.9693524468610977, "mi": -1.3969027817608264, "fo": 2.8333333333333335, "r": -0.028571428571428574, "e": 26.73859971475195}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7213_336663c9", "label": 1, "code": "@Converter\npublic static ByteBuffer toByteBuffer(Double value) {\n    ByteBuffer buf = ByteBuffer.allocate(8);\n    buf.putDouble(value);\n    return buf;\n}", "code_comment": NaN, "code_no_comment": "@Converter\npublic static ByteBuffer toByteBuffer(Double value) {\n    ByteBuffer buf = ByteBuffer.allocate(8);\n    buf.putDouble(value);\n    return buf;\n}", "lc": -0.36363636363636365, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.5896185833094353, "fo": -0.3333333333333333, "r": 1.2285714285714286, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "public removeConstraint_result getResult(I iface, removeConstraint_args args) throws org.apache.thrift.TException {\n    removeConstraint_result result = new removeConstraint_result();\n    try {\n        iface.removeConstraint(args.login, args.tableName, args.constraint);\n    } catch (AccumuloException ouch1) {\n        result.ouch1 = ouch1;\n    } catch (AccumuloSecurityException ouch2) {\n        result.ouch2 = ouch2;\n    }\n    return result;\n}", "code_comment": NaN, "code_no_comment": "public removeConstraint_result getResult(I iface, removeConstraint_args args) throws org.apache.thrift.TException {\n    removeConstraint_result result = new removeConstraint_result();\n    try {\n        iface.removeConstraint(args.login, args.tableName, args.constraint);\n    } catch (AccumuloException ouch1) {\n        result.ouch1 = ouch1;\n    } catch (AccumuloSecurityException ouch2) {\n        result.ouch2 = ouch2;\n    }\n    return result;\n}", "lc": -0.13636363636363635, "pi": -0.17857142857142863, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.13822770289647246, "fo": -0.4166666666666667, "r": 0.0, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-326_ce185345", "label": 1, "code": "/**\n * {@inheritDoc}\n */\npublic double getL1Norm() {\n    double sum = 0;\n    for (double a : data) {\n        sum += Math.abs(a);\n    }\n    return sum;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public double getL1Norm() {\n    double sum = 0;\n    for (double a : data) {\n        sum += Math.abs(a);\n    }\n    return sum;\n}", "lc": -0.3181818181818182, "pi": -0.2346938775510204, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.10776075135936727, "mi": 0.5486091195870376, "fo": -0.4166666666666667, "r": 2.7714285714285714, "e": -0.1387950197232323}
{"project_name": "Lang", "project_version": 46, "label": 0, "code": "/**\n * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>\n * <p>Escapes any values it finds into their JavaScript String form.\n * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n *\n * <p>So a tab becomes the characters <code>'\\\\'</code> and\n * <code>'t'</code>.</p>\n *\n * <p>The only difference between Java strings and JavaScript strings\n * is that in JavaScript, a single quote must be escaped.</p>\n *\n * <p>Example:\n * <pre>\n * input string: He didn't say, \"Stop!\"\n * output string: He didn\\'t say, \\\"Stop!\\\"\n * </pre>\n * </p>\n *\n * @param str  String to escape values in, may be null\n * @return String with escaped values, <code>null</code> if null string input\n */\npublic static String escapeJavaScript(String str) {\n    return escapeJavaStyleString(str, true);\n}", "code_comment": "/**\n * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>\n * <p>Escapes any values it finds into their JavaScript String form.\n * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n *\n * <p>So a tab becomes the characters <code>'\\\\'</code> and\n * <code>'t'</code>.</p>\n *\n * <p>The only difference between Java strings and JavaScript strings\n * is that in JavaScript, a single quote must be escaped.</p>\n *\n * <p>Example:\n * <pre>\n * input string: He didn't say, \"Stop!\"\n * output string: He didn\\'t say, \\\"Stop!\\\"\n * </pre>\n * </p>\n *\n * @param str  String to escape values in, may be null\n * @return String with escaped values, <code>null</code> if null string input\n */\n", "code_no_comment": "public static String escapeJavaScript(String str) {\n    return escapeJavaStyleString(str, true);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.0585030111843994, "fo": -0.4166666666666667, "r": 0.3428571428571429, "e": -0.16422749602751402}
{"project_name": "JxPath", "project_version": 4, "label": 1, "code": "protected String getLanguage() {\n    Node n = node;\n    while (n != null) {\n        if (n.getNodeType() == Node.ELEMENT_NODE) {\n            Element e = (Element) n;\n            String attr = e.getAttribute(\"xml:lang\");\n            if (attr != null && !attr.equals(\"\")) {\n                return attr;\n            }\n        }\n        n = n.getParentNode();\n    }\n    return null;\n}", "code_comment": NaN, "code_no_comment": "protected String getLanguage() {\n    Node n = node;\n    while (n != null) {\n        if (n.getNodeType() == Node.ELEMENT_NODE) {\n            Element e = (Element) n;\n            String attr = e.getAttribute(\"xml:lang\");\n            if (attr != null && !attr.equals(\"\")) {\n                return attr;\n            }\n        }\n        n = n.getParentNode();\n    }\n    return null;\n}", "lc": 0.0, "pi": 0.8826530612244898, "ma": 0.0, "nbd": 0.5, "ml": 0.25, "d": 0.34107760751359373, "mi": 0.0017206767995412186, "fo": -0.16666666666666666, "r": 1.1142857142857143, "e": 0.11440331333170578}
{"project_name": "Compress", "project_version": 6, "label": 1, "code": "/* (non-Javadoc)\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\npublic boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null || getClass() != obj.getClass()) {\n        return false;\n    }\n    ZipArchiveEntry other = (ZipArchiveEntry) obj;\n    if (name == null) {\n        if (other.name != null) {\n            return false;\n        }\n    } else if (!name.equals(other.name)) {\n        return false;\n    }\n    return true;\n}", "code_comment": NaN, "code_no_comment": "public boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null || getClass() != obj.getClass()) {\n        return false;\n    }\n    ZipArchiveEntry other = (ZipArchiveEntry) obj;\n    if (name == null) {\n        if (other.name != null) {\n            return false;\n        }\n    } else if (!name.equals(other.name)) {\n        return false;\n    }\n    return true;\n}", "lc": 0.13636363636363635, "pi": -0.015306122448979493, "ma": 0.3333333333333333, "nbd": 0.0, "ml": 0.5833333333333334, "d": 0.6258032624814632, "mi": -0.0696874103814169, "fo": -0.25, "r": 1.3142857142857143, "e": 0.1497552263353335}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-3077_17654199", "label": 0, "code": "/**\n * For testing purposes only -- should not be called by server code\n * <p>\n * Allows mocking of a Writer for testing\n *\n * @param creds\n *          Credentials\n * @param writer\n *          A Writer to use for the given credentials\n */\nprotected static synchronized void addWriter(Credentials creds, Writer writer) {\n    writers.put(creds, writer);\n}", "code_comment": "/**\n * For testing purposes only -- should not be called by server code\n * <p>\n * Allows mocking of a Writer for testing\n *\n * @param creds\n *          Credentials\n * @param writer\n *          A Writer to use for the given credentials\n */\n", "code_no_comment": "protected static synchronized void addWriter(Credentials creds, Writer writer) {\n    writers.put(creds, writer);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.003154574132492, "fo": -0.4166666666666667, "r": 2.8000000000000003, "e": -0.16422749602751402}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-5655_96337372", "label": 1, "code": "public void afterExecutionFailure(MojoExecutionEvent event) {\n    for (Object provided : getScopeState().provided.values()) {\n        if (provided instanceof WeakMojoExecutionListener) {\n            ((WeakMojoExecutionListener) provided).afterExecutionFailure(event);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "public void afterExecutionFailure(MojoExecutionEvent event) {\n    for (Object provided : getScopeState().provided.values()) {\n        if (provided instanceof WeakMojoExecutionListener) {\n            ((WeakMojoExecutionListener) provided).afterExecutionFailure(event);\n        }\n    }\n}", "lc": -0.3181818181818182, "pi": 0.5612244897959184, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.25, "d": -0.3806228373702422, "mi": 0.5276742185259534, "fo": -0.25, "r": 0.14285714285714285, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd", "label": 1, "code": "/**\n * search the index for the provided PropertyRestriction\n *\n * @param filter\n * @param indexName\n * @param indexMeta\n * @param pr\n * @return the iterable\n */\npublic Iterable<String> query(final Filter filter, final String indexName, final NodeState indexMeta, final PropertyRestriction pr) {\n    return query(filter, indexName, indexMeta, INDEX_CONTENT_NODE_NAME, pr);\n}", "code_comment": "/**\n * search the index for the provided PropertyRestriction\n *\n * @param filter\n * @param indexName\n * @param indexMeta\n * @param pr\n * @return the iterable\n */\n", "code_no_comment": "public Iterable<String> query(final Filter filter, final String indexName, final NodeState indexMeta, final PropertyRestriction pr) {\n    return query(filter, indexName, indexMeta, INDEX_CONTENT_NODE_NAME, pr);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.888729566963006, "fo": -0.4166666666666667, "r": 2.628571428571429, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 74, "label": 2, "code": "/**\n * Try to fold comparison nodes, e.g ==\n */\n@SuppressWarnings(\"fallthrough\")\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\n        // We only handle non-literal operands for LT and GT.\n        if (n.getType() != Token.GT && n.getType() != Token.LT) {\n            return n;\n        }\n    }\n    int op = n.getType();\n    boolean result;\n    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = left.getType();\n    int rhType = right.getType();\n    switch(lhType) {\n        case Token.VOID:\n            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                return n;\n            } else if (!rightLiteral) {\n                return n;\n            } else {\n                result = compareToUndefined(right, op);\n            }\n            break;\n        case Token.NULL:\n        case Token.TRUE:\n        case Token.FALSE:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = lhType == rhType;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = lhType != rhType;\n                    break;\n                case Token.GE:\n                case Token.LE:\n                case Token.GT:\n                case Token.LT:\n                    Boolean compareResult = compareAsNumbers(op, left, right);\n                    if (compareResult != null) {\n                        result = compareResult;\n                    } else {\n                        return n;\n                    }\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.THIS:\n            if (right.getType() != Token.THIS) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = true;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = false;\n                    break;\n                // whether it is a string, NaN or other number value.\n                default:\n                    return n;\n            }\n            break;\n        case Token.STRING:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.STRING != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = left.getString().equals(right.getString());\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = !left.getString().equals(right.getString());\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.NUMBER:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.NUMBER != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            Boolean compareResult = compareAsNumbers(op, left, right);\n            if (compareResult != null) {\n                result = compareResult;\n            } else {\n                return null;\n            }\n            break;\n        case Token.NAME:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral) {\n                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n                if (undefinedLeft) {\n                    result = compareToUndefined(right, op);\n                    break;\n                }\n            }\n            if (Token.NAME != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            String ln = left.getString();\n            String rn = right.getString();\n            if (!ln.equals(rn)) {\n                // Not the same value name.\n                return n;\n            }\n            switch(op) {\n                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n                case Token.LT:\n                case Token.GT:\n                    result = false;\n                    break;\n                default:\n                    // don't handle that op\n                    return n;\n            }\n            break;\n        default:\n            // assert, this should cover all consts\n            return n;\n    }\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}", "code_comment": "/**\n * Try to fold comparison nodes, e.g ==\n */\n", "code_no_comment": "@SuppressWarnings(\"fallthrough\")\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\n                if (n.getType() != Token.GT && n.getType() != Token.LT) {\n            return n;\n        }\n    }\n    int op = n.getType();\n    boolean result;\n        boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = left.getType();\n    int rhType = right.getType();\n    switch(lhType) {\n        case Token.VOID:\n            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                return n;\n            } else if (!rightLiteral) {\n                return n;\n            } else {\n                result = compareToUndefined(right, op);\n            }\n            break;\n        case Token.NULL:\n        case Token.TRUE:\n        case Token.FALSE:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = lhType == rhType;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = lhType != rhType;\n                    break;\n                case Token.GE:\n                case Token.LE:\n                case Token.GT:\n                case Token.LT:\n                    Boolean compareResult = compareAsNumbers(op, left, right);\n                    if (compareResult != null) {\n                        result = compareResult;\n                    } else {\n                        return n;\n                    }\n                    break;\n                default:\n                                        return n;\n            }\n            break;\n        case Token.THIS:\n            if (right.getType() != Token.THIS) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = true;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = false;\n                    break;\n                                default:\n                    return n;\n            }\n            break;\n        case Token.STRING:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.STRING != right.getType()) {\n                                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = left.getString().equals(right.getString());\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = !left.getString().equals(right.getString());\n                    break;\n                default:\n                                        return n;\n            }\n            break;\n        case Token.NUMBER:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.NUMBER != right.getType()) {\n                                return n;\n            }\n            Boolean compareResult = compareAsNumbers(op, left, right);\n            if (compareResult != null) {\n                result = compareResult;\n            } else {\n                return null;\n            }\n            break;\n        case Token.NAME:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral) {\n                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n                if (undefinedLeft) {\n                    result = compareToUndefined(right, op);\n                    break;\n                }\n            }\n            if (Token.NAME != right.getType()) {\n                                return n;\n            }\n            String ln = left.getString();\n            String rn = right.getString();\n            if (!ln.equals(rn)) {\n                                return n;\n            }\n            switch(op) {\n                                case Token.LT:\n                case Token.GT:\n                    result = false;\n                    break;\n                default:\n                                        return n;\n            }\n            break;\n        default:\n                        return n;\n    }\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}", "lc": 6.045454545454546, "pi": 1.0561224489795917, "ma": 11.0, "nbd": 1.5, "ml": 5.166666666666667, "d": 2.6307464162135448, "mi": -1.8786922856323494, "fo": 3.0, "r": -0.028571428571428574, "e": 12.227196217251082}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5770_cf6172bd", "label": 1, "code": "@Override\npublic PageParameters decodePageParameters(final Url url) {\n    PageParameters parameters = new PageParameters();\n    int i = 0;\n    for (String s : url.getSegments()) {\n        parameters.set(i, s);\n        ++i;\n    }\n    for (QueryParameter p : url.getQueryParameters()) {\n        parameters.add(p.getName(), p.getValue(), INamedParameters.Type.QUERY_STRING);\n    }\n    return parameters.isEmpty() ? null : parameters;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic PageParameters decodePageParameters(final Url url) {\n    PageParameters parameters = new PageParameters();\n    int i = 0;\n    for (String s : url.getSegments()) {\n        parameters.set(i, s);\n        ++i;\n    }\n    for (QueryParameter p : url.getQueryParameters()) {\n        parameters.add(p.getName(), p.getValue(), INamedParameters.Type.QUERY_STRING);\n    }\n    return parameters.isEmpty() ? null : parameters;\n}", "lc": -0.045454545454545456, "pi": -0.15306122448979584, "ma": 0.0, "nbd": -0.5, "ml": -0.25, "d": -0.07612456747404842, "mi": 0.028391167192428884, "fo": 0.08333333333333333, "r": -0.028571428571428574, "e": -0.040080349150466196}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1257_03178c8b", "label": 3, "code": "/**\n * {@inheritDoc}\n *\n * If {@code x} is more than 40 standard deviations from the mean, 0 or 1\n * is returned, as in these cases the actual value is within\n * {@code Double.MIN_VALUE} of 0 or 1.\n */\n@Override\npublic double cumulativeProbability(double x) {\n    final double dev = x - mean;\n    if (FastMath.abs(dev) > 40 * standardDeviation) {\n        return dev < 0 ? 0.0d : 1.0d;\n    }\n    return 0.5 * (1 + Erf.erf(dev / (standardDeviation * SQRT2)));\n}", "code_comment": "/**\n * {@inheritDoc}\n *\n * If {@code x} is more than 40 standard deviations from the mean, 0 or 1\n * is returned, as in these cases the actual value is within\n * {@code Double.MIN_VALUE} of 0 or 1.\n */\n", "code_no_comment": "@Override\npublic double cumulativeProbability(double x) {\n    final double dev = x - mean;\n    if (FastMath.abs(dev) > 40 * standardDeviation) {\n        return dev < 0 ? 0.0d : 1.0d;\n    }\n    return 0.5 * (1 + Erf.erf(dev / (standardDeviation * SQRT2)));\n}", "lc": -0.2727272727272727, "pi": -0.1887755102040817, "ma": -0.16666666666666666, "nbd": -0.5, "ml": 0.0, "d": 0.3766683143845775, "mi": 0.29566963005448826, "fo": -0.3333333333333333, "r": 1.7714285714285716, "e": 0.07975381294409395}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3428_320545cd", "label": 3, "code": "public <T extends Endpoint> T getEndpoint(String name, Class<T> endpointType) {\n    Endpoint endpoint = getEndpoint(name);\n    if (endpoint instanceof InterceptSendToEndpoint) {\n        endpoint = ((InterceptSendToEndpoint) endpoint).getDelegate();\n    }\n    if (endpointType.isInstance(endpoint)) {\n        return endpointType.cast(endpoint);\n    } else {\n        throw new IllegalArgumentException(\"The endpoint is not of type: \" + endpointType + \" but is: \" + endpoint.getClass().getCanonicalName());\n    }\n}", "code_comment": NaN, "code_no_comment": "public <T extends Endpoint> T getEndpoint(String name, Class<T> endpointType) {\n    Endpoint endpoint = getEndpoint(name);\n    if (endpoint instanceof InterceptSendToEndpoint) {\n        endpoint = ((InterceptSendToEndpoint) endpoint).getDelegate();\n    }\n    if (endpointType.isInstance(endpoint)) {\n        return endpointType.cast(endpoint);\n    } else {\n        throw new IllegalArgumentException(\"The endpoint is not of type: \" + endpointType + \" but is: \" + endpoint.getClass().getCanonicalName());\n    }\n}", "lc": -0.13636363636363635, "pi": -0.17857142857142863, "ma": 0.0, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.01878398418190801, "mi": 0.13421279036420974, "fo": 0.0, "r": 0.0, "e": -0.04205481388207177}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-579_7d72e6ed", "label": 3, "code": "public abstract void restrictPushDown(SelectorImpl selectorImpl);", "code_comment": NaN, "code_no_comment": "public abstract void restrictPushDown(SelectorImpl selectorImpl);", "lc": -0.5909090909090909, "pi": -1.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.7106395182104968, "fo": -0.5, "r": 2.8000000000000003, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-988_d270055e", "label": 1, "code": "/**\n * Get the intersection of the instance and another sub-line.\n * <p>\n * This method is related to the {@link Line#intersection(Line)\n * intersection} method in the {@link Line Line} class, but in addition\n * to compute the point along infinite lines, it also checks the point\n * lies on both sub-line ranges.\n * </p>\n * @param subLine other sub-line which may intersect instance\n * @param includeEndPoints if true, endpoints are considered to belong to\n * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\n * are considered to not belong to instance (i.e. they are open sets) and intersection\n * occurring on endpoints lead to null being returned\n * @return the intersection point if there is one, null if the sub-lines don't intersect\n */\npublic Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {\n    // retrieve the underlying lines\n    Line line1 = (Line) getHyperplane();\n    Line line2 = (Line) subLine.getHyperplane();\n    // compute the intersection on infinite line\n    Vector2D v2D = line1.intersection(line2);\n    // check location of point with respect to first sub-line\n    Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n    // check location of point with respect to second sub-line\n    Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\n    if (includeEndPoints) {\n        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;\n    } else {\n        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;\n    }\n}", "code_comment": "/**\n * Get the intersection of the instance and another sub-line.\n * <p>\n * This method is related to the {@link Line#intersection(Line)\n * intersection} method in the {@link Line Line} class, but in addition\n * to compute the point along infinite lines, it also checks the point\n * lies on both sub-line ranges.\n * </p>\n * @param subLine other sub-line which may intersect instance\n * @param includeEndPoints if true, endpoints are considered to belong to\n * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\n * are considered to not belong to instance (i.e. they are open sets) and intersection\n * occurring on endpoints lead to null being returned\n * @return the intersection point if there is one, null if the sub-lines don't intersect\n */\n", "code_no_comment": "public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {\n        Line line1 = (Line) getHyperplane();\n    Line line2 = (Line) subLine.getHyperplane();\n        Vector2D v2D = line1.intersection(line2);\n        Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n        Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\n    if (includeEndPoints) {\n        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;\n    } else {\n        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;\n    }\n}", "lc": -0.09090909090909091, "pi": -0.3622448979591837, "ma": 0.0, "nbd": -0.5, "ml": 0.25, "d": 0.64755313890262, "mi": 0.0014338973329508797, "fo": 0.25, "r": -0.028571428571428574, "e": 0.47909251716413753}
{"project_name": "JxPath", "project_version": 11, "label": 1, "code": "private Attr getAttribute(Element element, QName name) {\n    String testPrefix = name.getPrefix();\n    String testNS = null;\n    if (testPrefix != null) {\n        testNS = parent.getNamespaceURI(testPrefix);\n    }\n    if (testNS != null) {\n        Attr attr = element.getAttributeNodeNS(testNS, name.getName());\n        if (attr != null) {\n            return attr;\n        }\n        // This may mean that the parser does not support NS for\n        // attributes, example - the version of Crimson bundled\n        // with JDK 1.4.0\n        NamedNodeMap nnm = element.getAttributes();\n        for (int i = 0; i < nnm.getLength(); i++) {\n            attr = (Attr) nnm.item(i);\n            if (testAttr(attr, name)) {\n                return attr;\n            }\n        }\n        return null;\n    }\n    return element.getAttributeNode(name.getName());\n}", "code_comment": NaN, "code_no_comment": "private Attr getAttribute(Element element, QName name) {\n    String testPrefix = name.getPrefix();\n    String testNS = null;\n    if (testPrefix != null) {\n        testNS = parent.getNamespaceURI(testPrefix);\n    }\n    if (testNS != null) {\n        Attr attr = element.getAttributeNodeNS(testNS, name.getName());\n        if (attr != null) {\n            return attr;\n        }\n                                NamedNodeMap nnm = element.getAttributes();\n        for (int i = 0; i < nnm.getLength(); i++) {\n            attr = (Attr) nnm.item(i);\n            if (testAttr(attr, name)) {\n                return attr;\n            }\n        }\n        return null;\n    }\n    return element.getAttributeNode(name.getName());\n}", "lc": 0.36363636363636365, "pi": 0.4948979591836736, "ma": 0.3333333333333333, "nbd": 0.5, "ml": 0.5833333333333334, "d": 0.4715768660405339, "mi": -0.31488385431603116, "fo": 0.3333333333333333, "r": -0.028571428571428574, "e": 0.4513857658653166}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1348_6ff92b12", "label": 1, "code": "public int start() throws IOException {\n    if (configError)\n        return 1;\n    String input;\n    if (isVerbose())\n        printInfo();\n    String home = System.getProperty(\"HOME\");\n    if (home == null)\n        home = System.getenv(\"HOME\");\n    String configDir = home + \"/\" + HISTORY_DIR_NAME;\n    String historyPath = configDir + \"/\" + HISTORY_FILE_NAME;\n    File accumuloDir = new File(configDir);\n    if (!accumuloDir.exists() && !accumuloDir.mkdirs())\n        log.warn(\"Unable to make directory for history at \" + accumuloDir);\n    try {\n        History history = new History();\n        history.setHistoryFile(new File(historyPath));\n        reader.setHistory(history);\n    } catch (IOException e) {\n        log.warn(\"Unable to load history file at \" + historyPath);\n    }\n    ShellCompletor userCompletor = null;\n    if (execFile != null) {\n        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));\n        try {\n            while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());\n        } finally {\n            scanner.close();\n        }\n    } else if (execCommand != null) {\n        for (String command : execCommand.split(\"\\n\")) {\n            execCommand(command, true, isVerbose());\n        }\n        return exitCode;\n    }\n    while (true) {\n        if (hasExited())\n            return exitCode;\n        // If tab completion is true we need to reset\n        if (tabCompletion) {\n            if (userCompletor != null)\n                reader.removeCompletor(userCompletor);\n            userCompletor = setupCompletion();\n            reader.addCompletor(userCompletor);\n        }\n        reader.setDefaultPrompt(getDefaultPrompt());\n        input = reader.readLine();\n        if (input == null) {\n            reader.printNewline();\n            return exitCode;\n        }\n        // user canceled\n        execCommand(input, disableAuthTimeout, false);\n    }\n}", "code_comment": NaN, "code_no_comment": "public int start() throws IOException {\n    if (configError)\n        return 1;\n    String input;\n    if (isVerbose())\n        printInfo();\n    String home = System.getProperty(\"HOME\");\n    if (home == null)\n        home = System.getenv(\"HOME\");\n    String configDir = home + \"/\" + HISTORY_DIR_NAME;\n    String historyPath = configDir + \"/\" + HISTORY_FILE_NAME;\n    File accumuloDir = new File(configDir);\n    if (!accumuloDir.exists() && !accumuloDir.mkdirs())\n        log.warn(\"Unable to make directory for history at \" + accumuloDir);\n    try {\n        History history = new History();\n        history.setHistoryFile(new File(historyPath));\n        reader.setHistory(history);\n    } catch (IOException e) {\n        log.warn(\"Unable to load history file at \" + historyPath);\n    }\n    ShellCompletor userCompletor = null;\n    if (execFile != null) {\n        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));\n        try {\n            while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());\n        } finally {\n            scanner.close();\n        }\n    } else if (execCommand != null) {\n        for (String command : execCommand.split(\"\\n\")) {\n            execCommand(command, true, isVerbose());\n        }\n        return exitCode;\n    }\n    while (true) {\n        if (hasExited())\n            return exitCode;\n                if (tabCompletion) {\n            if (userCompletor != null)\n                reader.removeCompletor(userCompletor);\n            userCompletor = setupCompletion();\n            reader.addCompletor(userCompletor);\n        }\n        reader.setDefaultPrompt(getDefaultPrompt());\n        input = reader.readLine();\n        if (input == null) {\n            reader.printNewline();\n            return exitCode;\n        }\n                execCommand(input, disableAuthTimeout, false);\n    }\n}", "lc": 1.7727272727272727, "pi": 0.15816326530612249, "ma": 1.8333333333333333, "nbd": 0.5, "ml": 1.6666666666666667, "d": 0.8057340583292142, "mi": -0.9262976770863208, "fo": 1.75, "r": -0.028571428571428574, "e": 2.0805376026314777}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-412_be2fdba7", "label": 1, "code": "@Override\npublic void run() {\n    ClientService.Iface client = null;\n    try {\n        client = ServerClient.getConnection(HdfsZooInstance.getInstance());\n        List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);\n        attempt.removeAll(fail);\n        filesToLoad.removeAll(attempt);\n    } catch (Exception ex) {\n        log.error(ex, ex);\n    } finally {\n        ServerClient.close(client);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void run() {\n    ClientService.Iface client = null;\n    try {\n        client = ServerClient.getConnection(HdfsZooInstance.getInstance());\n        List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);\n        attempt.removeAll(fail);\n        filesToLoad.removeAll(attempt);\n    } catch (Exception ex) {\n        log.error(ex, ex);\n    } finally {\n        ServerClient.close(client);\n    }\n}", "lc": 0.0, "pi": 0.035714285714285636, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": -0.010037281330656973, "fo": 0.16666666666666666, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4066_4d3d1f85", "label": 1, "code": "public int getCompatibilityScore(Request request) {\n    return 0;\n}", "code_comment": NaN, "code_no_comment": "public int getCompatibilityScore(Request request) {\n    return 0;\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.144536851161457, "fo": -0.5, "r": 1.8, "e": -0.16422749602751402}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-914_f8a42197", "label": 3, "code": "/**\n * Format the stack trace including packaging information.\n *\n * @param ignorePackages\n *        List of packages to be ignored in the trace.\n * @return The formatted stack trace including packaging information.\n */\npublic String getExtendedStackTraceAsString(final List<String> ignorePackages) {\n    final StringBuilder sb = new StringBuilder(this.name);\n    final String msg = this.message;\n    if (msg != null) {\n        sb.append(\": \").append(msg);\n    }\n    sb.append(EOL);\n    this.formatElements(sb, 0, this.throwable.getStackTrace(), this.extendedStackTrace, ignorePackages);\n    this.formatCause(sb, this.causeProxy, ignorePackages);\n    return sb.toString();\n}", "code_comment": "/**\n * Format the stack trace including packaging information.\n *\n * @param ignorePackages\n *        List of packages to be ignored in the trace.\n * @return The formatted stack trace including packaging information.\n */\n", "code_no_comment": "public String getExtendedStackTraceAsString(final List<String> ignorePackages) {\n    final StringBuilder sb = new StringBuilder(this.name);\n    final String msg = this.message;\n    if (msg != null) {\n        sb.append(\": \").append(msg);\n    }\n    sb.append(EOL);\n    this.formatElements(sb, 0, this.throwable.getStackTrace(), this.extendedStackTrace, ignorePackages);\n    this.formatCause(sb, this.causeProxy, ignorePackages);\n    return sb.toString();\n}", "lc": -0.13636363636363635, "pi": -0.4897959183673469, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.056351952545724164, "mi": 0.12675652423286501, "fo": 0.08333333333333333, "r": 0.0, "e": -0.038906806121268955}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1167_259f10c0", "label": 3, "code": "public void setNextPartialSolution(OptimizerNode solutionSetDelta, OptimizerNode nextWorkset) {\n    // the partial solution (so we can potentially do direct updates)\n    if (solutionSetDelta instanceof TwoInputNode) {\n        TwoInputNode solutionDeltaTwoInput = (TwoInputNode) solutionSetDelta;\n        if (solutionDeltaTwoInput.getFirstPredecessorNode() == this.solutionSetNode || solutionDeltaTwoInput.getSecondPredecessorNode() == this.solutionSetNode) {\n            this.solutionDeltaImmediatelyAfterSolutionJoin = true;\n        }\n    }\n    // if the next workset is equal to the workset, we need to inject a no-op node\n    if (nextWorkset == worksetNode) {\n        NoOpNode noop = new NoOpNode();\n        noop.setDegreeOfParallelism(getDegreeOfParallelism());\n        PactConnection noOpConn = new PactConnection(nextWorkset, noop);\n        noop.setIncomingConnection(noOpConn);\n        nextWorkset.addOutgoingConnection(noOpConn);\n        nextWorkset = noop;\n    }\n    // attach an extra node to the solution set delta for the cases where we need to repartition\n    UnaryOperatorNode solutionSetDeltaUpdateAux = new UnaryOperatorNode(\"Solution-Set Delta\", getSolutionSetKeyFields(), new SolutionSetDeltaOperator(getSolutionSetKeyFields()));\n    solutionSetDeltaUpdateAux.setDegreeOfParallelism(getDegreeOfParallelism());\n    PactConnection conn = new PactConnection(solutionSetDelta, solutionSetDeltaUpdateAux);\n    solutionSetDeltaUpdateAux.setIncomingConnection(conn);\n    solutionSetDelta.addOutgoingConnection(conn);\n    this.solutionSetDelta = solutionSetDeltaUpdateAux;\n    this.nextWorkset = nextWorkset;\n    this.singleRoot = new SingleRootJoiner();\n    this.solutionSetDeltaRootConnection = new PactConnection(solutionSetDeltaUpdateAux, this.singleRoot);\n    this.nextWorksetRootConnection = new PactConnection(nextWorkset, this.singleRoot);\n    this.singleRoot.setInputs(this.solutionSetDeltaRootConnection, this.nextWorksetRootConnection);\n    solutionSetDeltaUpdateAux.addOutgoingConnection(this.solutionSetDeltaRootConnection);\n    nextWorkset.addOutgoingConnection(this.nextWorksetRootConnection);\n}", "code_comment": NaN, "code_no_comment": "public void setNextPartialSolution(OptimizerNode solutionSetDelta, OptimizerNode nextWorkset) {\n        if (solutionSetDelta instanceof TwoInputNode) {\n        TwoInputNode solutionDeltaTwoInput = (TwoInputNode) solutionSetDelta;\n        if (solutionDeltaTwoInput.getFirstPredecessorNode() == this.solutionSetNode || solutionDeltaTwoInput.getSecondPredecessorNode() == this.solutionSetNode) {\n            this.solutionDeltaImmediatelyAfterSolutionJoin = true;\n        }\n    }\n        if (nextWorkset == worksetNode) {\n        NoOpNode noop = new NoOpNode();\n        noop.setDegreeOfParallelism(getDegreeOfParallelism());\n        PactConnection noOpConn = new PactConnection(nextWorkset, noop);\n        noop.setIncomingConnection(noOpConn);\n        nextWorkset.addOutgoingConnection(noOpConn);\n        nextWorkset = noop;\n    }\n        UnaryOperatorNode solutionSetDeltaUpdateAux = new UnaryOperatorNode(\"Solution-Set Delta\", getSolutionSetKeyFields(), new SolutionSetDeltaOperator(getSolutionSetKeyFields()));\n    solutionSetDeltaUpdateAux.setDegreeOfParallelism(getDegreeOfParallelism());\n    PactConnection conn = new PactConnection(solutionSetDelta, solutionSetDeltaUpdateAux);\n    solutionSetDeltaUpdateAux.setIncomingConnection(conn);\n    solutionSetDelta.addOutgoingConnection(conn);\n    this.solutionSetDelta = solutionSetDeltaUpdateAux;\n    this.nextWorkset = nextWorkset;\n    this.singleRoot = new SingleRootJoiner();\n    this.solutionSetDeltaRootConnection = new PactConnection(solutionSetDeltaUpdateAux, this.singleRoot);\n    this.nextWorksetRootConnection = new PactConnection(nextWorkset, this.singleRoot);\n    this.singleRoot.setInputs(this.solutionSetDeltaRootConnection, this.nextWorksetRootConnection);\n    solutionSetDeltaUpdateAux.addOutgoingConnection(this.solutionSetDeltaRootConnection);\n    nextWorkset.addOutgoingConnection(this.nextWorksetRootConnection);\n}", "lc": 0.6818181818181818, "pi": -0.21428571428571425, "ma": 0.0, "nbd": 0.0, "ml": 0.4166666666666667, "d": 0.15126050420168072, "mi": -0.49698881560080305, "fo": 0.75, "r": -0.028571428571428574, "e": 0.43798853011594086}
{"project_name": "Closure", "project_version": 134, "label": 2, "code": "private void addNonUnionType(JSType newType) {\n    if (skipAmbiguating || isInvalidatingType(newType)) {\n        skipAmbiguating = true;\n        return;\n    }\n    if (type == null) {\n        type = newType;\n    } else {\n        type = type.getLeastSupertype(newType);\n    }\n    typesSet.set(getIntForType(newType));\n}", "code_comment": NaN, "code_no_comment": "private void addNonUnionType(JSType newType) {\n    if (skipAmbiguating || isInvalidatingType(newType)) {\n        skipAmbiguating = true;\n        return;\n    }\n    if (type == null) {\n        type = newType;\n    } else {\n        type = type.getLeastSupertype(newType);\n    }\n    typesSet.set(getIntForType(newType));\n}", "lc": -0.09090909090909091, "pi": -0.13775510204081634, "ma": -0.16666666666666666, "nbd": -0.5, "ml": 0.16666666666666666, "d": -0.06030647553138898, "mi": 0.16030972182391756, "fo": -0.16666666666666666, "r": 0.6, "e": -0.09227303292344988}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-621_00b4b8a0", "label": 1, "code": "@Nonnull\nstatic TreeImpl createRoot(final RootImpl root) {\n    return new TreeImpl(root, null, \"\") {\n\n        @Override\n        protected NodeState getBaseState() {\n            return root.getBaseState();\n        }\n\n        @Override\n        protected synchronized NodeBuilder getNodeBuilder() {\n            if (nodeBuilder == null) {\n                nodeBuilder = root.createRootBuilder();\n            }\n            return nodeBuilder;\n        }\n    };\n}", "code_comment": NaN, "code_no_comment": "@Nonnull\nstatic TreeImpl createRoot(final RootImpl root) {\n    return new TreeImpl(root, null, \"\") {\n\n        @Override\n        protected NodeState getBaseState() {\n            return root.getBaseState();\n        }\n\n        @Override\n        protected synchronized NodeBuilder getNodeBuilder() {\n            if (nodeBuilder == null) {\n                nodeBuilder = root.createRootBuilder();\n            }\n            return nodeBuilder;\n        }\n    };\n}", "lc": 0.09090909090909091, "pi": 0.8367346938775511, "ma": -0.3333333333333333, "nbd": 0.0, "ml": -0.25, "d": -0.06426099851705384, "mi": 0.030111843991970103, "fo": -0.3333333333333333, "r": 0.7142857142857143, "e": -0.09139930015718624}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1067_4786a739", "label": 3, "code": "@SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\nprivate void formatCause(final StringBuilder sb, final ThrowableProxy cause, final List<String> ignorePackages) {\n    if (cause == null) {\n        return;\n    }\n    sb.append(\"Caused by: \").append(cause).append(EOL);\n    this.formatElements(sb, cause.commonElementCount, cause.getThrowable().getStackTrace(), cause.extendedStackTrace, ignorePackages);\n    this.formatCause(sb, cause.causeProxy, ignorePackages);\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\nprivate void formatCause(final StringBuilder sb, final ThrowableProxy cause, final List<String> ignorePackages) {\n    if (cause == null) {\n        return;\n    }\n    sb.append(\"Caused by: \").append(cause).append(EOL);\n    this.formatElements(sb, cause.commonElementCount, cause.getThrowable().getStackTrace(), cause.extendedStackTrace, ignorePackages);\n    this.formatCause(sb, cause.causeProxy, ignorePackages);\n}", "lc": -0.22727272727272727, "pi": -0.2602040816326532, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.3806228373702422, "mi": 0.23601950100372832, "fo": 0.08333333333333333, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5728_3cc3fe95", "label": 1, "code": "/**\n *  Dequeues components. The default implementation iterates direct children of this container\n *  found in its markup and tries to find matching\n *  components in queues filled by a call to {@link #queue(Component...)}. It then delegates the\n *  dequeueing to these children.\n *\n *  The provided {@link DequeueContext} is used to maintain the place in markup as well as the\n *  stack of components whose queues will be searched. For example, before delegating the call to\n *  a child the container will push the child onto the stack of components.\n *\n *  Certain components that implement custom markup behaviors (such as repeaters and borders)\n *  override this method to bring dequeueing in line with their custom markup handling.\n *\n *  @param dequeue\n */\npublic void dequeue(DequeueContext dequeue) {\n    while (dequeue.isAtOpenOrOpenCloseTag()) {\n        ComponentTag tag = dequeue.takeTag();\n        // see if child is already added to parent\n        Component child = get(tag.getId());\n        if (child == null) {\n            // the container does not yet have a child with this id, see if we can\n            // dequeue\n            child = dequeue.findComponentToDequeue(tag);\n            if (child != null) {\n                addDequeuedComponent(child, tag);\n                if (child instanceof IQueueRegion) {\n                    ((MarkupContainer) child).dequeue();\n                }\n            }\n        }\n        if (child == null || !(child instanceof MarkupContainer)) {\n            if (tag.isOpen()) {\n                dequeue.skipToCloseTag();\n            }\n        } else {\n            MarkupContainer container = (MarkupContainer) child;\n            if (container instanceof IQueueRegion) {\n                // itself when it is dequeued for the first time\n                if (tag.isOpen()) {\n                    dequeue.skipToCloseTag();\n                }\n            } else if (tag.isOpen()) {\n                // this component has more markup and possibly more children to dequeue\n                dequeue.pushContainer(container);\n                container.dequeue(dequeue);\n                dequeue.popContainer();\n            }\n        }\n        if (tag.isOpen() && !tag.hasNoCloseTag()) {\n            // pull the close tag off\n            ComponentTag close = dequeue.takeTag();\n            if (!close.closes(tag)) {\n                // sanity check\n                throw new IllegalStateException(String.format(\"Tag '%s' should be the closing one for '%s'\", close, tag));\n            }\n        }\n    }\n}", "code_comment": "/**\n *  Dequeues components. The default implementation iterates direct children of this container\n *  found in its markup and tries to find matching\n *  components in queues filled by a call to {@link #queue(Component...)}. It then delegates the\n *  dequeueing to these children.\n *\n *  The provided {@link DequeueContext} is used to maintain the place in markup as well as the\n *  stack of components whose queues will be searched. For example, before delegating the call to\n *  a child the container will push the child onto the stack of components.\n *\n *  Certain components that implement custom markup behaviors (such as repeaters and borders)\n *  override this method to bring dequeueing in line with their custom markup handling.\n *\n *  @param dequeue\n */\n", "code_no_comment": "public void dequeue(DequeueContext dequeue) {\n    while (dequeue.isAtOpenOrOpenCloseTag()) {\n        ComponentTag tag = dequeue.takeTag();\n                Component child = get(tag.getId());\n        if (child == null) {\n                                    child = dequeue.findComponentToDequeue(tag);\n            if (child != null) {\n                addDequeuedComponent(child, tag);\n                if (child instanceof IQueueRegion) {\n                    ((MarkupContainer) child).dequeue();\n                }\n            }\n        }\n        if (child == null || !(child instanceof MarkupContainer)) {\n            if (tag.isOpen()) {\n                dequeue.skipToCloseTag();\n            }\n        } else {\n            MarkupContainer container = (MarkupContainer) child;\n            if (container instanceof IQueueRegion) {\n                                if (tag.isOpen()) {\n                    dequeue.skipToCloseTag();\n                }\n            } else if (tag.isOpen()) {\n                                dequeue.pushContainer(container);\n                container.dequeue(dequeue);\n                dequeue.popContainer();\n            }\n        }\n        if (tag.isOpen() && !tag.hasNoCloseTag()) {\n                        ComponentTag close = dequeue.takeTag();\n            if (!close.closes(tag)) {\n                                throw new IllegalStateException(String.format(\"Tag '%s' should be the closing one for '%s'\", close, tag));\n            }\n        }\n    }\n}", "lc": 1.0454545454545454, "pi": 0.8877551020408162, "ma": 1.5, "nbd": 1.0, "ml": 1.25, "d": 1.2288680177953537, "mi": -0.6481215944938347, "fo": 1.1666666666666667, "r": -0.028571428571428574, "e": 1.4148988568662975}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5359_61122bab", "label": 3, "code": "/**\n *  Convert to boolean, returning default value if text is inconvertible.\n *\n *  @param defaultValue\n *             the default value\n *  @return the converted text as a boolean or the default value if text is empty or inconvertible\n *  @see Strings#isTrue(String)\n */\npublic final boolean toBoolean(final boolean defaultValue) {\n    if (text != null) {\n        try {\n            return toBoolean();\n        } catch (StringValueConversionException x) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(String.format(\"An error occurred while converting '%s' to a boolean: %s\", text, x.getMessage()), x);\n            }\n        }\n    }\n    return defaultValue;\n}", "code_comment": "/**\n *  Convert to boolean, returning default value if text is inconvertible.\n *\n *  @param defaultValue\n *             the default value\n *  @return the converted text as a boolean or the default value if text is empty or inconvertible\n *  @see Strings#isTrue(String)\n */\n", "code_no_comment": "public final boolean toBoolean(final boolean defaultValue) {\n    if (text != null) {\n        try {\n            return toBoolean();\n        } catch (StringValueConversionException x) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(String.format(\"An error occurred while converting '%s' to a boolean: %s\", text, x.getMessage()), x);\n            }\n        }\n    }\n    return defaultValue;\n}", "lc": -0.09090909090909091, "pi": 0.933673469387755, "ma": 0.0, "nbd": 0.5, "ml": -0.08333333333333333, "d": -0.3806228373702422, "mi": 0.1892744479495267, "fo": -0.08333333333333333, "r": 1.2285714285714286, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 49, "label": 3, "code": "@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.FUNCTION:\n            {\n                // Add recursive function name, if needed.\n                // NOTE: \"enterScope\" is called after we need to pick up this name.\n                Renamer renamer = nameStack.peek().forChildScope();\n                // If needed, add the function recursive name.\n                String name = n.getFirstChild().getString();\n                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n                    renamer.addDeclaredName(name);\n                }\n                // Add the function parameters\n                // Add the function body declarations\n                nameStack.push(renamer);\n            }\n            break;\n        case Token.CATCH:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                String name = n.getFirstChild().getString();\n                renamer.addDeclaredName(name);\n                nameStack.push(renamer);\n            }\n            break;\n    }\n    return true;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.FUNCTION:\n            {\n                                                Renamer renamer = nameStack.peek().forChildScope();\n                                String name = n.getFirstChild().getString();\n                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n                    renamer.addDeclaredName(name);\n                }\n                                                nameStack.push(renamer);\n            }\n            break;\n        case Token.CATCH:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                String name = n.getFirstChild().getString();\n                renamer.addDeclaredName(name);\n                nameStack.push(renamer);\n            }\n            break;\n    }\n    return true;\n}", "lc": 0.45454545454545453, "pi": 1.4795918367346939, "ma": 0.3333333333333333, "nbd": 0.5, "ml": 0.5833333333333334, "d": 0.4241225902125558, "mi": -0.35790077430456, "fo": 0.75, "r": -0.028571428571428574, "e": 0.42866443093870593}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6604_4209fabb", "label": 1, "code": "public void begin() {\n    // we have already acquired and prepare the producer\n    LOG.trace(\"RecipientProcessorExchangePair #{} begin: {}\", index, exchange);\n    exchange.setProperty(Exchange.RECIPIENT_LIST_ENDPOINT, endpoint.getEndpointUri());\n}", "code_comment": NaN, "code_no_comment": "public void begin() {\n        LOG.trace(\"RecipientProcessorExchangePair #{} begin: {}\", index, exchange);\n    exchange.setProperty(Exchange.RECIPIENT_LIST_ENDPOINT, endpoint.getEndpointUri());\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8038428448523088, "fo": -0.25, "r": 0.4571428571428572, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7016_4ed448c7", "label": 3, "code": "public void updateRouteFromXml(String xml) throws Exception {\n    // convert to model from xml\n    RouteDefinition def = ModelHelper.createModelFromXml(xml, RouteDefinition.class);\n    if (def == null) {\n        return;\n    }\n    // add will remove existing route first\n    context.addRouteDefinition(def);\n}", "code_comment": NaN, "code_no_comment": "public void updateRouteFromXml(String xml) throws Exception {\n        RouteDefinition def = ModelHelper.createModelFromXml(xml, RouteDefinition.class);\n    if (def == null) {\n        return;\n    }\n        context.addRouteDefinition(def);\n}", "lc": -0.3181818181818182, "pi": -0.2346938775510204, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.11764705882352938, "mi": 0.4794952681388014, "fo": -0.3333333333333333, "r": 2.314285714285714, "e": -0.12508940770341057}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5968_8b7946d8", "label": 1, "code": "@Override\npublic int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + (extension != null ? extension.hashCode() : 0);\n    return result;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + (extension != null ? extension.hashCode() : 0);\n    return result;\n}", "lc": -0.36363636363636365, "pi": -0.5204081632653061, "ma": -0.3333333333333333, "nbd": -1.0, "ml": -0.25, "d": 0.3114186851211074, "mi": 0.55205047318612, "fo": -0.3333333333333333, "r": 1.342857142857143, "e": -0.06212068647984204}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3713_e1168a57", "label": 3, "code": "/**\n *  @param userAgent\n *             The user agent string\n *  @return Whether the user agent matches this enum or not\n */\npublic boolean matches(String userAgent) {\n    if (notAllowedList != null) {\n        for (String value : notAllowedList) {\n            if (userAgent.contains(value)) {\n                return false;\n            }\n        }\n    }\n    for (List<String> detectionGroup : detectionStrings) {\n        for (String detectionString : detectionGroup) {\n            if (!userAgent.contains(detectionString)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}", "code_comment": "/**\n *  @param userAgent\n *             The user agent string\n *  @return Whether the user agent matches this enum or not\n */\n", "code_no_comment": "public boolean matches(String userAgent) {\n    if (notAllowedList != null) {\n        for (String value : notAllowedList) {\n            if (userAgent.contains(value)) {\n                return false;\n            }\n        }\n    }\n    for (List<String> detectionGroup : detectionStrings) {\n        for (String detectionString : detectionGroup) {\n            if (!userAgent.contains(detectionString)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}", "lc": 0.18181818181818182, "pi": 0.8622448979591837, "ma": 0.5, "nbd": 0.5, "ml": 0.25, "d": -0.012852199703410724, "mi": -0.06538571838256386, "fo": -0.3333333333333333, "r": 0.8285714285714285, "e": -0.0751410178986727}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7055_15e1077d", "label": 1, "code": "public void close() throws IOException {\n    currentStream.close();\n    cleanUpTempFile();\n}", "code_comment": NaN, "code_no_comment": "public void close() throws IOException {\n    currentStream.close();\n    cleanUpTempFile();\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9836535704043596, "fo": -0.3333333333333333, "r": 1.7428571428571429, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3535_b56d2962", "label": 1, "code": "public void process(Exchange exchange) throws Exception {\n    // compute correlation expression\n    String key = correlationExpression.evaluate(exchange, String.class);\n    if (ObjectHelper.isEmpty(key)) {\n        // we have a bad correlation key\n        if (isIgnoreInvalidCorrelationKeys()) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Invalid correlation key. This Exchange will be ignored: \" + exchange);\n            }\n            return;\n        } else {\n            throw new CamelExchangeException(\"Invalid correlation key\", exchange);\n        }\n    }\n    // is the correlation key closed?\n    if (closedCorrelationKeys != null && closedCorrelationKeys.containsKey(key)) {\n        throw new ClosedCorrelationKeyException(key, exchange);\n    }\n    // when memory based then its fast using synchronized, but if the aggregation repository is IO\n    // bound such as JPA etc then concurrent aggregation per correlation key could\n    // improve performance as we can run aggregation repository get/add in parallel\n    lock.lock();\n    try {\n        doAggregation(key, exchange);\n    } finally {\n        lock.unlock();\n    }\n}", "code_comment": NaN, "code_no_comment": "public void process(Exchange exchange) throws Exception {\n        String key = correlationExpression.evaluate(exchange, String.class);\n    if (ObjectHelper.isEmpty(key)) {\n                if (isIgnoreInvalidCorrelationKeys()) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Invalid correlation key. This Exchange will be ignored: \" + exchange);\n            }\n            return;\n        } else {\n            throw new CamelExchangeException(\"Invalid correlation key\", exchange);\n        }\n    }\n        if (closedCorrelationKeys != null && closedCorrelationKeys.containsKey(key)) {\n        throw new ClosedCorrelationKeyException(key, exchange);\n    }\n                lock.lock();\n    try {\n        doAggregation(key, exchange);\n    } finally {\n        lock.unlock();\n    }\n}", "lc": 0.36363636363636365, "pi": 0.5357142857142858, "ma": 0.5, "nbd": 0.5, "ml": 0.5, "d": 0.23628274839347513, "mi": -0.25150559219959845, "fo": 0.25, "r": -0.028571428571428574, "e": 0.1149172737824491}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1820_39d526e6", "label": 0, "code": "/**\n *  Static utility to parse a field of type int from a byte sequence that represents text characters\n *  (such as when read from a file stream).\n *\n *  @param bytes The bytes containing the text data that should be parsed.\n *  @param startPos The offset to start the parsing.\n *  @param length The length of the byte sequence (counting from the offset).\n *  @param delimiter The delimiter that terminates the field.\n *\n *  @return The parsed value.\n *\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n */\npublic static final int parseField(byte[] bytes, int startPos, int length, char delimiter) {\n    if (length <= 0) {\n        throw new NumberFormatException(\"Invalid input: Empty string\");\n    }\n    long val = 0;\n    boolean neg = false;\n    if (bytes[startPos] == '-') {\n        neg = true;\n        startPos++;\n        length--;\n        if (length == 0 || bytes[startPos] == delimiter) {\n            throw new NumberFormatException(\"Orphaned minus sign.\");\n        }\n    }\n    for (; length > 0; startPos++, length--) {\n        if (bytes[startPos] == delimiter) {\n            return (int) (neg ? -val : val);\n        }\n        if (bytes[startPos] < 48 || bytes[startPos] > 57) {\n            throw new NumberFormatException(\"Invalid character.\");\n        }\n        val *= 10;\n        val += bytes[startPos] - 48;\n        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {\n            throw new NumberFormatException(\"Value overflow/underflow\");\n        }\n    }\n    return (int) (neg ? -val : val);\n}", "code_comment": "/**\n *  Static utility to parse a field of type int from a byte sequence that represents text characters\n *  (such as when read from a file stream).\n *\n *  @param bytes The bytes containing the text data that should be parsed.\n *  @param startPos The offset to start the parsing.\n *  @param length The length of the byte sequence (counting from the offset).\n *  @param delimiter The delimiter that terminates the field.\n *\n *  @return The parsed value.\n *\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n */\n", "code_no_comment": "public static final int parseField(byte[] bytes, int startPos, int length, char delimiter) {\n    if (length <= 0) {\n        throw new NumberFormatException(\"Invalid input: Empty string\");\n    }\n    long val = 0;\n    boolean neg = false;\n    if (bytes[startPos] == '-') {\n        neg = true;\n        startPos++;\n        length--;\n        if (length == 0 || bytes[startPos] == delimiter) {\n            throw new NumberFormatException(\"Orphaned minus sign.\");\n        }\n    }\n    for (; length > 0; startPos++, length--) {\n        if (bytes[startPos] == delimiter) {\n            return (int) (neg ? -val : val);\n        }\n        if (bytes[startPos] < 48 || bytes[startPos] > 57) {\n            throw new NumberFormatException(\"Invalid character.\");\n        }\n        val *= 10;\n        val += bytes[startPos] - 48;\n        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {\n            throw new NumberFormatException(\"Value overflow/underflow\");\n        }\n    }\n    return (int) (neg ? -val : val);\n}", "lc": 0.6818181818181818, "pi": 0.07653061224489792, "ma": 1.6666666666666667, "nbd": 0.0, "ml": 1.0, "d": 2.9629263470093923, "mi": -0.5425867507886437, "fo": -0.5, "r": -0.028571428571428574, "e": 3.141865933416424}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1214_6ecd0f82", "label": 1, "code": "@Override\npublic void computeInterestingPropertiesForInputs(CostEstimator estimator) {\n    // get what we inherit and what is preserved by our user code\n    final InterestingProperties props = getInterestingProperties().filterByCodeAnnotations(this, 0);\n    // add all properties relevant to this node\n    for (OperatorDescriptorSingle dps : getPossibleProperties()) {\n        for (RequestedGlobalProperties gp : dps.getPossibleGlobalProperties()) {\n            props.addGlobalProperties(gp);\n        }\n        for (RequestedLocalProperties lp : dps.getPossibleLocalProperties()) {\n            props.addLocalProperties(lp);\n        }\n    }\n    this.inConn.setInterestingProperties(props);\n    for (PactConnection conn : getBroadcastConnections()) {\n        conn.setInterestingProperties(new InterestingProperties());\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void computeInterestingPropertiesForInputs(CostEstimator estimator) {\n        final InterestingProperties props = getInterestingProperties().filterByCodeAnnotations(this, 0);\n        for (OperatorDescriptorSingle dps : getPossibleProperties()) {\n        for (RequestedGlobalProperties gp : dps.getPossibleGlobalProperties()) {\n            props.addGlobalProperties(gp);\n        }\n        for (RequestedLocalProperties lp : dps.getPossibleLocalProperties()) {\n            props.addLocalProperties(lp);\n        }\n    }\n    this.inConn.setInterestingProperties(props);\n    for (PactConnection conn : getBroadcastConnections()) {\n        conn.setInterestingProperties(new InterestingProperties());\n    }\n}", "lc": 0.09090909090909091, "pi": 0.3520408163265306, "ma": 0.16666666666666666, "nbd": 0.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": -0.0648121594493836, "fo": 0.3333333333333333, "r": 0.0, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-373_bfe4623c", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic void increment(final double d) {\n    if (n == 0) {\n        value = d * d;\n    } else {\n        value += d * d;\n    }\n    n++;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic void increment(final double d) {\n    if (n == 0) {\n        value = d * d;\n    } else {\n        value += d * d;\n    }\n    n++;\n}", "lc": -0.22727272727272727, "pi": -0.035714285714285636, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": 0.3529411764705883, "mi": 0.36363636363636354, "fo": -0.5, "r": 2.8000000000000003, "e": -0.055867500995798375}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1269_b8fe2ded", "label": 1, "code": "@Override\npublic Cursor query(Filter filter, NodeState root) {\n    NodeTypeIndexLookup lookup = new NodeTypeIndexLookup(root);\n    if (!hasNodeTypeRestriction(filter) || !lookup.isIndexed(filter.getPath())) {\n        throw new IllegalStateException(\"NodeType index is used even when no index is available for filter \" + filter);\n    }\n    return Cursors.newPathCursorDistinct(lookup.query(filter));\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Cursor query(Filter filter, NodeState root) {\n    NodeTypeIndexLookup lookup = new NodeTypeIndexLookup(root);\n    if (!hasNodeTypeRestriction(filter) || !lookup.isIndexed(filter.getPath())) {\n        throw new IllegalStateException(\"NodeType index is used even when no index is available for filter \" + filter);\n    }\n    return Cursors.newPathCursorDistinct(lookup.query(filter));\n}", "lc": -0.2727272727272727, "pi": -0.1887755102040817, "ma": -0.16666666666666666, "nbd": -0.5, "ml": 0.08333333333333333, "d": 0.22441917943648054, "mi": 0.3085747060510466, "fo": -0.08333333333333333, "r": 0.028571428571428574, "e": 0.014159610417978337}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-442_246d53c5", "label": 1, "code": "/**\n *  Gets the converter instance. This method returns the cached converter for\n *  the current locale. Whenever the locale is changed, the cached value is\n *  cleared and the converter will be recreated for the new locale on a next\n *  request.\n *\n *  @param type\n *             TODO\n *\n *  @return the converter\n */\npublic final IConverter getConverter(Class type) {\n    if (converterSupplier == null) {\n        // Let the factory create a new converter\n        converterSupplier = getApplication().getApplicationSettings().getConverterLocatorFactory().newConverterLocator();\n    }\n    return converterSupplier.getConverter(type);\n}", "code_comment": "/**\n *  Gets the converter instance. This method returns the cached converter for\n *  the current locale. Whenever the locale is changed, the cached value is\n *  cleared and the converter will be recreated for the new locale on a next\n *  request.\n *\n *  @param type\n *             TODO\n *\n *  @return the converter\n */\n", "code_no_comment": "public final IConverter getConverter(Class type) {\n    if (converterSupplier == null) {\n                converterSupplier = getApplication().getApplicationSettings().getConverterLocatorFactory().newConverterLocator();\n    }\n    return converterSupplier.getConverter(type);\n}", "lc": -0.36363636363636365, "pi": -0.13775510204081634, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.11171527434503209, "mi": 0.5640952107829081, "fo": -0.08333333333333333, "r": 0.7142857142857143, "e": -0.12748788980687936}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-478_a7f0e808", "label": 1, "code": "@Override\npublic void childNodeDeleted(String name, NodeState before) {\n    childNodeChanged(name, before, EMPTY_NODE);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void childNodeDeleted(String name, NodeState before) {\n    childNodeChanged(name, before, EMPTY_NODE);\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8468597648408377, "fo": -0.4166666666666667, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4", "label": 1, "code": "private final Component children_set(int index, Component child) {\n    final Component replaced;\n    if (index < children_size()) {\n        if (children == null || children instanceof Component) {\n            replaced = (Component) children;\n            children = child;\n        } else {\n            final Component[] children = (Component[]) this.children;\n            replaced = children[index];\n            children[index] = child;\n        }\n    } else {\n        throw new IndexOutOfBoundsException();\n    }\n    return replaced != child ? replaced : null;\n}", "code_comment": NaN, "code_no_comment": "private final Component children_set(int index, Component child) {\n    final Component replaced;\n    if (index < children_size()) {\n        if (children == null || children instanceof Component) {\n            replaced = (Component) children;\n            children = child;\n        } else {\n            final Component[] children = (Component[]) this.children;\n            replaced = children[index];\n            children[index] = child;\n        }\n    } else {\n        throw new IndexOutOfBoundsException();\n    }\n    return replaced != child ? replaced : null;\n}", "lc": 0.09090909090909091, "pi": 0.5612244897959184, "ma": 0.16666666666666666, "nbd": 0.0, "ml": 0.3333333333333333, "d": 0.9639149777558084, "mi": -0.05792945225121871, "fo": -0.4166666666666667, "r": 0.028571428571428574, "e": 0.3250500040688535}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4927_8c827e33", "label": 1, "code": "@Override\npublic void write(CharSequence sequence) {\n    writeBuffered();\n    originalResponse.write(sequence);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void write(CharSequence sequence) {\n    writeBuffered();\n    originalResponse.write(sequence);\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7912245483223405, "fo": -0.3333333333333333, "r": 1.5142857142857145, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1877_716e1237", "label": 0, "code": "@Override\npublic synchronized void run() {\n    log.debug(\"Running background index task {}\", name);\n    if (isAlreadyRunning(store, name)) {\n        log.debug(\"The {} indexer is already running; skipping this update\", name);\n        return;\n    }\n    NodeState before;\n    NodeState root = store.getRoot();\n    String refCheckpoint = root.getChildNode(ASYNC).getString(name);\n    if (refCheckpoint != null) {\n        NodeState state = store.retrieve(refCheckpoint);\n        if (state == null) {\n            log.warn(\"Failed to retrieve previously indexed checkpoint {};\" + \" rerunning the initial {} index update\", refCheckpoint, name);\n            before = MISSING_NODE;\n        } else if (noVisibleChanges(state, root)) {\n            log.debug(\"No changes since last checkpoint;\" + \" skipping the {} index update\", name);\n            return;\n        } else {\n            before = state;\n        }\n    } else {\n        log.info(\"Initial {} index update\", name);\n        before = MISSING_NODE;\n    }\n    String checkpoint = store.checkpoint(lifetime);\n    NodeState after = store.retrieve(checkpoint);\n    if (after == null) {\n        log.warn(\"Unable to retrieve newly created checkpoint {},\" + \" skipping the {} index update\", checkpoint, name);\n        return;\n    }\n    NodeBuilder builder = store.getRoot().builder();\n    NodeBuilder async = builder.child(ASYNC);\n    AsyncUpdateCallback callback = new AsyncUpdateCallback();\n    preAsyncRunStatsStats(indexStats);\n    IndexUpdate indexUpdate = new IndexUpdate(provider, name, after, builder, callback);\n    CommitFailedException exception = EditorDiff.process(indexUpdate, before, after);\n    if (exception == null) {\n        if (callback.dirty) {\n            async.setProperty(name, checkpoint);\n            try {\n                store.merge(builder, newCommitHook(name, refCheckpoint), CommitInfo.EMPTY);\n            } catch (CommitFailedException e) {\n                if (e != CONCURRENT_UPDATE) {\n                    exception = e;\n                }\n            }\n            if (switchOnSync) {\n                reindexedDefinitions.addAll(indexUpdate.getReindexedDefinitions());\n            }\n        } else if (switchOnSync) {\n            log.debug(\"No changes detected after diff, will try to switch to synchronous updates on \" + reindexedDefinitions);\n            async.setProperty(name, checkpoint);\n            // no changes after diff, switch to sync on the async defs\n            for (String path : reindexedDefinitions) {\n                NodeBuilder c = builder;\n                for (String p : elements(path)) {\n                    c = c.getChildNode(p);\n                }\n                if (c.exists() && !c.getBoolean(REINDEX_PROPERTY_NAME)) {\n                    c.removeProperty(ASYNC_PROPERTY_NAME);\n                }\n            }\n            try {\n                store.merge(builder, newCommitHook(name, refCheckpoint), CommitInfo.EMPTY);\n                reindexedDefinitions.clear();\n            } catch (CommitFailedException e) {\n                if (e != CONCURRENT_UPDATE) {\n                    exception = e;\n                }\n            }\n        }\n    }\n    postAsyncRunStatsStatus(indexStats);\n    // checkpoints cleanup\n    if (exception != null || (exception == null && !callback.dirty)) {\n        log.debug(\"The {} index update failed; releasing the related checkpoint {}\", name, checkpoint);\n        store.release(checkpoint);\n    } else {\n        if (refCheckpoint != null) {\n            log.debug(\"The {} index update succeeded; releasing the previous checkpoint {}\", name, refCheckpoint);\n            store.release(refCheckpoint);\n        }\n    }\n    if (exception != null) {\n        if (!failing) {\n            log.warn(\"Index update {} failed\", name, exception);\n        }\n        failing = true;\n    } else {\n        if (failing) {\n            log.info(\"Index update {} no longer fails\", name);\n        }\n        failing = false;\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic synchronized void run() {\n    log.debug(\"Running background index task {}\", name);\n    if (isAlreadyRunning(store, name)) {\n        log.debug(\"The {} indexer is already running; skipping this update\", name);\n        return;\n    }\n    NodeState before;\n    NodeState root = store.getRoot();\n    String refCheckpoint = root.getChildNode(ASYNC).getString(name);\n    if (refCheckpoint != null) {\n        NodeState state = store.retrieve(refCheckpoint);\n        if (state == null) {\n            log.warn(\"Failed to retrieve previously indexed checkpoint {};\" + \" rerunning the initial {} index update\", refCheckpoint, name);\n            before = MISSING_NODE;\n        } else if (noVisibleChanges(state, root)) {\n            log.debug(\"No changes since last checkpoint;\" + \" skipping the {} index update\", name);\n            return;\n        } else {\n            before = state;\n        }\n    } else {\n        log.info(\"Initial {} index update\", name);\n        before = MISSING_NODE;\n    }\n    String checkpoint = store.checkpoint(lifetime);\n    NodeState after = store.retrieve(checkpoint);\n    if (after == null) {\n        log.warn(\"Unable to retrieve newly created checkpoint {},\" + \" skipping the {} index update\", checkpoint, name);\n        return;\n    }\n    NodeBuilder builder = store.getRoot().builder();\n    NodeBuilder async = builder.child(ASYNC);\n    AsyncUpdateCallback callback = new AsyncUpdateCallback();\n    preAsyncRunStatsStats(indexStats);\n    IndexUpdate indexUpdate = new IndexUpdate(provider, name, after, builder, callback);\n    CommitFailedException exception = EditorDiff.process(indexUpdate, before, after);\n    if (exception == null) {\n        if (callback.dirty) {\n            async.setProperty(name, checkpoint);\n            try {\n                store.merge(builder, newCommitHook(name, refCheckpoint), CommitInfo.EMPTY);\n            } catch (CommitFailedException e) {\n                if (e != CONCURRENT_UPDATE) {\n                    exception = e;\n                }\n            }\n            if (switchOnSync) {\n                reindexedDefinitions.addAll(indexUpdate.getReindexedDefinitions());\n            }\n        } else if (switchOnSync) {\n            log.debug(\"No changes detected after diff, will try to switch to synchronous updates on \" + reindexedDefinitions);\n            async.setProperty(name, checkpoint);\n                        for (String path : reindexedDefinitions) {\n                NodeBuilder c = builder;\n                for (String p : elements(path)) {\n                    c = c.getChildNode(p);\n                }\n                if (c.exists() && !c.getBoolean(REINDEX_PROPERTY_NAME)) {\n                    c.removeProperty(ASYNC_PROPERTY_NAME);\n                }\n            }\n            try {\n                store.merge(builder, newCommitHook(name, refCheckpoint), CommitInfo.EMPTY);\n                reindexedDefinitions.clear();\n            } catch (CommitFailedException e) {\n                if (e != CONCURRENT_UPDATE) {\n                    exception = e;\n                }\n            }\n        }\n    }\n    postAsyncRunStatsStatus(indexStats);\n        if (exception != null || (exception == null && !callback.dirty)) {\n        log.debug(\"The {} index update failed; releasing the related checkpoint {}\", name, checkpoint);\n        store.release(checkpoint);\n    } else {\n        if (refCheckpoint != null) {\n            log.debug(\"The {} index update succeeded; releasing the previous checkpoint {}\", name, refCheckpoint);\n            store.release(refCheckpoint);\n        }\n    }\n    if (exception != null) {\n        if (!failing) {\n            log.warn(\"Index update {} failed\", name, exception);\n        }\n        failing = true;\n    } else {\n        if (failing) {\n            log.info(\"Index update {} no longer fails\", name);\n        }\n        failing = false;\n    }\n}", "lc": 3.6363636363636362, "pi": 0.9744897959183673, "ma": 3.0, "nbd": 1.5, "ml": 2.5, "d": 1.2466633712308457, "mi": -1.3386865500430172, "fo": 2.9166666666666665, "r": -0.028571428571428574, "e": 5.863188011015886}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2658_ce68cbd9", "label": 1, "code": "/**\n *  Creates a Flink program that uses the specified spouts and bolts.\n */\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\npublic FlinkTopology createTopology() {\n    final StormTopology stormTopolgoy = this.stormBuilder.createTopology();\n    final FlinkTopology env = new FlinkTopology(stormTopolgoy);\n    env.setParallelism(1);\n    final HashMap<String, HashMap<String, DataStream>> availableInputs = new HashMap<String, HashMap<String, DataStream>>();\n    for (final Entry<String, IRichSpout> spout : this.spouts.entrySet()) {\n        final String spoutId = spout.getKey();\n        final IRichSpout userSpout = spout.getValue();\n        final FlinkOutputFieldsDeclarer declarer = new FlinkOutputFieldsDeclarer();\n        userSpout.declareOutputFields(declarer);\n        final HashMap<String, Fields> sourceStreams = declarer.outputStreams;\n        this.outputStreams.put(spoutId, sourceStreams);\n        declarers.put(spoutId, declarer);\n        AbstractStormSpoutWrapper spoutWrapper;\n        if (userSpout instanceof FiniteStormSpout) {\n            spoutWrapper = new FiniteStormSpoutWrapper((FiniteStormSpout) userSpout);\n        } else {\n            spoutWrapper = new StormSpoutWrapper(userSpout);\n        }\n        DataStreamSource source;\n        HashMap<String, DataStream> outputStreams = new HashMap<String, DataStream>();\n        if (sourceStreams.size() == 1) {\n            final String outputStreamId = (String) sourceStreams.keySet().toArray()[0];\n            source = env.addSource(spoutWrapper, spoutId, declarer.getOutputType(outputStreamId));\n            outputStreams.put(outputStreamId, source);\n        } else {\n            source = env.addSource(spoutWrapper, spoutId, TypeExtractor.getForClass(SplitStreamType.class));\n            SplitDataStream splitSource = source.split(new FlinkStormStreamSelector());\n            for (String streamId : sourceStreams.keySet()) {\n                outputStreams.put(streamId, splitSource.select(streamId));\n            }\n        }\n        availableInputs.put(spoutId, outputStreams);\n        int dop = 1;\n        final ComponentCommon common = stormTopolgoy.get_spouts().get(spoutId).get_common();\n        if (common.is_set_parallelism_hint()) {\n            dop = common.get_parallelism_hint();\n            source.setParallelism(dop);\n        }\n        env.increaseNumberOfTasks(dop);\n    }\n    final HashMap<String, IRichBolt> unprocessedBolts = new HashMap<String, IRichBolt>();\n    unprocessedBolts.putAll(this.bolts);\n    final HashMap<String, Set<Entry<GlobalStreamId, Grouping>>> unprocessdInputsPerBolt = new HashMap<String, Set<Entry<GlobalStreamId, Grouping>>>();\n    /* Because we do not know the order in which an iterator steps over a set, we might process a consumer before\n\t\t * its producer\n\t\t * ->thus, we might need to repeat multiple times\n\t\t */\n    boolean makeProgress = true;\n    while (unprocessedBolts.size() > 0) {\n        if (!makeProgress) {\n            throw new RuntimeException(\"Unable to build Topology. Could not connect the following bolts: \" + unprocessedBolts.keySet());\n        }\n        makeProgress = false;\n        final Iterator<Entry<String, IRichBolt>> boltsIterator = unprocessedBolts.entrySet().iterator();\n        while (boltsIterator.hasNext()) {\n            final Entry<String, IRichBolt> bolt = boltsIterator.next();\n            final String boltId = bolt.getKey();\n            final IRichBolt userBolt = bolt.getValue();\n            final ComponentCommon common = stormTopolgoy.get_bolts().get(boltId).get_common();\n            Set<Entry<GlobalStreamId, Grouping>> unprocessedInputs = unprocessdInputsPerBolt.get(boltId);\n            if (unprocessedInputs == null) {\n                unprocessedInputs = new HashSet<Entry<GlobalStreamId, Grouping>>();\n                unprocessedInputs.addAll(common.get_inputs().entrySet());\n                unprocessdInputsPerBolt.put(boltId, unprocessedInputs);\n            }\n            // connect each available producer to the current bolt\n            final Iterator<Entry<GlobalStreamId, Grouping>> inputStreamsIterator = unprocessedInputs.iterator();\n            while (inputStreamsIterator.hasNext()) {\n                final Entry<GlobalStreamId, Grouping> stormInputStream = inputStreamsIterator.next();\n                final String producerId = stormInputStream.getKey().get_componentId();\n                final String inputStreamId = stormInputStream.getKey().get_streamId();\n                HashMap<String, DataStream> producer = availableInputs.get(producerId);\n                if (producer != null) {\n                    makeProgress = true;\n                    DataStream inputStream = producer.get(inputStreamId);\n                    if (inputStream != null) {\n                        final FlinkOutputFieldsDeclarer declarer = new FlinkOutputFieldsDeclarer();\n                        userBolt.declareOutputFields(declarer);\n                        final HashMap<String, Fields> boltOutputStreams = declarer.outputStreams;\n                        this.outputStreams.put(boltId, boltOutputStreams);\n                        this.declarers.put(boltId, declarer);\n                        // if producer was processed already\n                        final Grouping grouping = stormInputStream.getValue();\n                        if (grouping.is_set_shuffle()) {\n                            // Storm uses a round-robin shuffle strategy\n                            inputStream = inputStream.rebalance();\n                        } else if (grouping.is_set_fields()) {\n                            // global grouping is emulated in Storm via an empty fields grouping list\n                            final List<String> fields = grouping.get_fields();\n                            if (fields.size() > 0) {\n                                FlinkOutputFieldsDeclarer prodDeclarer = this.declarers.get(producerId);\n                                inputStream = inputStream.groupBy(prodDeclarer.getGroupingFieldIndexes(inputStreamId, grouping.get_fields()));\n                            } else {\n                                inputStream = inputStream.global();\n                            }\n                        } else if (grouping.is_set_all()) {\n                            inputStream = inputStream.broadcast();\n                        } else if (!grouping.is_set_local_or_shuffle()) {\n                            throw new UnsupportedOperationException(\"Flink only supports (local-or-)shuffle, fields, all, and global grouping\");\n                        }\n                        SingleOutputStreamOperator outputStream;\n                        if (boltOutputStreams.size() < 2) {\n                            // single output stream or sink\n                            String outputStreamId = null;\n                            if (boltOutputStreams.size() == 1) {\n                                outputStreamId = (String) boltOutputStreams.keySet().toArray()[0];\n                            }\n                            final TypeInformation<?> outType = declarer.getOutputType(outputStreamId);\n                            outputStream = inputStream.transform(boltId, outType, new StormBoltWrapper(userBolt, this.outputStreams.get(producerId).get(inputStreamId)));\n                            if (outType != null) {\n                                // only for non-sink nodes\n                                HashMap<String, DataStream> op = new HashMap<String, DataStream>();\n                                op.put(outputStreamId, outputStream);\n                                availableInputs.put(boltId, op);\n                            }\n                        } else {\n                            final TypeInformation<?> outType = TypeExtractor.getForClass(SplitStreamType.class);\n                            outputStream = inputStream.transform(boltId, outType, new StormBoltWrapper(userBolt, this.outputStreams.get(producerId).get(inputStreamId)));\n                            SplitDataStream splitStreams = outputStream.split(new FlinkStormStreamSelector());\n                            HashMap<String, DataStream> op = new HashMap<String, DataStream>();\n                            for (String outputStreamId : boltOutputStreams.keySet()) {\n                                op.put(outputStreamId, splitStreams.select(outputStreamId));\n                            }\n                            availableInputs.put(boltId, op);\n                        }\n                        int dop = 1;\n                        if (common.is_set_parallelism_hint()) {\n                            dop = common.get_parallelism_hint();\n                            outputStream.setParallelism(dop);\n                        }\n                        env.increaseNumberOfTasks(dop);\n                        inputStreamsIterator.remove();\n                    } else {\n                        throw new RuntimeException(\"Cannot connect '\" + boltId + \"' to '\" + producerId + \"'. Stream '\" + inputStreamId + \"' not found.\");\n                    }\n                }\n            }\n            if (unprocessedInputs.size() == 0) {\n                // all inputs are connected; processing bolt completed\n                boltsIterator.remove();\n            }\n        }\n    }\n    return env;\n}", "code_comment": "/**\n *  Creates a Flink program that uses the specified spouts and bolts.\n */\n", "code_no_comment": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\npublic FlinkTopology createTopology() {\n    final StormTopology stormTopolgoy = this.stormBuilder.createTopology();\n    final FlinkTopology env = new FlinkTopology(stormTopolgoy);\n    env.setParallelism(1);\n    final HashMap<String, HashMap<String, DataStream>> availableInputs = new HashMap<String, HashMap<String, DataStream>>();\n    for (final Entry<String, IRichSpout> spout : this.spouts.entrySet()) {\n        final String spoutId = spout.getKey();\n        final IRichSpout userSpout = spout.getValue();\n        final FlinkOutputFieldsDeclarer declarer = new FlinkOutputFieldsDeclarer();\n        userSpout.declareOutputFields(declarer);\n        final HashMap<String, Fields> sourceStreams = declarer.outputStreams;\n        this.outputStreams.put(spoutId, sourceStreams);\n        declarers.put(spoutId, declarer);\n        AbstractStormSpoutWrapper spoutWrapper;\n        if (userSpout instanceof FiniteStormSpout) {\n            spoutWrapper = new FiniteStormSpoutWrapper((FiniteStormSpout) userSpout);\n        } else {\n            spoutWrapper = new StormSpoutWrapper(userSpout);\n        }\n        DataStreamSource source;\n        HashMap<String, DataStream> outputStreams = new HashMap<String, DataStream>();\n        if (sourceStreams.size() == 1) {\n            final String outputStreamId = (String) sourceStreams.keySet().toArray()[0];\n            source = env.addSource(spoutWrapper, spoutId, declarer.getOutputType(outputStreamId));\n            outputStreams.put(outputStreamId, source);\n        } else {\n            source = env.addSource(spoutWrapper, spoutId, TypeExtractor.getForClass(SplitStreamType.class));\n            SplitDataStream splitSource = source.split(new FlinkStormStreamSelector());\n            for (String streamId : sourceStreams.keySet()) {\n                outputStreams.put(streamId, splitSource.select(streamId));\n            }\n        }\n        availableInputs.put(spoutId, outputStreams);\n        int dop = 1;\n        final ComponentCommon common = stormTopolgoy.get_spouts().get(spoutId).get_common();\n        if (common.is_set_parallelism_hint()) {\n            dop = common.get_parallelism_hint();\n            source.setParallelism(dop);\n        }\n        env.increaseNumberOfTasks(dop);\n    }\n    final HashMap<String, IRichBolt> unprocessedBolts = new HashMap<String, IRichBolt>();\n    unprocessedBolts.putAll(this.bolts);\n    final HashMap<String, Set<Entry<GlobalStreamId, Grouping>>> unprocessdInputsPerBolt = new HashMap<String, Set<Entry<GlobalStreamId, Grouping>>>();\n        boolean makeProgress = true;\n    while (unprocessedBolts.size() > 0) {\n        if (!makeProgress) {\n            throw new RuntimeException(\"Unable to build Topology. Could not connect the following bolts: \" + unprocessedBolts.keySet());\n        }\n        makeProgress = false;\n        final Iterator<Entry<String, IRichBolt>> boltsIterator = unprocessedBolts.entrySet().iterator();\n        while (boltsIterator.hasNext()) {\n            final Entry<String, IRichBolt> bolt = boltsIterator.next();\n            final String boltId = bolt.getKey();\n            final IRichBolt userBolt = bolt.getValue();\n            final ComponentCommon common = stormTopolgoy.get_bolts().get(boltId).get_common();\n            Set<Entry<GlobalStreamId, Grouping>> unprocessedInputs = unprocessdInputsPerBolt.get(boltId);\n            if (unprocessedInputs == null) {\n                unprocessedInputs = new HashSet<Entry<GlobalStreamId, Grouping>>();\n                unprocessedInputs.addAll(common.get_inputs().entrySet());\n                unprocessdInputsPerBolt.put(boltId, unprocessedInputs);\n            }\n                        final Iterator<Entry<GlobalStreamId, Grouping>> inputStreamsIterator = unprocessedInputs.iterator();\n            while (inputStreamsIterator.hasNext()) {\n                final Entry<GlobalStreamId, Grouping> stormInputStream = inputStreamsIterator.next();\n                final String producerId = stormInputStream.getKey().get_componentId();\n                final String inputStreamId = stormInputStream.getKey().get_streamId();\n                HashMap<String, DataStream> producer = availableInputs.get(producerId);\n                if (producer != null) {\n                    makeProgress = true;\n                    DataStream inputStream = producer.get(inputStreamId);\n                    if (inputStream != null) {\n                        final FlinkOutputFieldsDeclarer declarer = new FlinkOutputFieldsDeclarer();\n                        userBolt.declareOutputFields(declarer);\n                        final HashMap<String, Fields> boltOutputStreams = declarer.outputStreams;\n                        this.outputStreams.put(boltId, boltOutputStreams);\n                        this.declarers.put(boltId, declarer);\n                                                final Grouping grouping = stormInputStream.getValue();\n                        if (grouping.is_set_shuffle()) {\n                                                        inputStream = inputStream.rebalance();\n                        } else if (grouping.is_set_fields()) {\n                                                        final List<String> fields = grouping.get_fields();\n                            if (fields.size() > 0) {\n                                FlinkOutputFieldsDeclarer prodDeclarer = this.declarers.get(producerId);\n                                inputStream = inputStream.groupBy(prodDeclarer.getGroupingFieldIndexes(inputStreamId, grouping.get_fields()));\n                            } else {\n                                inputStream = inputStream.global();\n                            }\n                        } else if (grouping.is_set_all()) {\n                            inputStream = inputStream.broadcast();\n                        } else if (!grouping.is_set_local_or_shuffle()) {\n                            throw new UnsupportedOperationException(\"Flink only supports (local-or-)shuffle, fields, all, and global grouping\");\n                        }\n                        SingleOutputStreamOperator outputStream;\n                        if (boltOutputStreams.size() < 2) {\n                                                        String outputStreamId = null;\n                            if (boltOutputStreams.size() == 1) {\n                                outputStreamId = (String) boltOutputStreams.keySet().toArray()[0];\n                            }\n                            final TypeInformation<?> outType = declarer.getOutputType(outputStreamId);\n                            outputStream = inputStream.transform(boltId, outType, new StormBoltWrapper(userBolt, this.outputStreams.get(producerId).get(inputStreamId)));\n                            if (outType != null) {\n                                                                HashMap<String, DataStream> op = new HashMap<String, DataStream>();\n                                op.put(outputStreamId, outputStream);\n                                availableInputs.put(boltId, op);\n                            }\n                        } else {\n                            final TypeInformation<?> outType = TypeExtractor.getForClass(SplitStreamType.class);\n                            outputStream = inputStream.transform(boltId, outType, new StormBoltWrapper(userBolt, this.outputStreams.get(producerId).get(inputStreamId)));\n                            SplitDataStream splitStreams = outputStream.split(new FlinkStormStreamSelector());\n                            HashMap<String, DataStream> op = new HashMap<String, DataStream>();\n                            for (String outputStreamId : boltOutputStreams.keySet()) {\n                                op.put(outputStreamId, splitStreams.select(outputStreamId));\n                            }\n                            availableInputs.put(boltId, op);\n                        }\n                        int dop = 1;\n                        if (common.is_set_parallelism_hint()) {\n                            dop = common.get_parallelism_hint();\n                            outputStream.setParallelism(dop);\n                        }\n                        env.increaseNumberOfTasks(dop);\n                        inputStreamsIterator.remove();\n                    } else {\n                        throw new RuntimeException(\"Cannot connect '\" + boltId + \"' to '\" + producerId + \"'. Stream '\" + inputStreamId + \"' not found.\");\n                    }\n                }\n            }\n            if (unprocessedInputs.size() == 0) {\n                                boltsIterator.remove();\n            }\n        }\n    }\n    return env;\n}", "lc": 5.545454545454546, "pi": 3.1632653061224496, "ma": 3.8333333333333335, "nbd": 3.5, "ml": 2.75, "d": 1.7528423133959465, "mi": -1.6638944651562955, "fo": 7.583333333333333, "r": -0.028571428571428574, "e": 17.569194067183197}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_add180fb", "label": 1, "code": "@Override\npublic void delete(String tableName) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n    acu.tables.remove(tableName);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void delete(String tableName) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n    acu.tables.remove(tableName);\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8210496128477202, "fo": -0.4166666666666667, "r": 0.20000000000000004, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-393_d4b02f6a", "label": 3, "code": "/**\n * Get the number of evaluations of the objective function.\n * <p>\n * The number of evaluations corresponds to the last call to the\n * {@link #optimize(UnivariateRealFunction, GoalType, double, double) optimize}\n * method. It is 0 if the method has not been called yet.\n * </p>\n * @return number of evaluations of the objective function\n */\nint getEvaluations();", "code_comment": "/**\n * Get the number of evaluations of the objective function.\n * <p>\n * The number of evaluations corresponds to the last call to the\n * {@link #optimize(UnivariateRealFunction, GoalType, double, double) optimize}\n * method. It is 0 if the method has not been called yet.\n * </p>\n * @return number of evaluations of the objective function\n */\n", "code_no_comment": "int getEvaluations();", "lc": -0.5909090909090909, "pi": -1.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.9174075136220248, "fo": -0.5, "r": 2.742857142857143, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1081_4ce4e3c9", "label": 3, "code": "@Override\npublic boolean apply(Tree tree) {\n    return !tree.getName().startsWith(\":\");\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean apply(Tree tree) {\n    return !tree.getName().startsWith(\":\");\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8611987381703473, "fo": -0.3333333333333333, "r": 1.6285714285714286, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1227_117b0a3d", "label": 1, "code": "@Override\npublic boolean hasProperty(String relPath) throws RepositoryException {\n    final String oakPath = getOakPathOrThrow(relPath);\n    return perform(new NodeOperation<Boolean>(dlg) {\n\n        @Override\n        public Boolean perform() throws RepositoryException {\n            return node.getPropertyOrNull(oakPath) != null;\n        }\n    });\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean hasProperty(String relPath) throws RepositoryException {\n    final String oakPath = getOakPathOrThrow(relPath);\n    return perform(new NodeOperation<Boolean>(dlg) {\n\n        @Override\n        public Boolean perform() throws RepositoryException {\n            return node.getPropertyOrNull(oakPath) != null;\n        }\n    });\n}", "lc": -0.18181818181818182, "pi": 0.4591836734693877, "ma": -0.5, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.08996539792387542, "mi": 0.266991683395469, "fo": -0.25, "r": 1.6857142857142857, "e": -0.10260363798339052}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-846_7acb091a", "label": 3, "code": "@Override\nvoid uncommittedModification(Revision uncommitted) {\n    if (collisions.get() == null) {\n        collisions.set(new ArrayList<Revision>());\n    }\n    collisions.get().add(uncommitted);\n}", "code_comment": NaN, "code_no_comment": "@Override\nvoid uncommittedModification(Revision uncommitted) {\n    if (collisions.get() == null) {\n        collisions.set(new ArrayList<Revision>());\n    }\n    collisions.get().add(uncommitted);\n}", "lc": -0.3181818181818182, "pi": -0.11224489795918377, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.3806228373702422, "mi": 0.49698881560080305, "fo": -0.16666666666666666, "r": 0.4857142857142857, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-428_4a6a573b", "label": 3, "code": "public Object next() {\n    // Find next key\n    i = nextKey(nextIndex(i));\n    // Just in case... (WICKET-428)\n    if (!hasNext()) {\n        throw new NoSuchElementException();\n    }\n    // Get key\n    return keys[i];\n}", "code_comment": NaN, "code_no_comment": "public Object next() {\n        i = nextKey(nextIndex(i));\n        if (!hasNext()) {\n        throw new NoSuchElementException();\n    }\n        return keys[i];\n}", "lc": -0.3181818181818182, "pi": -0.2346938775510204, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.25, "d": -0.1393969352446861, "mi": 0.5357040435904789, "fo": -0.25, "r": 2.7714285714285714, "e": -0.140683824379714}
{"project_name": "Math", "project_version": 6, "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\nprotected PointValuePair doOptimize() {\n    checkParameters();\n    // Indirect call to \"computeObjectiveValue\" in order to update the\n    // evaluations counter.\n    final MultivariateFunction evalFunc = new MultivariateFunction() {\n\n        public double value(double[] point) {\n            return computeObjectiveValue(point);\n        }\n    };\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n    final Comparator<PointValuePair> comparator = new Comparator<PointValuePair>() {\n\n        public int compare(final PointValuePair o1, final PointValuePair o2) {\n            final double v1 = o1.getValue();\n            final double v2 = o2.getValue();\n            return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\n        }\n    };\n    // Initialize search.\n    simplex.build(getStartPoint());\n    simplex.evaluate(evalFunc, comparator);\n    PointValuePair[] previous = null;\n    int iteration = 0;\n    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n    while (true) {\n        if (iteration > 0) {\n            boolean converged = true;\n            for (int i = 0; i < simplex.getSize(); i++) {\n                PointValuePair prev = previous[i];\n                converged = converged && checker.converged(iteration, prev, simplex.getPoint(i));\n            }\n            if (converged) {\n                // We have found an optimum.\n                return simplex.getPoint(0);\n            }\n        }\n        // We still need to search.\n        previous = simplex.getPoints();\n        simplex.iterate(evalFunc, comparator);\n        ++iteration;\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\nprotected PointValuePair doOptimize() {\n    checkParameters();\n            final MultivariateFunction evalFunc = new MultivariateFunction() {\n\n        public double value(double[] point) {\n            return computeObjectiveValue(point);\n        }\n    };\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n    final Comparator<PointValuePair> comparator = new Comparator<PointValuePair>() {\n\n        public int compare(final PointValuePair o1, final PointValuePair o2) {\n            final double v1 = o1.getValue();\n            final double v2 = o2.getValue();\n            return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\n        }\n    };\n        simplex.build(getStartPoint());\n    simplex.evaluate(evalFunc, comparator);\n    PointValuePair[] previous = null;\n    int iteration = 0;\n    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n    while (true) {\n        if (iteration > 0) {\n            boolean converged = true;\n            for (int i = 0; i < simplex.getSize(); i++) {\n                PointValuePair prev = previous[i];\n                converged = converged && checker.converged(iteration, prev, simplex.getPoint(i));\n            }\n            if (converged) {\n                                return simplex.getPoint(0);\n            }\n        }\n                previous = simplex.getPoints();\n        simplex.iterate(evalFunc, comparator);\n        ++iteration;\n    }\n}", "lc": 1.0454545454545454, "pi": 0.7244897959183676, "ma": 0.3333333333333333, "nbd": 0.5, "ml": 0.4166666666666667, "d": 0.9322787938704895, "mi": -0.6501290507599659, "fo": 0.9166666666666666, "r": -0.028571428571428574, "e": 1.6154505077500954}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-949_f83bbc1d", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\nprotected PointValuePair doOptimize() {\n    checkParameters();\n    // Indirect call to \"computeObjectiveValue\" in order to update the\n    // evaluations counter.\n    final MultivariateFunction evalFunc = new MultivariateFunction() {\n\n        public double value(double[] point) {\n            return computeObjectiveValue(point);\n        }\n    };\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n    final Comparator<PointValuePair> comparator = new Comparator<PointValuePair>() {\n\n        public int compare(final PointValuePair o1, final PointValuePair o2) {\n            final double v1 = o1.getValue();\n            final double v2 = o2.getValue();\n            return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\n        }\n    };\n    // Initialize search.\n    simplex.build(getStartPoint());\n    simplex.evaluate(evalFunc, comparator);\n    PointValuePair[] previous = null;\n    int iteration = 0;\n    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n    while (true) {\n        if (iteration > 0) {\n            boolean converged = true;\n            for (int i = 0; i < simplex.getSize(); i++) {\n                PointValuePair prev = previous[i];\n                converged = converged && checker.converged(iteration, prev, simplex.getPoint(i));\n            }\n            if (converged) {\n                // We have found an optimum.\n                return simplex.getPoint(0);\n            }\n        }\n        // We still need to search.\n        previous = simplex.getPoints();\n        simplex.iterate(evalFunc, comparator);\n        ++iteration;\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\nprotected PointValuePair doOptimize() {\n    checkParameters();\n            final MultivariateFunction evalFunc = new MultivariateFunction() {\n\n        public double value(double[] point) {\n            return computeObjectiveValue(point);\n        }\n    };\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n    final Comparator<PointValuePair> comparator = new Comparator<PointValuePair>() {\n\n        public int compare(final PointValuePair o1, final PointValuePair o2) {\n            final double v1 = o1.getValue();\n            final double v2 = o2.getValue();\n            return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\n        }\n    };\n        simplex.build(getStartPoint());\n    simplex.evaluate(evalFunc, comparator);\n    PointValuePair[] previous = null;\n    int iteration = 0;\n    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n    while (true) {\n        if (iteration > 0) {\n            boolean converged = true;\n            for (int i = 0; i < simplex.getSize(); i++) {\n                PointValuePair prev = previous[i];\n                converged = converged && checker.converged(iteration, prev, simplex.getPoint(i));\n            }\n            if (converged) {\n                                return simplex.getPoint(0);\n            }\n        }\n                previous = simplex.getPoints();\n        simplex.iterate(evalFunc, comparator);\n        ++iteration;\n    }\n}", "lc": 1.0454545454545454, "pi": 0.7244897959183676, "ma": 0.3333333333333333, "nbd": 0.5, "ml": 0.4166666666666667, "d": 0.9322787938704895, "mi": -0.6501290507599659, "fo": 0.9166666666666666, "r": -0.028571428571428574, "e": 1.6154505077500954}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1122_5286861d", "label": 3, "code": "public String commit(String path, String jsonDiff, String revisionId, String message) throws MicroKernelException {\n    if (rep == null) {\n        throw new IllegalStateException(\"this instance has already been disposed\");\n    }\n    if (path.length() > 0 && !PathUtils.isAbsolute(path)) {\n        throw new IllegalArgumentException(\"absolute path expected: \" + path);\n    }\n    if (jsonDiff == null || jsonDiff.length() == 0) {\n        return getHeadRevision();\n    }\n    Id revId = revisionId == null ? getHeadRevisionId() : Id.fromString(revisionId);\n    try {\n        JsopTokenizer t = new JsopTokenizer(jsonDiff);\n        CommitBuilder cb = rep.getCommitBuilder(revId, message);\n        while (true) {\n            int r = t.read();\n            if (r == JsopReader.END) {\n                break;\n            }\n            // used for error reporting\n            int pos;\n            switch(r) {\n                case '+':\n                    {\n                        pos = t.getLastPos();\n                        String subPath = t.readString();\n                        t.read(':');\n                        t.read('{');\n                        String nodePath = PathUtils.concat(path, subPath);\n                        if (!PathUtils.isAbsolute(nodePath)) {\n                            throw new Exception(\"absolute path expected: \" + nodePath + \", pos: \" + pos);\n                        }\n                        String parentPath = PathUtils.getParentPath(nodePath);\n                        String nodeName = PathUtils.getName(nodePath);\n                        cb.addNode(parentPath, nodeName, JsonObject.create(t));\n                        break;\n                    }\n                case '-':\n                    {\n                        pos = t.getLastPos();\n                        String subPath = t.readString();\n                        String targetPath = PathUtils.concat(path, subPath);\n                        if (!PathUtils.isAbsolute(targetPath)) {\n                            throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\n                        }\n                        cb.removeNode(targetPath);\n                        break;\n                    }\n                case '^':\n                    {\n                        pos = t.getLastPos();\n                        String subPath = t.readString();\n                        t.read(':');\n                        String value;\n                        if (t.matches(JsopReader.NULL)) {\n                            value = null;\n                        } else {\n                            value = t.readRawValue().trim();\n                        }\n                        String targetPath = PathUtils.concat(path, subPath);\n                        if (!PathUtils.isAbsolute(targetPath)) {\n                            throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\n                        }\n                        String parentPath = PathUtils.getParentPath(targetPath);\n                        String propName = PathUtils.getName(targetPath);\n                        cb.setProperty(parentPath, propName, value);\n                        break;\n                    }\n                case '>':\n                    {\n                        pos = t.getLastPos();\n                        String subPath = t.readString();\n                        String srcPath = PathUtils.concat(path, subPath);\n                        if (!PathUtils.isAbsolute(srcPath)) {\n                            throw new Exception(\"absolute path expected: \" + srcPath + \", pos: \" + pos);\n                        }\n                        t.read(':');\n                        pos = t.getLastPos();\n                        String targetPath = t.readString();\n                        if (!PathUtils.isAbsolute(targetPath)) {\n                            targetPath = PathUtils.concat(path, targetPath);\n                            if (!PathUtils.isAbsolute(targetPath)) {\n                                throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\n                            }\n                        }\n                        cb.moveNode(srcPath, targetPath);\n                        break;\n                    }\n                case '*':\n                    {\n                        pos = t.getLastPos();\n                        String subPath = t.readString();\n                        String srcPath = PathUtils.concat(path, subPath);\n                        if (!PathUtils.isAbsolute(srcPath)) {\n                            throw new Exception(\"absolute path expected: \" + srcPath + \", pos: \" + pos);\n                        }\n                        t.read(':');\n                        pos = t.getLastPos();\n                        String targetPath = t.readString();\n                        if (!PathUtils.isAbsolute(targetPath)) {\n                            targetPath = PathUtils.concat(path, targetPath);\n                            if (!PathUtils.isAbsolute(targetPath)) {\n                                throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\n                            }\n                        }\n                        cb.copyNode(srcPath, targetPath);\n                        break;\n                    }\n                default:\n                    throw new IllegalArgumentException(\"jsonDiff: illegal token '\" + t.getToken() + \"' at pos: \" + t.getLastPos());\n            }\n        }\n        Id newHead = cb.doCommit();\n        if (!newHead.equals(revId)) {\n            // non-empty commit\n            if (rep.getCommit(newHead).getBranchRootId() == null) {\n                // OAK-265: only trigger commit gate for non-branch commits\n                gate.commit(newHead.toString());\n            }\n        }\n        return newHead.toString();\n    } catch (Exception e) {\n        throw new MicroKernelException(e);\n    }\n}", "code_comment": NaN, "code_no_comment": "public String commit(String path, String jsonDiff, String revisionId, String message) throws MicroKernelException {\n    if (rep == null) {\n        throw new IllegalStateException(\"this instance has already been disposed\");\n    }\n    if (path.length() > 0 && !PathUtils.isAbsolute(path)) {\n        throw new IllegalArgumentException(\"absolute path expected: \" + path);\n    }\n    if (jsonDiff == null || jsonDiff.length() == 0) {\n        return getHeadRevision();\n    }\n    Id revId = revisionId == null ? getHeadRevisionId() : Id.fromString(revisionId);\n    try {\n        JsopTokenizer t = new JsopTokenizer(jsonDiff);\n        CommitBuilder cb = rep.getCommitBuilder(revId, message);\n        while (true) {\n            int r = t.read();\n            if (r == JsopReader.END) {\n                break;\n            }\n                        int pos;\n            switch(r) {\n                case '+':\n                    {\n                        pos = t.getLastPos();\n                        String subPath = t.readString();\n                        t.read(':');\n                        t.read('{');\n                        String nodePath = PathUtils.concat(path, subPath);\n                        if (!PathUtils.isAbsolute(nodePath)) {\n                            throw new Exception(\"absolute path expected: \" + nodePath + \", pos: \" + pos);\n                        }\n                        String parentPath = PathUtils.getParentPath(nodePath);\n                        String nodeName = PathUtils.getName(nodePath);\n                        cb.addNode(parentPath, nodeName, JsonObject.create(t));\n                        break;\n                    }\n                case '-':\n                    {\n                        pos = t.getLastPos();\n                        String subPath = t.readString();\n                        String targetPath = PathUtils.concat(path, subPath);\n                        if (!PathUtils.isAbsolute(targetPath)) {\n                            throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\n                        }\n                        cb.removeNode(targetPath);\n                        break;\n                    }\n                case '^':\n                    {\n                        pos = t.getLastPos();\n                        String subPath = t.readString();\n                        t.read(':');\n                        String value;\n                        if (t.matches(JsopReader.NULL)) {\n                            value = null;\n                        } else {\n                            value = t.readRawValue().trim();\n                        }\n                        String targetPath = PathUtils.concat(path, subPath);\n                        if (!PathUtils.isAbsolute(targetPath)) {\n                            throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\n                        }\n                        String parentPath = PathUtils.getParentPath(targetPath);\n                        String propName = PathUtils.getName(targetPath);\n                        cb.setProperty(parentPath, propName, value);\n                        break;\n                    }\n                case '>':\n                    {\n                        pos = t.getLastPos();\n                        String subPath = t.readString();\n                        String srcPath = PathUtils.concat(path, subPath);\n                        if (!PathUtils.isAbsolute(srcPath)) {\n                            throw new Exception(\"absolute path expected: \" + srcPath + \", pos: \" + pos);\n                        }\n                        t.read(':');\n                        pos = t.getLastPos();\n                        String targetPath = t.readString();\n                        if (!PathUtils.isAbsolute(targetPath)) {\n                            targetPath = PathUtils.concat(path, targetPath);\n                            if (!PathUtils.isAbsolute(targetPath)) {\n                                throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\n                            }\n                        }\n                        cb.moveNode(srcPath, targetPath);\n                        break;\n                    }\n                case '*':\n                    {\n                        pos = t.getLastPos();\n                        String subPath = t.readString();\n                        String srcPath = PathUtils.concat(path, subPath);\n                        if (!PathUtils.isAbsolute(srcPath)) {\n                            throw new Exception(\"absolute path expected: \" + srcPath + \", pos: \" + pos);\n                        }\n                        t.read(':');\n                        pos = t.getLastPos();\n                        String targetPath = t.readString();\n                        if (!PathUtils.isAbsolute(targetPath)) {\n                            targetPath = PathUtils.concat(path, targetPath);\n                            if (!PathUtils.isAbsolute(targetPath)) {\n                                throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\n                            }\n                        }\n                        cb.copyNode(srcPath, targetPath);\n                        break;\n                    }\n                default:\n                    throw new IllegalArgumentException(\"jsonDiff: illegal token '\" + t.getToken() + \"' at pos: \" + t.getLastPos());\n            }\n        }\n        Id newHead = cb.doCommit();\n        if (!newHead.equals(revId)) {\n                        if (rep.getCommit(newHead).getBranchRootId() == null) {\n                                gate.commit(newHead.toString());\n            }\n        }\n        return newHead.toString();\n    } catch (Exception e) {\n        throw new MicroKernelException(e);\n    }\n}", "lc": 4.909090909090909, "pi": 2.5051020408163267, "ma": 6.5, "nbd": 2.0, "ml": 3.1666666666666665, "d": 2.0, "mi": -1.6486951534270151, "fo": 4.916666666666667, "r": -0.028571428571428574, "e": 12.195467725425196}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2487_f2920c26", "label": 0, "code": "/**\n * @return the current size of the buffer.\n */\npublic int getSize() {\n    if (this.value == null) {\n        throw new IllegalStateException(\"Uninitialized. Null constructor \" + \"called w/o accompanying readFields invocation\");\n    }\n    return this.value.length;\n}", "code_comment": "/**\n * @return the current size of the buffer.\n */\n", "code_no_comment": "public int getSize() {\n    if (this.value == null) {\n        throw new IllegalStateException(\"Uninitialized. Null constructor \" + \"called w/o accompanying readFields invocation\");\n    }\n    return this.value.length;\n}", "lc": -0.36363636363636365, "pi": -0.13775510204081634, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.25, "d": -0.15916955017301035, "mi": 0.6383710926297677, "fo": -0.5, "r": 2.7142857142857144, "e": -0.14662006758579926}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4519_e62ded51", "label": 3, "code": "/**\n * {@inheritDoc}\n */\npublic boolean visitObject(final Object object) {\n    return clazz.isAssignableFrom(object.getClass());\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public boolean visitObject(final Object object) {\n    return clazz.isAssignableFrom(object.getClass());\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.046171494121021, "fo": -0.3333333333333333, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "Math", "project_version": 80, "label": 1, "code": "/**\n * Flip qd array if warranted.\n * @param n number of rows in the block\n * @param step within the array (1 for flipping all elements, 2 for flipping\n * only every other element)\n * @return true if qd array was flipped\n */\nprivate boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n        // flip array\n        int j = 4 * n - 1;\n        for (int i = 0; i < j; i += 4) {\n            for (int k = 0; k < 4; k += step) {\n                final double tmp = work[i + k];\n                work[i + k] = work[j - k];\n                work[j - k] = tmp;\n            }\n            j -= 4;\n        }\n        return true;\n    }\n    return false;\n}", "code_comment": "/**\n * Flip qd array if warranted.\n * @param n number of rows in the block\n * @param step within the array (1 for flipping all elements, 2 for flipping\n * only every other element)\n * @return true if qd array was flipped\n */\n", "code_no_comment": "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n                int j = 4 * n - 1;\n        for (int i = 0; i < j; i += 4) {\n            for (int k = 0; k < 4; k += step) {\n                final double tmp = work[i + k];\n                work[i + k] = work[j - k];\n                work[j - k] = tmp;\n            }\n            j -= 4;\n        }\n        return true;\n    }\n    return false;\n}", "lc": 0.045454545454545456, "pi": 1.1326530612244898, "ma": 0.0, "nbd": 0.5, "ml": 0.08333333333333333, "d": 1.32377656945131, "mi": -0.11155721250358479, "fo": -0.5, "r": 1.0571428571428572, "e": 0.9720833815171257}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4292_9cb617ae", "label": 1, "code": "/**\n *  Add a cookie to the response.\n *\n *  @param cookie\n *             The cookie to add\n */\n@Override\npublic void addCookie(final Cookie cookie) {\n    // remove any potential duplicates\n    cookies.remove(cookie);\n    cookies.add(cookie);\n}", "code_comment": "/**\n *  Add a cookie to the response.\n *\n *  @param cookie\n *             The cookie to add\n */\n", "code_no_comment": "@Override\npublic void addCookie(final Cookie cookie) {\n        cookies.remove(cookie);\n    cookies.add(cookie);\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7516489819328936, "fo": -0.3333333333333333, "r": 2.742857142857143, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4", "label": 1, "code": "/**\n *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL OR\n *  OVERRIDE.\n *\n *  Called when a request begins.\n */\n@Override\npublic void internalAttach() {\n    // Handle begin request for the container itself\n    try {\n        super.internalAttach();\n        // Loop through child components\n        final int size = children_size();\n        for (int i = 0; i < size; i++) {\n            // Get next child\n            final Component child = children_get(i);\n            // Ignore feedback as that was done in Page\n            if (!(child instanceof IFeedback)) {\n                // Call begin request on the child\n                child.internalAttach();\n            }\n        }\n    } catch (RuntimeException ex) {\n        if (ex instanceof WicketRuntimeException) {\n            throw ex;\n        } else {\n            throw new WicketRuntimeException(\"Error attaching this container for rendering: \" + this, ex);\n        }\n    }\n}", "code_comment": "/**\n *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL OR\n *  OVERRIDE.\n *\n *  Called when a request begins.\n */\n", "code_no_comment": "@Override\npublic void internalAttach() {\n        try {\n        super.internalAttach();\n                final int size = children_size();\n        for (int i = 0; i < size; i++) {\n                        final Component child = children_get(i);\n                        if (!(child instanceof IFeedback)) {\n                                child.internalAttach();\n            }\n        }\n    } catch (RuntimeException ex) {\n        if (ex instanceof WicketRuntimeException) {\n            throw ex;\n        } else {\n            throw new WicketRuntimeException(\"Error attaching this container for rendering: \" + this, ex);\n        }\n    }\n}", "lc": 0.22727272727272727, "pi": 0.7448979591836737, "ma": 0.5, "nbd": 0.5, "ml": 0.16666666666666666, "d": 0.33119130004943165, "mi": -0.13105821623171807, "fo": -0.16666666666666666, "r": 1.0571428571428572, "e": 0.062343402675164146}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-343_f6dd42b4", "label": 0, "code": "/**\n * Find a zero in the given interval.\n * <p>\n * Requires that the values of the function at the endpoints have opposite\n * signs. An <code>IllegalArgumentException</code> is thrown if this is not\n * the case.</p>\n *\n * @param f the function to solve\n * @param min the lower bound for the interval.\n * @param max the upper bound for the interval.\n * @return the value where the function is zero\n * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n * @throws FunctionEvaluationException if an error occurs evaluating the\n * function\n * @throws IllegalArgumentException if min is not less than max or the\n * signs of the values of the function at the endpoints are not opposites\n */\npublic double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double ret = Double.NaN;\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    // Verify bracketing\n    double sign = yMin * yMax;\n    if (sign > 0) {\n        // check if either value is close to a zero\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(min, 0);\n            ret = min;\n        } else if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(max, 0);\n            ret = max;\n        } else {\n            // neither value is close to zero and min and max do not bracket root.\n            throw MathRuntimeException.createIllegalArgumentException(\"function values at endpoints do not have different signs.  \" + \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\", min, max, yMin, yMax);\n        }\n    } else if (sign < 0) {\n        // solve using only the first endpoint as initial guess\n        ret = solve(f, min, yMin, max, yMax, min, yMin);\n    } else {\n        // either min or max is a root\n        if (yMin == 0.0) {\n            ret = min;\n        } else {\n            ret = max;\n        }\n    }\n    return ret;\n}", "code_comment": "/**\n * Find a zero in the given interval.\n * <p>\n * Requires that the values of the function at the endpoints have opposite\n * signs. An <code>IllegalArgumentException</code> is thrown if this is not\n * the case.</p>\n *\n * @param f the function to solve\n * @param min the lower bound for the interval.\n * @param max the upper bound for the interval.\n * @return the value where the function is zero\n * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n * @throws FunctionEvaluationException if an error occurs evaluating the\n * function\n * @throws IllegalArgumentException if min is not less than max or the\n * signs of the values of the function at the endpoints are not opposites\n */\n", "code_no_comment": "public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double ret = Double.NaN;\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n        double sign = yMin * yMax;\n    if (sign > 0) {\n                if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(min, 0);\n            ret = min;\n        } else if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(max, 0);\n            ret = max;\n        } else {\n                        throw MathRuntimeException.createIllegalArgumentException(\"function values at endpoints do not have different signs.  \" + \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\", min, max, yMin, yMax);\n        }\n    } else if (sign < 0) {\n                ret = solve(f, min, yMin, max, yMax, min, yMin);\n    } else {\n                if (yMin == 0.0) {\n            ret = min;\n        } else {\n            ret = max;\n        }\n    }\n    return ret;\n}", "lc": 0.6363636363636364, "pi": 0.3367346938775511, "ma": 0.5, "nbd": 0.5, "ml": 0.5, "d": 1.2011863568956997, "mi": -0.47720103240607986, "fo": 0.3333333333333333, "r": -0.028571428571428574, "e": 1.369760280279766}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5724_b92591f6", "label": 1, "code": "@Override\nprotected MarkupElement onComponentTag(final ComponentTag tag) throws ParseException {\n    // We only need ComponentTags\n    if (tag instanceof WicketTag) {\n        return tag;\n    }\n    // Has wicket:enclosure attribute?\n    String enclosureAttr = getAttribute(tag, null);\n    if (enclosureAttr != null) {\n        if (tag.isOpen()) {\n            // Make sure 'wicket:id' and 'id' are consistent\n            String htmlId = tag.getAttribute(\"id\");\n            if ((tag.getId() != null) && !Strings.isEmpty(htmlId) && !htmlId.equals(tag.getId())) {\n                throw new ParseException(\"Make sure that 'id' and 'wicket:id' are the same if both are provided. Tag:\" + tag.toString(), tag.getPos());\n            }\n            // if it doesn't have a wicket-id already, then assign one now.\n            if (Strings.isEmpty(tag.getId())) {\n                if (Strings.isEmpty(htmlId)) {\n                    String id = getWicketNamespace() + \"_\" + INLINE_ENCLOSURE_ID_PREFIX + (counter++);\n                    tag.setId(id);\n                } else {\n                    tag.setId(htmlId);\n                }\n                tag.setAutoComponentTag(true);\n                tag.setAutoComponentFactory(new ComponentTag.IAutoComponentFactory() {\n\n                    @Override\n                    public Component newComponent(ComponentTag tag) {\n                        String attributeName = getInlineEnclosureAttributeName(null);\n                        String childId = tag.getAttribute(attributeName);\n                        return new InlineEnclosure(tag.getId(), childId);\n                    }\n                });\n                tag.setModified(true);\n            }\n            // Put the enclosure on the stack. The most current one will be on top\n            if (enclosures == null) {\n                enclosures = new ArrayDeque<>();\n            }\n            enclosures.push(tag);\n        } else {\n            throw new ParseException(\"Open-close tags don't make sense for InlineEnclosure. Tag:\" + tag.toString(), tag.getPos());\n        }\n    } else // Are we within an enclosure?\n    if ((enclosures != null) && (enclosures.size() > 0)) {\n        // first ComponentTag's id found as the controlling child to the enclosure.\n        if (tag.isOpen() && (tag.getId() != null) && !(tag instanceof WicketTag) && !tag.isAutoComponentTag()) {\n            Iterator<ComponentTag> componentTagIterator = enclosures.descendingIterator();\n            while (componentTagIterator.hasNext()) {\n                ComponentTag lastEnclosure = componentTagIterator.next();\n                String attr = getAttribute(lastEnclosure, null);\n                if (Strings.isEmpty(attr) == true) {\n                    lastEnclosure.getAttributes().put(getInlineEnclosureAttributeName(null), tag.getId());\n                    lastEnclosure.setModified(true);\n                }\n            }\n        } else if (tag.isClose() && tag.closes(enclosures.peek())) {\n            ComponentTag lastEnclosure = enclosures.pop();\n            String attr = getAttribute(lastEnclosure, null);\n            if (Strings.isEmpty(attr) == true) {\n                throw new ParseException(\"Did not find any child for InlineEnclosure. Tag:\" + lastEnclosure.toString(), tag.getPos());\n            }\n        }\n    }\n    return tag;\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected MarkupElement onComponentTag(final ComponentTag tag) throws ParseException {\n        if (tag instanceof WicketTag) {\n        return tag;\n    }\n        String enclosureAttr = getAttribute(tag, null);\n    if (enclosureAttr != null) {\n        if (tag.isOpen()) {\n                        String htmlId = tag.getAttribute(\"id\");\n            if ((tag.getId() != null) && !Strings.isEmpty(htmlId) && !htmlId.equals(tag.getId())) {\n                throw new ParseException(\"Make sure that 'id' and 'wicket:id' are the same if both are provided. Tag:\" + tag.toString(), tag.getPos());\n            }\n                        if (Strings.isEmpty(tag.getId())) {\n                if (Strings.isEmpty(htmlId)) {\n                    String id = getWicketNamespace() + \"_\" + INLINE_ENCLOSURE_ID_PREFIX + (counter++);\n                    tag.setId(id);\n                } else {\n                    tag.setId(htmlId);\n                }\n                tag.setAutoComponentTag(true);\n                tag.setAutoComponentFactory(new ComponentTag.IAutoComponentFactory() {\n\n                    @Override\n                    public Component newComponent(ComponentTag tag) {\n                        String attributeName = getInlineEnclosureAttributeName(null);\n                        String childId = tag.getAttribute(attributeName);\n                        return new InlineEnclosure(tag.getId(), childId);\n                    }\n                });\n                tag.setModified(true);\n            }\n                        if (enclosures == null) {\n                enclosures = new ArrayDeque<>();\n            }\n            enclosures.push(tag);\n        } else {\n            throw new ParseException(\"Open-close tags don't make sense for InlineEnclosure. Tag:\" + tag.toString(), tag.getPos());\n        }\n    } else     if ((enclosures != null) && (enclosures.size() > 0)) {\n                if (tag.isOpen() && (tag.getId() != null) && !(tag instanceof WicketTag) && !tag.isAutoComponentTag()) {\n            Iterator<ComponentTag> componentTagIterator = enclosures.descendingIterator();\n            while (componentTagIterator.hasNext()) {\n                ComponentTag lastEnclosure = componentTagIterator.next();\n                String attr = getAttribute(lastEnclosure, null);\n                if (Strings.isEmpty(attr) == true) {\n                    lastEnclosure.getAttributes().put(getInlineEnclosureAttributeName(null), tag.getId());\n                    lastEnclosure.setModified(true);\n                }\n            }\n        } else if (tag.isClose() && tag.closes(enclosures.peek())) {\n            ComponentTag lastEnclosure = enclosures.pop();\n            String attr = getAttribute(lastEnclosure, null);\n            if (Strings.isEmpty(attr) == true) {\n                throw new ParseException(\"Did not find any child for InlineEnclosure. Tag:\" + lastEnclosure.toString(), tag.getPos());\n            }\n        }\n    }\n    return tag;\n}", "lc": 2.0454545454545454, "pi": 1.5816326530612246, "ma": 2.1666666666666665, "nbd": 1.5, "ml": 2.6666666666666665, "d": 1.8991596638655466, "mi": -1.0395755663894468, "fo": 3.3333333333333335, "r": -0.028571428571428574, "e": 5.884521652725489}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3448_b345dd82", "label": 0, "code": "@Override\npublic String toString() {\n    return \"ExceptionPolicyKey[\" + exceptionClass + (when != null ? \" \" + when : \"\") + \"]\";\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic String toString() {\n    return \"ExceptionPolicyKey[\" + exceptionClass + (when != null ? \" \" + when : \"\") + \"]\";\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.3333333333333333, "nbd": -1.0, "ml": -0.25, "d": -0.16510133465150764, "mi": 0.7711499856610269, "fo": -0.5, "r": 2.7714285714285714, "e": -0.13829390828375757}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5", "label": 3, "code": "@Override\npublic void write(org.apache.thrift.protocol.TProtocol prot, update_result struct) throws org.apache.thrift.TException {\n    TTupleProtocol oprot = (TTupleProtocol) prot;\n    BitSet optionals = new BitSet();\n    if (struct.isSetOuch1()) {\n        optionals.set(0);\n    }\n    if (struct.isSetOuch2()) {\n        optionals.set(1);\n    }\n    oprot.writeBitSet(optionals, 2);\n    if (struct.isSetOuch1()) {\n        struct.ouch1.write(oprot);\n    }\n    if (struct.isSetOuch2()) {\n        struct.ouch2.write(oprot);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void write(org.apache.thrift.protocol.TProtocol prot, update_result struct) throws org.apache.thrift.TException {\n    TTupleProtocol oprot = (TTupleProtocol) prot;\n    BitSet optionals = new BitSet();\n    if (struct.isSetOuch1()) {\n        optionals.set(0);\n    }\n    if (struct.isSetOuch2()) {\n        optionals.set(1);\n    }\n    oprot.writeBitSet(optionals, 2);\n    if (struct.isSetOuch1()) {\n        struct.ouch1.write(oprot);\n    }\n    if (struct.isSetOuch2()) {\n        struct.ouch2.write(oprot);\n    }\n}", "lc": 0.18181818181818182, "pi": -0.2755102040816327, "ma": 0.16666666666666666, "nbd": -0.5, "ml": 0.08333333333333333, "d": -0.3806228373702422, "mi": -0.16260395755663903, "fo": 0.25, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5853_b80f6640", "label": 3, "code": "/**\n *  @see org.apache.wicket.util.convert.IConverter#convertToObject(String, java.util.Locale)\n */\n@Override\npublic Double convertToObject(final String value, final Locale locale) {\n    final Number number = parse(value, -Double.MAX_VALUE, Double.MAX_VALUE, locale);\n    if (number == null) {\n        return null;\n    }\n    return number.doubleValue();\n}", "code_comment": "/**\n *  @see org.apache.wicket.util.convert.IConverter#convertToObject(String, java.util.Locale)\n */\n", "code_no_comment": "@Override\npublic Double convertToObject(final String value, final Locale locale) {\n    final Number number = parse(value, -Double.MAX_VALUE, Double.MAX_VALUE, locale);\n    if (number == null) {\n        return null;\n    }\n    return number.doubleValue();\n}", "lc": -0.2727272727272727, "pi": -0.1887755102040817, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.07019278299555112, "mi": 0.35790077430456, "fo": -0.3333333333333333, "r": 0.2571428571428572, "e": -0.09545102171054604}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4256_09166ea8", "label": 1, "code": "/**\n */\nprivate final void internalBeforeRender() {\n    configure();\n    if ((determineVisibility()) && !getFlag(FLAG_RENDERING) && !getFlag(FLAG_PREPARED_FOR_RENDER)) {\n        setRequestFlag(RFLAG_BEFORE_RENDER_SUPER_CALL_VERIFIED, false);\n        getApplication().getComponentPreOnBeforeRenderListeners().onBeforeRender(this);\n        onBeforeRender();\n        getApplication().getComponentPostOnBeforeRenderListeners().onBeforeRender(this);\n        if (!getRequestFlag(RFLAG_BEFORE_RENDER_SUPER_CALL_VERIFIED)) {\n            throw new IllegalStateException(Component.class.getName() + \" has not been properly rendered. Something in the hierarchy of \" + getClass().getName() + \" has not called super.onBeforeRender() in the override of onBeforeRender() method\");\n        }\n    }\n}", "code_comment": "/**\n */\n", "code_no_comment": "private final void internalBeforeRender() {\n    configure();\n    if ((determineVisibility()) && !getFlag(FLAG_RENDERING) && !getFlag(FLAG_PREPARED_FOR_RENDER)) {\n        setRequestFlag(RFLAG_BEFORE_RENDER_SUPER_CALL_VERIFIED, false);\n        getApplication().getComponentPreOnBeforeRenderListeners().onBeforeRender(this);\n        onBeforeRender();\n        getApplication().getComponentPostOnBeforeRenderListeners().onBeforeRender(this);\n        if (!getRequestFlag(RFLAG_BEFORE_RENDER_SUPER_CALL_VERIFIED)) {\n            throw new IllegalStateException(Component.class.getName() + \" has not been properly rendered. Something in the hierarchy of \" + getClass().getName() + \" has not called super.onBeforeRender() in the override of onBeforeRender() method\");\n        }\n    }\n}", "lc": -0.09090909090909091, "pi": 0.22448979591836732, "ma": 0.0, "nbd": 0.0, "ml": 0.25, "d": -0.1255561047948591, "mi": 0.10238026957269843, "fo": 0.8333333333333334, "r": -0.028571428571428574, "e": -0.08343291317066485}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-843_65390f8c", "label": 3, "code": "@Override\npublic void offline(String tableName) throws AccumuloSecurityException, AccumuloException {\n    throw new NotImplementedException();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void offline(String tableName) throws AccumuloSecurityException, AccumuloException {\n    throw new NotImplementedException();\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.3333333333333333, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8961858330943507, "fo": -0.5, "r": 1.5999999999999999, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-9217_e7ac45b6", "label": 3, "code": "/**\n * Strategy for validation of the uri when creating the endpoint.\n *\n * @param uri        the uri\n * @param path       the path - part after the scheme\n * @param parameters the parameters, an empty map if no parameters given\n * @throws ResolveEndpointFailedException should be thrown if the URI validation failed\n */\nprotected void validateURI(String uri, String path, Map<String, Object> parameters) {\n    // check for uri containing & but no ? marker\n    if (uri.contains(\"&\") && !uri.contains(\"?\")) {\n        throw new ResolveEndpointFailedException(uri, \"Invalid uri syntax: no ? marker however the uri \" + \"has & parameter separators. Check the uri if its missing a ? marker.\");\n    }\n    // check for uri containing double && markers without include by RAW\n    if (uri.contains(\"&&\")) {\n        Pattern pattern = Pattern.compile(\"RAW(.*&&.*)\");\n        Matcher m = pattern.matcher(uri);\n        // we should skip the RAW part\n        if (!m.find()) {\n            throw new ResolveEndpointFailedException(uri, \"Invalid uri syntax: Double && marker found. \" + \"Check the uri and remove the duplicate & marker.\");\n        }\n    }\n    // if we have a trailing & then that is invalid as well\n    if (uri.endsWith(\"&\")) {\n        throw new ResolveEndpointFailedException(uri, \"Invalid uri syntax: Trailing & marker found. \" + \"Check the uri and remove the trailing & marker.\");\n    }\n}", "code_comment": "/**\n * Strategy for validation of the uri when creating the endpoint.\n *\n * @param uri        the uri\n * @param path       the path - part after the scheme\n * @param parameters the parameters, an empty map if no parameters given\n * @throws ResolveEndpointFailedException should be thrown if the URI validation failed\n */\n", "code_no_comment": "protected void validateURI(String uri, String path, Map<String, Object> parameters) {\n        if (uri.contains(\"&\") && !uri.contains(\"?\")) {\n        throw new ResolveEndpointFailedException(uri, \"Invalid uri syntax: no ? marker however the uri \" + \"has & parameter separators. Check the uri if its missing a ? marker.\");\n    }\n        if (uri.contains(\"&&\")) {\n        Pattern pattern = Pattern.compile(\"RAW(.*&&.*)\");\n        Matcher m = pattern.matcher(uri);\n                if (!m.find()) {\n            throw new ResolveEndpointFailedException(uri, \"Invalid uri syntax: Double && marker found. \" + \"Check the uri and remove the duplicate & marker.\");\n        }\n    }\n        if (uri.endsWith(\"&\")) {\n        throw new ResolveEndpointFailedException(uri, \"Invalid uri syntax: Trailing & marker found. \" + \"Check the uri and remove the trailing & marker.\");\n    }\n}", "lc": 0.045454545454545456, "pi": 0.09183673469387764, "ma": 0.6666666666666666, "nbd": 0.0, "ml": 0.5, "d": 0.2698961937716264, "mi": -0.11843991970174926, "fo": 0.08333333333333333, "r": -0.028571428571428574, "e": 0.21573489919950659}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1429_c2f5ca6c", "label": 1, "code": "private void diffManyChildren(JsopWriter w, String path, Revision fromRev, Revision toRev) {\n    long minTimestamp = Math.min(fromRev.getTimestamp(), toRev.getTimestamp());\n    long minValue = Commit.getModified(minTimestamp);\n    String fromKey = Utils.getKeyLowerLimit(path);\n    String toKey = Utils.getKeyUpperLimit(path);\n    Set<String> paths = Sets.newHashSet();\n    for (NodeDocument doc : store.query(Collection.NODES, fromKey, toKey, NodeDocument.MODIFIED, minValue, Integer.MAX_VALUE)) {\n        paths.add(Utils.getPathFromId(doc.getId()));\n    }\n    // also consider nodes with not yet stored modifications (OAK-1107)\n    Revision minRev = new Revision(minTimestamp, 0, getClusterId());\n    addPathsForDiff(path, paths, getPendingModifications(), minRev);\n    for (Revision r : new Revision[] { fromRev, toRev }) {\n        if (r.isBranch()) {\n            Branch b = getBranches().getBranch(fromRev);\n            if (b != null) {\n                addPathsForDiff(path, paths, b.getModifications(r), r);\n            }\n        }\n    }\n    for (String p : paths) {\n        DocumentNodeState fromNode = getNode(p, fromRev);\n        DocumentNodeState toNode = getNode(p, toRev);\n        if (fromNode != null) {\n            // exists in fromRev\n            if (toNode != null) {\n                // check if different\n                if (!fromNode.getLastRevision().equals(toNode.getLastRevision())) {\n                    w.tag('^').key(p).object().endObject().newline();\n                }\n            } else {\n                // does not exist in toRev -> was removed\n                w.tag('-').value(p).newline();\n            }\n        } else {\n            // does not exist in fromRev\n            if (toNode != null) {\n                // exists in toRev\n                w.tag('+').key(p).object().endObject().newline();\n            } else {\n            // does not exist in either revisions\n            // -> do nothing\n            }\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private void diffManyChildren(JsopWriter w, String path, Revision fromRev, Revision toRev) {\n    long minTimestamp = Math.min(fromRev.getTimestamp(), toRev.getTimestamp());\n    long minValue = Commit.getModified(minTimestamp);\n    String fromKey = Utils.getKeyLowerLimit(path);\n    String toKey = Utils.getKeyUpperLimit(path);\n    Set<String> paths = Sets.newHashSet();\n    for (NodeDocument doc : store.query(Collection.NODES, fromKey, toKey, NodeDocument.MODIFIED, minValue, Integer.MAX_VALUE)) {\n        paths.add(Utils.getPathFromId(doc.getId()));\n    }\n        Revision minRev = new Revision(minTimestamp, 0, getClusterId());\n    addPathsForDiff(path, paths, getPendingModifications(), minRev);\n    for (Revision r : new Revision[] { fromRev, toRev }) {\n        if (r.isBranch()) {\n            Branch b = getBranches().getBranch(fromRev);\n            if (b != null) {\n                addPathsForDiff(path, paths, b.getModifications(r), r);\n            }\n        }\n    }\n    for (String p : paths) {\n        DocumentNodeState fromNode = getNode(p, fromRev);\n        DocumentNodeState toNode = getNode(p, toRev);\n        if (fromNode != null) {\n                        if (toNode != null) {\n                                if (!fromNode.getLastRevision().equals(toNode.getLastRevision())) {\n                    w.tag('^').key(p).object().endObject().newline();\n                }\n            } else {\n                                w.tag('-').value(p).newline();\n            }\n        } else {\n                        if (toNode != null) {\n                                w.tag('+').key(p).object().endObject().newline();\n            } else {\n                                    }\n        }\n    }\n}", "lc": 1.0909090909090908, "pi": 0.9897959183673469, "ma": 1.0, "nbd": 1.0, "ml": 0.5833333333333334, "d": 0.0187839841819081, "mi": -0.742758818468598, "fo": 2.5833333333333335, "r": -0.028571428571428574, "e": 0.6107863166595997}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-757_76b7413d", "label": 1, "code": "/**\n * Discards the <code>i</code> initial elements of the array.  For example,\n * if the array contains the elements 1,2,3,4, invoking\n * <code>discardFrontElements(2)</code> will cause the first two elements\n * to be discarded, leaving 3,4 in the array.  Throws illegalArgumentException\n * if i exceeds numElements.\n *\n * @param i  the number of elements to discard from the front of the array\n * @throws MathIllegalArgumentException if i is greater than numElements.\n * @since 2.0\n */\npublic synchronized void discardFrontElements(int i) throws MathIllegalArgumentException {\n    discardExtremeElements(i, true);\n}", "code_comment": "/**\n * Discards the <code>i</code> initial elements of the array.  For example,\n * if the array contains the elements 1,2,3,4, invoking\n * <code>discardFrontElements(2)</code> will cause the first two elements\n * to be discarded, leaving 3,4 in the array.  Throws illegalArgumentException\n * if i exceeds numElements.\n *\n * @param i  the number of elements to discard from the front of the array\n * @throws MathIllegalArgumentException if i is greater than numElements.\n * @since 2.0\n */\n", "code_no_comment": "public synchronized void discardFrontElements(int i) throws MathIllegalArgumentException {\n    discardExtremeElements(i, true);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.0785775738457126, "fo": -0.4166666666666667, "r": 0.05714285714285714, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-209_76d727f0", "label": 1, "code": "@Override\npublic void init(SortedKeyValueIterator<Key, Value> source, Map<String, String> options, IteratorEnvironment env) throws IOException {\n    super.init(source, options, env);\n    if (options.containsKey(ROW_REGEX)) {\n        rowMatcher = Pattern.compile(options.get(ROW_REGEX)).matcher(\"\");\n    } else {\n        rowMatcher = null;\n    }\n    if (options.containsKey(COLF_REGEX)) {\n        colfMatcher = Pattern.compile(options.get(COLF_REGEX)).matcher(\"\");\n    } else {\n        colfMatcher = null;\n    }\n    if (options.containsKey(COLQ_REGEX)) {\n        colqMatcher = Pattern.compile(options.get(COLQ_REGEX)).matcher(\"\");\n    } else {\n        colqMatcher = null;\n    }\n    if (options.containsKey(VALUE_REGEX)) {\n        valueMatcher = Pattern.compile(options.get(VALUE_REGEX)).matcher(\"\");\n    } else {\n        valueMatcher = null;\n    }\n    if (options.containsKey(OR_FIELDS)) {\n        orFields = Boolean.parseBoolean(options.get(OR_FIELDS));\n    } else {\n        orFields = false;\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void init(SortedKeyValueIterator<Key, Value> source, Map<String, String> options, IteratorEnvironment env) throws IOException {\n    super.init(source, options, env);\n    if (options.containsKey(ROW_REGEX)) {\n        rowMatcher = Pattern.compile(options.get(ROW_REGEX)).matcher(\"\");\n    } else {\n        rowMatcher = null;\n    }\n    if (options.containsKey(COLF_REGEX)) {\n        colfMatcher = Pattern.compile(options.get(COLF_REGEX)).matcher(\"\");\n    } else {\n        colfMatcher = null;\n    }\n    if (options.containsKey(COLQ_REGEX)) {\n        colqMatcher = Pattern.compile(options.get(COLQ_REGEX)).matcher(\"\");\n    } else {\n        colqMatcher = null;\n    }\n    if (options.containsKey(VALUE_REGEX)) {\n        valueMatcher = Pattern.compile(options.get(VALUE_REGEX)).matcher(\"\");\n    } else {\n        valueMatcher = null;\n    }\n    if (options.containsKey(OR_FIELDS)) {\n        orFields = Boolean.parseBoolean(options.get(OR_FIELDS));\n    } else {\n        orFields = false;\n    }\n}", "lc": 0.6818181818181818, "pi": -0.2653061224489796, "ma": 0.3333333333333333, "nbd": -0.5, "ml": 0.4166666666666667, "d": -0.3806228373702422, "mi": -0.49211356466876977, "fo": 1.1666666666666667, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3324_5f863af6", "label": 1, "code": "@Override\npublic boolean apply(@Nullable PermissionEntry entry) {\n    if (entry == null) {\n        return false;\n    }\n    if (tree != null) {\n        return entry.matches(tree, property) || applyToParent(entry);\n    } else if (path != null) {\n        return entry.matches(path) || applyToParent(entry);\n    } else {\n        return entry.matches();\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean apply(@Nullable PermissionEntry entry) {\n    if (entry == null) {\n        return false;\n    }\n    if (tree != null) {\n        return entry.matches(tree, property) || applyToParent(entry);\n    } else if (path != null) {\n        return entry.matches(path) || applyToParent(entry);\n    } else {\n        return entry.matches();\n    }\n}", "lc": -0.045454545454545456, "pi": -0.051020408163265356, "ma": 0.0, "nbd": 0.0, "ml": 0.08333333333333333, "d": 0.01482946119624324, "mi": 0.09033553197591031, "fo": -0.08333333333333333, "r": 0.14285714285714285, "e": -0.05800900287389552}
{"project_name": "Lang", "project_version": 32, "label": 1, "code": "/**\n * <p>\n * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid\n * infinite loops.\n * </p>\n *\n * @param value\n *            The object to lookup in the registry.\n * @return boolean <code>true</code> if the registry contains the given object.\n * @since 2.3\n */\nstatic boolean isRegistered(Object value) {\n    return getRegistry().contains(new IDKey(value));\n}", "code_comment": "/**\n * <p>\n * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid\n * infinite loops.\n * </p>\n *\n * @param value\n *            The object to lookup in the registry.\n * @return boolean <code>true</code> if the registry contains the given object.\n * @since 2.3\n */\n", "code_no_comment": "static boolean isRegistered(Object value) {\n    return getRegistry().contains(new IDKey(value));\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.046171494121021, "fo": -0.3333333333333333, "r": 2.542857142857143, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2079_ceac38b1", "label": 3, "code": "/**\n *  Throw an exception if not all components rendered.\n *\n *  @param renderedContainer\n *             The page itself if it was a full page render or the container that was rendered\n *             standalone\n */\nprivate final void checkRendering(final MarkupContainer renderedContainer) {\n    // If the application wants component uses checked and\n    // the response is not a redirect\n    final IDebugSettings debugSettings = Application.get().getDebugSettings();\n    if (debugSettings.getComponentUseCheck() && !getResponse().isRedirect()) {\n        final List<Component> unrenderedComponents = new ArrayList<Component>();\n        final StringBuffer buffer = new StringBuffer();\n        renderedContainer.visitChildren(new IVisitor<Component>() {\n\n            public Object component(final Component component) {\n                // If component never rendered\n                if (renderedComponents == null || !renderedComponents.contains(component)) {\n                    // If auto component ...\n                    if (!component.isAuto() && component.isVisibleInHierarchy()) {\n                        // Increase number of unrendered components\n                        unrenderedComponents.add(component);\n                        // Add to explanatory string to buffer\n                        buffer.append(Integer.toString(unrenderedComponents.size()) + \". \" + component + \"\\n\");\n                        String metadata = component.getMetaData(Component.CONSTRUCTED_AT_KEY);\n                        if (metadata != null) {\n                            buffer.append(metadata);\n                        }\n                        metadata = component.getMetaData(Component.ADDED_AT_KEY);\n                        if (metadata != null) {\n                            buffer.append(metadata);\n                        }\n                    } else {\n                        // not visible\n                        return CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;\n                    }\n                }\n                return CONTINUE_TRAVERSAL;\n            }\n        });\n        // Throw exception if any errors were found\n        if (unrenderedComponents.size() > 0) {\n            // Get rid of set\n            renderedComponents = null;\n            Iterator<Component> iterator = unrenderedComponents.iterator();\n            while (iterator.hasNext()) {\n                Component component = iterator.next();\n                // Now first test if the component has a sibling that is a transparent resolver.\n                Iterator<? extends Component> iterator2 = component.getParent().iterator();\n                while (iterator2.hasNext()) {\n                    Component sibling = iterator2.next();\n                    if (!sibling.isVisible()) {\n                        boolean isTransparentMarkupContainer = sibling instanceof MarkupContainer && ((MarkupContainer) sibling).isTransparentResolver();\n                        boolean isComponentResolver = sibling instanceof IComponentResolver;\n                        if (isTransparentMarkupContainer || isComponentResolver) {\n                            // we found a transparent container that isn't visible\n                            // then ignore this component and only do a debug statement here.\n                            log.debug(\"Component {} wasn't rendered but most likely it has a transparent parent: {}\", component, sibling);\n                            iterator.remove();\n                            break;\n                        }\n                    }\n                }\n            }\n            // if still > 0\n            if (unrenderedComponents.size() > 0) {\n                // Throw exception\n                throw new WicketRuntimeException(\"The component(s) below failed to render. A common problem is that you have added a component in code but forgot to reference it in the markup (thus the component will never be rendered).\\n\\n\" + buffer.toString());\n            }\n        }\n    }\n    // Get rid of set\n    renderedComponents = null;\n}", "code_comment": "/**\n *  Throw an exception if not all components rendered.\n *\n *  @param renderedContainer\n *             The page itself if it was a full page render or the container that was rendered\n *             standalone\n */\n", "code_no_comment": "private final void checkRendering(final MarkupContainer renderedContainer) {\n            final IDebugSettings debugSettings = Application.get().getDebugSettings();\n    if (debugSettings.getComponentUseCheck() && !getResponse().isRedirect()) {\n        final List<Component> unrenderedComponents = new ArrayList<Component>();\n        final StringBuffer buffer = new StringBuffer();\n        renderedContainer.visitChildren(new IVisitor<Component>() {\n\n            public Object component(final Component component) {\n                                if (renderedComponents == null || !renderedComponents.contains(component)) {\n                                        if (!component.isAuto() && component.isVisibleInHierarchy()) {\n                                                unrenderedComponents.add(component);\n                                                buffer.append(Integer.toString(unrenderedComponents.size()) + \". \" + component + \"\\n\");\n                        String metadata = component.getMetaData(Component.CONSTRUCTED_AT_KEY);\n                        if (metadata != null) {\n                            buffer.append(metadata);\n                        }\n                        metadata = component.getMetaData(Component.ADDED_AT_KEY);\n                        if (metadata != null) {\n                            buffer.append(metadata);\n                        }\n                    } else {\n                                                return CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;\n                    }\n                }\n                return CONTINUE_TRAVERSAL;\n            }\n        });\n                if (unrenderedComponents.size() > 0) {\n                        renderedComponents = null;\n            Iterator<Component> iterator = unrenderedComponents.iterator();\n            while (iterator.hasNext()) {\n                Component component = iterator.next();\n                                Iterator<? extends Component> iterator2 = component.getParent().iterator();\n                while (iterator2.hasNext()) {\n                    Component sibling = iterator2.next();\n                    if (!sibling.isVisible()) {\n                        boolean isTransparentMarkupContainer = sibling instanceof MarkupContainer && ((MarkupContainer) sibling).isTransparentResolver();\n                        boolean isComponentResolver = sibling instanceof IComponentResolver;\n                        if (isTransparentMarkupContainer || isComponentResolver) {\n                                                                                    log.debug(\"Component {} wasn't rendered but most likely it has a transparent parent: {}\", component, sibling);\n                            iterator.remove();\n                            break;\n                        }\n                    }\n                }\n            }\n                        if (unrenderedComponents.size() > 0) {\n                                throw new WicketRuntimeException(\"The component(s) below failed to render. A common problem is that you have added a component in code but forgot to reference it in the markup (thus the component will never be rendered).\\n\\n\" + buffer.toString());\n            }\n        }\n    }\n        renderedComponents = null;\n}", "lc": 1.7272727272727273, "pi": 2.4795918367346936, "ma": 1.6666666666666667, "nbd": 2.0, "ml": 2.0, "d": 1.3336628769154724, "mi": -0.9260108976197309, "fo": 2.0833333333333335, "r": -0.028571428571428574, "e": 3.4285787708635826}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-373_bfe4623c", "label": 1, "code": "/**\n * The weighted sum of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if any of the following are true:\n * <ul><li>the values array is null</li>\n *     <li>the weights array is null</li>\n *     <li>the weights array does not have the same length as the values array</li>\n *     <li>the weights array contains one or more infinite values</li>\n *     <li>the weights array contains one or more NaN values</li>\n *     <li>the weights array contains negative values</li>\n *     <li>the start and length arguments do not determine a valid array</li>\n * </ul></p>\n * <p>\n * Uses the formula, <pre>\n *    weighted sum = &Sigma;(values[i] * weights[i])\n * </pre></p>\n *\n * @param values the input array\n * @param weights the weights array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the sum of the values or Double.NaN if length = 0\n * @throws IllegalArgumentException if the parameters are not valid\n * @since 2.1\n */\npublic double evaluate(final double[] values, final double[] weights, final int begin, final int length) {\n    double sum = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        sum = 0.0;\n        for (int i = begin; i < begin + length; i++) {\n            sum += values[i] * weights[i];\n        }\n    }\n    return sum;\n}", "code_comment": "/**\n * The weighted sum of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if any of the following are true:\n * <ul><li>the values array is null</li>\n *     <li>the weights array is null</li>\n *     <li>the weights array does not have the same length as the values array</li>\n *     <li>the weights array contains one or more infinite values</li>\n *     <li>the weights array contains one or more NaN values</li>\n *     <li>the weights array contains negative values</li>\n *     <li>the start and length arguments do not determine a valid array</li>\n * </ul></p>\n * <p>\n * Uses the formula, <pre>\n *    weighted sum = &Sigma;(values[i] * weights[i])\n * </pre></p>\n *\n * @param values the input array\n * @param weights the weights array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the sum of the values or Double.NaN if length = 0\n * @throws IllegalArgumentException if the parameters are not valid\n * @since 2.1\n */\n", "code_no_comment": "public double evaluate(final double[] values, final double[] weights, final int begin, final int length) {\n    double sum = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        sum = 0.0;\n        for (int i = begin; i < begin + length; i++) {\n            sum += values[i] * weights[i];\n        }\n    }\n    return sum;\n}", "lc": -0.18181818181818182, "pi": 0.2959183673469388, "ma": -0.16666666666666666, "nbd": 0.0, "ml": 0.25, "d": 1.003460207612457, "mi": 0.19042156581588765, "fo": -0.4166666666666667, "r": -0.028571428571428574, "e": 0.28583910468089474}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2047_a0a495f0", "label": 0, "code": "@SuppressWarnings(\"deprecation\")\nprivate void copyPrivileges(NodeBuilder root) throws RepositoryException {\n    PrivilegeRegistry registry = source.getPrivilegeRegistry();\n    NodeBuilder privileges = root.child(JCR_SYSTEM).child(REP_PRIVILEGES);\n    privileges.setProperty(JCR_PRIMARYTYPE, NT_REP_PRIVILEGES, NAME);\n    PrivilegeBits next = PrivilegeBits.NEXT_AFTER_BUILT_INS;\n    logger.info(\"Copying registered privileges\");\n    for (Privilege privilege : registry.getRegisteredPrivileges()) {\n        String name = privilege.getName();\n        NodeBuilder def = privileges.child(name);\n        def.setProperty(JCR_PRIMARYTYPE, NT_REP_PRIVILEGE, NAME);\n        if (privilege.isAbstract()) {\n            def.setProperty(REP_IS_ABSTRACT, true);\n        }\n        Privilege[] aggregate = privilege.getDeclaredAggregatePrivileges();\n        if (aggregate.length > 0) {\n            List<String> names = newArrayListWithCapacity(aggregate.length);\n            for (Privilege p : aggregate) {\n                names.add(p.getName());\n            }\n            def.setProperty(REP_AGGREGATES, names, NAMES);\n        }\n        PrivilegeBits bits = PrivilegeBits.BUILT_IN.get(name);\n        if (bits != null) {\n            def.setProperty(bits.asPropertyState(REP_BITS));\n        } else if (aggregate.length == 0) {\n            bits = next;\n            next = next.nextBits();\n            def.setProperty(bits.asPropertyState(REP_BITS));\n        }\n    }\n    privileges.setProperty(next.asPropertyState(REP_NEXT));\n    // resolve privilege bits also for all aggregates\n    for (String name : privileges.getChildNodeNames()) {\n        resolvePrivilegeBits(privileges, name);\n    }\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings(\"deprecation\")\nprivate void copyPrivileges(NodeBuilder root) throws RepositoryException {\n    PrivilegeRegistry registry = source.getPrivilegeRegistry();\n    NodeBuilder privileges = root.child(JCR_SYSTEM).child(REP_PRIVILEGES);\n    privileges.setProperty(JCR_PRIMARYTYPE, NT_REP_PRIVILEGES, NAME);\n    PrivilegeBits next = PrivilegeBits.NEXT_AFTER_BUILT_INS;\n    logger.info(\"Copying registered privileges\");\n    for (Privilege privilege : registry.getRegisteredPrivileges()) {\n        String name = privilege.getName();\n        NodeBuilder def = privileges.child(name);\n        def.setProperty(JCR_PRIMARYTYPE, NT_REP_PRIVILEGE, NAME);\n        if (privilege.isAbstract()) {\n            def.setProperty(REP_IS_ABSTRACT, true);\n        }\n        Privilege[] aggregate = privilege.getDeclaredAggregatePrivileges();\n        if (aggregate.length > 0) {\n            List<String> names = newArrayListWithCapacity(aggregate.length);\n            for (Privilege p : aggregate) {\n                names.add(p.getName());\n            }\n            def.setProperty(REP_AGGREGATES, names, NAMES);\n        }\n        PrivilegeBits bits = PrivilegeBits.BUILT_IN.get(name);\n        if (bits != null) {\n            def.setProperty(bits.asPropertyState(REP_BITS));\n        } else if (aggregate.length == 0) {\n            bits = next;\n            next = next.nextBits();\n            def.setProperty(bits.asPropertyState(REP_BITS));\n        }\n    }\n    privileges.setProperty(next.asPropertyState(REP_NEXT));\n        for (String name : privileges.getChildNodeNames()) {\n        resolvePrivilegeBits(privileges, name);\n    }\n}", "lc": 1.0, "pi": 0.44897959183673464, "ma": 0.6666666666666666, "nbd": 0.5, "ml": 0.16666666666666666, "d": 0.43203163618388546, "mi": -0.6816747920848868, "fo": 1.6666666666666667, "r": -0.028571428571428574, "e": 1.1914031548605668}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1926_9225a3e2", "label": 1, "code": "/**\n * Initialize with un-merged branches from <code>store</code> for this\n * <code>clusterId</code>.\n *\n * @param store the document store.\n * @param context the revision context.\n */\nvoid init(DocumentStore store, RevisionContext context) {\n    if (!initialized.compareAndSet(false, true)) {\n        throw new IllegalStateException(\"already initialized\");\n    }\n    NodeDocument doc = store.find(Collection.NODES, Utils.getIdFromPath(\"/\"));\n    if (doc == null) {\n        return;\n    }\n    SortedMap<Revision, Revision> revisions = doc.getUncommittedRevisions(context);\n    while (!revisions.isEmpty()) {\n        SortedSet<Revision> commits = new TreeSet<Revision>(comparator);\n        Revision head = revisions.lastKey();\n        commits.add(head);\n        Revision base = revisions.remove(head).asTrunkRevision();\n        while (revisions.containsKey(base)) {\n            commits.add(base);\n            base = revisions.remove(base).asTrunkRevision();\n        }\n        branches.add(new Branch(commits, base));\n    }\n}", "code_comment": "/**\n * Initialize with un-merged branches from <code>store</code> for this\n * <code>clusterId</code>.\n *\n * @param store the document store.\n * @param context the revision context.\n */\n", "code_no_comment": "void init(DocumentStore store, RevisionContext context) {\n    if (!initialized.compareAndSet(false, true)) {\n        throw new IllegalStateException(\"already initialized\");\n    }\n    NodeDocument doc = store.find(Collection.NODES, Utils.getIdFromPath(\"/\"));\n    if (doc == null) {\n        return;\n    }\n    SortedMap<Revision, Revision> revisions = doc.getUncommittedRevisions(context);\n    while (!revisions.isEmpty()) {\n        SortedSet<Revision> commits = new TreeSet<Revision>(comparator);\n        Revision head = revisions.lastKey();\n        commits.add(head);\n        Revision base = revisions.remove(head).asTrunkRevision();\n        while (revisions.containsKey(base)) {\n            commits.add(base);\n            base = revisions.remove(base).asTrunkRevision();\n        }\n        branches.add(new Branch(commits, base));\n    }\n}", "lc": 0.3181818181818182, "pi": 0.08163265306122457, "ma": 0.3333333333333333, "nbd": 0.0, "ml": 0.3333333333333333, "d": -0.040533860603064735, "mi": -0.3237740177803272, "fo": 0.6666666666666666, "r": -0.028571428571428574, "e": 0.13731310042358905}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4777_eccb3b11", "label": 3, "code": "/**\n *  Write a reference to a javascript file to the response object\n *\n *  @param response\n *             The HTTP response\n *  @param url\n *             The javascript file URL\n *  @param id\n *             Unique identifier of element\n *  @param defer\n *             specifies that the execution of a script should be deferred (delayed) until after\n *             the page has been loaded.\n *  @param charset\n *             a non null value specifies the charset attribute of the script tag\n */\npublic static void writeJavaScriptUrl(final Response response, final CharSequence url, final String id, boolean defer, String charset) {\n    response.write(\"<script type=\\\"text/javascript\\\" \");\n    if (id != null) {\n        response.write(\"id=\\\"\" + Strings.escapeMarkup(id) + \"\\\" \");\n    }\n    if (defer) {\n        response.write(\"defer=\\\"defer\\\" \");\n    }\n    if (charset != null) {\n        response.write(\"charset=\\\"\" + Strings.escapeMarkup(charset) + \"\\\" \");\n    }\n    response.write(\"src=\\\"\");\n    response.write(Strings.escapeMarkup(url));\n    response.write(\"\\\"></script>\");\n    response.write(\"\\n\");\n}", "code_comment": "/**\n *  Write a reference to a javascript file to the response object\n *\n *  @param response\n *             The HTTP response\n *  @param url\n *             The javascript file URL\n *  @param id\n *             Unique identifier of element\n *  @param defer\n *             specifies that the execution of a script should be deferred (delayed) until after\n *             the page has been loaded.\n *  @param charset\n *             a non null value specifies the charset attribute of the script tag\n */\n", "code_no_comment": "public static void writeJavaScriptUrl(final Response response, final CharSequence url, final String id, boolean defer, String charset) {\n    response.write(\"<script type=\\\"text/javascript\\\" \");\n    if (id != null) {\n        response.write(\"id=\\\"\" + Strings.escapeMarkup(id) + \"\\\" \");\n    }\n    if (defer) {\n        response.write(\"defer=\\\"defer\\\" \");\n    }\n    if (charset != null) {\n        response.write(\"charset=\\\"\" + Strings.escapeMarkup(charset) + \"\\\" \");\n    }\n    response.write(\"src=\\\"\");\n    response.write(Strings.escapeMarkup(url));\n    response.write(\"\\\"></script>\");\n    response.write(\"\\n\");\n}", "lc": 0.09090909090909091, "pi": -0.40816326530612235, "ma": 0.0, "nbd": -0.5, "ml": 0.08333333333333333, "d": 0.06821552150271878, "mi": -0.1092629767708633, "fo": 0.4166666666666667, "r": -0.028571428571428574, "e": 0.07677712533353893}
{"project_name": "Closure", "project_version": 134, "label": 2, "code": "public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, externs, new ProcessExterns());\n    NodeTraversal.traverse(compiler, root, new ProcessProperties());\n    Set<String> reservedNames = new HashSet<String>(externedNames.size() + quotedNames.size());\n    reservedNames.addAll(externedNames);\n    reservedNames.addAll(quotedNames);\n    int numRenamedPropertyNames = 0;\n    int numSkippedPropertyNames = 0;\n    Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);\n    for (Property p : propertyMap.values()) {\n        if (!p.skipAmbiguating) {\n            ++numRenamedPropertyNames;\n            computeRelatedTypes(p.type);\n            propsByFreq.add(p);\n        } else {\n            ++numSkippedPropertyNames;\n            reservedNames.add(p.oldName);\n        }\n    }\n    PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq));\n    GraphColoring<Property, Void> coloring = new GreedyGraphColoring<Property, Void>(graph, FREQUENCY_COMPARATOR);\n    int numNewPropertyNames = coloring.color();\n    NameGenerator nameGen = new NameGenerator(reservedNames, \"\", reservedCharacters);\n    for (int i = 0; i < numNewPropertyNames; ++i) {\n        colorMap.put(i, nameGen.generateNextName());\n    }\n    for (GraphNode<Property, Void> node : graph.getNodes()) {\n        node.getValue().newName = colorMap.get(node.getAnnotation().hashCode());\n        renamingMap.put(node.getValue().oldName, node.getValue().newName);\n    }\n    // Update the string nodes.\n    for (Node n : stringNodesToRename) {\n        String oldName = n.getString();\n        Property p = propertyMap.get(oldName);\n        if (p != null && p.newName != null) {\n            Preconditions.checkState(oldName.equals(p.oldName));\n            if (!p.newName.equals(oldName)) {\n                n.setString(p.newName);\n                compiler.reportCodeChange();\n            }\n        }\n    }\n    logger.info(\"Collapsed \" + numRenamedPropertyNames + \" properties into \" + numNewPropertyNames + \" and skipped renaming \" + numSkippedPropertyNames + \" properties.\");\n}", "code_comment": NaN, "code_no_comment": "public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, externs, new ProcessExterns());\n    NodeTraversal.traverse(compiler, root, new ProcessProperties());\n    Set<String> reservedNames = new HashSet<String>(externedNames.size() + quotedNames.size());\n    reservedNames.addAll(externedNames);\n    reservedNames.addAll(quotedNames);\n    int numRenamedPropertyNames = 0;\n    int numSkippedPropertyNames = 0;\n    Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);\n    for (Property p : propertyMap.values()) {\n        if (!p.skipAmbiguating) {\n            ++numRenamedPropertyNames;\n            computeRelatedTypes(p.type);\n            propsByFreq.add(p);\n        } else {\n            ++numSkippedPropertyNames;\n            reservedNames.add(p.oldName);\n        }\n    }\n    PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq));\n    GraphColoring<Property, Void> coloring = new GreedyGraphColoring<Property, Void>(graph, FREQUENCY_COMPARATOR);\n    int numNewPropertyNames = coloring.color();\n    NameGenerator nameGen = new NameGenerator(reservedNames, \"\", reservedCharacters);\n    for (int i = 0; i < numNewPropertyNames; ++i) {\n        colorMap.put(i, nameGen.generateNextName());\n    }\n    for (GraphNode<Property, Void> node : graph.getNodes()) {\n        node.getValue().newName = colorMap.get(node.getAnnotation().hashCode());\n        renamingMap.put(node.getValue().oldName, node.getValue().newName);\n    }\n        for (Node n : stringNodesToRename) {\n        String oldName = n.getString();\n        Property p = propertyMap.get(oldName);\n        if (p != null && p.newName != null) {\n            Preconditions.checkState(oldName.equals(p.oldName));\n            if (!p.newName.equals(oldName)) {\n                n.setString(p.newName);\n                compiler.reportCodeChange();\n            }\n        }\n    }\n    logger.info(\"Collapsed \" + numRenamedPropertyNames + \" properties into \" + numNewPropertyNames + \" and skipped renaming \" + numSkippedPropertyNames + \" properties.\");\n}", "lc": 1.3181818181818181, "pi": 0.4540816326530613, "ma": 0.6666666666666666, "nbd": 0.5, "ml": 0.5833333333333334, "d": 0.8610973801285222, "mi": -0.8230570691138518, "fo": 2.0, "r": -0.028571428571428574, "e": 2.9137874173915654}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3769_306a9e00", "label": 1, "code": "/**\n * Following logic is taken from org.apache.jackrabbit.core.query.lucene.JackrabbitQueryParser#parse(java.lang.String)\n */\nprivate static String rewriteQueryText(String textsearch) {\n    // replace escaped ' with just '\n    StringBuilder rewritten = new StringBuilder();\n    // the default lucene query parser recognizes 'AND' and 'NOT' as\n    // keywords.\n    textsearch = textsearch.replaceAll(\"AND\", \"and\");\n    textsearch = textsearch.replaceAll(\"NOT\", \"not\");\n    boolean escaped = false;\n    for (int i = 0; i < textsearch.length(); i++) {\n        if (textsearch.charAt(i) == '\\\\') {\n            if (escaped) {\n                rewritten.append(\"\\\\\\\\\");\n                escaped = false;\n            } else {\n                escaped = true;\n            }\n        } else if (textsearch.charAt(i) == '\\'') {\n            if (escaped) {\n                escaped = false;\n            }\n            rewritten.append(textsearch.charAt(i));\n        } else if (textsearch.charAt(i) == ':') {\n            // fields as known in lucene are not supported\n            rewritten.append(\"\\\\:\");\n        } else {\n            if (escaped) {\n                rewritten.append('\\\\');\n                escaped = false;\n            }\n            rewritten.append(textsearch.charAt(i));\n        }\n    }\n    return rewritten.toString();\n}", "code_comment": "/**\n * Following logic is taken from org.apache.jackrabbit.core.query.lucene.JackrabbitQueryParser#parse(java.lang.String)\n */\n", "code_no_comment": "private static String rewriteQueryText(String textsearch) {\n        StringBuilder rewritten = new StringBuilder();\n            textsearch = textsearch.replaceAll(\"AND\", \"and\");\n    textsearch = textsearch.replaceAll(\"NOT\", \"not\");\n    boolean escaped = false;\n    for (int i = 0; i < textsearch.length(); i++) {\n        if (textsearch.charAt(i) == '\\\\') {\n            if (escaped) {\n                rewritten.append(\"\\\\\\\\\");\n                escaped = false;\n            } else {\n                escaped = true;\n            }\n        } else if (textsearch.charAt(i) == '\\'') {\n            if (escaped) {\n                escaped = false;\n            }\n            rewritten.append(textsearch.charAt(i));\n        } else if (textsearch.charAt(i) == ':') {\n                        rewritten.append(\"\\\\:\");\n        } else {\n            if (escaped) {\n                rewritten.append('\\\\');\n                escaped = false;\n            }\n            rewritten.append(textsearch.charAt(i));\n        }\n    }\n    return rewritten.toString();\n}", "lc": 0.7272727272727273, "pi": 0.9591836734693879, "ma": 0.6666666666666666, "nbd": 1.5, "ml": 0.5, "d": 0.726643598615917, "mi": -0.5021508459994267, "fo": 0.6666666666666666, "r": -0.028571428571428574, "e": 0.8145202393342499}
{"project_name": "JxPath", "project_version": 4, "label": 1, "code": "public Object getValue() {\n    return stringValue(node);\n}", "code_comment": NaN, "code_no_comment": "public Object getValue() {\n    return stringValue(node);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.144536851161457, "fo": -0.4166666666666667, "r": 2.6, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-442_246d53c5", "label": 1, "code": "/**\n *  Clean up the request cycle.\n */\nprivate void detach() {\n    // furthermore, the targets will be cg-ed with this cycle too\n    for (Iterator iter = requestTargets.iterator(); iter.hasNext(); ) {\n        IRequestTarget target = (IRequestTarget) iter.next();\n        if (target != null) {\n            try {\n                target.detach(this);\n            } catch (RuntimeException e) {\n                log.error(\"there was an error cleaning up target \" + target + \".\", e);\n            }\n        }\n    }\n    // remove any rendered feedback messages from the session\n    try {\n        session.cleanupFeedbackMessages();\n    } catch (RuntimeException re) {\n        log.error(\"there was an error cleaning up the feedback messages\", re);\n    }\n    if (updateSession) {\n        // attributes that might be required to update the cluster\n        try {\n            session.update();\n        } catch (RuntimeException re) {\n            log.error(\"there was an error updating the session \" + session + \".\", re);\n        }\n    }\n    try {\n        IRequestLogger requestLogger = getApplication().getRequestLogger();\n        if (requestLogger != null) {\n            requestLogger.requestTime((System.currentTimeMillis() - startTime));\n        }\n    } catch (RuntimeException re) {\n        log.error(\"there was an error in the RequestLogger ending.\", re);\n    }\n    // clear the used pagemap for this thread,\n    try {\n        session.requestDetached();\n    } catch (RuntimeException re) {\n        log.error(\"there was an error detaching the request from the session \" + session + \".\", re);\n    }\n    if (getResponse() instanceof BufferedWebResponse) {\n        try {\n            ((BufferedWebResponse) getResponse()).filter();\n        } catch (RuntimeException re) {\n            log.error(\"there was an error filtering the response.\", re);\n        }\n    }\n    try {\n        onEndRequest();\n    } catch (RuntimeException e) {\n        log.error(\"Exception occurred during onEndRequest\", e);\n    }\n    // Release thread local resources\n    try {\n        threadDetach();\n    } catch (RuntimeException re) {\n        log.error(\"Exception occurred during threadDetach\", re);\n    }\n}", "code_comment": "/**\n *  Clean up the request cycle.\n */\n", "code_no_comment": "private void detach() {\n        for (Iterator iter = requestTargets.iterator(); iter.hasNext(); ) {\n        IRequestTarget target = (IRequestTarget) iter.next();\n        if (target != null) {\n            try {\n                target.detach(this);\n            } catch (RuntimeException e) {\n                log.error(\"there was an error cleaning up target \" + target + \".\", e);\n            }\n        }\n    }\n        try {\n        session.cleanupFeedbackMessages();\n    } catch (RuntimeException re) {\n        log.error(\"there was an error cleaning up the feedback messages\", re);\n    }\n    if (updateSession) {\n                try {\n            session.update();\n        } catch (RuntimeException re) {\n            log.error(\"there was an error updating the session \" + session + \".\", re);\n        }\n    }\n    try {\n        IRequestLogger requestLogger = getApplication().getRequestLogger();\n        if (requestLogger != null) {\n            requestLogger.requestTime((System.currentTimeMillis() - startTime));\n        }\n    } catch (RuntimeException re) {\n        log.error(\"there was an error in the RequestLogger ending.\", re);\n    }\n        try {\n        session.requestDetached();\n    } catch (RuntimeException re) {\n        log.error(\"there was an error detaching the request from the session \" + session + \".\", re);\n    }\n    if (getResponse() instanceof BufferedWebResponse) {\n        try {\n            ((BufferedWebResponse) getResponse()).filter();\n        } catch (RuntimeException re) {\n            log.error(\"there was an error filtering the response.\", re);\n        }\n    }\n    try {\n        onEndRequest();\n    } catch (RuntimeException e) {\n        log.error(\"Exception occurred during onEndRequest\", e);\n    }\n        try {\n        threadDetach();\n    } catch (RuntimeException re) {\n        log.error(\"Exception occurred during threadDetach\", re);\n    }\n}", "lc": 1.8181818181818181, "pi": 0.25510204081632654, "ma": 1.6666666666666667, "nbd": 0.5, "ml": 0.4166666666666667, "d": 0.5032130499258528, "mi": -0.8680814453685117, "fo": 1.5, "r": -0.028571428571428574, "e": 0.951152342160604}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6667_1fc7bd7a", "label": 1, "code": "@Override\npublic boolean process(Exchange exchange, AsyncCallback callback) {\n    // use atomic integer to be able to pass reference and keep track on the values\n    AtomicInteger index = new AtomicInteger();\n    AtomicInteger count = new AtomicInteger();\n    // Intermediate conversion to String is needed when direct conversion to Integer is not available\n    // but evaluation result is a textual representation of a numeric value.\n    String text = expression.evaluate(exchange, String.class);\n    try {\n        int num = ExchangeHelper.convertToMandatoryType(exchange, Integer.class, text);\n        count.set(num);\n    } catch (NoTypeConversionAvailableException e) {\n        exchange.setException(e);\n        callback.done(true);\n        return true;\n    }\n    Exchange target = exchange;\n    // set the size before we start\n    exchange.setProperty(Exchange.LOOP_SIZE, count);\n    // loop synchronously\n    while (index.get() < count.get()) {\n        // and prepare for next iteration\n        target = prepareExchange(exchange, index.get());\n        boolean sync = process(target, callback, index, count);\n        if (!sync) {\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", target.getExchangeId());\n            // so we break out now, then the callback will be invoked which then continue routing from where we left here\n            return false;\n        }\n        LOG.trace(\"Processing exchangeId: {} is continued being processed synchronously\", target.getExchangeId());\n        // increment counter before next loop\n        index.getAndIncrement();\n    }\n    // we are done so prepare the result\n    ExchangeHelper.copyResults(exchange, target);\n    LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n    callback.done(true);\n    return true;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean process(Exchange exchange, AsyncCallback callback) {\n        AtomicInteger index = new AtomicInteger();\n    AtomicInteger count = new AtomicInteger();\n            String text = expression.evaluate(exchange, String.class);\n    try {\n        int num = ExchangeHelper.convertToMandatoryType(exchange, Integer.class, text);\n        count.set(num);\n    } catch (NoTypeConversionAvailableException e) {\n        exchange.setException(e);\n        callback.done(true);\n        return true;\n    }\n    Exchange target = exchange;\n        exchange.setProperty(Exchange.LOOP_SIZE, count);\n        while (index.get() < count.get()) {\n                target = prepareExchange(exchange, index.get());\n        boolean sync = process(target, callback, index, count);\n        if (!sync) {\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", target.getExchangeId());\n                        return false;\n        }\n        LOG.trace(\"Processing exchangeId: {} is continued being processed synchronously\", target.getExchangeId());\n                index.getAndIncrement();\n    }\n        ExchangeHelper.copyResults(exchange, target);\n    LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n    callback.done(true);\n    return true;\n}", "lc": 0.7272727272727273, "pi": 0.005102040816326422, "ma": 0.0, "nbd": 0.0, "ml": 0.0, "d": 0.06623826000988631, "mi": -0.5127616862632636, "fo": 1.1666666666666667, "r": -0.028571428571428574, "e": 0.34126545628980515}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1922_ccd574a4", "label": 1, "code": "public void deployToSlot(final SimpleSlot slot) throws JobException {\n    // sanity checks\n    if (slot == null) {\n        throw new NullPointerException();\n    }\n    if (!slot.isAlive()) {\n        throw new JobException(\"Target slot for deployment is not alive.\");\n    }\n    // make sure exactly one deployment call happens from the correct state\n    // note: the transition from CREATED to DEPLOYING is for testing purposes only\n    ExecutionState previous = this.state;\n    if (previous == SCHEDULED || previous == CREATED) {\n        if (!transitionState(previous, DEPLOYING)) {\n            // this should actually not happen and indicates a race somewhere else\n            throw new IllegalStateException(\"Cannot deploy task: Concurrent deployment call race.\");\n        }\n    } else {\n        // vertex may have been cancelled, or it was already scheduled\n        throw new IllegalStateException(\"The vertex must be in CREATED or SCHEDULED state to be deployed. Found state \" + previous);\n    }\n    try {\n        // good, we are allowed to deploy\n        if (!slot.setExecutedVertex(this)) {\n            throw new JobException(\"Could not assign the ExecutionVertex to the slot \" + slot);\n        }\n        this.assignedResource = slot;\n        this.assignedResourceLocation = slot.getInstance().getInstanceConnectionInfo();\n        // race double check, did we fail/cancel and do we need to release the slot?\n        if (this.state != DEPLOYING) {\n            slot.releaseSlot();\n            return;\n        }\n        if (LOG.isInfoEnabled()) {\n            LOG.info(String.format(\"Deploying %s (attempt #%d) to %s\", vertex.getSimpleName(), attemptNumber, slot.getInstance().getInstanceConnectionInfo().getHostname()));\n        }\n        final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(attemptId, slot);\n        // register this execution at the execution graph, to receive call backs\n        vertex.getExecutionGraph().registerExecution(this);\n        Instance instance = slot.getInstance();\n        Future<Object> deployAction = Patterns.ask(instance.getTaskManager(), new SubmitTask(deployment), new Timeout(timeout));\n        deployAction.onComplete(new OnComplete<Object>() {\n\n            @Override\n            public void onComplete(Throwable failure, Object success) throws Throwable {\n                if (failure != null) {\n                    if (failure instanceof TimeoutException) {\n                        markFailed(new Exception(\"Cannot deploy task - TaskManager not responding.\", failure));\n                    } else {\n                        markFailed(failure);\n                    }\n                } else {\n                    if (success == null) {\n                        markFailed(new Exception(\"Failed to deploy the task to slot \" + slot + \": TaskOperationResult was null\"));\n                    }\n                    if (success instanceof TaskOperationResult) {\n                        TaskOperationResult result = (TaskOperationResult) success;\n                        if (!result.executionID().equals(attemptId)) {\n                            markFailed(new Exception(\"Answer execution id does not match the request execution id.\"));\n                        } else if (result.success()) {\n                            switchToRunning();\n                        } else {\n                            // deployment failed :(\n                            markFailed(new Exception(\"Failed to deploy the task \" + getVertexWithAttempt() + \" to slot \" + slot + \": \" + result.description()));\n                        }\n                    } else {\n                        markFailed(new Exception(\"Failed to deploy the task to slot \" + slot + \": Response was not of type TaskOperationResult\"));\n                    }\n                }\n            }\n        }, AkkaUtils.globalExecutionContext());\n    } catch (Throwable t) {\n        markFailed(t);\n        ExceptionUtils.rethrow(t);\n    }\n}", "code_comment": NaN, "code_no_comment": "public void deployToSlot(final SimpleSlot slot) throws JobException {\n        if (slot == null) {\n        throw new NullPointerException();\n    }\n    if (!slot.isAlive()) {\n        throw new JobException(\"Target slot for deployment is not alive.\");\n    }\n            ExecutionState previous = this.state;\n    if (previous == SCHEDULED || previous == CREATED) {\n        if (!transitionState(previous, DEPLOYING)) {\n                        throw new IllegalStateException(\"Cannot deploy task: Concurrent deployment call race.\");\n        }\n    } else {\n                throw new IllegalStateException(\"The vertex must be in CREATED or SCHEDULED state to be deployed. Found state \" + previous);\n    }\n    try {\n                if (!slot.setExecutedVertex(this)) {\n            throw new JobException(\"Could not assign the ExecutionVertex to the slot \" + slot);\n        }\n        this.assignedResource = slot;\n        this.assignedResourceLocation = slot.getInstance().getInstanceConnectionInfo();\n                if (this.state != DEPLOYING) {\n            slot.releaseSlot();\n            return;\n        }\n        if (LOG.isInfoEnabled()) {\n            LOG.info(String.format(\"Deploying %s (attempt #%d) to %s\", vertex.getSimpleName(), attemptNumber, slot.getInstance().getInstanceConnectionInfo().getHostname()));\n        }\n        final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(attemptId, slot);\n                vertex.getExecutionGraph().registerExecution(this);\n        Instance instance = slot.getInstance();\n        Future<Object> deployAction = Patterns.ask(instance.getTaskManager(), new SubmitTask(deployment), new Timeout(timeout));\n        deployAction.onComplete(new OnComplete<Object>() {\n\n            @Override\n            public void onComplete(Throwable failure, Object success) throws Throwable {\n                if (failure != null) {\n                    if (failure instanceof TimeoutException) {\n                        markFailed(new Exception(\"Cannot deploy task - TaskManager not responding.\", failure));\n                    } else {\n                        markFailed(failure);\n                    }\n                } else {\n                    if (success == null) {\n                        markFailed(new Exception(\"Failed to deploy the task to slot \" + slot + \": TaskOperationResult was null\"));\n                    }\n                    if (success instanceof TaskOperationResult) {\n                        TaskOperationResult result = (TaskOperationResult) success;\n                        if (!result.executionID().equals(attemptId)) {\n                            markFailed(new Exception(\"Answer execution id does not match the request execution id.\"));\n                        } else if (result.success()) {\n                            switchToRunning();\n                        } else {\n                                                        markFailed(new Exception(\"Failed to deploy the task \" + getVertexWithAttempt() + \" to slot \" + slot + \": \" + result.description()));\n                        }\n                    } else {\n                        markFailed(new Exception(\"Failed to deploy the task to slot \" + slot + \": Response was not of type TaskOperationResult\"));\n                    }\n                }\n            }\n        }, AkkaUtils.globalExecutionContext());\n    } catch (Throwable t) {\n        markFailed(t);\n        ExceptionUtils.rethrow(t);\n    }\n}", "lc": 2.3181818181818183, "pi": 2.4285714285714284, "ma": 2.6666666666666665, "nbd": 2.0, "ml": 1.75, "d": 0.6831438457736037, "mi": -1.0880412962431893, "fo": 2.4166666666666665, "r": -0.028571428571428574, "e": 2.3651646172493694}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-579_7d72e6ed", "label": 3, "code": "@Override\npublic void restrict(FilterImpl f) {\n    if (f.getSelector() == selector1) {\n        String p2 = selector2.currentPath();\n        if (p2 != null) {\n            if (selector2Path.equals(\".\")) {\n                f.restrictPath(p2, Filter.PathRestriction.EXACT);\n            } else {\n                // TODO normalize paths; support more complex relative path (\"..\" and so on)\n                String p = PathUtils.concat(p2, selector2Path);\n                f.restrictPath(p, Filter.PathRestriction.EXACT);\n            }\n        }\n    }\n    if (f.getSelector() == selector2) {\n        String p1 = selector1.currentPath();\n        if (p1 != null) {\n            if (selector2Path.equals(\".\")) {\n                f.restrictPath(p1, Filter.PathRestriction.EXACT);\n            } else {\n            // TODO normalize paths; support relative path (\"..\" and so on)\n            }\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void restrict(FilterImpl f) {\n    if (f.getSelector() == selector1) {\n        String p2 = selector2.currentPath();\n        if (p2 != null) {\n            if (selector2Path.equals(\".\")) {\n                f.restrictPath(p2, Filter.PathRestriction.EXACT);\n            } else {\n                                String p = PathUtils.concat(p2, selector2Path);\n                f.restrictPath(p, Filter.PathRestriction.EXACT);\n            }\n        }\n    }\n    if (f.getSelector() == selector2) {\n        String p1 = selector1.currentPath();\n        if (p1 != null) {\n            if (selector2Path.equals(\".\")) {\n                f.restrictPath(p1, Filter.PathRestriction.EXACT);\n            } else {\n                        }\n        }\n    }\n}", "lc": 0.4090909090909091, "pi": 1.0561224489795917, "ma": 0.5, "nbd": 0.5, "ml": 0.5833333333333334, "d": 0.07414730598121602, "mi": -0.3168913105821623, "fo": 0.3333333333333333, "r": 0.0, "e": 0.11412063508379697}
{"project_name": "Compress", "project_version": 4, "label": 1, "code": "/**\n * Closes this output stream and releases any system resources\n * associated with the stream.\n *\n * @exception  IOException  if an I/O error occurs.\n */\npublic void close() throws IOException {\n    finish();\n    if (raf != null) {\n        raf.close();\n    }\n    if (out != null) {\n        out.close();\n    }\n}", "code_comment": "/**\n * Closes this output stream and releases any system resources\n * associated with the stream.\n *\n * @exception  IOException  if an I/O error occurs.\n */\n", "code_no_comment": "public void close() throws IOException {\n    finish();\n    if (raf != null) {\n        raf.close();\n    }\n    if (out != null) {\n        out.close();\n    }\n}", "lc": -0.22727272727272727, "pi": -0.17857142857142863, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.3806228373702422, "mi": 0.4293088614855177, "fo": -0.25, "r": 2.7714285714285714, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-9444_baece126", "label": 1, "code": "private AggregationStrategy createAggregationStrategy(RouteContext routeContext) {\n    AggregationStrategy strategy = getAggregationStrategy();\n    if (strategy == null && strategyRef != null) {\n        Object aggStrategy = routeContext.lookup(strategyRef, Object.class);\n        if (aggStrategy instanceof AggregationStrategy) {\n            strategy = (AggregationStrategy) aggStrategy;\n        } else if (aggStrategy != null) {\n            AggregationStrategyBeanAdapter adapter = new AggregationStrategyBeanAdapter(aggStrategy, getStrategyMethodName());\n            if (getStrategyMethodAllowNull() != null) {\n                adapter.setAllowNullNewExchange(getStrategyMethodAllowNull());\n                adapter.setAllowNullOldExchange(getStrategyMethodAllowNull());\n            }\n            strategy = adapter;\n        } else {\n            throw new IllegalArgumentException(\"Cannot find AggregationStrategy in Registry with name: \" + strategyRef);\n        }\n    }\n    if (strategy == null) {\n        // fallback to use latest\n        strategy = new UseLatestAggregationStrategy();\n    }\n    if (strategy instanceof CamelContextAware) {\n        ((CamelContextAware) strategy).setCamelContext(routeContext.getCamelContext());\n    }\n    return strategy;\n}", "code_comment": NaN, "code_no_comment": "private AggregationStrategy createAggregationStrategy(RouteContext routeContext) {\n    AggregationStrategy strategy = getAggregationStrategy();\n    if (strategy == null && strategyRef != null) {\n        Object aggStrategy = routeContext.lookup(strategyRef, Object.class);\n        if (aggStrategy instanceof AggregationStrategy) {\n            strategy = (AggregationStrategy) aggStrategy;\n        } else if (aggStrategy != null) {\n            AggregationStrategyBeanAdapter adapter = new AggregationStrategyBeanAdapter(aggStrategy, getStrategyMethodName());\n            if (getStrategyMethodAllowNull() != null) {\n                adapter.setAllowNullNewExchange(getStrategyMethodAllowNull());\n                adapter.setAllowNullOldExchange(getStrategyMethodAllowNull());\n            }\n            strategy = adapter;\n        } else {\n            throw new IllegalArgumentException(\"Cannot find AggregationStrategy in Registry with name: \" + strategyRef);\n        }\n    }\n    if (strategy == null) {\n                strategy = new UseLatestAggregationStrategy();\n    }\n    if (strategy instanceof CamelContextAware) {\n        ((CamelContextAware) strategy).setCamelContext(routeContext.getCamelContext());\n    }\n    return strategy;\n}", "lc": 0.5, "pi": 0.6887755102040817, "ma": 0.6666666666666666, "nbd": 1.0, "ml": 0.5, "d": 0.5249629263470095, "mi": -0.386005162030399, "fo": 0.3333333333333333, "r": -0.028571428571428574, "e": 0.48424925368659544}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-193_8ad5a888", "label": 3, "code": "public String toString() {\n    String labelString = new ColumnVisibility(colVisibility).toString();\n    String s = toPrintableString(row, 0, row.length, Constants.MAX_DATA_TO_PRINT) + \" \" + toPrintableString(colFamily, 0, colFamily.length, Constants.MAX_DATA_TO_PRINT) + \":\" + toPrintableString(colQualifier, 0, colQualifier.length, Constants.MAX_DATA_TO_PRINT) + \" \" + labelString + \" \" + Long.toString(timestamp) + \" \" + deleted;\n    return s;\n}", "code_comment": NaN, "code_no_comment": "public String toString() {\n    String labelString = new ColumnVisibility(colVisibility).toString();\n    String s = toPrintableString(row, 0, row.length, Constants.MAX_DATA_TO_PRINT) + \" \" + toPrintableString(colFamily, 0, colFamily.length, Constants.MAX_DATA_TO_PRINT) + \":\" + toPrintableString(colQualifier, 0, colQualifier.length, Constants.MAX_DATA_TO_PRINT) + \" \" + labelString + \" \" + Long.toString(timestamp) + \" \" + deleted;\n    return s;\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": 0.03460207612456753, "mi": 0.48236306280470315, "fo": -0.08333333333333333, "r": -0.028571428571428574, "e": 0.016266848266025938}
{"project_name": "Closure", "project_version": 108, "label": 2, "code": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n}", "lc": -0.045454545454545456, "pi": 0.09183673469387764, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.16666666666666666, "d": -0.0958971824023727, "mi": 0.10868941783768263, "fo": 0.0, "r": 0.4857142857142857, "e": -0.09361361309913868}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-208_b224bad8", "label": 3, "code": "/**\n *  @see wicket.behavior.AbstractAjaxBehavior#renderHead(wicket.markup.html.IHeaderResponse)\n */\npublic void renderHead(IHeaderResponse response) {\n    super.renderHead(response);\n    if (this.attachedBodyOnLoadModifier == false) {\n        this.attachedBodyOnLoadModifier = true;\n        ((WebPage) getComponent().getPage()).getBodyContainer().addOnLoadModifier(getJsTimeoutCall(updateInterval), getComponent());\n    }\n}", "code_comment": "/**\n *  @see wicket.behavior.AbstractAjaxBehavior#renderHead(wicket.markup.html.IHeaderResponse)\n */\n", "code_no_comment": "public void renderHead(IHeaderResponse response) {\n    super.renderHead(response);\n    if (this.attachedBodyOnLoadModifier == false) {\n        this.attachedBodyOnLoadModifier = true;\n        ((WebPage) getComponent().getPage()).getBodyContainer().addOnLoadModifier(getJsTimeoutCall(updateInterval), getComponent());\n    }\n}", "lc": -0.3181818181818182, "pi": 0.0, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.1255561047948591, "mi": 0.45655291081158605, "fo": 0.08333333333333333, "r": 0.4571428571428572, "e": -0.1201725193912995}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3834_747bccb5", "label": 1, "code": "/**\n *  Parses the given URL string.\n *\n *  @param url\n *  @return Url object\n */\npublic static Url parse(final String url) {\n    return parse(url, null);\n}", "code_comment": "/**\n *  Parses the given URL string.\n *\n *  @param url\n *  @return Url object\n */\n", "code_no_comment": "public static Url parse(final String url) {\n    return parse(url, null);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.0585030111843994, "fo": -0.4166666666666667, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-855_ac597cc1", "label": 3, "code": "/**\n * {@inheritDoc}\n */\n@Override\nprotected UnivariatePointValuePair doOptimize() {\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n    final double lo = getMin();\n    final double mid = getStartValue();\n    final double hi = getMax();\n    // Optional additional convergence criteria.\n    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\n    double a;\n    double b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(x);\n    if (!isMinim) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n    UnivariatePointValuePair previous = null;\n    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n    int iter = 0;\n    while (true) {\n        final double m = 0.5 * (a + b);\n        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 = 2 * tol1;\n        // Default stopping criterion.\n        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n            if (FastMath.abs(e) > tol1) {\n                // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n            // Update by at least \"tol1\".\n            if (FastMath.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                u = x + d;\n            }\n            double fu = computeObjectiveValue(u);\n            if (!isMinim) {\n                fu = -fu;\n            }\n            // User-defined convergence checker.\n            previous = current;\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n            if (checker != null) {\n                if (checker.converged(iter, previous, current)) {\n                    return best(current, previous, isMinim);\n                }\n            }\n            // Update a, b, v, w and x.\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw || Precision.equals(w, x)) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else {\n            // Default termination (Brent's criterion).\n            return best(current, previous, isMinim);\n        }\n        ++iter;\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\nprotected UnivariatePointValuePair doOptimize() {\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n    final double lo = getMin();\n    final double mid = getStartValue();\n    final double hi = getMax();\n        final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\n    double a;\n    double b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(x);\n    if (!isMinim) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n    UnivariatePointValuePair previous = null;\n    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n    int iter = 0;\n    while (true) {\n        final double m = 0.5 * (a + b);\n        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 = 2 * tol1;\n                final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n            if (FastMath.abs(e) > tol1) {\n                                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                                        d = p / q;\n                    u = x + d;\n                                        if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                    }\n                } else {\n                                        if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n                        if (FastMath.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                u = x + d;\n            }\n            double fu = computeObjectiveValue(u);\n            if (!isMinim) {\n                fu = -fu;\n            }\n                        previous = current;\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n            if (checker != null) {\n                if (checker.converged(iter, previous, current)) {\n                    return best(current, previous, isMinim);\n                }\n            }\n                        if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw || Precision.equals(w, x)) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else {\n                        return best(current, previous, isMinim);\n        }\n        ++iter;\n    }\n}", "lc": 5.363636363636363, "pi": 1.7500000000000002, "ma": 3.3333333333333335, "nbd": 2.0, "ml": 4.833333333333333, "d": 6.897676717745924, "mi": -1.5744192715801555, "fo": 1.0833333333333333, "r": -0.028571428571428574, "e": 41.445141146388785}
{"project_name": "Closure", "project_version": 148, "label": 2, "code": "/**\n * Adds a mapping for the given node.  Mappings must be added in order.\n *\n * @param node The node that the new mapping represents.\n * @param startPosition The position on the starting line\n * @param endPosition The position on the ending line.\n */\nvoid addMapping(Node node, Position startPosition, Position endPosition) {\n    String sourceFile = (String) node.getProp(Node.SOURCEFILE_PROP);\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n        return;\n    }\n    String escapedSourceFile;\n    if (lastSourceFile != sourceFile) {\n        // yes, \"s1 != s2\" not \"!s1.equals(s2)\"\n        lastSourceFile = sourceFile;\n        lastSourceFileEscaped = escapeString(sourceFile);\n    }\n    escapedSourceFile = lastSourceFileEscaped;\n    // Create the new mapping.\n    Mapping mapping = new Mapping();\n    mapping.id = mappings.size();\n    mapping.sourceFile = escapedSourceFile;\n    mapping.originalPosition = new Position(node.getLineno(), node.getCharno());\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n    if (originalName != null) {\n        mapping.originalName = escapeString(originalName);\n    }\n    // If the mapping is found on the first line, we need to offset\n    // its character position by the number of characters found on\n    // the *last* line of the source file to which the code is\n    // being generated.\n    int offsetLine = offsetPosition.getLineNumber();\n    int startOffsetPosition = offsetPosition.getCharacterIndex();\n    int endOffsetPosition = offsetPosition.getCharacterIndex();\n    if (startPosition.getLineNumber() > 0) {\n        startOffsetPosition = 0;\n    }\n    if (endPosition.getLineNumber() > 0) {\n        endOffsetPosition = 0;\n    }\n    mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition);\n    mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition);\n    mappings.add(mapping);\n}", "code_comment": "/**\n * Adds a mapping for the given node.  Mappings must be added in order.\n *\n * @param node The node that the new mapping represents.\n * @param startPosition The position on the starting line\n * @param endPosition The position on the ending line.\n */\n", "code_no_comment": "void addMapping(Node node, Position startPosition, Position endPosition) {\n    String sourceFile = (String) node.getProp(Node.SOURCEFILE_PROP);\n        if (sourceFile == null || node.getLineno() < 0) {\n        return;\n    }\n    String escapedSourceFile;\n    if (lastSourceFile != sourceFile) {\n                lastSourceFile = sourceFile;\n        lastSourceFileEscaped = escapeString(sourceFile);\n    }\n    escapedSourceFile = lastSourceFileEscaped;\n        Mapping mapping = new Mapping();\n    mapping.id = mappings.size();\n    mapping.sourceFile = escapedSourceFile;\n    mapping.originalPosition = new Position(node.getLineno(), node.getCharno());\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n    if (originalName != null) {\n        mapping.originalName = escapeString(originalName);\n    }\n                    int offsetLine = offsetPosition.getLineNumber();\n    int startOffsetPosition = offsetPosition.getCharacterIndex();\n    int endOffsetPosition = offsetPosition.getCharacterIndex();\n    if (startPosition.getLineNumber() > 0) {\n        startOffsetPosition = 0;\n    }\n    if (endPosition.getLineNumber() > 0) {\n        endOffsetPosition = 0;\n    }\n    mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition);\n    mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition);\n    mappings.add(mapping);\n}", "lc": 0.8181818181818182, "pi": -0.5510204081632654, "ma": 0.3333333333333333, "nbd": -0.5, "ml": 0.5833333333333334, "d": 1.3811171527434507, "mi": -0.5973616289073703, "fo": 1.0, "r": -0.028571428571428574, "e": 2.473734479465139}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2544_7ec60f1b", "label": 1, "code": "@Override\npublic void deleteRows(String tableName, Text start, Text end) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n    if (!exists(tableName))\n        throw new TableNotFoundException(tableName, tableName, \"\");\n    MockTable t = acu.tables.get(tableName);\n    Set<Key> keep = new TreeSet<Key>(t.table.tailMap(new Key(start)).headMap(new Key(end)).keySet());\n    t.table.keySet().removeAll(keep);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void deleteRows(String tableName, Text start, Text end) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n    if (!exists(tableName))\n        throw new TableNotFoundException(tableName, tableName, \"\");\n    MockTable t = acu.tables.get(tableName);\n    Set<Key> keep = new TreeSet<Key>(t.table.tailMap(new Key(start)).headMap(new Key(end)).keySet());\n    t.table.keySet().removeAll(keep);\n}", "lc": -0.2727272727272727, "pi": -0.1887755102040817, "ma": -0.16666666666666666, "nbd": -1.0, "ml": -0.16666666666666666, "d": -0.06623826000988627, "mi": 0.23458560367077702, "fo": 0.08333333333333333, "r": -0.028571428571428574, "e": -0.011799675348315285}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-757_76b7413d", "label": 1, "code": "/**\n * Sets the {@link ExpansionMode expansion mode}.\n *\n * @param expansionMode Expansion mode to use for resizing the array.\n * @deprecated As of 3.1 (to be removed in 4.0 as field will become \"final\").\n */\n@Deprecated\npublic void setExpansionMode(ExpansionMode expansionMode) {\n    this.expansionMode = expansionMode;\n}", "code_comment": "/**\n * Sets the {@link ExpansionMode expansion mode}.\n *\n * @param expansionMode Expansion mode to use for resizing the array.\n * @deprecated As of 3.1 (to be removed in 4.0 as field will become \"final\").\n */\n", "code_no_comment": "@Deprecated\npublic void setExpansionMode(ExpansionMode expansionMode) {\n    this.expansionMode = expansionMode;\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9248637797533699, "fo": -0.5, "r": 2.542857142857143, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 53, "label": 2, "code": "/**\n * Replaces an assignment like x = {...} with t1=a,t2=b,t3=c,true.\n * Note that the resulting expression will always evaluate to\n * true, as would the x = {...} expression.\n */\nprivate void replaceAssignmentExpression(Var v, Reference ref, Map<String, String> varmap) {\n    // Compute all of the assignments necessary\n    List<Node> nodes = Lists.newArrayList();\n    Node val = ref.getAssignedValue();\n    blacklistVarReferencesInTree(val, v.scope);\n    Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n    Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n    for (Node key = val.getFirstChild(); key != null; key = key.getNext()) {\n        String var = key.getString();\n        Node value = key.removeFirstChild();\n        // TODO(user): Copy type information.\n        nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), value));\n        all.remove(var);\n    }\n    // TODO(user): Better source information.\n    for (String var : all) {\n        nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), NodeUtil.newUndefinedNode(null)));\n    }\n    Node replacement;\n    // All assignments evaluate to true, so make sure that the\n    // expr statement evaluates to true in case it matters.\n    nodes.add(new Node(Token.TRUE));\n    // Join these using COMMA.  A COMMA node must have 2 children, so we\n    // create a tree. In the tree the first child be the COMMA to match\n    // the parser, otherwise tree equality tests fail.\n    nodes = Lists.reverse(nodes);\n    replacement = new Node(Token.COMMA);\n    Node cur = replacement;\n    int i;\n    for (i = 0; i < nodes.size() - 2; i++) {\n        cur.addChildToFront(nodes.get(i));\n        Node t = new Node(Token.COMMA);\n        cur.addChildToFront(t);\n        cur = t;\n    }\n    cur.addChildToFront(nodes.get(i));\n    cur.addChildToFront(nodes.get(i + 1));\n    Node replace = ref.getParent();\n    replacement.copyInformationFromForTree(replace);\n    if (replace.getType() == Token.VAR) {\n        replace.getParent().replaceChild(replace, NodeUtil.newExpr(replacement));\n    } else {\n        replace.getParent().replaceChild(replace, replacement);\n    }\n}", "code_comment": "/**\n * Replaces an assignment like x = {...} with t1=a,t2=b,t3=c,true.\n * Note that the resulting expression will always evaluate to\n * true, as would the x = {...} expression.\n */\n", "code_no_comment": "private void replaceAssignmentExpression(Var v, Reference ref, Map<String, String> varmap) {\n        List<Node> nodes = Lists.newArrayList();\n    Node val = ref.getAssignedValue();\n    blacklistVarReferencesInTree(val, v.scope);\n    Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n    Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n    for (Node key = val.getFirstChild(); key != null; key = key.getNext()) {\n        String var = key.getString();\n        Node value = key.removeFirstChild();\n                nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), value));\n        all.remove(var);\n    }\n        for (String var : all) {\n        nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), NodeUtil.newUndefinedNode(null)));\n    }\n    Node replacement;\n            nodes.add(new Node(Token.TRUE));\n                nodes = Lists.reverse(nodes);\n    replacement = new Node(Token.COMMA);\n    Node cur = replacement;\n    int i;\n    for (i = 0; i < nodes.size() - 2; i++) {\n        cur.addChildToFront(nodes.get(i));\n        Node t = new Node(Token.COMMA);\n        cur.addChildToFront(t);\n        cur = t;\n    }\n    cur.addChildToFront(nodes.get(i));\n    cur.addChildToFront(nodes.get(i + 1));\n    Node replace = ref.getParent();\n    replacement.copyInformationFromForTree(replace);\n    if (replace.getType() == Token.VAR) {\n        replace.getParent().replaceChild(replace, NodeUtil.newExpr(replacement));\n    } else {\n        replace.getParent().replaceChild(replace, replacement);\n    }\n}", "lc": 1.0454545454545454, "pi": -0.43877551020408156, "ma": 0.16666666666666666, "nbd": -0.5, "ml": 0.16666666666666666, "d": 1.1695501730103808, "mi": -0.7301405219386297, "fo": 2.5833333333333335, "r": -0.028571428571428574, "e": 3.5887888093677858}
{"project_name": "JxPath", "project_version": 4, "label": 1, "code": "public Object getValue() {\n    if (node instanceof Element) {\n        return ((Element) node).getTextTrim();\n    }\n    if (node instanceof Comment) {\n        String text = ((Comment) node).getText();\n        if (text != null) {\n            text = text.trim();\n        }\n        return text;\n    }\n    if (node instanceof Text) {\n        return ((Text) node).getTextTrim();\n    }\n    if (node instanceof CDATA) {\n        return ((CDATA) node).getTextTrim();\n    }\n    if (node instanceof ProcessingInstruction) {\n        String text = ((ProcessingInstruction) node).getData();\n        if (text != null) {\n            text = text.trim();\n        }\n        return text;\n    }\n    return null;\n}", "code_comment": NaN, "code_no_comment": "public Object getValue() {\n    if (node instanceof Element) {\n        return ((Element) node).getTextTrim();\n    }\n    if (node instanceof Comment) {\n        String text = ((Comment) node).getText();\n        if (text != null) {\n            text = text.trim();\n        }\n        return text;\n    }\n    if (node instanceof Text) {\n        return ((Text) node).getTextTrim();\n    }\n    if (node instanceof CDATA) {\n        return ((CDATA) node).getTextTrim();\n    }\n    if (node instanceof ProcessingInstruction) {\n        String text = ((ProcessingInstruction) node).getData();\n        if (text != null) {\n            text = text.trim();\n        }\n        return text;\n    }\n    return null;\n}", "lc": 0.5454545454545454, "pi": -0.015306122448979493, "ma": 0.6666666666666666, "nbd": 0.0, "ml": 0.3333333333333333, "d": 0.17498764211566986, "mi": -0.33839977057642673, "fo": 0.08333333333333333, "r": 0.0, "e": 0.09194752463797912}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1136_cc4ab51e", "label": 3, "code": "/**\n * {@inheritDoc} *\n */\n@Override\npublic double logProbability(int x) {\n    double ret;\n    if (x < 0 || x > numberOfTrials) {\n        ret = Double.NEGATIVE_INFINITY;\n    } else {\n        ret = SaddlePointExpansion.logBinomialProbability(x, numberOfTrials, probabilityOfSuccess, 1.0 - probabilityOfSuccess);\n    }\n    return ret;\n}", "code_comment": "/**\n * {@inheritDoc} *\n */\n", "code_no_comment": "@Override\npublic double logProbability(int x) {\n    double ret;\n    if (x < 0 || x > numberOfTrials) {\n        ret = Double.NEGATIVE_INFINITY;\n    } else {\n        ret = SaddlePointExpansion.logBinomialProbability(x, numberOfTrials, probabilityOfSuccess, 1.0 - probabilityOfSuccess);\n    }\n    return ret;\n}", "lc": -0.18181818181818182, "pi": -0.11224489795918377, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.08333333333333333, "d": 0.2580326248146318, "mi": 0.2397476340694007, "fo": -0.4166666666666667, "r": 1.2571428571428573, "e": -0.008433234395946565}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4616_dd1df04b", "label": 1, "code": "@Override\npublic void component(final Component component, final IVisit<Void> visit) {\n    final Form<?> form = (Form<?>) component;\n    if (!form.isEnabledInHierarchy() || !form.isVisibleInHierarchy()) {\n        visit.dontGoDeeper();\n        return;\n    }\n    if (form.hasError()) {\n        form.onError();\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void component(final Component component, final IVisit<Void> visit) {\n    final Form<?> form = (Form<?>) component;\n    if (!form.isEnabledInHierarchy() || !form.isVisibleInHierarchy()) {\n        visit.dontGoDeeper();\n        return;\n    }\n    if (form.hasError()) {\n        form.onError();\n    }\n}", "lc": -0.13636363636363635, "pi": -0.035714285714285636, "ma": -0.16666666666666666, "nbd": -0.5, "ml": 0.08333333333333333, "d": -0.07019278299555112, "mi": 0.19759105248064246, "fo": -0.08333333333333333, "r": -0.028571428571428574, "e": -0.09270133329906931}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2882_ebe56869", "label": 1, "code": "/**\n *  @see org.apache.wicket.application.IComponentOnBeforeRenderListener#onBeforeRender(org.apache.wicket.Component)\n */\npublic void onAfterRender(final Component component) {\n    if (log.isWarnEnabled()) {\n        if ((component instanceof FormComponent) || (component instanceof IFormSubmittingComponent) || (component instanceof Form)) {\n            log.warn(\"Please note that onBeforeRender() and validate() might be called on invisible components inside an Enclosure. \" + \"Please see EnclosureContainer for an alternative. Enclosure: \" + enclosure.toString());\n        }\n    }\n}", "code_comment": "/**\n *  @see org.apache.wicket.application.IComponentOnBeforeRenderListener#onBeforeRender(org.apache.wicket.Component)\n */\n", "code_no_comment": "public void onAfterRender(final Component component) {\n    if (log.isWarnEnabled()) {\n        if ((component instanceof FormComponent) || (component instanceof IFormSubmittingComponent) || (component instanceof Form)) {\n            log.warn(\"Please note that onBeforeRender() and validate() might be called on invisible components inside an Enclosure. \" + \"Please see EnclosureContainer for an alternative. Enclosure: \" + enclosure.toString());\n        }\n    }\n}", "lc": -0.3181818181818182, "pi": 0.5612244897959184, "ma": -0.16666666666666666, "nbd": 0.0, "ml": 0.08333333333333333, "d": -0.1255561047948591, "mi": 0.44995698308001153, "fo": -0.25, "r": 0.05714285714285714, "e": -0.1201725193912995}
{"project_name": "Closure", "project_version": 165, "label": 2, "code": "/**\n * Returns whether the given property can possibly be set on the given type.\n */\npublic boolean canPropertyBeDefined(JSType type, String propertyName) {\n    if (typesIndexedByProperty.containsKey(propertyName)) {\n        for (JSType alt : typesIndexedByProperty.get(propertyName).getAlternates()) {\n            JSType greatestSubtype = alt.getGreatestSubtype(type);\n            if (!greatestSubtype.isEmptyType()) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "code_comment": "/**\n * Returns whether the given property can possibly be set on the given type.\n */\n", "code_no_comment": "public boolean canPropertyBeDefined(JSType type, String propertyName) {\n    if (typesIndexedByProperty.containsKey(propertyName)) {\n        for (JSType alt : typesIndexedByProperty.get(propertyName).getAlternates()) {\n            JSType greatestSubtype = alt.getGreatestSubtype(type);\n            if (!greatestSubtype.isEmptyType()) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "lc": -0.13636363636363635, "pi": 1.040816326530612, "ma": 0.0, "nbd": 0.5, "ml": 0.0, "d": -0.08403361344537813, "mi": 0.18812733008316615, "fo": -0.08333333333333333, "r": 0.7142857142857143, "e": -0.09457300594052621}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1829_ca36450e", "label": 1, "code": "@Override\npublic PropertyValue currentProperty() {\n    PropertyValue p = operand.currentProperty();\n    if (p == null) {\n        return null;\n    }\n    // TODO what is the expected result of LOWER(x) for an array property?\n    // currently throws an exception\n    String value = p.getValue(STRING);\n    // TODO toLowerCase(): document the Turkish locale problem\n    return PropertyValues.newString(value.toLowerCase());\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic PropertyValue currentProperty() {\n    PropertyValue p = operand.currentProperty();\n    if (p == null) {\n        return null;\n    }\n            String value = p.getValue(STRING);\n        return PropertyValues.newString(value.toLowerCase());\n}", "lc": -0.22727272727272727, "pi": -0.2602040816326532, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.09787444389520514, "mi": 0.3188987668482939, "fo": -0.16666666666666666, "r": 2.4571428571428573, "e": -0.10793597765985241}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5357_4cf7e80e", "label": 1, "code": "public static String encode(String s) {\n    int n = s == null ? 0 : s.length();\n    if (n == 0) {\n        return s;\n    }\n    // First check whether we actually need to encode\n    char[] chars = s.toCharArray();\n    for (int i = 0; ; ) {\n        // just deal with the ascii character\n        if (chars[i] > 0 && chars[i] < 128) {\n            if (unsafeCharacters.get(chars[i])) {\n                break;\n            }\n        }\n        if (++i >= chars.length) {\n            return s;\n        }\n    }\n    // okay there are some unsafe characters so we do need to encode\n    StringBuilder sb = new StringBuilder();\n    for (char ch : chars) {\n        if (ch > 0 && ch < 128 && unsafeCharacters.get(ch)) {\n            appendEscape(sb, (byte) ch);\n        } else {\n            sb.append(ch);\n        }\n    }\n    return sb.toString();\n}", "code_comment": NaN, "code_no_comment": "public static String encode(String s) {\n    int n = s == null ? 0 : s.length();\n    if (n == 0) {\n        return s;\n    }\n        char[] chars = s.toCharArray();\n    for (int i = 0; ; ) {\n                if (chars[i] > 0 && chars[i] < 128) {\n            if (unsafeCharacters.get(chars[i])) {\n                break;\n            }\n        }\n        if (++i >= chars.length) {\n            return s;\n        }\n    }\n        StringBuilder sb = new StringBuilder();\n    for (char ch : chars) {\n        if (ch > 0 && ch < 128 && unsafeCharacters.get(ch)) {\n            appendEscape(sb, (byte) ch);\n        } else {\n            sb.append(ch);\n        }\n    }\n    return sb.toString();\n}", "lc": 0.5454545454545454, "pi": 0.46428571428571436, "ma": 1.0, "nbd": 0.5, "ml": 0.9166666666666666, "d": 1.1913000494315376, "mi": -0.4141095497562375, "fo": 0.08333333333333333, "r": 0.14285714285714285, "e": 0.936714336498473}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-428_4a6a573b", "label": 3, "code": "public Iterator iterator() {\n    return new Iterator() {\n\n        public boolean hasNext() {\n            return i < size;\n        }\n\n        public Object next() {\n            // Find next key\n            i = nextKey(nextIndex(i));\n            // Just in case... (WICKET-428)\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            // Get key\n            return keys[i];\n        }\n\n        public void remove() {\n            keys[i] = null;\n            values[i] = null;\n            size--;\n        }\n\n        int i = -1;\n    };\n}", "code_comment": NaN, "code_no_comment": "public Iterator iterator() {\n    return new Iterator() {\n\n        public boolean hasNext() {\n            return i < size;\n        }\n\n        public Object next() {\n                        i = nextKey(nextIndex(i));\n                        if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n                        return keys[i];\n        }\n\n        public void remove() {\n            keys[i] = null;\n            values[i] = null;\n            size--;\n        }\n\n        int i = -1;\n    };\n}", "lc": 0.2727272727272727, "pi": 0.5612244897959184, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.25, "d": 0.2876915472071182, "mi": -0.13507312876398075, "fo": -0.25, "r": 2.6, "e": 0.05799187085887076}
{"project_name": "Math", "project_version": 76, "label": 1, "code": "/**\n * {@inheritDoc}\n */\npublic RealMatrix getU() throws InvalidMatrixException {\n    if (cachedU == null) {\n        final int p = singularValues.length;\n        if (m >= n) {\n            // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n            final double[][] eData = e.getData();\n            final double[][] wData = new double[m][p];\n            double[] ei1 = eData[0];\n            for (int i = 0; i < p - 1; ++i) {\n                // compute W = B.E.S^(-1) where E is the eigenvectors matrix\n                final double mi = mainBidiagonal[i];\n                final double[] ei0 = ei1;\n                final double[] wi = wData[i];\n                ei1 = eData[i + 1];\n                final double si = secondaryBidiagonal[i];\n                for (int j = 0; j < p; ++j) {\n                    wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                }\n            }\n            for (int j = 0; j < p; ++j) {\n                wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n            }\n            for (int i = p; i < m; ++i) {\n                wData[i] = new double[p];\n            }\n            cachedU = transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\n        } else {\n            // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n            cachedU = transformer.getU().multiply(e);\n        }\n    }\n    // return the cached matrix\n    return cachedU;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public RealMatrix getU() throws InvalidMatrixException {\n    if (cachedU == null) {\n        final int p = singularValues.length;\n        if (m >= n) {\n                        final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n            final double[][] eData = e.getData();\n            final double[][] wData = new double[m][p];\n            double[] ei1 = eData[0];\n            for (int i = 0; i < p - 1; ++i) {\n                                final double mi = mainBidiagonal[i];\n                final double[] ei0 = ei1;\n                final double[] wi = wData[i];\n                ei1 = eData[i + 1];\n                final double si = secondaryBidiagonal[i];\n                for (int j = 0; j < p; ++j) {\n                    wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                }\n            }\n            for (int j = 0; j < p; ++j) {\n                wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n            }\n            for (int i = p; i < m; ++i) {\n                wData[i] = new double[p];\n            }\n            cachedU = transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\n        } else {\n                        final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n            cachedU = transformer.getU().multiply(e);\n        }\n    }\n        return cachedU;\n}", "lc": 0.8181818181818182, "pi": 0.9132653061224488, "ma": 0.5, "nbd": 1.0, "ml": 0.5833333333333334, "d": 2.3756796836381615, "mi": -0.6363636363636365, "fo": 0.3333333333333333, "r": -0.028571428571428574, "e": 4.954535915127997}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-498_f2a2edec", "label": 1, "code": "@Override\npublic boolean name(String name, int index) {\n    return true;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean name(String name, int index) {\n    return true;\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9446515629480932, "fo": -0.5, "r": 1.8285714285714287, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2799_3979fa8d", "label": 1, "code": "@Override\npublic OakIndexInput clone() {\n    return new OakIndexInput(this);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic OakIndexInput clone() {\n    return new OakIndexInput(this);\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.0332664181244626, "fo": -0.5, "r": 2.0571428571428574, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 167, "label": 2, "code": "private FlowScope caseNameOrGetProp(Node name, FlowScope blindScope, boolean outcome) {\n    JSType type = getTypeIfRefinable(name, blindScope);\n    if (type != null) {\n        JSType restrictedType = type.getRestrictedTypeGivenToBooleanOutcome(outcome);\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, name, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}", "code_comment": NaN, "code_no_comment": "private FlowScope caseNameOrGetProp(Node name, FlowScope blindScope, boolean outcome) {\n    JSType type = getTypeIfRefinable(name, blindScope);\n    if (type != null) {\n        JSType restrictedType = type.getRestrictedTypeGivenToBooleanOutcome(outcome);\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, name, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}", "lc": -0.18181818181818182, "pi": -0.015306122448979493, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.00889767671774591, "mi": 0.20562087754516786, "fo": -0.16666666666666666, "r": 0.0, "e": -0.0503724071766011}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5176_34634266", "label": 3, "code": "/**\n *  @see org.apache.wicket.model.IDetachable#detach()\n */\n@Override\nprotected final void onDetach() {\n    super.onDetach();\n    // detach any model\n    if (model != null) {\n        model.detach();\n    }\n    // some parameters can be detachable\n    if (parameters != null) {\n        for (Object parameter : parameters) {\n            if (parameter instanceof IDetachable) {\n                ((IDetachable) parameter).detach();\n            }\n        }\n    }\n    if (defaultValue != null) {\n        defaultValue.detach();\n    }\n}", "code_comment": "/**\n *  @see org.apache.wicket.model.IDetachable#detach()\n */\n", "code_no_comment": "@Override\nprotected final void onDetach() {\n    super.onDetach();\n        if (model != null) {\n        model.detach();\n    }\n        if (parameters != null) {\n        for (Object parameter : parameters) {\n            if (parameter instanceof IDetachable) {\n                ((IDetachable) parameter).detach();\n            }\n        }\n    }\n    if (defaultValue != null) {\n        defaultValue.detach();\n    }\n}", "lc": 0.13636363636363635, "pi": 0.6836734693877553, "ma": 0.3333333333333333, "nbd": 0.5, "ml": 0.25, "d": -0.3806228373702422, "mi": 0.0008603383997706093, "fo": -0.16666666666666666, "r": 0.6285714285714287, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-705_645d642b", "label": 1, "code": "/**\n * Reinitialize the instance\n * <p>Some Runge-Kutta integrators need fewer functions evaluations\n * than their counterpart step interpolators. So the interpolator\n * should perform the last evaluations they need by themselves. The\n * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n * abstract classes call this method in order to let the step\n * interpolator perform the evaluations it needs. These evaluations\n * will be performed during the call to <code>doFinalize</code> if\n * any, i.e. only if the step handler either calls the {@link\n * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n * {@link AbstractStepInterpolator#getInterpolatedState\n * getInterpolatedState} method (for an interpolator which needs a\n * finalization) or if it clones the step interpolator.</p>\n * @param rkIntegrator integrator being used\n * @param y reference to the integrator array holding the state at\n * the end of the step\n * @param yDotArray reference to the integrator array holding all the\n * intermediate slopes\n * @param forward integration direction indicator\n * @param primaryMapper equations mapper for the primary equations set\n * @param secondaryMappers equations mappers for the secondary equations sets\n */\npublic void reinitialize(final AbstractIntegrator rkIntegrator, final double[] y, final double[][] yDotArray, final boolean forward, final EquationsMapper primaryMapper, final EquationsMapper[] secondaryMappers) {\n    reinitialize(y, forward, primaryMapper, secondaryMappers);\n    this.yDotK = yDotArray;\n    this.integrator = rkIntegrator;\n}", "code_comment": "/**\n * Reinitialize the instance\n * <p>Some Runge-Kutta integrators need fewer functions evaluations\n * than their counterpart step interpolators. So the interpolator\n * should perform the last evaluations they need by themselves. The\n * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n * abstract classes call this method in order to let the step\n * interpolator perform the evaluations it needs. These evaluations\n * will be performed during the call to <code>doFinalize</code> if\n * any, i.e. only if the step handler either calls the {@link\n * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n * {@link AbstractStepInterpolator#getInterpolatedState\n * getInterpolatedState} method (for an interpolator which needs a\n * finalization) or if it clones the step interpolator.</p>\n * @param rkIntegrator integrator being used\n * @param y reference to the integrator array holding the state at\n * the end of the step\n * @param yDotArray reference to the integrator array holding all the\n * intermediate slopes\n * @param forward integration direction indicator\n * @param primaryMapper equations mapper for the primary equations set\n * @param secondaryMappers equations mappers for the secondary equations sets\n */\n", "code_no_comment": "public void reinitialize(final AbstractIntegrator rkIntegrator, final double[] y, final double[][] yDotArray, final boolean forward, final EquationsMapper primaryMapper, final EquationsMapper[] secondaryMappers) {\n    reinitialize(y, forward, primaryMapper, secondaryMappers);\n    this.yDotK = yDotArray;\n    this.integrator = rkIntegrator;\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.6168626326355032, "fo": -0.4166666666666667, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "Math", "project_version": 98, "label": 1, "code": "/**\n * @param v vector to operate on\n * @throws IllegalArgumentException if columnDimension != v.length\n * @return resulting vector\n */\npublic double[] operate(double[] v) throws IllegalArgumentException {\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    if (v.length != nCols) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final double[] out = new double[v.length];\n    for (int row = 0; row < nRows; row++) {\n        final double[] dataRow = data[row];\n        double sum = 0;\n        for (int i = 0; i < nCols; i++) {\n            sum += dataRow[i] * v[i];\n        }\n        out[row] = sum;\n    }\n    return out;\n}", "code_comment": "/**\n * @param v vector to operate on\n * @throws IllegalArgumentException if columnDimension != v.length\n * @return resulting vector\n */\n", "code_no_comment": "public double[] operate(double[] v) throws IllegalArgumentException {\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    if (v.length != nCols) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final double[] out = new double[v.length];\n    for (int row = 0; row < nRows; row++) {\n        final double[] dataRow = data[row];\n        double sum = 0;\n        for (int i = 0; i < nCols; i++) {\n            sum += dataRow[i] * v[i];\n        }\n        out[row] = sum;\n    }\n    return out;\n}", "lc": 0.13636363636363635, "pi": 0.015306122448979493, "ma": 0.16666666666666666, "nbd": 0.0, "ml": 0.25, "d": 1.0153237765694514, "mi": -0.14453685116145706, "fo": -0.3333333333333333, "r": 1.342857142857143, "e": 0.5879579066390841}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1932_913c2f53", "label": 1, "code": "public void compact() {\n    long start = System.nanoTime();\n    log.info(\"TarMK compaction started\");\n    SegmentWriter writer = new SegmentWriter(this, tracker);\n    Compactor compactor = new Compactor(writer);\n    SegmentNodeState before = getHead();\n    SegmentNodeState after = compactor.compact(EMPTY_NODE, before);\n    while (!setHead(before, after)) {\n        // Some other concurrent changes have been made.\n        // Rebase (and compact) those changes on top of the\n        // compacted state before retrying to set the head.\n        SegmentNodeState head = getHead();\n        after = compactor.compact(before, head);\n        before = head;\n    }\n    tracker.setCompactionMap(compactor.getCompactionMap());\n    log.info(\"TarMK compaction completed in {}ms\", MILLISECONDS.convert(System.nanoTime() - start, NANOSECONDS));\n    cleanupNeeded.set(true);\n}", "code_comment": NaN, "code_no_comment": "public void compact() {\n    long start = System.nanoTime();\n    log.info(\"TarMK compaction started\");\n    SegmentWriter writer = new SegmentWriter(this, tracker);\n    Compactor compactor = new Compactor(writer);\n    SegmentNodeState before = getHead();\n    SegmentNodeState after = compactor.compact(EMPTY_NODE, before);\n    while (!setHead(before, after)) {\n                                SegmentNodeState head = getHead();\n        after = compactor.compact(before, head);\n        before = head;\n    }\n    tracker.setCompactionMap(compactor.getCompactionMap());\n    log.info(\"TarMK compaction completed in {}ms\", MILLISECONDS.convert(System.nanoTime() - start, NANOSECONDS));\n    cleanupNeeded.set(true);\n}", "lc": 0.09090909090909091, "pi": -0.40816326530612235, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.012852199703410724, "mi": -0.13421279036421016, "fo": 0.5833333333333334, "r": -0.028571428571428574, "e": 0.0909795657890792}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2430_be3a9114", "label": 1, "code": "@Override\npublic boolean propertyChanged(PropertyState before, PropertyState after) {\n    if (!loader.isRunning()) {\n        return false;\n    }\n    builder.setProperty(binaryCheck(after));\n    return true;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean propertyChanged(PropertyState before, PropertyState after) {\n    if (!loader.isRunning()) {\n        return false;\n    }\n    builder.setProperty(binaryCheck(after));\n    return true;\n}", "lc": -0.2727272727272727, "pi": -0.1887755102040817, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.3806228373702422, "mi": 0.4350444508173216, "fo": -0.25, "r": 0.4571428571428572, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-520_ec961a38", "label": 1, "code": "@Override\npublic void remove(NodeBuilder index, String key, Iterable<String> values) {\n    if (!index.hasChildNode(key)) {\n        return;\n    }\n    NodeBuilder child = index.child(key);\n    Queue<NodeBuilder> parentQueue = new LinkedList<NodeBuilder>();\n    for (String rm : values) {\n        if (PathUtils.denotesRoot(rm)) {\n            child.removeProperty(\"match\");\n        } else {\n            NodeBuilder indexEntry = child;\n            Iterator<String> segments = PathUtils.elements(rm).iterator();\n            while (segments.hasNext()) {\n                String segment = segments.next();\n                if (segments.hasNext()) {\n                    parentQueue.add(indexEntry);\n                    indexEntry = indexEntry.child(segment);\n                } else {\n                    // last segment\n                    if (indexEntry.hasChildNode(segment)) {\n                        indexEntry.removeNode(segment);\n                    }\n                }\n            }\n        }\n    }\n    // finally remove the index node if empty\n    if (child.getChildNodeCount() == 0) {\n        index.removeNode(key);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void remove(NodeBuilder index, String key, Iterable<String> values) {\n    if (!index.hasChildNode(key)) {\n        return;\n    }\n    NodeBuilder child = index.child(key);\n    Queue<NodeBuilder> parentQueue = new LinkedList<NodeBuilder>();\n    for (String rm : values) {\n        if (PathUtils.denotesRoot(rm)) {\n            child.removeProperty(\"match\");\n        } else {\n            NodeBuilder indexEntry = child;\n            Iterator<String> segments = PathUtils.elements(rm).iterator();\n            while (segments.hasNext()) {\n                String segment = segments.next();\n                if (segments.hasNext()) {\n                    parentQueue.add(indexEntry);\n                    indexEntry = indexEntry.child(segment);\n                } else {\n                                        if (indexEntry.hasChildNode(segment)) {\n                        indexEntry.removeNode(segment);\n                    }\n                }\n            }\n        }\n    }\n        if (child.getChildNodeCount() == 0) {\n        index.removeNode(key);\n    }\n}", "lc": 0.7272727272727273, "pi": 1.903061224489796, "ma": 0.6666666666666666, "nbd": 1.5, "ml": 0.75, "d": 0.06030647553138907, "mi": -0.4961284772010325, "fo": 0.75, "r": -0.028571428571428574, "e": 0.20922045048633506}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1025_a96b455c", "label": 1, "code": "/*\n     * TODO consider making public.\n     */\nprivate void mapLog4jToJul(Level level, java.util.logging.Level julLevel) {\n    log4jToJul.put(level, julLevel);\n}", "code_comment": NaN, "code_no_comment": "private void mapLog4jToJul(Level level, java.util.logging.Level julLevel) {\n    log4jToJul.put(level, julLevel);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9486664754803554, "fo": -0.4166666666666667, "r": 2.4, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3998_b76f9c44", "label": 3, "code": "/**\n *  Check if the credit card is a Visa. A Visa number has to start with a 4 and has to have a\n *  length of 13 or 16 digits. The number has to be validated with the Luhn algorithm.\n *\n *  @param creditCardNumber\n *             the credit card number as a string\n *  @return The credit card id of the issuer\n */\nprivate CreditCard isVisa(String creditCardNumber) {\n    if (creditCardNumber.length() == 13 || creditCardNumber.length() == 16) {\n        if (creditCardNumber.startsWith(\"4\")) {\n            return CreditCard.SWITCH;\n        }\n    }\n    return CreditCard.INVALID;\n}", "code_comment": "/**\n *  Check if the credit card is a Visa. A Visa number has to start with a 4 and has to have a\n *  length of 13 or 16 digits. The number has to be validated with the Luhn algorithm.\n *\n *  @param creditCardNumber\n *             the credit card number as a string\n *  @return The credit card id of the issuer\n */\n", "code_no_comment": "private CreditCard isVisa(String creditCardNumber) {\n    if (creditCardNumber.length() == 13 || creditCardNumber.length() == 16) {\n        if (creditCardNumber.startsWith(\"4\")) {\n            return CreditCard.SWITCH;\n        }\n    }\n    return CreditCard.INVALID;\n}", "lc": -0.2727272727272727, "pi": 0.43367346938775514, "ma": -0.16666666666666666, "nbd": 0.0, "ml": 0.0, "d": -0.08403361344537813, "mi": 0.3880126182965301, "fo": -0.25, "r": 2.0571428571428574, "e": -0.11286143197947585}
{"project_name": "Closure", "project_version": 175, "label": 2, "code": "/**\n * @param t  The traversal use to reach the call site.\n * @param callNode The CALL node.\n * @param fnNode The function to evaluate for inlining.\n * @param needAliases A set of function parameter names that can not be\n *     used without aliasing. Returned by getUnsafeParameterNames().\n * @param mode Inlining mode to be used.\n * @param referencesThis Whether fnNode contains references to its this\n *     object.\n * @param containsFunctions Whether fnNode contains inner functions.\n * @return Whether the inlining can occur.\n */\nCanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set<String> needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n    // Allow direct function calls or \"fn.call\" style calls.\n    if (!isSupportedCallType(callNode)) {\n        return CanInlineResult.NO;\n    }\n    // last until explicitly cleared.\n    if (containsFunctions) {\n        if (!assumeMinimumCapture && !t.inGlobalScope()) {\n            // inner functions.\n            return CanInlineResult.NO;\n        } else if (NodeUtil.isWithinLoop(callNode)) {\n            // single iteration through a loop.\n            return CanInlineResult.NO;\n        }\n    }\n    // TODO(johnlenz): Add support for 'apply'\n    if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {\n        // global 'this' object.\n        return CanInlineResult.NO;\n    }\n    if (mode == InliningMode.DIRECT) {\n        return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n        return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);\n    }\n}", "code_comment": "/**\n * @param t  The traversal use to reach the call site.\n * @param callNode The CALL node.\n * @param fnNode The function to evaluate for inlining.\n * @param needAliases A set of function parameter names that can not be\n *     used without aliasing. Returned by getUnsafeParameterNames().\n * @param mode Inlining mode to be used.\n * @param referencesThis Whether fnNode contains references to its this\n *     object.\n * @param containsFunctions Whether fnNode contains inner functions.\n * @return Whether the inlining can occur.\n */\n", "code_no_comment": "CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set<String> needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n        if (!isSupportedCallType(callNode)) {\n        return CanInlineResult.NO;\n    }\n        if (containsFunctions) {\n        if (!assumeMinimumCapture && !t.inGlobalScope()) {\n                        return CanInlineResult.NO;\n        } else if (NodeUtil.isWithinLoop(callNode)) {\n                        return CanInlineResult.NO;\n        }\n    }\n        if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {\n                return CanInlineResult.NO;\n    }\n    if (mode == InliningMode.DIRECT) {\n        return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n        return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);\n    }\n}", "lc": 0.2727272727272727, "pi": 0.10204081632653071, "ma": 0.5, "nbd": 0.5, "ml": 1.0, "d": -0.0009886307464161926, "mi": -0.2423286492687125, "fo": 0.0, "r": -0.028571428571428574, "e": 0.053203472659445535}
{"project_name": "Closure", "project_version": 68, "label": 2, "code": "/**\n * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n *     | FunctionType | UnionType | RecordType | ArrayType\n */\nprivate Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n        skipEOLs();\n        return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n        skipEOLs();\n        return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n        skipEOLs();\n        return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n        String string = stream.getString();\n        if (\"function\".equals(string)) {\n            skipEOLs();\n            return parseFunctionType(next());\n        } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n            return newStringNode(string);\n        } else {\n            return parseTypeName(token);\n        }\n    }\n    return reportGenericTypeSyntaxWarning();\n}", "code_comment": "/**\n * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n *     | FunctionType | UnionType | RecordType | ArrayType\n */\n", "code_no_comment": "private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n        skipEOLs();\n        return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n        skipEOLs();\n        return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n        skipEOLs();\n        return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n        String string = stream.getString();\n        if (\"function\".equals(string)) {\n            skipEOLs();\n            return parseFunctionType(next());\n        } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n            return newStringNode(string);\n        } else {\n            return parseTypeName(token);\n        }\n    }\n    return reportGenericTypeSyntaxWarning();\n}", "lc": 0.5, "pi": 0.14285714285714277, "ma": 0.6666666666666666, "nbd": 2.5, "ml": 0.6666666666666666, "d": -0.01878398418190801, "mi": -0.37166618870088936, "fo": 1.1666666666666667, "r": 0.0, "e": 0.07060103391710673}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4927_8c827e33", "label": 1, "code": "@Override\npublic void clearCookie(Cookie cookie) {\n    checkHeader();\n    bufferedResponse.clearCookie(cookie);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void clearCookie(Cookie cookie) {\n    checkHeader();\n    bufferedResponse.clearCookie(cookie);\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7912245483223405, "fo": -0.3333333333333333, "r": 1.5999999999999999, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd", "label": 1, "code": "public double getCost(Filter filter, String propertyName, PropertyValue value) {\n    NodeState indexMeta = getIndexNode(root, propertyName, filter);\n    if (indexMeta == null) {\n        return Double.POSITIVE_INFINITY;\n    }\n    return COST_OVERHEAD + getStrategy(indexMeta).count(indexMeta, encode(value), MAX_COST);\n}", "code_comment": NaN, "code_no_comment": "public double getCost(Filter filter, String propertyName, PropertyValue value) {\n    NodeState indexMeta = getIndexNode(root, propertyName, filter);\n    if (indexMeta == null) {\n        return Double.POSITIVE_INFINITY;\n    }\n    return COST_OVERHEAD + getStrategy(indexMeta).count(indexMeta, encode(value), MAX_COST);\n}", "lc": -0.3181818181818182, "pi": -0.2346938775510204, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.12357884330202666, "mi": 0.38285058789790644, "fo": -0.16666666666666666, "r": 0.0, "e": -0.09118514996937653}
{"project_name": "Math", "project_version": 53, "label": 1, "code": "/**\n * Return the sum of this complex number and the given complex number.\n * <p>\n * Uses the definitional formula\n * <pre>\n * (a + bi) + (c + di) = (a+c) + (b+d)i\n * </pre></p>\n * <p>\n * If either this or <code>rhs</code> has a NaN value in either part,\n * {@link #NaN} is returned; otherwise Infinite and NaN values are\n * returned in the parts of the result according to the rules for\n * {@link java.lang.Double} arithmetic.</p>\n *\n * @param rhs the other complex number\n * @return the complex number sum\n * @throws NullArgumentException if <code>rhs</code> is null\n */\npublic Complex add(Complex rhs) throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n}", "code_comment": "/**\n * Return the sum of this complex number and the given complex number.\n * <p>\n * Uses the definitional formula\n * <pre>\n * (a + bi) + (c + di) = (a+c) + (b+d)i\n * </pre></p>\n * <p>\n * If either this or <code>rhs</code> has a NaN value in either part,\n * {@link #NaN} is returned; otherwise Infinite and NaN values are\n * returned in the parts of the result according to the rules for\n * {@link java.lang.Double} arithmetic.</p>\n *\n * @param rhs the other complex number\n * @return the complex number sum\n * @throws NullArgumentException if <code>rhs</code> is null\n */\n", "code_no_comment": "public Complex add(Complex rhs) throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7505018640665331, "fo": -0.16666666666666666, "r": 1.2571428571428573, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 148, "label": 2, "code": "private void addCharEntry(String id) throws IOException {\n    if (firstChar) {\n        firstChar = false;\n    } else {\n        out.append(\",\");\n    }\n    out.append(id);\n}", "code_comment": NaN, "code_no_comment": "private void addCharEntry(String id) throws IOException {\n    if (firstChar) {\n        firstChar = false;\n    } else {\n        out.append(\",\");\n    }\n    out.append(id);\n}", "lc": -0.2727272727272727, "pi": -0.09693877551020405, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.3806228373702422, "mi": 0.4591339260108975, "fo": -0.3333333333333333, "r": 1.7714285714285716, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7429_43956f93", "label": 1, "code": "private String doParseUri(String uri, Properties properties, List<String> replaced, String prefixToken, String suffixToken, String propertyPrefix, String propertySuffix, boolean fallbackToUnaugmentedProperty) {\n    StringBuilder sb = new StringBuilder();\n    int pivot = 0;\n    int size = uri.length();\n    while (pivot < size) {\n        int idx = findTokenPosition(uri, pivot, prefixToken);\n        if (idx < 0) {\n            sb.append(createConstantPart(uri, pivot, size));\n            break;\n        } else {\n            if (pivot < idx) {\n                sb.append(createConstantPart(uri, pivot, idx));\n            }\n            pivot = idx + prefixToken.length();\n            int endIdx = findTokenPosition(uri, pivot, suffixToken);\n            if (endIdx < 0) {\n                throw new IllegalArgumentException(\"Expecting \" + suffixToken + \" but found end of string from text: \" + uri);\n            }\n            String key = uri.substring(pivot, endIdx);\n            String augmentedKey = key;\n            if (propertyPrefix != null) {\n                log.debug(\"Augmenting property key [{}] with prefix: {}\", key, propertyPrefix);\n                augmentedKey = propertyPrefix + augmentedKey;\n            }\n            if (propertySuffix != null) {\n                log.debug(\"Augmenting property key [{}] with suffix: {}\", key, propertySuffix);\n                augmentedKey = augmentedKey + propertySuffix;\n            }\n            String part = createPlaceholderPart(augmentedKey, properties, replaced, prefixToken, suffixToken);\n            // Note: Only fallback to unaugmented when the original key was actually augmented\n            if (part == null && fallbackToUnaugmentedProperty && (propertyPrefix != null || propertySuffix != null)) {\n                log.debug(\"Property wth key [{}] not found, attempting with unaugmented key: {}\", augmentedKey, key);\n                part = createPlaceholderPart(key, properties, replaced, prefixToken, suffixToken);\n            }\n            if (part == null) {\n                StringBuilder esb = new StringBuilder();\n                esb.append(\"Property with key [\").append(augmentedKey).append(\"] \");\n                if (fallbackToUnaugmentedProperty && (propertyPrefix != null || propertySuffix != null)) {\n                    esb.append(\"(and original key [\").append(key).append(\"]) \");\n                }\n                esb.append(\"not found in properties from text: \").append(uri);\n                throw new IllegalArgumentException(esb.toString());\n            }\n            sb.append(part);\n            pivot = endIdx + suffixToken.length();\n        }\n    }\n    return sb.toString();\n}", "code_comment": NaN, "code_no_comment": "private String doParseUri(String uri, Properties properties, List<String> replaced, String prefixToken, String suffixToken, String propertyPrefix, String propertySuffix, boolean fallbackToUnaugmentedProperty) {\n    StringBuilder sb = new StringBuilder();\n    int pivot = 0;\n    int size = uri.length();\n    while (pivot < size) {\n        int idx = findTokenPosition(uri, pivot, prefixToken);\n        if (idx < 0) {\n            sb.append(createConstantPart(uri, pivot, size));\n            break;\n        } else {\n            if (pivot < idx) {\n                sb.append(createConstantPart(uri, pivot, idx));\n            }\n            pivot = idx + prefixToken.length();\n            int endIdx = findTokenPosition(uri, pivot, suffixToken);\n            if (endIdx < 0) {\n                throw new IllegalArgumentException(\"Expecting \" + suffixToken + \" but found end of string from text: \" + uri);\n            }\n            String key = uri.substring(pivot, endIdx);\n            String augmentedKey = key;\n            if (propertyPrefix != null) {\n                log.debug(\"Augmenting property key [{}] with prefix: {}\", key, propertyPrefix);\n                augmentedKey = propertyPrefix + augmentedKey;\n            }\n            if (propertySuffix != null) {\n                log.debug(\"Augmenting property key [{}] with suffix: {}\", key, propertySuffix);\n                augmentedKey = augmentedKey + propertySuffix;\n            }\n            String part = createPlaceholderPart(augmentedKey, properties, replaced, prefixToken, suffixToken);\n                        if (part == null && fallbackToUnaugmentedProperty && (propertyPrefix != null || propertySuffix != null)) {\n                log.debug(\"Property wth key [{}] not found, attempting with unaugmented key: {}\", augmentedKey, key);\n                part = createPlaceholderPart(key, properties, replaced, prefixToken, suffixToken);\n            }\n            if (part == null) {\n                StringBuilder esb = new StringBuilder();\n                esb.append(\"Property with key [\").append(augmentedKey).append(\"] \");\n                if (fallbackToUnaugmentedProperty && (propertyPrefix != null || propertySuffix != null)) {\n                    esb.append(\"(and original key [\").append(key).append(\"]) \");\n                }\n                esb.append(\"not found in properties from text: \").append(uri);\n                throw new IllegalArgumentException(esb.toString());\n            }\n            sb.append(part);\n            pivot = endIdx + suffixToken.length();\n        }\n    }\n    return sb.toString();\n}", "lc": 1.5454545454545454, "pi": 0.8010204081632653, "ma": 1.5, "nbd": 1.0, "ml": 1.4166666666666667, "d": 1.7686604053386064, "mi": -0.9059363349584173, "fo": 1.6666666666666667, "r": -0.028571428571428574, "e": 5.115435517236949}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1058_4ebd967c", "label": 3, "code": "/**\n * Returns the regularized beta function I(x, a, b).\n *\n * The implementation of this method is based on:\n * <ul>\n * <li>\n * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n * Regularized Beta Function</a>.</li>\n * <li>\n * <a href=\"http://functions.wolfram.com/06.21.10.0001.01\">\n * Regularized Beta Function</a>.</li>\n * </ul>\n *\n * @param x the value.\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return the regularized beta function I(x, a, b)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n */\npublic static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations) {\n    double ret;\n    if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || x < 0 || x > 1 || a <= 0.0 || b <= 0.0) {\n        ret = Double.NaN;\n    } else if (x > (a + 1.0) / (a + b + 2.0)) {\n        ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\n    } else {\n        ContinuedFraction fraction = new ContinuedFraction() {\n\n            @Override\n            protected double getB(int n, double x) {\n                double ret;\n                double m;\n                if (n % 2 == 0) {\n                    // even\n                    m = n / 2.0;\n                    ret = (m * (b - m) * x) / ((a + (2 * m) - 1) * (a + (2 * m)));\n                } else {\n                    m = (n - 1.0) / 2.0;\n                    ret = -((a + m) * (a + b + m) * x) / ((a + (2 * m)) * (a + (2 * m) + 1.0));\n                }\n                return ret;\n            }\n\n            @Override\n            protected double getA(int n, double x) {\n                return 1.0;\n            }\n        };\n        ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log(1.0 - x)) - FastMath.log(a) - logBeta(a, b)) * 1.0 / fraction.evaluate(x, epsilon, maxIterations);\n    }\n    return ret;\n}", "code_comment": "/**\n * Returns the regularized beta function I(x, a, b).\n *\n * The implementation of this method is based on:\n * <ul>\n * <li>\n * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n * Regularized Beta Function</a>.</li>\n * <li>\n * <a href=\"http://functions.wolfram.com/06.21.10.0001.01\">\n * Regularized Beta Function</a>.</li>\n * </ul>\n *\n * @param x the value.\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return the regularized beta function I(x, a, b)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n */\n", "code_no_comment": "public static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations) {\n    double ret;\n    if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || x < 0 || x > 1 || a <= 0.0 || b <= 0.0) {\n        ret = Double.NaN;\n    } else if (x > (a + 1.0) / (a + b + 2.0)) {\n        ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\n    } else {\n        ContinuedFraction fraction = new ContinuedFraction() {\n\n            @Override\n            protected double getB(int n, double x) {\n                double ret;\n                double m;\n                if (n % 2 == 0) {\n                                        m = n / 2.0;\n                    ret = (m * (b - m) * x) / ((a + (2 * m) - 1) * (a + (2 * m)));\n                } else {\n                    m = (n - 1.0) / 2.0;\n                    ret = -((a + m) * (a + b + m) * x) / ((a + (2 * m)) * (a + (2 * m) + 1.0));\n                }\n                return ret;\n            }\n\n            @Override\n            protected double getA(int n, double x) {\n                return 1.0;\n            }\n        };\n        ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log(1.0 - x)) - FastMath.log(a) - logBeta(a, b)) * 1.0 / fraction.evaluate(x, epsilon, maxIterations);\n    }\n    return ret;\n}", "lc": 0.7272727272727273, "pi": 1.5306122448979589, "ma": 0.0, "nbd": 1.0, "ml": 0.9166666666666666, "d": 3.6767177459218985, "mi": -0.5970748494407804, "fo": 0.3333333333333333, "r": -0.028571428571428574, "e": 7.926405146457315}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-867_bfbb156d", "label": 1, "code": "/**\n * Checks dimensions and values of boundaries and inputSigma if defined.\n */\nprivate void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n        if (hasInfiniteBounds) {\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n            for (int i = 0; i < lB.length; i++) {\n                if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n                    final double max = Double.MAX_VALUE + boundaries[0][i];\n                    final NumberIsTooLargeException e = new NumberIsTooLargeException(boundaries[1][i], max, true);\n                    e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n                    e.getContext().addMessage(LocalizedFormats.INDEX, i);\n                    throw e;\n                }\n            }\n        }\n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}", "code_comment": "/**\n * Checks dimensions and values of boundaries and inputSigma if defined.\n */\n", "code_no_comment": "private void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n        boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n        boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n        if (hasInfiniteBounds) {\n                        throw new MathUnsupportedOperationException();\n        } else {\n                        boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n                        for (int i = 0; i < lB.length; i++) {\n                if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n                    final double max = Double.MAX_VALUE + boundaries[0][i];\n                    final NumberIsTooLargeException e = new NumberIsTooLargeException(boundaries[1][i], max, true);\n                    e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n                    e.getContext().addMessage(LocalizedFormats.INDEX, i);\n                    throw e;\n                }\n            }\n        }\n    } else {\n                boundaries = null;\n    }\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}", "lc": 1.8181818181818181, "pi": 1.2244897959183674, "ma": 3.0, "nbd": 1.0, "ml": 1.8333333333333333, "d": 2.7829955511616413, "mi": -0.9968454258675084, "fo": 0.5, "r": -0.028571428571428574, "e": 6.4951837622761595}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5724_b92591f6", "label": 1, "code": "@Override\nprotected final MarkupElement onComponentTag(ComponentTag tag) throws ParseException {\n    if (tag.isClose()) {\n        return tag;\n    }\n    String wicketIdAttr = getWicketNamespace() + \":\" + \"id\";\n    // Don't touch any wicket:id component and any auto-components\n    if ((tag instanceof WicketTag) || (tag.isAutolinkEnabled() == true) || (tag.getAttributes().get(wicketIdAttr) != null)) {\n        return tag;\n    }\n    // behavior that prepends the relative path.\n    for (String attrName : attributeNames) {\n        String attrValue = tag.getAttributes().getString(attrName);\n        if ((attrValue != null) && (attrValue.startsWith(\"/\") == false) && (!attrValue.contains(\":\")) && !(attrValue.startsWith(\"#\"))) {\n            if (tag.getId() == null) {\n                tag.setId(getWicketRelativePathPrefix(null));\n                tag.setAutoComponentTag(true);\n            }\n            tag.addBehavior(RELATIVE_PATH_BEHAVIOR);\n            tag.setModified(true);\n            break;\n        }\n    }\n    return tag;\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected final MarkupElement onComponentTag(ComponentTag tag) throws ParseException {\n    if (tag.isClose()) {\n        return tag;\n    }\n    String wicketIdAttr = getWicketNamespace() + \":\" + \"id\";\n        if ((tag instanceof WicketTag) || (tag.isAutolinkEnabled() == true) || (tag.getAttributes().get(wicketIdAttr) != null)) {\n        return tag;\n    }\n        for (String attrName : attributeNames) {\n        String attrValue = tag.getAttributes().getString(attrName);\n        if ((attrValue != null) && (attrValue.startsWith(\"/\") == false) && (!attrValue.contains(\":\")) && !(attrValue.startsWith(\"#\"))) {\n            if (tag.getId() == null) {\n                tag.setId(getWicketRelativePathPrefix(null));\n                tag.setAutoComponentTag(true);\n            }\n            tag.addBehavior(RELATIVE_PATH_BEHAVIOR);\n            tag.setModified(true);\n            break;\n        }\n    }\n    return tag;\n}", "lc": 0.4090909090909091, "pi": 0.8622448979591837, "ma": 0.5, "nbd": 0.5, "ml": 1.1666666666666667, "d": 0.7048937221947604, "mi": -0.37281330656724987, "fo": 0.8333333333333334, "r": -0.028571428571428574, "e": 0.7986474274137939}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1429_279bb3ce", "label": 1, "code": "/**\n * Returns the commit root path for the given <code>revision</code> or\n * <code>null</code> if this document does not have a commit root entry for\n * the given <code>revision</code>.\n *\n * @param revision a revision.\n * @return the commit root path or <code>null</code>.\n */\n@CheckForNull\npublic String getCommitRootPath(Revision revision) {\n    // check local map first\n    Map<Revision, String> local = getLocalCommitRoot();\n    String depth = local.get(revision);\n    if (depth != null) {\n        if (depth.equals(\"0\")) {\n            return \"/\";\n        }\n        String p = Utils.getPathFromId(getId());\n        return PathUtils.getAncestorPath(p, PathUtils.getDepth(p) - Integer.parseInt(depth));\n    }\n    // check previous\n    for (NodeDocument prev : getPreviousDocs(COMMIT_ROOT, revision)) {\n        String path = prev.getCommitRootPath(revision);\n        if (path != null) {\n            return path;\n        }\n    }\n    return null;\n}", "code_comment": "/**\n * Returns the commit root path for the given <code>revision</code> or\n * <code>null</code> if this document does not have a commit root entry for\n * the given <code>revision</code>.\n *\n * @param revision a revision.\n * @return the commit root path or <code>null</code>.\n */\n", "code_no_comment": "@CheckForNull\npublic String getCommitRootPath(Revision revision) {\n        Map<Revision, String> local = getLocalCommitRoot();\n    String depth = local.get(revision);\n    if (depth != null) {\n        if (depth.equals(\"0\")) {\n            return \"/\";\n        }\n        String p = Utils.getPathFromId(getId());\n        return PathUtils.getAncestorPath(p, PathUtils.getDepth(p) - Integer.parseInt(depth));\n    }\n        for (NodeDocument prev : getPreviousDocs(COMMIT_ROOT, revision)) {\n        String path = prev.getCommitRootPath(revision);\n        if (path != null) {\n            return path;\n        }\n    }\n    return null;\n}", "lc": 0.22727272727272727, "pi": 0.2499999999999999, "ma": 0.16666666666666666, "nbd": 0.0, "ml": 0.08333333333333333, "d": -0.040533860603064735, "mi": -0.21651849727559505, "fo": 0.3333333333333333, "r": 0.028571428571428574, "e": 0.046230742544361214}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-185_7fe28a0e", "label": 3, "code": "/**\n * @see Node#setProperty(String, javax.jcr.Value, int)\n */\n@Override\n@Nonnull\npublic Property setProperty(String jcrName, Value value, int type) throws RepositoryException {\n    checkStatus();\n    int targetType = getTargetType(value, type);\n    Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());\n    if (value == null) {\n        Property p = getProperty(jcrName);\n        p.remove();\n        return p;\n    } else {\n        String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n        CoreValue oakValue = ValueConverter.toCoreValue(targetValue, sessionDelegate);\n        return new PropertyImpl(dlg.setProperty(oakName, oakValue));\n    }\n}", "code_comment": "/**\n * @see Node#setProperty(String, javax.jcr.Value, int)\n */\n", "code_no_comment": "@Override\n@Nonnull\npublic Property setProperty(String jcrName, Value value, int type) throws RepositoryException {\n    checkStatus();\n    int targetType = getTargetType(value, type);\n    Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());\n    if (value == null) {\n        Property p = getProperty(jcrName);\n        p.remove();\n        return p;\n    } else {\n        String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n        CoreValue oakValue = ValueConverter.toCoreValue(targetValue, sessionDelegate);\n        return new PropertyImpl(dlg.setProperty(oakName, oakValue));\n    }\n}", "lc": 0.09090909090909091, "pi": 0.051020408163265356, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.07414730598121598, "mi": -0.11012331517063391, "fo": 0.25, "r": 0.0, "e": 0.016421036401248913}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3878_b9094cb5", "label": 1, "code": "@Override\nprotected void doStop() throws Exception {\n    ServiceHelper.stopServices(deadLetter, output, outputAsync);\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected void doStop() throws Exception {\n    ServiceHelper.stopServices(deadLetter, output, outputAsync);\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8769716088328073, "fo": -0.4166666666666667, "r": 0.4857142857142857, "e": -0.16422749602751402}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1406_a523dcd5", "label": 0, "code": "private void initThrowable(final Object[] params, final int argCount, final int usedParams) {\n    if (usedParams < argCount && this.throwable == null && params[argCount - 1] instanceof Throwable) {\n        this.throwable = (Throwable) params[argCount - 1];\n    }\n}", "code_comment": NaN, "code_no_comment": "private void initThrowable(final Object[] params, final int argCount, final int usedParams) {\n    if (usedParams < argCount && this.throwable == null && params[argCount - 1] instanceof Throwable) {\n        this.throwable = (Throwable) params[argCount - 1];\n    }\n}", "lc": -0.4090909090909091, "pi": -0.015306122448979493, "ma": -0.3333333333333333, "nbd": -0.5, "ml": 0.08333333333333333, "d": 0.37073652990608014, "mi": 0.5772870662460569, "fo": -0.5, "r": 0.17142857142857146, "e": 0.0010964489615857404}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1789_9f7c1df0", "label": 1, "code": "private Map<String, PropertyState> createProperties(NodePropBundle bundle) {\n    Map<String, PropertyState> properties = newHashMap();\n    String primary;\n    if (bundle.getNodeTypeName() != null) {\n        primary = createName(bundle.getNodeTypeName());\n    } else {\n        warn(\"Missing primary node type; defaulting to nt:unstructured\");\n        primary = NT_UNSTRUCTURED;\n    }\n    properties.put(JCR_PRIMARYTYPE, PropertyStates.createProperty(JCR_PRIMARYTYPE, primary, Type.NAME));\n    Set<String> mixins = newLinkedHashSet();\n    if (bundle.getMixinTypeNames() != null) {\n        for (Name mixin : bundle.getMixinTypeNames()) {\n            mixins.add(createName(mixin));\n        }\n    }\n    if (!mixins.isEmpty()) {\n        properties.put(JCR_MIXINTYPES, PropertyStates.createProperty(JCR_MIXINTYPES, mixins, Type.NAMES));\n    }\n    if (bundle.isReferenceable() || isReferenceable.apply(primary, mixins)) {\n        properties.put(JCR_UUID, PropertyStates.createProperty(JCR_UUID, bundle.getId().toString()));\n    }\n    if (isOrderable.apply(primary, mixins)) {\n        properties.put(OAK_CHILD_ORDER, PropertyStates.createProperty(OAK_CHILD_ORDER, nodes.keySet(), Type.NAMES));\n    }\n    for (PropertyEntry property : bundle.getPropertyEntries()) {\n        String name = createName(property.getName());\n        try {\n            int type = property.getType();\n            if (property.isMultiValued()) {\n                properties.put(name, createProperty(name, type, property.getValues()));\n            } else {\n                properties.put(name, createProperty(name, type, property.getValues()[0]));\n            }\n        } catch (Exception e) {\n            warn(\"Skipping broken property entry \" + name, e);\n        }\n    }\n    // OAK-1789: Convert the jcr:frozenUuid of a non-referenceable\n    // frozen node from UUID to a path identifier\n    PropertyState frozenUuid = properties.get(JCR_FROZENUUID);\n    if (frozenUuid != null && frozenUuid.getType() == STRING && isFrozenNode.apply(primary, mixins)) {\n        String frozenPrimary = NT_UNSTRUCTURED;\n        Set<String> frozenMixins = newHashSet();\n        PropertyState property = properties.get(JCR_FROZENPRIMARYTYPE);\n        if (property != null && property.getType() == NAME) {\n            primary = property.getValue(NAME);\n        }\n        property = properties.get(JCR_FROZENMIXINTYPES);\n        if (property != null && property.getType() == NAMES) {\n            addAll(frozenMixins, property.getValue(NAMES));\n        }\n        if (!isReferenceable.apply(frozenPrimary, frozenMixins)) {\n            frozenUuid = PropertyStates.createProperty(JCR_FROZENUUID, parent.getString(JCR_FROZENUUID) + \"/\" + name);\n            properties.put(JCR_FROZENUUID, frozenUuid);\n        }\n    }\n    return properties;\n}", "code_comment": NaN, "code_no_comment": "private Map<String, PropertyState> createProperties(NodePropBundle bundle) {\n    Map<String, PropertyState> properties = newHashMap();\n    String primary;\n    if (bundle.getNodeTypeName() != null) {\n        primary = createName(bundle.getNodeTypeName());\n    } else {\n        warn(\"Missing primary node type; defaulting to nt:unstructured\");\n        primary = NT_UNSTRUCTURED;\n    }\n    properties.put(JCR_PRIMARYTYPE, PropertyStates.createProperty(JCR_PRIMARYTYPE, primary, Type.NAME));\n    Set<String> mixins = newLinkedHashSet();\n    if (bundle.getMixinTypeNames() != null) {\n        for (Name mixin : bundle.getMixinTypeNames()) {\n            mixins.add(createName(mixin));\n        }\n    }\n    if (!mixins.isEmpty()) {\n        properties.put(JCR_MIXINTYPES, PropertyStates.createProperty(JCR_MIXINTYPES, mixins, Type.NAMES));\n    }\n    if (bundle.isReferenceable() || isReferenceable.apply(primary, mixins)) {\n        properties.put(JCR_UUID, PropertyStates.createProperty(JCR_UUID, bundle.getId().toString()));\n    }\n    if (isOrderable.apply(primary, mixins)) {\n        properties.put(OAK_CHILD_ORDER, PropertyStates.createProperty(OAK_CHILD_ORDER, nodes.keySet(), Type.NAMES));\n    }\n    for (PropertyEntry property : bundle.getPropertyEntries()) {\n        String name = createName(property.getName());\n        try {\n            int type = property.getType();\n            if (property.isMultiValued()) {\n                properties.put(name, createProperty(name, type, property.getValues()));\n            } else {\n                properties.put(name, createProperty(name, type, property.getValues()[0]));\n            }\n        } catch (Exception e) {\n            warn(\"Skipping broken property entry \" + name, e);\n        }\n    }\n            PropertyState frozenUuid = properties.get(JCR_FROZENUUID);\n    if (frozenUuid != null && frozenUuid.getType() == STRING && isFrozenNode.apply(primary, mixins)) {\n        String frozenPrimary = NT_UNSTRUCTURED;\n        Set<String> frozenMixins = newHashSet();\n        PropertyState property = properties.get(JCR_FROZENPRIMARYTYPE);\n        if (property != null && property.getType() == NAME) {\n            primary = property.getValue(NAME);\n        }\n        property = properties.get(JCR_FROZENMIXINTYPES);\n        if (property != null && property.getType() == NAMES) {\n            addAll(frozenMixins, property.getValue(NAMES));\n        }\n        if (!isReferenceable.apply(frozenPrimary, frozenMixins)) {\n            frozenUuid = PropertyStates.createProperty(JCR_FROZENUUID, parent.getString(JCR_FROZENUUID) + \"/\" + name);\n            properties.put(JCR_FROZENUUID, frozenUuid);\n        }\n    }\n    return properties;\n}", "lc": 1.9545454545454546, "pi": 0.27040816326530603, "ma": 1.6666666666666667, "nbd": 0.5, "ml": 2.25, "d": 1.2782995551161644, "mi": -1.0229423573272156, "fo": 3.8333333333333335, "r": -0.028571428571428574, "e": 4.843246345527045}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2839_15477252", "label": 1, "code": "@Override\npublic void write(byte[] b, int off, int len) throws IOException {\n    if (off == 0 || len == b.length) {\n        write(b);\n    } else {\n        byte[] copy = new byte[len];\n        System.arraycopy(b, off, copy, 0, len);\n        write(copy);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void write(byte[] b, int off, int len) throws IOException {\n    if (off == 0 || len == b.length) {\n        write(b);\n    } else {\n        byte[] copy = new byte[len];\n        System.arraycopy(b, off, copy, 0, len);\n        write(copy);\n    }\n}", "lc": -0.18181818181818182, "pi": 0.15306122448979584, "ma": -0.3333333333333333, "nbd": -0.5, "ml": 0.0, "d": 0.030647553138902675, "mi": 0.23888729566963007, "fo": -0.25, "r": 0.08571428571428572, "e": -0.0631314753663039}
{"project_name": "Closure", "project_version": 163, "label": 1, "code": "@Override\npublic void exitScope(NodeTraversal t) {\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void exitScope(NodeTraversal t) {\n}", "lc": -0.5, "pi": -1.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.144536851161457, "fo": -0.5, "r": 2.5142857142857147, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443", "label": 1, "code": "@Override\npublic Set<String> listIterators(String tableName) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {\n    Set<String> result = new HashSet<String>();\n    Set<String> lifecycles = new HashSet<String>();\n    for (IteratorScope scope : IteratorScope.values()) lifecycles.add(scope.name().toLowerCase());\n    for (Entry<String, String> property : this.getProperties(tableName)) {\n        String name = property.getKey();\n        String[] parts = name.split(\"\\\\.\");\n        if (parts.length == 4) {\n            if (parts[0].equals(\"table\") && parts[1].equals(\"iterator\") && lifecycles.contains(parts[2]))\n                result.add(parts[3]);\n        }\n    }\n    return result;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Set<String> listIterators(String tableName) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {\n    Set<String> result = new HashSet<String>();\n    Set<String> lifecycles = new HashSet<String>();\n    for (IteratorScope scope : IteratorScope.values()) lifecycles.add(scope.name().toLowerCase());\n    for (Entry<String, String> property : this.getProperties(tableName)) {\n        String name = property.getKey();\n        String[] parts = name.split(\"\\\\.\");\n        if (parts.length == 4) {\n            if (parts[0].equals(\"table\") && parts[1].equals(\"iterator\") && lifecycles.contains(parts[2]))\n                result.add(parts[3]);\n        }\n    }\n    return result;\n}", "lc": 0.045454545454545456, "pi": 0.6683673469387755, "ma": 0.16666666666666666, "nbd": 0.0, "ml": 0.25, "d": -0.01878398418190801, "mi": -0.14453685116145706, "fo": 0.4166666666666667, "r": -0.028571428571428574, "e": 0.12347471528732532}
{"project_name": "Closure", "project_version": 136, "label": 2, "code": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n        if (name.length() == 0) {\n        return;\n    }\n        Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n        if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n        if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n        if (!okToRenameVar(name, local)) {\n                return;\n    }\n    if (isExternsPass_) {\n                if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n                String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n                        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "lc": 1.0909090909090908, "pi": -0.17346938775510198, "ma": 1.0, "nbd": 0.0, "ml": 1.5, "d": 0.7345526445872468, "mi": -0.6659019214224263, "fo": 1.0, "r": -0.028571428571428574, "e": 1.1315738753902886}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-43_668f08f2", "label": 1, "code": "public void serialize(Binding binding) throws Exception {\n    binding.write(\"rootNodeId\", rootNodeId.getBytes());\n    binding.write(\"commitTS\", commitTS);\n    binding.write(\"msg\", msg == null ? \"\" : msg);\n    binding.write(\"parentId\", parentId == null ? \"\" : parentId.toString());\n}", "code_comment": NaN, "code_no_comment": "public void serialize(Binding binding) throws Exception {\n    binding.write(\"rootNodeId\", rootNodeId.getBytes());\n    binding.write(\"commitTS\", commitTS);\n    binding.write(\"msg\", msg == null ? \"\" : msg);\n    binding.write(\"parentId\", parentId == null ? \"\" : parentId.toString());\n}", "lc": -0.36363636363636365, "pi": -0.576530612244898, "ma": -0.16666666666666666, "nbd": -1.0, "ml": -0.08333333333333333, "d": -0.3806228373702422, "mi": 0.45970748494407815, "fo": 0.0, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4997_ee02c883", "label": 1, "code": "/**\n *  Gets a URL for the listener interface on a behavior (e.g. IBehaviorListener on\n *  AjaxPagingNavigationBehavior).\n *\n *  @param behaviour\n *             The behavior that the URL should point to\n *  @param listener\n *             The listener interface that the URL should call\n *  @param parameters\n *             The parameters that should be rendered into the urls\n *  @return The URL\n */\npublic final CharSequence urlFor(final Behavior behaviour, final RequestListenerInterface listener, final PageParameters parameters) {\n    int id = getBehaviorId(behaviour);\n    Page page = getPage();\n    PageAndComponentProvider provider = new PageAndComponentProvider(page, this, parameters);\n    IRequestHandler handler;\n    if (page.isBookmarkable()) {\n        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener, id);\n    } else {\n        handler = new ListenerInterfaceRequestHandler(provider, listener, id);\n    }\n    return getRequestCycle().urlFor(handler);\n}", "code_comment": "/**\n *  Gets a URL for the listener interface on a behavior (e.g. IBehaviorListener on\n *  AjaxPagingNavigationBehavior).\n *\n *  @param behaviour\n *             The behavior that the URL should point to\n *  @param listener\n *             The listener interface that the URL should call\n *  @param parameters\n *             The parameters that should be rendered into the urls\n *  @return The URL\n */\n", "code_no_comment": "public final CharSequence urlFor(final Behavior behaviour, final RequestListenerInterface listener, final PageParameters parameters) {\n    int id = getBehaviorId(behaviour);\n    Page page = getPage();\n    PageAndComponentProvider provider = new PageAndComponentProvider(page, this, parameters);\n    IRequestHandler handler;\n    if (page.isBookmarkable()) {\n        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener, id);\n    } else {\n        handler = new ListenerInterfaceRequestHandler(provider, listener, id);\n    }\n    return getRequestCycle().urlFor(handler);\n}", "lc": -0.09090909090909091, "pi": -0.3622448979591837, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.3806228373702422, "mi": 0.07714367651276165, "fo": -0.08333333333333333, "r": 0.20000000000000004, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5043_2b1ce91d", "label": 1, "code": "/**\n *  @see org.apache.wicket.core.request.mapper.AbstractBookmarkableMapper#pageMustHaveBeenCreatedBookmarkable()\n */\n@Override\nprotected boolean pageMustHaveBeenCreatedBookmarkable() {\n    return true;\n}", "code_comment": "/**\n *  @see org.apache.wicket.core.request.mapper.AbstractBookmarkableMapper#pageMustHaveBeenCreatedBookmarkable()\n */\n", "code_no_comment": "@Override\nprotected boolean pageMustHaveBeenCreatedBookmarkable() {\n    return true;\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.0665328362489248, "fo": -0.5, "r": 2.314285714285714, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-434_133cbc2d", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic boolean equals(Object other) {\n    if (this == other) {\n        return true;\n    }\n    if (other instanceof SimplexTableau) {\n        SimplexTableau rhs = (SimplexTableau) other;\n        return (restrictToNonNegative == rhs.restrictToNonNegative) && (numDecisionVariables == rhs.numDecisionVariables) && (numSlackVariables == rhs.numSlackVariables) && (numArtificialVariables == rhs.numArtificialVariables) && (epsilon == rhs.epsilon) && f.equals(rhs.f) && constraints.equals(rhs.constraints) && tableau.equals(rhs.tableau);\n    }\n    return false;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic boolean equals(Object other) {\n    if (this == other) {\n        return true;\n    }\n    if (other instanceof SimplexTableau) {\n        SimplexTableau rhs = (SimplexTableau) other;\n        return (restrictToNonNegative == rhs.restrictToNonNegative) && (numDecisionVariables == rhs.numDecisionVariables) && (numSlackVariables == rhs.numSlackVariables) && (numArtificialVariables == rhs.numArtificialVariables) && (epsilon == rhs.epsilon) && f.equals(rhs.f) && constraints.equals(rhs.constraints) && tableau.equals(rhs.tableau);\n    }\n    return false;\n}", "lc": -0.13636363636363635, "pi": -0.035714285714285636, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.16666666666666666, "d": 0.09589718240237279, "mi": 0.0949240034413537, "fo": -0.25, "r": 0.20000000000000004, "e": 0.05452692082010956}
{"project_name": "Lang", "project_version": 58, "label": 1, "code": "// -----------------------------------------------------------------------\n// must handle Long, Float, Integer, Float, Short,\n// BigDecimal, BigInteger and Byte\n// useful methods:\n// Byte.decode(String)\n// Byte.valueOf(String,int radix)\n// Byte.valueOf(String)\n// Double.valueOf(String)\n// Float.valueOf(String)\n// new Float(String)\n// Integer.valueOf(String,int radix)\n// Integer.valueOf(String)\n// Integer.decode(String)\n// Integer.getInteger(String)\n// Integer.getInteger(String,int val)\n// Integer.getInteger(String,Integer val)\n// new Integer(String)\n// new Double(String)\n// new Byte(String)\n// new Long(String)\n// Long.getLong(String)\n// Long.getLong(String,int)\n// Long.getLong(String,Integer)\n// Long.valueOf(String,int)\n// Long.valueOf(String)\n// new Short(String)\n// Short.decode(String)\n// Short.valueOf(String,int)\n// Short.valueOf(String)\n// new BigDecimal(String)\n// new BigInteger(String)\n// new BigInteger(String,int radix)\n// Possible inputs:\n// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd\n// plus minus everything. Prolly more. A lot are not separable.\n/**\n * <p>Turns a string value into a java.lang.Number.</p>\n *\n * <p>First, the value is examined for a type qualifier on the end\n * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts\n * trying to create successively larger types from the type specified\n * until one is found that can represent the value.</p>\n *\n * <p>If a type specifier is not found, it will check for a decimal point\n * and then try successively larger types from <code>Integer</code> to\n * <code>BigInteger</code> and from <code>Float</code> to\n * <code>BigDecimal</code>.</p>\n *\n * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n * will be interpreted as a hexadecimal integer.  Values with leading\n * <code>0</code>'s will not be interpreted as octal.</p>\n *\n * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n *\n * <p>This method does not trim the input string, i.e., strings with leading\n * or trailing spaces will generate NumberFormatExceptions.</p>\n *\n * @param str  String containing a number, may be null\n * @return Number created from the string\n * @throws NumberFormatException if the value cannot be converted\n */\npublic static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        // a wrong value.\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        // Requesting a specific type..\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch(lastChar) {\n            case 'l':\n            case 'L':\n                if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    // Too big for a long\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f':\n            case 'F':\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        // has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                // ignore the bad number\n                }\n            // Fall through\n            case 'd':\n            case 'D':\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                // ignore the bad number\n                }\n            // Fall through\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        // small and go from there...\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            // Must be an int,long,bigint\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            // ignore the bad number\n            }\n            return createBigInteger(str);\n        } else {\n            // Must be a float,double,BigDec\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            // ignore the bad number\n            }\n            try {\n                Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            // ignore the bad number\n            }\n            return createBigDecimal(str);\n        }\n    }\n}", "code_comment": "/**\n * <p>Turns a string value into a java.lang.Number.</p>\n *\n * <p>First, the value is examined for a type qualifier on the end\n * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts\n * trying to create successively larger types from the type specified\n * until one is found that can represent the value.</p>\n *\n * <p>If a type specifier is not found, it will check for a decimal point\n * and then try successively larger types from <code>Integer</code> to\n * <code>BigInteger</code> and from <code>Float</code> to\n * <code>BigDecimal</code>.</p>\n *\n * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n * will be interpreted as a hexadecimal integer.  Values with leading\n * <code>0</code>'s will not be interpreted as octal.</p>\n *\n * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n *\n * <p>This method does not trim the input string, i.e., strings with leading\n * or trailing spaces will generate NumberFormatExceptions.</p>\n *\n * @param str  String containing a number, may be null\n * @return Number created from the string\n * @throws NumberFormatException if the value cannot be converted\n */\n", "code_no_comment": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n                return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n                String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch(lastChar) {\n            case 'l':\n            case 'L':\n                if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                                        }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f':\n            case 'F':\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                                                return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                                }\n                        case 'd':\n            case 'D':\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                                }\n                        default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n                if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n                        try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n                        }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n                        }\n            return createBigInteger(str);\n        } else {\n                        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                        }\n            try {\n                Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                        }\n            return createBigDecimal(str);\n        }\n    }\n}", "lc": 4.681818181818182, "pi": 1.270408163265306, "ma": 5.5, "nbd": 1.5, "ml": 4.666666666666667, "d": 3.0004943153732087, "mi": -1.563234872383138, "fo": 3.75, "r": -0.028571428571428574, "e": 14.544292683344683}
{"project_name": "Closure", "project_version": 129, "label": 2, "code": "/**\n * There are two types of calls we are interested in calls without explicit\n * \"this\" values (what we are call \"free\" calls) and direct call to eval.\n */\nprivate void annotateCalls(Node n) {\n    Preconditions.checkState(n.isCall());\n    // Keep track of of the \"this\" context of a call.  A call without an\n    // explicit \"this\" is a free call.\n    Node first = n.getFirstChild();\n    if (!NodeUtil.isGet(first)) {\n        n.putBooleanProp(Node.FREE_CALL, true);\n    }\n    // to distinguish between \"(0, eval)()\" and \"eval()\".\n    if (first.isName() && \"eval\".equals(first.getString())) {\n        first.putBooleanProp(Node.DIRECT_EVAL, true);\n    }\n}", "code_comment": "/**\n * There are two types of calls we are interested in calls without explicit\n * \"this\" values (what we are call \"free\" calls) and direct call to eval.\n */\n", "code_no_comment": "private void annotateCalls(Node n) {\n    Preconditions.checkState(n.isCall());\n            Node first = n.getFirstChild();\n    if (!NodeUtil.isGet(first)) {\n        n.putBooleanProp(Node.FREE_CALL, true);\n    }\n        if (first.isName() && \"eval\".equals(first.getString())) {\n        first.putBooleanProp(Node.DIRECT_EVAL, true);\n    }\n}", "lc": -0.18181818181818182, "pi": -0.2500000000000001, "ma": -0.16666666666666666, "nbd": -0.5, "ml": 0.25, "d": -0.05832921403855659, "mi": 0.18898766848293677, "fo": 0.25, "r": 0.31428571428571433, "e": -0.058274549106779566}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5426_fb45a781", "label": 3, "code": "/**\n *  @see org.apache.wicket.request.component.IRequestablePage#renderPage()\n */\n@Override\npublic void renderPage() {\n    // page id is frozen during the render\n    final boolean frozen = setFreezePageId(true);\n    try {\n        ++renderCount;\n        render();\n    } finally {\n        setFreezePageId(frozen);\n    }\n}", "code_comment": "/**\n *  @see org.apache.wicket.request.component.IRequestablePage#renderPage()\n */\n", "code_no_comment": "@Override\npublic void renderPage() {\n        final boolean frozen = setFreezePageId(true);\n    try {\n        ++renderCount;\n        render();\n    } finally {\n        setFreezePageId(frozen);\n    }\n}", "lc": -0.18181818181818182, "pi": 0.04081632653061228, "ma": -0.5, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.1334651507661888, "mi": 0.40120447375967877, "fo": -0.25, "r": 2.142857142857143, "e": -0.14288528831039785}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-949_f83bbc1d", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\nprotected PointValuePair doOptimize() {\n    // -------------------- Initialization --------------------------------\n    isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n    final FitnessFunction fitfun = new FitnessFunction();\n    final double[] guess = getStartPoint();\n    // number of objective variables/problem dimension\n    dimension = guess.length;\n    initializeCMA(guess);\n    iterations = 0;\n    double bestValue = fitfun.value(guess);\n    push(fitnessHistory, bestValue);\n    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);\n    PointValuePair lastResult = null;\n    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {\n        // Generate and evaluate lambda offspring\n        final RealMatrix arz = randn1(dimension, lambda);\n        final RealMatrix arx = zeros(dimension, lambda);\n        final double[] fitness = new double[lambda];\n        // generate random offspring\n        for (int k = 0; k < lambda; k++) {\n            RealMatrix arxk = null;\n            for (int i = 0; i < checkFeasableCount + 1; i++) {\n                if (diagonalOnly <= 0) {\n                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(// m + sig * Normal(0,C)\n                    sigma));\n                } else {\n                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));\n                }\n                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {\n                    break;\n                }\n                // regenerate random arguments for row\n                arz.setColumn(k, randn(dimension));\n            }\n            copyColumn(arxk, 0, arx, k);\n            try {\n                // compute fitness\n                fitness[k] = fitfun.value(arx.getColumn(k));\n            } catch (TooManyEvaluationsException e) {\n                break generationLoop;\n            }\n        }\n        // Sort by fitness and compute weighted mean into xmean\n        final int[] arindex = sortedIndices(fitness);\n        // Calculate new xmean, this is selection and recombination\n        // for speed up of Eq. (2) and (3)\n        final RealMatrix xold = xmean;\n        final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n        xmean = bestArx.multiply(weights);\n        final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n        final RealMatrix zmean = bestArz.multiply(weights);\n        final boolean hsig = updateEvolutionPaths(zmean, xold);\n        if (diagonalOnly <= 0) {\n            updateCovariance(hsig, bestArx, arz, arindex, xold);\n        } else {\n            updateCovarianceDiagonalOnly(hsig, bestArz);\n        }\n        // Adapt step size sigma - Eq. (5)\n        sigma *= Math.exp(Math.min(1, (normps / chiN - 1) * cs / damps));\n        final double bestFitness = fitness[arindex[0]];\n        final double worstFitness = fitness[arindex[arindex.length - 1]];\n        if (bestValue > bestFitness) {\n            bestValue = bestFitness;\n            lastResult = optimum;\n            optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);\n            if (getConvergenceChecker() != null && lastResult != null) {\n                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                    break generationLoop;\n                }\n            }\n        }\n        // Break, if fitness is good enough\n        if (stopFitness != 0) {\n            // only if stopFitness is defined\n            if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n                break generationLoop;\n            }\n        }\n        final double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n        final double[] pcCol = pc.getColumn(0);\n        for (int i = 0; i < dimension; i++) {\n            if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {\n                break;\n            }\n            if (i >= dimension - 1) {\n                break generationLoop;\n            }\n        }\n        for (int i = 0; i < dimension; i++) {\n            if (sigma * sqrtDiagC[i] > stopTolUpX) {\n                break generationLoop;\n            }\n        }\n        final double historyBest = min(fitnessHistory);\n        final double historyWorst = max(fitnessHistory);\n        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {\n            break generationLoop;\n        }\n        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {\n            break generationLoop;\n        }\n        // condition number of the covariance matrix exceeds 1e14\n        if (max(diagD) / min(diagD) > 1e7) {\n            break generationLoop;\n        }\n        // user defined termination\n        if (getConvergenceChecker() != null) {\n            final PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);\n            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {\n                break generationLoop;\n            }\n            lastResult = current;\n        }\n        // Adjust step size in case of equal function values (flat fitness)\n        if (bestValue == fitness[arindex[(int) (0.1 + lambda / 4.)]]) {\n            sigma = sigma * Math.exp(0.2 + cs / damps);\n        }\n        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {\n            sigma = sigma * Math.exp(0.2 + cs / damps);\n        }\n        // store best in history\n        push(fitnessHistory, bestFitness);\n        fitfun.setValueRange(worstFitness - bestFitness);\n        if (generateStatistics) {\n            statisticsSigmaHistory.add(sigma);\n            statisticsFitnessHistory.add(bestFitness);\n            statisticsMeanHistory.add(xmean.transpose());\n            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n        }\n    }\n    return optimum;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\nprotected PointValuePair doOptimize() {\n        isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n    final FitnessFunction fitfun = new FitnessFunction();\n    final double[] guess = getStartPoint();\n        dimension = guess.length;\n    initializeCMA(guess);\n    iterations = 0;\n    double bestValue = fitfun.value(guess);\n    push(fitnessHistory, bestValue);\n    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);\n    PointValuePair lastResult = null;\n    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {\n                final RealMatrix arz = randn1(dimension, lambda);\n        final RealMatrix arx = zeros(dimension, lambda);\n        final double[] fitness = new double[lambda];\n                for (int k = 0; k < lambda; k++) {\n            RealMatrix arxk = null;\n            for (int i = 0; i < checkFeasableCount + 1; i++) {\n                if (diagonalOnly <= 0) {\n                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(                    sigma));\n                } else {\n                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));\n                }\n                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {\n                    break;\n                }\n                                arz.setColumn(k, randn(dimension));\n            }\n            copyColumn(arxk, 0, arx, k);\n            try {\n                                fitness[k] = fitfun.value(arx.getColumn(k));\n            } catch (TooManyEvaluationsException e) {\n                break generationLoop;\n            }\n        }\n                final int[] arindex = sortedIndices(fitness);\n                        final RealMatrix xold = xmean;\n        final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n        xmean = bestArx.multiply(weights);\n        final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n        final RealMatrix zmean = bestArz.multiply(weights);\n        final boolean hsig = updateEvolutionPaths(zmean, xold);\n        if (diagonalOnly <= 0) {\n            updateCovariance(hsig, bestArx, arz, arindex, xold);\n        } else {\n            updateCovarianceDiagonalOnly(hsig, bestArz);\n        }\n                sigma *= Math.exp(Math.min(1, (normps / chiN - 1) * cs / damps));\n        final double bestFitness = fitness[arindex[0]];\n        final double worstFitness = fitness[arindex[arindex.length - 1]];\n        if (bestValue > bestFitness) {\n            bestValue = bestFitness;\n            lastResult = optimum;\n            optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);\n            if (getConvergenceChecker() != null && lastResult != null) {\n                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                    break generationLoop;\n                }\n            }\n        }\n                if (stopFitness != 0) {\n                        if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n                break generationLoop;\n            }\n        }\n        final double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n        final double[] pcCol = pc.getColumn(0);\n        for (int i = 0; i < dimension; i++) {\n            if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {\n                break;\n            }\n            if (i >= dimension - 1) {\n                break generationLoop;\n            }\n        }\n        for (int i = 0; i < dimension; i++) {\n            if (sigma * sqrtDiagC[i] > stopTolUpX) {\n                break generationLoop;\n            }\n        }\n        final double historyBest = min(fitnessHistory);\n        final double historyWorst = max(fitnessHistory);\n        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {\n            break generationLoop;\n        }\n        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {\n            break generationLoop;\n        }\n                if (max(diagD) / min(diagD) > 1e7) {\n            break generationLoop;\n        }\n                if (getConvergenceChecker() != null) {\n            final PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);\n            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {\n                break generationLoop;\n            }\n            lastResult = current;\n        }\n                if (bestValue == fitness[arindex[(int) (0.1 + lambda / 4.)]]) {\n            sigma = sigma * Math.exp(0.2 + cs / damps);\n        }\n        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {\n            sigma = sigma * Math.exp(0.2 + cs / damps);\n        }\n                push(fitnessHistory, bestFitness);\n        fitfun.setValueRange(worstFitness - bestFitness);\n        if (generateStatistics) {\n            statisticsSigmaHistory.add(sigma);\n            statisticsFitnessHistory.add(bestFitness);\n            statisticsMeanHistory.add(xmean.transpose());\n            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n        }\n    }\n    return optimum;\n}", "lc": 4.681818181818182, "pi": 0.6377551020408161, "ma": 6.166666666666667, "nbd": 1.0, "ml": 5.583333333333333, "d": 4.171033119130005, "mi": -1.6624605678233442, "fo": 5.25, "r": -0.028571428571428574, "e": 32.09659030070969}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5724_b92591f6", "label": 1, "code": "/**\n *  Creates a new instance of auto component to be queued\n */\nComponent newComponent(ComponentTag tag);", "code_comment": "/**\n *  Creates a new instance of auto component to be queued\n */\n", "code_no_comment": "Component newComponent(ComponentTag tag);", "lc": -0.5909090909090909, "pi": -1.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.6550043016919995, "fo": -0.5, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1153_9f924f10", "label": 1, "code": "@Override\npublic PropertiesConfiguration getConfiguration(ConfigurationSource source) {\n    final InputStream configStream = source.getInputStream();\n    Properties properties = new Properties();\n    try {\n        properties.load(configStream);\n    } catch (IOException ioe) {\n        throw new ConfigurationException(\"Unable to load \" + source.toString(), ioe);\n    }\n    ConfigurationBuilder<PropertiesConfiguration> builder = newConfigurationBuilder(PropertiesConfiguration.class);\n    String value = properties.getProperty(STATUS_KEY);\n    if (value != null) {\n        builder.setStatusLevel(Level.toLevel(value, Level.ERROR));\n    } else {\n        builder.setStatusLevel(Level.ERROR);\n    }\n    value = properties.getProperty(SHUTDOWN_HOOK);\n    if (value != null) {\n        builder.setShutdownHook(value);\n    }\n    value = properties.getProperty(VERBOSE);\n    if (value != null) {\n        builder.setVerbosity(value);\n    }\n    value = properties.getProperty(PACKAGES);\n    if (value != null) {\n        builder.setPackages(value);\n    }\n    value = properties.getProperty(CONFIG_NAME);\n    if (value != null) {\n        builder.setConfigurationName(value);\n    }\n    value = properties.getProperty(MONITOR_INTERVAL);\n    if (value != null) {\n        builder.setMonitorInterval(value);\n    }\n    value = properties.getProperty(ADVERTISER_KEY);\n    if (value != null) {\n        builder.setAdvertiser(value);\n    }\n    Properties props = PropertiesUtil.extractSubset(properties, \"property\");\n    for (String key : props.stringPropertyNames()) {\n        builder.addProperty(key, props.getProperty(key));\n    }\n    Properties levelProps = PropertiesUtil.extractSubset(properties, \"customLevel\");\n    if (levelProps.size() > 0) {\n        for (String key : levelProps.stringPropertyNames()) {\n            builder.add(builder.newCustomLevel(key, Integer.parseInt(props.getProperty(key))));\n        }\n    }\n    String filterProp = properties.getProperty(\"filters\");\n    if (filterProp != null) {\n        String[] filterNames = filterProp.split(\",\");\n        for (String filterName : filterNames) {\n            String name = filterName.trim();\n            builder.add(createFilter(builder, name, PropertiesUtil.extractSubset(properties, \"filter.\" + name)));\n        }\n    }\n    String appenderProp = properties.getProperty(\"appenders\");\n    if (appenderProp != null) {\n        String[] appenderNames = appenderProp.split(\",\");\n        for (String appenderName : appenderNames) {\n            String name = appenderName.trim();\n            builder.add(createAppender(builder, name, PropertiesUtil.extractSubset(properties, \"appender.\" + name)));\n        }\n    }\n    String loggerProp = properties.getProperty(\"loggers\");\n    if (appenderProp != null) {\n        String[] loggerNames = loggerProp.split(\",\");\n        for (String loggerName : loggerNames) {\n            String name = loggerName.trim();\n            if (!name.equals(LoggerConfig.ROOT)) {\n                builder.add(createLogger(builder, name, PropertiesUtil.extractSubset(properties, \"logger.\" + name)));\n            }\n        }\n    }\n    props = PropertiesUtil.extractSubset(properties, \"rootLogger\");\n    if (props.size() > 0) {\n        builder.add(createRootLogger(builder, props));\n    }\n    return builder.build();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic PropertiesConfiguration getConfiguration(ConfigurationSource source) {\n    final InputStream configStream = source.getInputStream();\n    Properties properties = new Properties();\n    try {\n        properties.load(configStream);\n    } catch (IOException ioe) {\n        throw new ConfigurationException(\"Unable to load \" + source.toString(), ioe);\n    }\n    ConfigurationBuilder<PropertiesConfiguration> builder = newConfigurationBuilder(PropertiesConfiguration.class);\n    String value = properties.getProperty(STATUS_KEY);\n    if (value != null) {\n        builder.setStatusLevel(Level.toLevel(value, Level.ERROR));\n    } else {\n        builder.setStatusLevel(Level.ERROR);\n    }\n    value = properties.getProperty(SHUTDOWN_HOOK);\n    if (value != null) {\n        builder.setShutdownHook(value);\n    }\n    value = properties.getProperty(VERBOSE);\n    if (value != null) {\n        builder.setVerbosity(value);\n    }\n    value = properties.getProperty(PACKAGES);\n    if (value != null) {\n        builder.setPackages(value);\n    }\n    value = properties.getProperty(CONFIG_NAME);\n    if (value != null) {\n        builder.setConfigurationName(value);\n    }\n    value = properties.getProperty(MONITOR_INTERVAL);\n    if (value != null) {\n        builder.setMonitorInterval(value);\n    }\n    value = properties.getProperty(ADVERTISER_KEY);\n    if (value != null) {\n        builder.setAdvertiser(value);\n    }\n    Properties props = PropertiesUtil.extractSubset(properties, \"property\");\n    for (String key : props.stringPropertyNames()) {\n        builder.addProperty(key, props.getProperty(key));\n    }\n    Properties levelProps = PropertiesUtil.extractSubset(properties, \"customLevel\");\n    if (levelProps.size() > 0) {\n        for (String key : levelProps.stringPropertyNames()) {\n            builder.add(builder.newCustomLevel(key, Integer.parseInt(props.getProperty(key))));\n        }\n    }\n    String filterProp = properties.getProperty(\"filters\");\n    if (filterProp != null) {\n        String[] filterNames = filterProp.split(\",\");\n        for (String filterName : filterNames) {\n            String name = filterName.trim();\n            builder.add(createFilter(builder, name, PropertiesUtil.extractSubset(properties, \"filter.\" + name)));\n        }\n    }\n    String appenderProp = properties.getProperty(\"appenders\");\n    if (appenderProp != null) {\n        String[] appenderNames = appenderProp.split(\",\");\n        for (String appenderName : appenderNames) {\n            String name = appenderName.trim();\n            builder.add(createAppender(builder, name, PropertiesUtil.extractSubset(properties, \"appender.\" + name)));\n        }\n    }\n    String loggerProp = properties.getProperty(\"loggers\");\n    if (appenderProp != null) {\n        String[] loggerNames = loggerProp.split(\",\");\n        for (String loggerName : loggerNames) {\n            String name = loggerName.trim();\n            if (!name.equals(LoggerConfig.ROOT)) {\n                builder.add(createLogger(builder, name, PropertiesUtil.extractSubset(properties, \"logger.\" + name)));\n            }\n        }\n    }\n    props = PropertiesUtil.extractSubset(properties, \"rootLogger\");\n    if (props.size() > 0) {\n        builder.add(createRootLogger(builder, props));\n    }\n    return builder.build();\n}", "lc": 3.090909090909091, "pi": 0.025510204081632563, "ma": 2.8333333333333335, "nbd": 0.5, "ml": 1.1666666666666667, "d": 0.7721206129510629, "mi": -1.279609979925438, "fo": 4.083333333333333, "r": -0.028571428571428574, "e": 4.430634612666555}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3647_1b57b51c", "label": 1, "code": "/**\n *  Get the markupId\n *\n *  @return MarkupId\n */\npublic final Object getMarkupIdImpl() {\n    String id = getMarkupIdFromMarkup();\n    if (id != null) {\n        return id;\n    }\n    if (generatedMarkupId != -1) {\n        return generatedMarkupId;\n    }\n    return getMetaData(MARKUP_ID_KEY);\n}", "code_comment": "/**\n *  Get the markupId\n *\n *  @return MarkupId\n */\n", "code_no_comment": "public final Object getMarkupIdImpl() {\n    String id = getMarkupIdFromMarkup();\n    if (id != null) {\n        return id;\n    }\n    if (generatedMarkupId != -1) {\n        return generatedMarkupId;\n    }\n    return getMetaData(MARKUP_ID_KEY);\n}", "lc": -0.18181818181818182, "pi": -0.2500000000000001, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.12951062778052397, "mi": 0.307427588184686, "fo": -0.3333333333333333, "r": 2.742857142857143, "e": -0.1268711372659874}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-392_731c84b5", "label": 1, "code": "/**\n * Tear down the configuration.\n */\n@Override\npublic void stop() {\n    this.setStopping();\n    LOGGER.trace(\"Stopping {}...\", this);\n    // LOG4J2-392 first stop AsyncLogger Disruptor thread\n    final LoggerContextFactory factory = LogManager.getFactory();\n    if (factory instanceof Log4jContextFactory) {\n        ContextSelector selector = ((Log4jContextFactory) factory).getSelector();\n        if (selector instanceof AsyncLoggerContextSelector) {\n        // all loggers are async\n        // TODO until LOG4J2-493 is fixed we can only stop AsyncLogger once!\n        // but LoggerContext.setConfiguration will call config.stop()\n        // every time the configuration changes...\n        // \n        // Uncomment the line below after LOG4J2-493 is fixed\n        // AsyncLogger.stop();\n        // LOGGER.trace(\"AbstractConfiguration stopped AsyncLogger disruptor.\");\n        }\n    }\n    // similarly, first stop AsyncLoggerConfig Disruptor thread(s)\n    Set<LoggerConfig> alreadyStopped = new HashSet<LoggerConfig>();\n    int asyncLoggerConfigCount = 0;\n    for (final LoggerConfig logger : loggers.values()) {\n        if (logger instanceof AsyncLoggerConfig) {\n            // LOG4J2-520, LOG4J2-392:\n            // Important: do not clear appenders until after all AsyncLoggerConfigs\n            // have been stopped! Stopping the last AsyncLoggerConfig will\n            // shut down the disruptor and wait for all enqueued events to be processed.\n            // Only *after this* the appenders can be cleared or events will be lost.\n            logger.stop();\n            asyncLoggerConfigCount++;\n            alreadyStopped.add(logger);\n        }\n    }\n    if (root instanceof AsyncLoggerConfig) {\n        root.stop();\n        asyncLoggerConfigCount++;\n        alreadyStopped.add(root);\n    }\n    LOGGER.trace(\"AbstractConfiguration stopped {} AsyncLoggerConfigs.\", asyncLoggerConfigCount);\n    // Stop the appenders in reverse order in case they still have activity.\n    final Appender[] array = appenders.values().toArray(new Appender[appenders.size()]);\n    // LOG4J2-511, LOG4J2-392 stop AsyncAppenders first\n    int asyncAppenderCount = 0;\n    for (int i = array.length - 1; i >= 0; --i) {\n        if (array[i] instanceof AsyncAppender) {\n            array[i].stop();\n            asyncAppenderCount++;\n        }\n    }\n    LOGGER.trace(\"AbstractConfiguration stopped {} AsyncAppenders.\", asyncAppenderCount);\n    int appenderCount = 0;\n    for (int i = array.length - 1; i >= 0; --i) {\n        if (array[i].isStarted()) {\n            // then stop remaining Appenders\n            array[i].stop();\n            appenderCount++;\n        }\n    }\n    LOGGER.trace(\"AbstractConfiguration stopped {} Appenders.\", appenderCount);\n    int loggerCount = 0;\n    for (final LoggerConfig logger : loggers.values()) {\n        // clear appenders, even if this logger is already stopped.\n        logger.clearAppenders();\n        // the shared Disruptor may be shut down prematurely, resulting in NPE or other errors.\n        if (alreadyStopped.contains(logger)) {\n            continue;\n        }\n        logger.stop();\n        loggerCount++;\n    }\n    LOGGER.trace(\"AbstractConfiguration stopped {} Loggers.\", loggerCount);\n    // the shared Disruptor may be shut down prematurely, resulting in NPE or other errors.\n    if (!alreadyStopped.contains(root)) {\n        root.stop();\n    }\n    super.stop();\n    if (advertiser != null && advertisement != null) {\n        advertiser.unadvertise(advertisement);\n    }\n    LOGGER.debug(\"Stopped {} OK\", this);\n}", "code_comment": "/**\n * Tear down the configuration.\n */\n", "code_no_comment": "@Override\npublic void stop() {\n    this.setStopping();\n    LOGGER.trace(\"Stopping {}...\", this);\n        final LoggerContextFactory factory = LogManager.getFactory();\n    if (factory instanceof Log4jContextFactory) {\n        ContextSelector selector = ((Log4jContextFactory) factory).getSelector();\n        if (selector instanceof AsyncLoggerContextSelector) {\n                                                                        }\n    }\n        Set<LoggerConfig> alreadyStopped = new HashSet<LoggerConfig>();\n    int asyncLoggerConfigCount = 0;\n    for (final LoggerConfig logger : loggers.values()) {\n        if (logger instanceof AsyncLoggerConfig) {\n                                                                        logger.stop();\n            asyncLoggerConfigCount++;\n            alreadyStopped.add(logger);\n        }\n    }\n    if (root instanceof AsyncLoggerConfig) {\n        root.stop();\n        asyncLoggerConfigCount++;\n        alreadyStopped.add(root);\n    }\n    LOGGER.trace(\"AbstractConfiguration stopped {} AsyncLoggerConfigs.\", asyncLoggerConfigCount);\n        final Appender[] array = appenders.values().toArray(new Appender[appenders.size()]);\n        int asyncAppenderCount = 0;\n    for (int i = array.length - 1; i >= 0; --i) {\n        if (array[i] instanceof AsyncAppender) {\n            array[i].stop();\n            asyncAppenderCount++;\n        }\n    }\n    LOGGER.trace(\"AbstractConfiguration stopped {} AsyncAppenders.\", asyncAppenderCount);\n    int appenderCount = 0;\n    for (int i = array.length - 1; i >= 0; --i) {\n        if (array[i].isStarted()) {\n                        array[i].stop();\n            appenderCount++;\n        }\n    }\n    LOGGER.trace(\"AbstractConfiguration stopped {} Appenders.\", appenderCount);\n    int loggerCount = 0;\n    for (final LoggerConfig logger : loggers.values()) {\n                logger.clearAppenders();\n                if (alreadyStopped.contains(logger)) {\n            continue;\n        }\n        logger.stop();\n        loggerCount++;\n    }\n    LOGGER.trace(\"AbstractConfiguration stopped {} Loggers.\", loggerCount);\n        if (!alreadyStopped.contains(root)) {\n        root.stop();\n    }\n    super.stop();\n    if (advertiser != null && advertisement != null) {\n        advertiser.unadvertise(advertisement);\n    }\n    LOGGER.debug(\"Stopped {} OK\", this);\n}", "lc": 2.1363636363636362, "pi": 0.051020408163265356, "ma": 1.8333333333333333, "nbd": 0.0, "ml": 1.4166666666666667, "d": 1.6045477014335146, "mi": -1.0020074562661316, "fo": 1.8333333333333333, "r": -0.028571428571428574, "e": 3.864335856022546}
{"project_name": "Math", "project_version": 82, "label": 1, "code": "/**\n * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n * @param tableau simple tableau for the problem\n * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n * @return row with the minimum ratio\n */\nprivate Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n            final double ratio = rhs / entry;\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n}", "code_comment": "/**\n * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n * @param tableau simple tableau for the problem\n * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n * @return row with the minimum ratio\n */\n", "code_no_comment": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n            final double ratio = rhs / entry;\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n}", "lc": 0.09090909090909091, "pi": 0.9438775510204083, "ma": 0.0, "nbd": 0.5, "ml": 0.4166666666666667, "d": 0.782006920415225, "mi": -0.13736736449670225, "fo": 0.0, "r": 0.028571428571428574, "e": 0.5889429975030088}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "public int compareTo(removeConstraint_result other) {\n    if (!getClass().equals(other.getClass())) {\n        return getClass().getName().compareTo(other.getClass().getName());\n    }\n    int lastComparison = 0;\n    removeConstraint_result typedOther = (removeConstraint_result) other;\n    lastComparison = Boolean.valueOf(isSetOuch1()).compareTo(typedOther.isSetOuch1());\n    if (lastComparison != 0) {\n        return lastComparison;\n    }\n    if (isSetOuch1()) {\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch1, typedOther.ouch1);\n        if (lastComparison != 0) {\n            return lastComparison;\n        }\n    }\n    lastComparison = Boolean.valueOf(isSetOuch2()).compareTo(typedOther.isSetOuch2());\n    if (lastComparison != 0) {\n        return lastComparison;\n    }\n    if (isSetOuch2()) {\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch2, typedOther.ouch2);\n        if (lastComparison != 0) {\n            return lastComparison;\n        }\n    }\n    return 0;\n}", "code_comment": NaN, "code_no_comment": "public int compareTo(removeConstraint_result other) {\n    if (!getClass().equals(other.getClass())) {\n        return getClass().getName().compareTo(other.getClass().getName());\n    }\n    int lastComparison = 0;\n    removeConstraint_result typedOther = (removeConstraint_result) other;\n    lastComparison = Boolean.valueOf(isSetOuch1()).compareTo(typedOther.isSetOuch1());\n    if (lastComparison != 0) {\n        return lastComparison;\n    }\n    if (isSetOuch1()) {\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch1, typedOther.ouch1);\n        if (lastComparison != 0) {\n            return lastComparison;\n        }\n    }\n    lastComparison = Boolean.valueOf(isSetOuch2()).compareTo(typedOther.isSetOuch2());\n    if (lastComparison != 0) {\n        return lastComparison;\n    }\n    if (isSetOuch2()) {\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch2, typedOther.ouch2);\n        if (lastComparison != 0) {\n            return lastComparison;\n        }\n    }\n    return 0;\n}", "lc": 0.6363636363636364, "pi": -0.06122448979591842, "ma": 0.6666666666666666, "nbd": 0.0, "ml": 0.5833333333333334, "d": 0.28175976272862097, "mi": -0.4482363062804703, "fo": 1.1666666666666667, "r": -0.028571428571428574, "e": 0.3420278309584077}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5247_44a4132f", "label": 3, "code": "/**\n *  @see AbstractBookmarkableMapper#buildUrl(AbstractBookmarkableMapper.UrlInfo)\n */\n@Override\nprotected Url buildUrl(UrlInfo info) {\n    Url url = new Url();\n    for (String s : mountSegments) {\n        url.getSegments().add(s);\n    }\n    encodePageComponentInfo(url, info.getPageComponentInfo());\n    PageParameters copy = new PageParameters(info.getPageParameters());\n    int dropped = 0;\n    for (int i = 0; i < mountSegments.length; ++i) {\n        String placeholder = getPlaceholder(mountSegments[i]);\n        String optionalPlaceholder = getOptionalPlaceholder(mountSegments[i]);\n        if (placeholder != null) {\n            url.getSegments().set(i - dropped, copy.get(placeholder).toString(\"\"));\n            copy.remove(placeholder);\n        } else if (optionalPlaceholder != null) {\n            if (copy.getNamedKeys().contains(optionalPlaceholder)) {\n                url.getSegments().set(i - dropped, copy.get(optionalPlaceholder).toString(\"\"));\n                copy.remove(optionalPlaceholder);\n            } else {\n                url.getSegments().remove(i - dropped);\n                dropped++;\n            }\n        }\n    }\n    return encodePageParameters(url, copy, pageParametersEncoder);\n}", "code_comment": "/**\n *  @see AbstractBookmarkableMapper#buildUrl(AbstractBookmarkableMapper.UrlInfo)\n */\n", "code_no_comment": "@Override\nprotected Url buildUrl(UrlInfo info) {\n    Url url = new Url();\n    for (String s : mountSegments) {\n        url.getSegments().add(s);\n    }\n    encodePageComponentInfo(url, info.getPageComponentInfo());\n    PageParameters copy = new PageParameters(info.getPageParameters());\n    int dropped = 0;\n    for (int i = 0; i < mountSegments.length; ++i) {\n        String placeholder = getPlaceholder(mountSegments[i]);\n        String optionalPlaceholder = getOptionalPlaceholder(mountSegments[i]);\n        if (placeholder != null) {\n            url.getSegments().set(i - dropped, copy.get(placeholder).toString(\"\"));\n            copy.remove(placeholder);\n        } else if (optionalPlaceholder != null) {\n            if (copy.getNamedKeys().contains(optionalPlaceholder)) {\n                url.getSegments().set(i - dropped, copy.get(optionalPlaceholder).toString(\"\"));\n                copy.remove(optionalPlaceholder);\n            } else {\n                url.getSegments().remove(i - dropped);\n                dropped++;\n            }\n        }\n    }\n    return encodePageParameters(url, copy, pageParametersEncoder);\n}", "lc": 0.5909090909090909, "pi": 1.0000000000000002, "ma": 0.3333333333333333, "nbd": 1.0, "ml": 0.3333333333333333, "d": 0.6020761245674742, "mi": -0.48092916547175224, "fo": 1.3333333333333333, "r": -0.028571428571428574, "e": 0.9802853337102376}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4116_4624ab3d", "label": 1, "code": "/**\n *  The page instance is new only if there is no cached instance or the data stores doesn't have\n *  a page with that id with the same {@linkplain #pageClass}.\n *\n *  @see org.apache.wicket.request.handler.IPageProvider#isNewPageInstance()\n */\npublic boolean isNewPageInstance() {\n    boolean isNew = pageInstance == null;\n    if (isNew && pageId != null) {\n        IRequestablePage storedPageInstance = getStoredPage(pageId);\n        if (storedPageInstance != null) {\n            pageInstance = storedPageInstance;\n            isNew = false;\n        }\n    }\n    return isNew;\n}", "code_comment": "/**\n *  The page instance is new only if there is no cached instance or the data stores doesn't have\n *  a page with that id with the same {@linkplain #pageClass}.\n *\n *  @see org.apache.wicket.request.handler.IPageProvider#isNewPageInstance()\n */\n", "code_no_comment": "public boolean isNewPageInstance() {\n    boolean isNew = pageInstance == null;\n    if (isNew && pageId != null) {\n        IRequestablePage storedPageInstance = getStoredPage(pageId);\n        if (storedPageInstance != null) {\n            pageInstance = storedPageInstance;\n            isNew = false;\n        }\n    }\n    return isNew;\n}", "lc": -0.13636363636363635, "pi": 0.47448979591836743, "ma": -0.16666666666666666, "nbd": 0.0, "ml": 0.08333333333333333, "d": 0.37073652990608014, "mi": 0.20246630341267577, "fo": -0.4166666666666667, "r": 2.142857142857143, "e": 0.0030794797007036964}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-320_c06cc933", "label": 1, "code": "/**\n * {@inheritDoc}\n */\npublic RealMatrix getV() throws InvalidMatrixException {\n    if (cachedV == null) {\n        if (m >= n) {\n            // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n            cachedV = transformer.getV().multiply(eigenDecomposition.getV());\n        } else {\n            // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n            final double[][] eData = eigenDecomposition.getV().getData();\n            final double[][] iData = new double[n][];\n            double[] ei1 = eData[0];\n            iData[0] = ei1;\n            for (int i = 0; i < m - 1; ++i) {\n                // compute Bt.E.S^(-1) where E is the eigenvectors matrix\n                // we reuse the array from matrix E to store the result\n                final double mi = mainBidiagonal[i];\n                final double si = secondaryBidiagonal[i];\n                final double[] ei0 = ei1;\n                ei1 = eData[i + 1];\n                iData[i + 1] = ei1;\n                for (int j = 0; j < m; ++j) {\n                    ei0[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                }\n            }\n            // last row\n            final double lastMain = mainBidiagonal[m - 1];\n            for (int j = 0; j < m; ++j) {\n                ei1[j] *= lastMain / singularValues[j];\n            }\n            for (int i = m; i < n; ++i) {\n                iData[i] = new double[m];\n            }\n            cachedV = transformer.getV().multiply(MatrixUtils.createRealMatrix(iData));\n        }\n    }\n    // return the cached matrix\n    return cachedV;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public RealMatrix getV() throws InvalidMatrixException {\n    if (cachedV == null) {\n        if (m >= n) {\n                        cachedV = transformer.getV().multiply(eigenDecomposition.getV());\n        } else {\n                        final double[][] eData = eigenDecomposition.getV().getData();\n            final double[][] iData = new double[n][];\n            double[] ei1 = eData[0];\n            iData[0] = ei1;\n            for (int i = 0; i < m - 1; ++i) {\n                                                final double mi = mainBidiagonal[i];\n                final double si = secondaryBidiagonal[i];\n                final double[] ei0 = ei1;\n                ei1 = eData[i + 1];\n                iData[i + 1] = ei1;\n                for (int j = 0; j < m; ++j) {\n                    ei0[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                }\n            }\n                        final double lastMain = mainBidiagonal[m - 1];\n            for (int j = 0; j < m; ++j) {\n                ei1[j] *= lastMain / singularValues[j];\n            }\n            for (int i = m; i < n; ++i) {\n                iData[i] = new double[m];\n            }\n            cachedV = transformer.getV().multiply(MatrixUtils.createRealMatrix(iData));\n        }\n    }\n        return cachedV;\n}", "lc": 0.7727272727272727, "pi": 0.933673469387755, "ma": 0.5, "nbd": 1.0, "ml": 0.5, "d": 2.9036085022244196, "mi": -0.5884714654430743, "fo": 0.16666666666666666, "r": -0.028571428571428574, "e": 4.725699307438292}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1731_024e5d37", "label": 1, "code": "/**\n * Copies the full content from the source to the target repository.\n * <p>\n * The source repository <strong>must not be modified</strong> while\n * the copy operation is running to avoid an inconsistent copy.\n * <p>\n * Note that both the source and the target repository must be closed\n * during the copy operation as this method requires exclusive access\n * to the repositories.\n *\n * @param initializer optional extra repository initializer to use\n * @throws RepositoryException if the copy operation fails\n */\npublic void copy(RepositoryInitializer initializer) throws RepositoryException {\n    RepositoryConfig config = source.getRepositoryConfig();\n    logger.info(\"Copying repository content from {} to Oak\", config.getHomeDir());\n    try {\n        NodeBuilder builder = target.getRoot().builder();\n        String workspace = source.getRepositoryConfig().getDefaultWorkspaceName();\n        SecurityProviderImpl security = new SecurityProviderImpl(mapSecurityConfig(config.getSecurityConfig()));\n        // init target repository first\n        new InitialContent().initialize(builder);\n        if (initializer != null) {\n            initializer.initialize(builder);\n        }\n        for (SecurityConfiguration sc : security.getConfigurations()) {\n            sc.getWorkspaceInitializer().initialize(builder, workspace);\n        }\n        Map<String, String> uriToPrefix = newHashMap();\n        Map<Integer, String> idxToPrefix = newHashMap();\n        copyNamespaces(builder, uriToPrefix, idxToPrefix);\n        copyNodeTypes(builder);\n        copyPrivileges(builder);\n        NodeState root = builder.getNodeState();\n        copyVersionStore(builder, root, uriToPrefix, idxToPrefix);\n        copyWorkspace(builder, root, workspace, uriToPrefix, idxToPrefix);\n        logger.info(\"Applying default commit hooks\");\n        // TODO: default hooks?\n        List<CommitHook> hooks = newArrayList();\n        UserConfiguration userConf = security.getConfiguration(UserConfiguration.class);\n        String groupsPath = userConf.getParameters().getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);\n        // hooks specific to the upgrade, need to run first\n        hooks.add(new EditorHook(new CompositeEditorProvider(new RestrictionEditorProvider(), new GroupEditorProvider(groupsPath))));\n        // security-related hooks\n        for (SecurityConfiguration sc : security.getConfigurations()) {\n            hooks.addAll(sc.getCommitHooks(workspace));\n        }\n        // type validation, reference and indexing hooks\n        hooks.add(new EditorHook(new CompositeEditorProvider(new TypeEditorProvider(false), new IndexUpdateProvider(new CompositeIndexEditorProvider(new ReferenceEditorProvider(), new PropertyIndexEditorProvider())))));\n        target.merge(builder, CompositeHook.compose(hooks), CommitInfo.EMPTY);\n    } catch (Exception e) {\n        throw new RepositoryException(\"Failed to copy content\", e);\n    }\n}", "code_comment": "/**\n * Copies the full content from the source to the target repository.\n * <p>\n * The source repository <strong>must not be modified</strong> while\n * the copy operation is running to avoid an inconsistent copy.\n * <p>\n * Note that both the source and the target repository must be closed\n * during the copy operation as this method requires exclusive access\n * to the repositories.\n *\n * @param initializer optional extra repository initializer to use\n * @throws RepositoryException if the copy operation fails\n */\n", "code_no_comment": "public void copy(RepositoryInitializer initializer) throws RepositoryException {\n    RepositoryConfig config = source.getRepositoryConfig();\n    logger.info(\"Copying repository content from {} to Oak\", config.getHomeDir());\n    try {\n        NodeBuilder builder = target.getRoot().builder();\n        String workspace = source.getRepositoryConfig().getDefaultWorkspaceName();\n        SecurityProviderImpl security = new SecurityProviderImpl(mapSecurityConfig(config.getSecurityConfig()));\n                new InitialContent().initialize(builder);\n        if (initializer != null) {\n            initializer.initialize(builder);\n        }\n        for (SecurityConfiguration sc : security.getConfigurations()) {\n            sc.getWorkspaceInitializer().initialize(builder, workspace);\n        }\n        Map<String, String> uriToPrefix = newHashMap();\n        Map<Integer, String> idxToPrefix = newHashMap();\n        copyNamespaces(builder, uriToPrefix, idxToPrefix);\n        copyNodeTypes(builder);\n        copyPrivileges(builder);\n        NodeState root = builder.getNodeState();\n        copyVersionStore(builder, root, uriToPrefix, idxToPrefix);\n        copyWorkspace(builder, root, workspace, uriToPrefix, idxToPrefix);\n        logger.info(\"Applying default commit hooks\");\n                List<CommitHook> hooks = newArrayList();\n        UserConfiguration userConf = security.getConfiguration(UserConfiguration.class);\n        String groupsPath = userConf.getParameters().getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);\n                hooks.add(new EditorHook(new CompositeEditorProvider(new RestrictionEditorProvider(), new GroupEditorProvider(groupsPath))));\n                for (SecurityConfiguration sc : security.getConfigurations()) {\n            hooks.addAll(sc.getCommitHooks(workspace));\n        }\n                hooks.add(new EditorHook(new CompositeEditorProvider(new TypeEditorProvider(false), new IndexUpdateProvider(new CompositeIndexEditorProvider(new ReferenceEditorProvider(), new PropertyIndexEditorProvider())))));\n        target.merge(builder, CompositeHook.compose(hooks), CommitInfo.EMPTY);\n    } catch (Exception e) {\n        throw new RepositoryException(\"Failed to copy content\", e);\n    }\n}", "lc": 1.0, "pi": -0.22448979591836732, "ma": 0.3333333333333333, "nbd": 0.0, "ml": -0.25, "d": -0.030647553138902585, "mi": -0.7008890163464297, "fo": 2.3333333333333335, "r": -0.028571428571428574, "e": 0.5623883742146042}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-358_061f5017", "label": 0, "code": "/**\n * {@inheritDoc}\n */\npublic double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n        System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n        yDotK[i] = new double[y0.length];\n    }\n    final double[] yTmp = new double[y0.length];\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\n        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n        rki.reinitialize(this, yTmp, yDotK, forward);\n        interpolator = rki;\n    } else {\n        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n    // set up integration control objects\n    stepStart = t0;\n    stepSize = forward ? step : -step;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n    // main integration loop\n    while (!lastStep) {\n        interpolator.shift();\n        for (boolean loop = true; loop; ) {\n            // first stage\n            computeDerivatives(stepStart, y, yDotK[0]);\n            // next stages\n            for (int k = 1; k < stages; ++k) {\n                for (int j = 0; j < y0.length; ++j) {\n                    double sum = a[k - 1][0] * yDotK[0][j];\n                    for (int l = 1; l < k; ++l) {\n                        sum += a[k - 1][l] * yDotK[l][j];\n                    }\n                    yTmp[j] = y[j] + stepSize * sum;\n                }\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n            }\n            // estimate the state at the end of the step\n            for (int j = 0; j < y0.length; ++j) {\n                double sum = b[0] * yDotK[0][j];\n                for (int l = 1; l < stages; ++l) {\n                    sum += b[l] * yDotK[l][j];\n                }\n                yTmp[j] = y[j] + stepSize * sum;\n            }\n            // discrete events handling\n            interpolator.storeTime(stepStart + stepSize);\n            if (manager.evaluateStep(interpolator)) {\n                final double dt = manager.getEventTime() - stepStart;\n                if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                    // rejecting the step would lead to a too small next step, we accept it\n                    loop = false;\n                } else {\n                    // reject the step to match exactly the next switch time\n                    stepSize = dt;\n                }\n            } else {\n                loop = false;\n            }\n        }\n        // the step has been accepted\n        final double nextStep = stepStart + stepSize;\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\n        manager.stepAccepted(nextStep, y);\n        lastStep = manager.stop();\n        // provide the step data to the step handler\n        interpolator.storeTime(nextStep);\n        for (StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, lastStep);\n        }\n        stepStart = nextStep;\n        if (manager.reset(stepStart, y) && !lastStep) {\n            // some events handler has triggered changes that\n            // invalidate the derivatives, we need to recompute them\n            computeDerivatives(stepStart, y, yDotK[0]);\n        }\n        // make sure step size is set to default before next step\n        stepSize = forward ? step : -step;\n    }\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize = Double.NaN;\n    return stopTime;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n        final int stages = c.length + 1;\n    if (y != y0) {\n        System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n        yDotK[i] = new double[y0.length];\n    }\n    final double[] yTmp = new double[y0.length];\n        AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\n        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n        rki.reinitialize(this, yTmp, yDotK, forward);\n        interpolator = rki;\n    } else {\n        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n        stepStart = t0;\n    stepSize = forward ? step : -step;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n        while (!lastStep) {\n        interpolator.shift();\n        for (boolean loop = true; loop; ) {\n                        computeDerivatives(stepStart, y, yDotK[0]);\n                        for (int k = 1; k < stages; ++k) {\n                for (int j = 0; j < y0.length; ++j) {\n                    double sum = a[k - 1][0] * yDotK[0][j];\n                    for (int l = 1; l < k; ++l) {\n                        sum += a[k - 1][l] * yDotK[l][j];\n                    }\n                    yTmp[j] = y[j] + stepSize * sum;\n                }\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n            }\n                        for (int j = 0; j < y0.length; ++j) {\n                double sum = b[0] * yDotK[0][j];\n                for (int l = 1; l < stages; ++l) {\n                    sum += b[l] * yDotK[l][j];\n                }\n                yTmp[j] = y[j] + stepSize * sum;\n            }\n                        interpolator.storeTime(stepStart + stepSize);\n            if (manager.evaluateStep(interpolator)) {\n                final double dt = manager.getEventTime() - stepStart;\n                if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                                        loop = false;\n                } else {\n                                        stepSize = dt;\n                }\n            } else {\n                loop = false;\n            }\n        }\n                final double nextStep = stepStart + stepSize;\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\n        manager.stepAccepted(nextStep, y);\n        lastStep = manager.stop();\n                interpolator.storeTime(nextStep);\n        for (StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, lastStep);\n        }\n        stepStart = nextStep;\n        if (manager.reset(stepStart, y) && !lastStep) {\n                                    computeDerivatives(stepStart, y, yDotK[0]);\n        }\n                stepSize = forward ? step : -step;\n    }\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize = Double.NaN;\n    return stopTime;\n}", "lc": 3.090909090909091, "pi": 1.3469387755102042, "ma": 2.3333333333333335, "nbd": 1.5, "ml": 2.6666666666666665, "d": 3.9476025704399413, "mi": -1.2824777745913396, "fo": 1.6666666666666667, "r": -0.028571428571428574, "e": 19.910249656288947}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3281_f7dd2fff", "label": 1, "code": "/**\n * <a href=\"http://camel.apache.org/exception-clause.html\">Exception clause</a>\n * for catching certain exceptions and handling them.\n *\n * @param exception exception to catch\n * @return the builder\n */\npublic OnExceptionDefinition onException(Class exception) {\n    routeCollection.setCamelContext(getContext());\n    return routeCollection.onException(exception);\n}", "code_comment": "/**\n * <a href=\"http://camel.apache.org/exception-clause.html\">Exception clause</a>\n * for catching certain exceptions and handling them.\n *\n * @param exception exception to catch\n * @return the builder\n */\n", "code_no_comment": "public OnExceptionDefinition onException(Class exception) {\n    routeCollection.setCamelContext(getContext());\n    return routeCollection.onException(exception);\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.855176369371953, "fo": -0.25, "r": 2.6, "e": -0.16422749602751402}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2109_d594d024", "label": 1, "code": "/**\n *  Marks task execution failed for an external reason (a reason other than th task code itself\n *  throwing an exception). If the task is already in a terminal state\n *  (such as FINISHED, CANCELED, FAILED), or if the task is already canceling this does nothing.\n *  Otherwise it sets the state to FAILED, and, if the invokable code is running,\n *  starts an asynchronous thread that aborts that code.\n *\n *  <p>This method never blocks.</p>\n */\npublic void failExternally(Throwable cause) {\n    LOG.info(\"Attempting to fail task externally \" + taskNameWithSubtask);\n    cancelOrFailAndCancelInvokable(ExecutionState.FAILED, cause);\n}", "code_comment": "/**\n *  Marks task execution failed for an external reason (a reason other than th task code itself\n *  throwing an exception). If the task is already in a terminal state\n *  (such as FINISHED, CANCELED, FAILED), or if the task is already canceling this does nothing.\n *  Otherwise it sets the state to FAILED, and, if the invokable code is running,\n *  starts an asynchronous thread that aborts that code.\n *\n *  <p>This method never blocks.</p>\n */\n", "code_no_comment": "public void failExternally(Throwable cause) {\n    LOG.info(\"Attempting to fail task externally \" + taskNameWithSubtask);\n    cancelOrFailAndCancelInvokable(ExecutionState.FAILED, cause);\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8038428448523088, "fo": -0.3333333333333333, "r": 1.0285714285714287, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-189_cd7feb4d", "label": 3, "code": "@Override\npublic SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {\n    RegExFilter result = new RegExFilter();\n    result.setSource(getSource().deepCopy(env));\n    result.rowMatcher = rowMatcher.pattern().matcher(\"\");\n    result.colfMatcher = colfMatcher.pattern().matcher(\"\");\n    result.colqMatcher = colqMatcher.pattern().matcher(\"\");\n    result.valueMatcher = valueMatcher.pattern().matcher(\"\");\n    result.orFields = orFields;\n    return result;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {\n    RegExFilter result = new RegExFilter();\n    result.setSource(getSource().deepCopy(env));\n    result.rowMatcher = rowMatcher.pattern().matcher(\"\");\n    result.colfMatcher = colfMatcher.pattern().matcher(\"\");\n    result.colqMatcher = colqMatcher.pattern().matcher(\"\");\n    result.valueMatcher = valueMatcher.pattern().matcher(\"\");\n    result.orFields = orFields;\n    return result;\n}", "lc": -0.13636363636363635, "pi": -0.6326530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.10266704903928876, "fo": 0.4166666666666667, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5", "label": 3, "code": "@Override\npublic void updateAndFlush(ByteBuffer login, String tableName, Map<ByteBuffer, List<ColumnUpdate>> cells) throws TException {\n    try {\n        BatchWriter writer = getWriter(login, tableName, null);\n        addCellsToWriter(cells, writer);\n        writer.flush();\n        writer.close();\n    } catch (Exception e) {\n        throw translateException(e);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void updateAndFlush(ByteBuffer login, String tableName, Map<ByteBuffer, List<ColumnUpdate>> cells) throws TException {\n    try {\n        BatchWriter writer = getWriter(login, tableName, null);\n        addCellsToWriter(cells, writer);\n        writer.flush();\n        writer.close();\n    } catch (Exception e) {\n        throw translateException(e);\n    }\n}", "lc": -0.13636363636363635, "pi": 0.15816326530612249, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.15629480929165485, "fo": -0.08333333333333333, "r": 0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 66, "label": 2, "code": "/**\n * This is the meat of the type checking.  It is basically one big switch,\n * with each case representing one type of parse tree node.  The individual\n * cases are usually pretty straightforward.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of the node n.\n */\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    // To be explicitly set to false if the node is not typeable.\n    boolean typeable = true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable = visitName(t, n, parent);\n            break;\n        case Token.LP:\n            // ignored here.\n            if (parent.getType() != Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable = false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            // Object literal keys are handled with OBJECTLIT\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            // Object literal keys are not typeable\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            // Object literal keys are handled with OBJECTLIT\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable = !(parent.getType() == Token.ASSIGN && parent.getFirstChild() == n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            // The type of GETELEM is always unknown, so no point counting that.\n            // If that unknown leaks elsewhere (say by an assignment to another\n            // variable), then it will be counted.\n            typeable = false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable = false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable = true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable = !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable = false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left = n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType = getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left = n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType = getJSType(n.getFirstChild());\n                rightType = getJSType(n.getLastChild());\n                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n                TernaryValue result = leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result != TernaryValue.UNKNOWN) {\n                    if (n.getType() == Token.NE) {\n                        result = result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType = getJSType(n.getFirstChild());\n                rightType = getJSType(n.getLastChild());\n                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType = getJSType(n.getFirstChild());\n            rightType = getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {\n            // OK.\n            } else {\n                // Whether the comparison is numeric will be determined at runtime\n                // each time the expression is evaluated. Regardless, both operands\n                // should match a string context.\n                String message = \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message = \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left = n.getFirstChild();\n            right = n.getLastChild();\n            leftType = getJSType(left);\n            rightType = getJSType(right);\n            validator.expectObject(t, n, rightType, \"'in' requires an object\");\n            validator.expectString(t, left, leftType, \"left side of 'in'\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left = n.getFirstChild();\n            right = n.getLastChild();\n            leftType = getJSType(left);\n            rightType = getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable = false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                report(t, n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType = getJSType(parent.getFirstChild());\n            JSType caseType = getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable = false;\n            break;\n        case Token.WITH:\n            {\n                Node child = n.getFirstChild();\n                childType = getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable = false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        // These nodes have no interesting type behavior.\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable = false;\n            break;\n        // These nodes require data flow analysis.\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable = false;\n            break;\n        // These nodes are typed during the type inference.\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() != null) {\n                // If we didn't run type inference.\n                ensureTyped(t, n);\n            } else {\n                // If this is an enum, then give that type to the objectlit as well.\n                if ((n.getType() == Token.OBJECTLIT) && (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.getType() == Token.OBJECTLIT) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    // Don't count externs since the user's code may not even use that part.\n    typeable = typeable && !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}", "code_comment": "/**\n * This is the meat of the type checking.  It is basically one big switch,\n * with each case representing one type of parse tree node.  The individual\n * cases are usually pretty straightforward.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of the node n.\n */\n", "code_no_comment": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n        boolean typeable = true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable = visitName(t, n, parent);\n            break;\n        case Token.LP:\n                        if (parent.getType() != Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable = false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n                        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n                        }\n            break;\n        case Token.GET:\n        case Token.SET:\n                        break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable = !(parent.getType() == Token.ASSIGN && parent.getFirstChild() == n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n                                                typeable = false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable = false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable = true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable = !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable = false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left = n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType = getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left = n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType = getJSType(n.getFirstChild());\n                rightType = getJSType(n.getLastChild());\n                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n                TernaryValue result = leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result != TernaryValue.UNKNOWN) {\n                    if (n.getType() == Token.NE) {\n                        result = result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType = getJSType(n.getFirstChild());\n                rightType = getJSType(n.getLastChild());\n                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType = getJSType(n.getFirstChild());\n            rightType = getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {\n                        } else {\n                                                                String message = \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message = \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left = n.getFirstChild();\n            right = n.getLastChild();\n            leftType = getJSType(left);\n            rightType = getJSType(right);\n            validator.expectObject(t, n, rightType, \"'in' requires an object\");\n            validator.expectString(t, left, leftType, \"left side of 'in'\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left = n.getFirstChild();\n            right = n.getLastChild();\n            leftType = getJSType(left);\n            rightType = getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable = false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                report(t, n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType = getJSType(parent.getFirstChild());\n            JSType caseType = getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable = false;\n            break;\n        case Token.WITH:\n            {\n                Node child = n.getFirstChild();\n                childType = getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable = false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n                case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable = false;\n            break;\n                case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable = false;\n            break;\n                case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() != null) {\n                                ensureTyped(t, n);\n            } else {\n                                if ((n.getType() == Token.OBJECTLIT) && (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.getType() == Token.OBJECTLIT) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n        typeable = typeable && !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}", "lc": 11.909090909090908, "pi": 0.25510204081632654, "ma": 23.5, "nbd": 1.5, "ml": 9.75, "d": 1.0390509144834406, "mi": -2.827358761112705, "fo": 11.25, "r": -0.028571428571428574, "e": 17.068857851388337}
{"project_name": "Closure", "project_version": 158, "label": 2, "code": "CommandLineConfig setJscompWarning(List<String> jscompWarning) {\n    this.jscompWarning.clear();\n    this.jscompWarning.addAll(jscompWarning);\n    return this;\n}", "code_comment": NaN, "code_no_comment": "CommandLineConfig setJscompWarning(List<String> jscompWarning) {\n    this.jscompWarning.clear();\n    this.jscompWarning.addAll(jscompWarning);\n    return this;\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7516489819328936, "fo": -0.3333333333333333, "r": 0.08571428571428572, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "@Override\npublic void write(org.apache.thrift.protocol.TProtocol prot, removeTableProperty_result struct) throws org.apache.thrift.TException {\n    TTupleProtocol oprot = (TTupleProtocol) prot;\n    BitSet optionals = new BitSet();\n    if (struct.isSetOuch1()) {\n        optionals.set(0);\n    }\n    if (struct.isSetOuch2()) {\n        optionals.set(1);\n    }\n    oprot.writeBitSet(optionals, 2);\n    if (struct.isSetOuch1()) {\n        struct.ouch1.write(oprot);\n    }\n    if (struct.isSetOuch2()) {\n        struct.ouch2.write(oprot);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void write(org.apache.thrift.protocol.TProtocol prot, removeTableProperty_result struct) throws org.apache.thrift.TException {\n    TTupleProtocol oprot = (TTupleProtocol) prot;\n    BitSet optionals = new BitSet();\n    if (struct.isSetOuch1()) {\n        optionals.set(0);\n    }\n    if (struct.isSetOuch2()) {\n        optionals.set(1);\n    }\n    oprot.writeBitSet(optionals, 2);\n    if (struct.isSetOuch1()) {\n        struct.ouch1.write(oprot);\n    }\n    if (struct.isSetOuch2()) {\n        struct.ouch2.write(oprot);\n    }\n}", "lc": 0.18181818181818182, "pi": -0.2755102040816327, "ma": 0.16666666666666666, "nbd": -0.5, "ml": 0.08333333333333333, "d": -0.3806228373702422, "mi": -0.16260395755663903, "fo": 0.25, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 13, "label": 2, "code": "private void traverse(Node node) {\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n        return;\n    }\n    int visits = 0;\n    do {\n        Node c = node.getFirstChild();\n        while (c != null) {\n            traverse(c);\n            Node next = c.getNext();\n            c = next;\n        }\n        visit(node);\n        visits++;\n        Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n    exitNode(node);\n}", "code_comment": NaN, "code_no_comment": "private void traverse(Node node) {\n        if (!shouldVisit(node)) {\n        return;\n    }\n    int visits = 0;\n    do {\n        Node c = node.getFirstChild();\n        while (c != null) {\n            traverse(c);\n            Node next = c.getNext();\n            c = next;\n        }\n        visit(node);\n        visits++;\n        Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n    exitNode(node);\n}", "lc": 0.18181818181818182, "pi": 0.2755102040816327, "ma": 0.0, "nbd": 0.0, "ml": 0.16666666666666666, "d": 0.3272367770637668, "mi": -0.12646974476627468, "fo": 0.16666666666666666, "r": 0.20000000000000004, "e": 0.13095283984564057}
{"project_name": "Closure", "project_version": 159, "label": 2, "code": "/**\n * @see #findCalledFunctions(Node)\n */\nprivate void findCalledFunctions(Node node, Set<String> changed) {\n    Preconditions.checkArgument(changed != null);\n    // For each referenced function, add a new reference\n    if (node.getType() == Token.CALL) {\n        Node child = node.getFirstChild();\n        if (child.getType() == Token.NAME) {\n            changed.add(child.getString());\n        }\n    }\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n        findCalledFunctions(c, changed);\n    }\n}", "code_comment": "/**\n * @see #findCalledFunctions(Node)\n */\n", "code_no_comment": "private void findCalledFunctions(Node node, Set<String> changed) {\n    Preconditions.checkArgument(changed != null);\n        if (node.getType() == Token.CALL) {\n        Node child = node.getFirstChild();\n        if (child.getType() == Token.NAME) {\n            changed.add(child.getString());\n        }\n    }\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n        findCalledFunctions(c, changed);\n    }\n}", "lc": -0.09090909090909091, "pi": 0.1938775510204081, "ma": 0.0, "nbd": 0.0, "ml": 0.08333333333333333, "d": 0.004943153732081095, "mi": 0.05047318611987357, "fo": 0.25, "r": 0.6285714285714287, "e": 0.009559664383825661}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "public boolean equals(removeTableProperty_result that) {\n    if (that == null)\n        return false;\n    boolean this_present_ouch1 = true && this.isSetOuch1();\n    boolean that_present_ouch1 = true && that.isSetOuch1();\n    if (this_present_ouch1 || that_present_ouch1) {\n        if (!(this_present_ouch1 && that_present_ouch1))\n            return false;\n        if (!this.ouch1.equals(that.ouch1))\n            return false;\n    }\n    boolean this_present_ouch2 = true && this.isSetOuch2();\n    boolean that_present_ouch2 = true && that.isSetOuch2();\n    if (this_present_ouch2 || that_present_ouch2) {\n        if (!(this_present_ouch2 && that_present_ouch2))\n            return false;\n        if (!this.ouch2.equals(that.ouch2))\n            return false;\n    }\n    return true;\n}", "code_comment": NaN, "code_no_comment": "public boolean equals(removeTableProperty_result that) {\n    if (that == null)\n        return false;\n    boolean this_present_ouch1 = true && this.isSetOuch1();\n    boolean that_present_ouch1 = true && that.isSetOuch1();\n    if (this_present_ouch1 || that_present_ouch1) {\n        if (!(this_present_ouch1 && that_present_ouch1))\n            return false;\n        if (!this.ouch1.equals(that.ouch1))\n            return false;\n    }\n    boolean this_present_ouch2 = true && this.isSetOuch2();\n    boolean that_present_ouch2 = true && that.isSetOuch2();\n    if (this_present_ouch2 || that_present_ouch2) {\n        if (!(this_present_ouch2 && that_present_ouch2))\n            return false;\n        if (!this.ouch2.equals(that.ouch2))\n            return false;\n    }\n    return true;\n}", "lc": 0.3181818181818182, "pi": 0.3061224489795919, "ma": 0.6666666666666666, "nbd": -0.5, "ml": 1.25, "d": 0.726643598615917, "mi": -0.26641812446228874, "fo": 0.0, "r": -0.028571428571428574, "e": 0.4473725913457626}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-139_50e19247", "label": 1, "code": "/**\n * @param host The name of the host to connect to.\n * @param portNum The port to connect to on the target host.\n * @param protocol The Protocol to use.\n * @param delay The interval in which failed writes should be retried.\n * @param immediateFail True if the write should fail if no socket is immediately available.\n * @param name The name of the Appender.\n * @param immediateFlush \"true\" if data should be flushed on each write.\n * @param suppress \"true\" if exceptions should be hidden from the application, \"false\" otherwise.\n * The default is \"true\".\n * @param layout The layout to use (defaults to SerializedLayout).\n * @param filter The Filter or null.\n * @param advertise \"true\" if the appender configuration should be advertised, \"false\" otherwise.\n * @param config The Configuration\n * @return A SocketAppender.\n */\n@PluginFactory\npublic static <S extends Serializable> SocketAppender<S> createAppender(@PluginAttr(\"host\") final String host, @PluginAttr(\"port\") final String portNum, @PluginAttr(\"protocol\") final String protocol, @PluginAttr(\"reconnectionDelay\") final String delay, @PluginAttr(\"immediateFail\") final String immediateFail, @PluginAttr(\"name\") final String name, @PluginAttr(\"immediateFlush\") final String immediateFlush, @PluginAttr(\"suppressExceptions\") final String suppress, @PluginElement(\"layout\") Layout<S> layout, @PluginElement(\"filters\") final Filter filter, @PluginAttr(\"advertise\") final String advertise, @PluginConfiguration final Configuration config) {\n    boolean isFlush = immediateFlush == null ? true : Boolean.valueOf(immediateFlush);\n    boolean isAdvertise = advertise == null ? false : Boolean.valueOf(advertise);\n    final boolean handleExceptions = suppress == null ? true : Boolean.valueOf(suppress);\n    final boolean fail = immediateFail == null ? true : Boolean.valueOf(immediateFail);\n    final int reconnectDelay = delay == null ? 0 : Integer.parseInt(delay);\n    final int port = portNum == null ? 0 : Integer.parseInt(portNum);\n    if (layout == null) {\n        @SuppressWarnings({ \"unchecked\", \"UnnecessaryLocalVariable\" })\n        Layout<S> l = (Layout<S>) SerializedLayout.createLayout();\n        layout = l;\n    }\n    if (name == null) {\n        LOGGER.error(\"No name provided for SocketAppender\");\n        return null;\n    }\n    final String prot = protocol != null ? protocol : Protocol.TCP.name();\n    final Protocol p = EnglishEnums.valueOf(Protocol.class, protocol);\n    if (p.equals(Protocol.UDP)) {\n        isFlush = true;\n    }\n    final AbstractSocketManager manager = createSocketManager(p, host, port, reconnectDelay, fail, layout);\n    if (manager == null) {\n        return null;\n    }\n    return new SocketAppender<S>(name, layout, filter, manager, handleExceptions, isFlush, isAdvertise ? config.getAdvertiser() : null);\n}", "code_comment": "/**\n * @param host The name of the host to connect to.\n * @param portNum The port to connect to on the target host.\n * @param protocol The Protocol to use.\n * @param delay The interval in which failed writes should be retried.\n * @param immediateFail True if the write should fail if no socket is immediately available.\n * @param name The name of the Appender.\n * @param immediateFlush \"true\" if data should be flushed on each write.\n * @param suppress \"true\" if exceptions should be hidden from the application, \"false\" otherwise.\n * The default is \"true\".\n * @param layout The layout to use (defaults to SerializedLayout).\n * @param filter The Filter or null.\n * @param advertise \"true\" if the appender configuration should be advertised, \"false\" otherwise.\n * @param config The Configuration\n * @return A SocketAppender.\n */\n", "code_no_comment": "@PluginFactory\npublic static <S extends Serializable> SocketAppender<S> createAppender(@PluginAttr(\"host\") final String host, @PluginAttr(\"port\") final String portNum, @PluginAttr(\"protocol\") final String protocol, @PluginAttr(\"reconnectionDelay\") final String delay, @PluginAttr(\"immediateFail\") final String immediateFail, @PluginAttr(\"name\") final String name, @PluginAttr(\"immediateFlush\") final String immediateFlush, @PluginAttr(\"suppressExceptions\") final String suppress, @PluginElement(\"layout\") Layout<S> layout, @PluginElement(\"filters\") final Filter filter, @PluginAttr(\"advertise\") final String advertise, @PluginConfiguration final Configuration config) {\n    boolean isFlush = immediateFlush == null ? true : Boolean.valueOf(immediateFlush);\n    boolean isAdvertise = advertise == null ? false : Boolean.valueOf(advertise);\n    final boolean handleExceptions = suppress == null ? true : Boolean.valueOf(suppress);\n    final boolean fail = immediateFail == null ? true : Boolean.valueOf(immediateFail);\n    final int reconnectDelay = delay == null ? 0 : Integer.parseInt(delay);\n    final int port = portNum == null ? 0 : Integer.parseInt(portNum);\n    if (layout == null) {\n        @SuppressWarnings({ \"unchecked\", \"UnnecessaryLocalVariable\" })\n        Layout<S> l = (Layout<S>) SerializedLayout.createLayout();\n        layout = l;\n    }\n    if (name == null) {\n        LOGGER.error(\"No name provided for SocketAppender\");\n        return null;\n    }\n    final String prot = protocol != null ? protocol : Protocol.TCP.name();\n    final Protocol p = EnglishEnums.valueOf(Protocol.class, protocol);\n    if (p.equals(Protocol.UDP)) {\n        isFlush = true;\n    }\n    final AbstractSocketManager manager = createSocketManager(p, host, port, reconnectDelay, fail, layout);\n    if (manager == null) {\n        return null;\n    }\n    return new SocketAppender<S>(name, layout, filter, manager, handleExceptions, isFlush, isAdvertise ? config.getAdvertiser() : null);\n}", "lc": 0.6363636363636364, "pi": -0.35714285714285726, "ma": 1.5, "nbd": -0.5, "ml": 1.5833333333333333, "d": 0.1334651507661889, "mi": -0.6512761686263268, "fo": 0.5833333333333334, "r": -0.028571428571428574, "e": 1.0615210659539749}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2691_d2da7499", "label": 0, "code": "/**\n * Retrieves the {# CLUSTER_ID_PROP}\n *\n * @param store the NodeStore instance\n * @return the repository id\n */\npublic static String getId(NodeStore store) {\n    return store.getRoot().getChildNode(CLUSTER_CONFIG_NODE).getProperty(CLUSTER_ID_PROP).getValue(Type.STRING);\n}", "code_comment": "/**\n * Retrieves the {# CLUSTER_ID_PROP}\n *\n * @param store the NodeStore instance\n * @return the repository id\n */\n", "code_no_comment": "public static String getId(NodeStore store) {\n    return store.getRoot().getChildNode(CLUSTER_CONFIG_NODE).getProperty(CLUSTER_ID_PROP).getValue(Type.STRING);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9217092056208774, "fo": -0.16666666666666666, "r": 2.8000000000000003, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-9641_9a6e6d8a", "label": 1, "code": "private Expression createSimpleExpression(String function, boolean strict) {\n    // return the function directly if we can create function without analyzing the prefix\n    Expression answer = createSimpleExpressionDirectly(function);\n    if (answer != null) {\n        return answer;\n    }\n    // body and headers first\n    answer = createSimpleExpressionBodyOrHeader(function, strict);\n    if (answer != null) {\n        return answer;\n    }\n    // camelContext OGNL\n    String remainder = ifStartsWithReturnRemainder(\"camelContext\", function);\n    if (remainder != null) {\n        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);\n        if (invalid) {\n            throw new SimpleParserException(\"Valid syntax: ${camelContext.OGNL} was: \" + function, token.getIndex());\n        }\n        return ExpressionBuilder.camelContextOgnlExpression(remainder);\n    }\n    // Exception OGNL\n    remainder = ifStartsWithReturnRemainder(\"exception\", function);\n    if (remainder != null) {\n        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);\n        if (invalid) {\n            throw new SimpleParserException(\"Valid syntax: ${exception.OGNL} was: \" + function, token.getIndex());\n        }\n        return ExpressionBuilder.exchangeExceptionOgnlExpression(remainder);\n    }\n    // property\n    remainder = ifStartsWithReturnRemainder(\"property\", function);\n    if (remainder == null) {\n        remainder = ifStartsWithReturnRemainder(\"exchangeProperty\", function);\n    }\n    if (remainder != null) {\n        // remove leading character (dot or ?)\n        if (remainder.startsWith(\".\") || remainder.startsWith(\"?\")) {\n            remainder = remainder.substring(1);\n        }\n        // remove starting and ending brackets\n        if (remainder.startsWith(\"[\") && remainder.endsWith(\"]\")) {\n            remainder = remainder.substring(1, remainder.length() - 1);\n        }\n        // validate syntax\n        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);\n        if (invalid) {\n            throw new SimpleParserException(\"Valid syntax: ${exchangeProperty.OGNL} was: \" + function, token.getIndex());\n        }\n        if (OgnlHelper.isValidOgnlExpression(remainder)) {\n            // ognl based property\n            return ExpressionBuilder.propertyOgnlExpression(remainder);\n        } else {\n            // regular property\n            return ExpressionBuilder.exchangePropertyExpression(remainder);\n        }\n    }\n    // system property\n    remainder = ifStartsWithReturnRemainder(\"sys.\", function);\n    if (remainder != null) {\n        return ExpressionBuilder.systemPropertyExpression(remainder);\n    }\n    remainder = ifStartsWithReturnRemainder(\"sysenv.\", function);\n    if (remainder != null) {\n        return ExpressionBuilder.systemEnvironmentExpression(remainder);\n    }\n    // exchange OGNL\n    remainder = ifStartsWithReturnRemainder(\"exchange\", function);\n    if (remainder != null) {\n        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);\n        if (invalid) {\n            throw new SimpleParserException(\"Valid syntax: ${exchange.OGNL} was: \" + function, token.getIndex());\n        }\n        return ExpressionBuilder.exchangeOgnlExpression(remainder);\n    }\n    // file: prefix\n    remainder = ifStartsWithReturnRemainder(\"file:\", function);\n    if (remainder != null) {\n        Expression fileExpression = createSimpleFileExpression(remainder);\n        if (function != null) {\n            return fileExpression;\n        }\n    }\n    // date: prefix\n    remainder = ifStartsWithReturnRemainder(\"date:\", function);\n    if (remainder != null) {\n        String[] parts = remainder.split(\":\");\n        if (parts.length < 2) {\n            throw new SimpleParserException(\"Valid syntax: ${date:command:pattern} was: \" + function, token.getIndex());\n        }\n        String command = ObjectHelper.before(remainder, \":\");\n        String pattern = ObjectHelper.after(remainder, \":\");\n        return ExpressionBuilder.dateExpression(command, pattern);\n    }\n    // bean: prefix\n    remainder = ifStartsWithReturnRemainder(\"bean:\", function);\n    if (remainder != null) {\n        return ExpressionBuilder.beanExpression(remainder);\n    }\n    // properties: prefix\n    remainder = ifStartsWithReturnRemainder(\"properties:\", function);\n    if (remainder != null) {\n        String[] parts = remainder.split(\":\");\n        if (parts.length > 2) {\n            throw new SimpleParserException(\"Valid syntax: ${properties:key[:default]} was: \" + function, token.getIndex());\n        }\n        return ExpressionBuilder.propertiesComponentExpression(remainder, null);\n    }\n    // properties-location: prefix\n    remainder = ifStartsWithReturnRemainder(\"properties-location:\", function);\n    if (remainder != null) {\n        String[] parts = remainder.split(\":\");\n        if (parts.length > 3) {\n            throw new SimpleParserException(\"Valid syntax: ${properties-location:location:key[:default]} was: \" + function, token.getIndex());\n        }\n        String locations = null;\n        String key = remainder;\n        if (parts.length >= 2) {\n            locations = ObjectHelper.before(remainder, \":\");\n            key = ObjectHelper.after(remainder, \":\");\n        }\n        return ExpressionBuilder.propertiesComponentExpression(key, locations);\n    }\n    // ref: prefix\n    remainder = ifStartsWithReturnRemainder(\"ref:\", function);\n    if (remainder != null) {\n        return ExpressionBuilder.refExpression(remainder);\n    }\n    // const: prefix\n    remainder = ifStartsWithReturnRemainder(\"type:\", function);\n    if (remainder != null) {\n        Expression exp = ExpressionBuilder.typeExpression(remainder);\n        // we want to cache this expression so we wont re-evaluate it as the type/constant wont change\n        return ExpressionBuilder.cacheExpression(exp);\n    }\n    // random\n    remainder = ifStartsWithReturnRemainder(\"random\", function);\n    if (remainder != null) {\n        String values = ObjectHelper.between(remainder, \"(\", \")\");\n        if (values == null || ObjectHelper.isEmpty(values)) {\n            throw new SimpleParserException(\"Valid syntax: ${random(min,max)} or ${random(max)} was: \" + function, token.getIndex());\n        }\n        if (values.contains(\",\")) {\n            String[] tokens = values.split(\",\", -1);\n            if (tokens.length > 2) {\n                throw new SimpleParserException(\"Valid syntax: ${random(min,max)} or ${random(max)} was: \" + function, token.getIndex());\n            }\n            int min = Integer.parseInt(tokens[0].trim());\n            int max = Integer.parseInt(tokens[1].trim());\n            return ExpressionBuilder.randomExpression(min, max);\n        } else {\n            int max = Integer.parseInt(values.trim());\n            return ExpressionBuilder.randomExpression(max);\n        }\n    }\n    // collate function\n    remainder = ifStartsWithReturnRemainder(\"collate\", function);\n    if (remainder != null) {\n        String values = ObjectHelper.between(remainder, \"(\", \")\");\n        if (values == null || ObjectHelper.isEmpty(values)) {\n            throw new SimpleParserException(\"Valid syntax: ${collate(group)} was: \" + function, token.getIndex());\n        }\n        String exp = \"${body}\";\n        int num = Integer.parseInt(values.trim());\n        return ExpressionBuilder.collateExpression(exp, num);\n    }\n    if (strict) {\n        throw new SimpleParserException(\"Unknown function: \" + function, token.getIndex());\n    } else {\n        return null;\n    }\n}", "code_comment": NaN, "code_no_comment": "private Expression createSimpleExpression(String function, boolean strict) {\n        Expression answer = createSimpleExpressionDirectly(function);\n    if (answer != null) {\n        return answer;\n    }\n        answer = createSimpleExpressionBodyOrHeader(function, strict);\n    if (answer != null) {\n        return answer;\n    }\n        String remainder = ifStartsWithReturnRemainder(\"camelContext\", function);\n    if (remainder != null) {\n        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);\n        if (invalid) {\n            throw new SimpleParserException(\"Valid syntax: ${camelContext.OGNL} was: \" + function, token.getIndex());\n        }\n        return ExpressionBuilder.camelContextOgnlExpression(remainder);\n    }\n        remainder = ifStartsWithReturnRemainder(\"exception\", function);\n    if (remainder != null) {\n        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);\n        if (invalid) {\n            throw new SimpleParserException(\"Valid syntax: ${exception.OGNL} was: \" + function, token.getIndex());\n        }\n        return ExpressionBuilder.exchangeExceptionOgnlExpression(remainder);\n    }\n        remainder = ifStartsWithReturnRemainder(\"property\", function);\n    if (remainder == null) {\n        remainder = ifStartsWithReturnRemainder(\"exchangeProperty\", function);\n    }\n    if (remainder != null) {\n                if (remainder.startsWith(\".\") || remainder.startsWith(\"?\")) {\n            remainder = remainder.substring(1);\n        }\n                if (remainder.startsWith(\"[\") && remainder.endsWith(\"]\")) {\n            remainder = remainder.substring(1, remainder.length() - 1);\n        }\n                boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);\n        if (invalid) {\n            throw new SimpleParserException(\"Valid syntax: ${exchangeProperty.OGNL} was: \" + function, token.getIndex());\n        }\n        if (OgnlHelper.isValidOgnlExpression(remainder)) {\n                        return ExpressionBuilder.propertyOgnlExpression(remainder);\n        } else {\n                        return ExpressionBuilder.exchangePropertyExpression(remainder);\n        }\n    }\n        remainder = ifStartsWithReturnRemainder(\"sys.\", function);\n    if (remainder != null) {\n        return ExpressionBuilder.systemPropertyExpression(remainder);\n    }\n    remainder = ifStartsWithReturnRemainder(\"sysenv.\", function);\n    if (remainder != null) {\n        return ExpressionBuilder.systemEnvironmentExpression(remainder);\n    }\n        remainder = ifStartsWithReturnRemainder(\"exchange\", function);\n    if (remainder != null) {\n        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);\n        if (invalid) {\n            throw new SimpleParserException(\"Valid syntax: ${exchange.OGNL} was: \" + function, token.getIndex());\n        }\n        return ExpressionBuilder.exchangeOgnlExpression(remainder);\n    }\n        remainder = ifStartsWithReturnRemainder(\"file:\", function);\n    if (remainder != null) {\n        Expression fileExpression = createSimpleFileExpression(remainder);\n        if (function != null) {\n            return fileExpression;\n        }\n    }\n        remainder = ifStartsWithReturnRemainder(\"date:\", function);\n    if (remainder != null) {\n        String[] parts = remainder.split(\":\");\n        if (parts.length < 2) {\n            throw new SimpleParserException(\"Valid syntax: ${date:command:pattern} was: \" + function, token.getIndex());\n        }\n        String command = ObjectHelper.before(remainder, \":\");\n        String pattern = ObjectHelper.after(remainder, \":\");\n        return ExpressionBuilder.dateExpression(command, pattern);\n    }\n        remainder = ifStartsWithReturnRemainder(\"bean:\", function);\n    if (remainder != null) {\n        return ExpressionBuilder.beanExpression(remainder);\n    }\n        remainder = ifStartsWithReturnRemainder(\"properties:\", function);\n    if (remainder != null) {\n        String[] parts = remainder.split(\":\");\n        if (parts.length > 2) {\n            throw new SimpleParserException(\"Valid syntax: ${properties:key[:default]} was: \" + function, token.getIndex());\n        }\n        return ExpressionBuilder.propertiesComponentExpression(remainder, null);\n    }\n        remainder = ifStartsWithReturnRemainder(\"properties-location:\", function);\n    if (remainder != null) {\n        String[] parts = remainder.split(\":\");\n        if (parts.length > 3) {\n            throw new SimpleParserException(\"Valid syntax: ${properties-location:location:key[:default]} was: \" + function, token.getIndex());\n        }\n        String locations = null;\n        String key = remainder;\n        if (parts.length >= 2) {\n            locations = ObjectHelper.before(remainder, \":\");\n            key = ObjectHelper.after(remainder, \":\");\n        }\n        return ExpressionBuilder.propertiesComponentExpression(key, locations);\n    }\n        remainder = ifStartsWithReturnRemainder(\"ref:\", function);\n    if (remainder != null) {\n        return ExpressionBuilder.refExpression(remainder);\n    }\n        remainder = ifStartsWithReturnRemainder(\"type:\", function);\n    if (remainder != null) {\n        Expression exp = ExpressionBuilder.typeExpression(remainder);\n                return ExpressionBuilder.cacheExpression(exp);\n    }\n        remainder = ifStartsWithReturnRemainder(\"random\", function);\n    if (remainder != null) {\n        String values = ObjectHelper.between(remainder, \"(\", \")\");\n        if (values == null || ObjectHelper.isEmpty(values)) {\n            throw new SimpleParserException(\"Valid syntax: ${random(min,max)} or ${random(max)} was: \" + function, token.getIndex());\n        }\n        if (values.contains(\",\")) {\n            String[] tokens = values.split(\",\", -1);\n            if (tokens.length > 2) {\n                throw new SimpleParserException(\"Valid syntax: ${random(min,max)} or ${random(max)} was: \" + function, token.getIndex());\n            }\n            int min = Integer.parseInt(tokens[0].trim());\n            int max = Integer.parseInt(tokens[1].trim());\n            return ExpressionBuilder.randomExpression(min, max);\n        } else {\n            int max = Integer.parseInt(values.trim());\n            return ExpressionBuilder.randomExpression(max);\n        }\n    }\n        remainder = ifStartsWithReturnRemainder(\"collate\", function);\n    if (remainder != null) {\n        String values = ObjectHelper.between(remainder, \"(\", \")\");\n        if (values == null || ObjectHelper.isEmpty(values)) {\n            throw new SimpleParserException(\"Valid syntax: ${collate(group)} was: \" + function, token.getIndex());\n        }\n        String exp = \"${body}\";\n        int num = Integer.parseInt(values.trim());\n        return ExpressionBuilder.collateExpression(exp, num);\n    }\n    if (strict) {\n        throw new SimpleParserException(\"Unknown function: \" + function, token.getIndex());\n    } else {\n        return null;\n    }\n}", "lc": 6.136363636363637, "pi": -0.005102040816326648, "ma": 7.166666666666667, "nbd": 0.5, "ml": 4.083333333333333, "d": 3.5442412259021263, "mi": -1.8161743619156876, "fo": 6.166666666666667, "r": -0.028571428571428574, "e": 27.969192353981693}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1822_016df669", "label": 1, "code": "/**\n * Increment the value.\n *\n * @param property the key\n * @param value the increment\n */\npublic void increment(@Nonnull String property, long value) {\n    Operation op = new Operation();\n    op.type = Operation.Type.INCREMENT;\n    op.value = value;\n    changes.put(new Key(property, null), op);\n}", "code_comment": "/**\n * Increment the value.\n *\n * @param property the key\n * @param value the increment\n */\n", "code_no_comment": "public void increment(@Nonnull String property, long value) {\n    Operation op = new Operation();\n    op.type = Operation.Type.INCREMENT;\n    op.value = value;\n    changes.put(new Key(property, null), op);\n}", "lc": -0.36363636363636365, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.4955549182678522, "fo": -0.4166666666666667, "r": 2.2285714285714286, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8954_7b1253db", "label": 3, "code": "/**\n * Creates a copy based on the source\n *\n * @param source the source\n * @return a copy of the source\n */\n@SuppressWarnings(\"unchecked\")\npublic GenericFile<T> copyFrom(GenericFile<T> source) {\n    GenericFile<T> result;\n    try {\n        result = source.getClass().newInstance();\n    } catch (Exception e) {\n        throw ObjectHelper.wrapRuntimeCamelException(e);\n    }\n    result.setEndpointPath(source.getEndpointPath());\n    result.setAbsolute(source.isAbsolute());\n    result.setDirectory(source.isDirectory());\n    result.setAbsoluteFilePath(source.getAbsoluteFilePath());\n    result.setRelativeFilePath(source.getRelativeFilePath());\n    result.setFileName(source.getFileName());\n    result.setFileNameOnly(source.getFileNameOnly());\n    result.setFileLength(source.getFileLength());\n    result.setLastModified(source.getLastModified());\n    result.setFile(source.getFile());\n    result.setBody(source.getBody());\n    result.setBinding(source.getBinding());\n    result.setCharset(source.getCharset());\n    copyFromPopulateAdditional(source, result);\n    return result;\n}", "code_comment": "/**\n * Creates a copy based on the source\n *\n * @param source the source\n * @return a copy of the source\n */\n", "code_no_comment": "@SuppressWarnings(\"unchecked\")\npublic GenericFile<T> copyFrom(GenericFile<T> source) {\n    GenericFile<T> result;\n    try {\n        result = source.getClass().newInstance();\n    } catch (Exception e) {\n        throw ObjectHelper.wrapRuntimeCamelException(e);\n    }\n    result.setEndpointPath(source.getEndpointPath());\n    result.setAbsolute(source.isAbsolute());\n    result.setDirectory(source.isDirectory());\n    result.setAbsoluteFilePath(source.getAbsoluteFilePath());\n    result.setRelativeFilePath(source.getRelativeFilePath());\n    result.setFileName(source.getFileName());\n    result.setFileNameOnly(source.getFileNameOnly());\n    result.setFileLength(source.getFileLength());\n    result.setLastModified(source.getLastModified());\n    result.setFile(source.getFile());\n    result.setBody(source.getBody());\n    result.setBinding(source.getBinding());\n    result.setCharset(source.getCharset());\n    copyFromPopulateAdditional(source, result);\n    return result;\n}", "lc": 0.45454545454545453, "pi": -0.6122448979591837, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": -0.3699455119013481, "fo": 2.0, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-4138_50db442b", "label": 1, "code": "@Override\npublic Options getOptions() {\n    final Options o = new Options();\n    verboseOpt = new Option(\"v\", \"verbose\", false, \"verbose output during merge\");\n    sizeOpt = new Option(\"s\", \"size\", true, \"merge tablets to the given size over the entire table\");\n    forceOpt = new Option(\"f\", \"force\", false, \"merge small tablets to large tablets, even if it goes over the given size\");\n    allOpt = new Option(\"\", \"all\", false, \"allow an entire table to be merged into one tablet without prompting the user for confirmation\");\n    Option startRowOpt = OptUtil.startRowOpt();\n    startRowOpt.setDescription(\"begin row (NOT inclusive)\");\n    o.addOption(startRowOpt);\n    o.addOption(OptUtil.endRowOpt());\n    o.addOption(OptUtil.tableOpt(\"table to be merged\"));\n    o.addOption(verboseOpt);\n    o.addOption(sizeOpt);\n    o.addOption(forceOpt);\n    o.addOption(allOpt);\n    return o;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Options getOptions() {\n    final Options o = new Options();\n    verboseOpt = new Option(\"v\", \"verbose\", false, \"verbose output during merge\");\n    sizeOpt = new Option(\"s\", \"size\", true, \"merge tablets to the given size over the entire table\");\n    forceOpt = new Option(\"f\", \"force\", false, \"merge small tablets to large tablets, even if it goes over the given size\");\n    allOpt = new Option(\"\", \"all\", false, \"allow an entire table to be merged into one tablet without prompting the user for confirmation\");\n    Option startRowOpt = OptUtil.startRowOpt();\n    startRowOpt.setDescription(\"begin row (NOT inclusive)\");\n    o.addOption(startRowOpt);\n    o.addOption(OptUtil.endRowOpt());\n    o.addOption(OptUtil.tableOpt(\"table to be merged\"));\n    o.addOption(verboseOpt);\n    o.addOption(sizeOpt);\n    o.addOption(forceOpt);\n    o.addOption(allOpt);\n    return o;\n}", "lc": 0.18181818181818182, "pi": -0.7806122448979592, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": -0.19501003728133062, "fo": 0.4166666666666667, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3448_b345dd82", "label": 0, "code": "public static ExceptionPolicyKey newInstance(Class exceptionClass) {\n    return new ExceptionPolicyKey(exceptionClass, null);\n}", "code_comment": NaN, "code_no_comment": "public static ExceptionPolicyKey newInstance(Class exceptionClass) {\n    return new ExceptionPolicyKey(exceptionClass, null);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.0585030111843994, "fo": -0.5, "r": 1.2, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7167_1e33fcbc", "label": 3, "code": "/**\n * Common work which must be done when we are done multicasting.\n * <p/>\n * This logic applies for both running synchronous and asynchronous as there are multiple exist points\n * when using the asynchronous routing engine. And therefore we want the logic in one method instead\n * of being scattered.\n *\n * @param original     the original exchange\n * @param subExchange  the current sub exchange, can be <tt>null</tt> for the synchronous part\n * @param pairs        the pairs with the exchanges to process\n * @param callback     the callback\n * @param doneSync     the <tt>doneSync</tt> parameter to call on callback\n * @param forceExhaust whether or not error handling is exhausted\n */\nprotected void doDone(Exchange original, Exchange subExchange, final Iterable<ProcessorExchangePair> pairs, AsyncCallback callback, boolean doneSync, boolean forceExhaust) {\n    // we are done so close the pairs iterator\n    if (pairs != null && pairs instanceof Closeable) {\n        IOHelper.close((Closeable) pairs, \"pairs\", LOG);\n    }\n    // cleanup any per exchange aggregation strategy\n    removeAggregationStrategyFromExchange(original);\n    // we need to know if there was an exception, and if the stopOnException option was enabled\n    // also we would need to know if any error handler has attempted redelivery and exhausted\n    boolean stoppedOnException = false;\n    boolean exception = false;\n    boolean exhaust = forceExhaust || subExchange != null && (subExchange.getException() != null || ExchangeHelper.isRedeliveryExhausted(subExchange));\n    if (original.getException() != null || subExchange != null && subExchange.getException() != null) {\n        // there was an exception and we stopped\n        stoppedOnException = isStopOnException();\n        exception = true;\n    }\n    // must copy results at this point\n    if (subExchange != null) {\n        if (stoppedOnException) {\n            // if we stopped due an exception then only propagte the exception\n            original.setException(subExchange.getException());\n        } else {\n            // copy the current result to original so it will contain this result of this eip\n            ExchangeHelper.copyResults(original, subExchange);\n        }\n    }\n    // handled has been in use, then the exhaust would be false (if not forced)\n    if (exception) {\n        // multicast uses error handling on its output processors and they have tried to redeliver\n        // so we shall signal back to the other error handlers that we are exhausted and they should not\n        // also try to redeliver as we will then do that twice\n        original.setProperty(Exchange.REDELIVERY_EXHAUSTED, exhaust);\n    }\n    callback.done(doneSync);\n}", "code_comment": "/**\n * Common work which must be done when we are done multicasting.\n * <p/>\n * This logic applies for both running synchronous and asynchronous as there are multiple exist points\n * when using the asynchronous routing engine. And therefore we want the logic in one method instead\n * of being scattered.\n *\n * @param original     the original exchange\n * @param subExchange  the current sub exchange, can be <tt>null</tt> for the synchronous part\n * @param pairs        the pairs with the exchanges to process\n * @param callback     the callback\n * @param doneSync     the <tt>doneSync</tt> parameter to call on callback\n * @param forceExhaust whether or not error handling is exhausted\n */\n", "code_no_comment": "protected void doDone(Exchange original, Exchange subExchange, final Iterable<ProcessorExchangePair> pairs, AsyncCallback callback, boolean doneSync, boolean forceExhaust) {\n        if (pairs != null && pairs instanceof Closeable) {\n        IOHelper.close((Closeable) pairs, \"pairs\", LOG);\n    }\n        removeAggregationStrategyFromExchange(original);\n            boolean stoppedOnException = false;\n    boolean exception = false;\n    boolean exhaust = forceExhaust || subExchange != null && (subExchange.getException() != null || ExchangeHelper.isRedeliveryExhausted(subExchange));\n    if (original.getException() != null || subExchange != null && subExchange.getException() != null) {\n                stoppedOnException = isStopOnException();\n        exception = true;\n    }\n        if (subExchange != null) {\n        if (stoppedOnException) {\n                        original.setException(subExchange.getException());\n        } else {\n                        ExchangeHelper.copyResults(original, subExchange);\n        }\n    }\n        if (exception) {\n                                original.setProperty(Exchange.REDELIVERY_EXHAUSTED, exhaust);\n    }\n    callback.done(doneSync);\n}", "lc": 0.45454545454545453, "pi": -0.005102040816326648, "ma": 0.3333333333333333, "nbd": 0.0, "ml": 0.75, "d": 0.4972812654473556, "mi": -0.40321193002581035, "fo": 0.5, "r": -0.028571428571428574, "e": 0.7102762109122369}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1363_69b68890", "label": 0, "code": "/**\n * Create the {@code AuthInfo} for the specified {@code tokenInfo} as well as\n * userId and principals, that have been set upon {@link #login}.\n *\n * @param tokenInfo The tokenInfo to retrieve attributes from.\n * @return The {@code AuthInfo} resulting from the successful login.\n */\n@Nonnull\nprivate AuthInfo getAuthInfo(TokenInfo tokenInfo) {\n    Map<String, Object> attributes = new HashMap<String, Object>();\n    if (tokenProvider != null && tokenInfo != null) {\n        Map<String, String> publicAttributes = tokenInfo.getPublicAttributes();\n        for (String attrName : publicAttributes.keySet()) {\n            attributes.put(attrName, publicAttributes.get(attrName));\n        }\n    }\n    return new AuthInfoImpl(userId, attributes, principals);\n}", "code_comment": "/**\n * Create the {@code AuthInfo} for the specified {@code tokenInfo} as well as\n * userId and principals, that have been set upon {@link #login}.\n *\n * @param tokenInfo The tokenInfo to retrieve attributes from.\n * @return The {@code AuthInfo} resulting from the successful login.\n */\n", "code_no_comment": "@Nonnull\nprivate AuthInfo getAuthInfo(TokenInfo tokenInfo) {\n    Map<String, Object> attributes = new HashMap<String, Object>();\n    if (tokenProvider != null && tokenInfo != null) {\n        Map<String, String> publicAttributes = tokenInfo.getPublicAttributes();\n        for (String attrName : publicAttributes.keySet()) {\n            attributes.put(attrName, publicAttributes.get(attrName));\n        }\n    }\n    return new AuthInfoImpl(userId, attributes, principals);\n}", "lc": -0.13636363636363635, "pi": 0.36734693877551033, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.04844290657439445, "mi": 0.10696874103814182, "fo": -0.16666666666666666, "r": 0.05714285714285714, "e": -0.023732123813072596}
{"project_name": "Math", "project_version": 103, "label": 3, "code": "/**\n * For this disbution, X, this method returns P(X &lt; <code>x</code>).\n * @param x the value at which the CDF is evaluated.\n * @return CDF evaluted at <code>x</code>.\n * @throws MathException if the algorithm fails to converge; unless\n * x is more than 20 standard deviations from the mean, in which case the\n * convergence exception is caught and 0 or 1 is returned.\n */\npublic double cumulativeProbability(double x) throws MathException {\n    return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0))));\n}", "code_comment": "/**\n * For this disbution, X, this method returns P(X &lt; <code>x</code>).\n * @param x the value at which the CDF is evaluated.\n * @return CDF evaluted at <code>x</code>.\n * @throws MathException if the algorithm fails to converge; unless\n * x is more than 20 standard deviations from the mean, in which case the\n * convergence exception is caught and 0 or 1 is returned.\n */\n", "code_no_comment": "public double cumulativeProbability(double x) throws MathException {\n    return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0))));\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": 0.044488383588729634, "mi": 0.8611987381703473, "fo": -0.3333333333333333, "r": 0.6, "e": -0.09258569219765206}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4927_8c827e33", "label": 1, "code": "@Override\npublic void setContentType(String mimeType) {\n    checkHeader();\n    bufferedResponse.setContentType(mimeType);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void setContentType(String mimeType) {\n    checkHeader();\n    bufferedResponse.setContentType(mimeType);\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7912245483223405, "fo": -0.3333333333333333, "r": 1.342857142857143, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3428_ffc0cae9", "label": 1, "code": "/**\n *  Processes the request.\n *\n *  @return <code>true</code> if the request resolved to a Wicket request, <code>false</code>\n *          otherwise.\n */\npublic boolean processRequest() {\n    try {\n        set(this);\n        IRequestHandler handler = resolveRequestHandler();\n        if (handler != null) {\n            executeRequestHandler(handler);\n            return true;\n        }\n        // Did not find any suitable handler, thus not executing the request\n        log.debug(\"No suitable handler found for URL {}, falling back to container to process this request\", request.getUrl());\n    } catch (Exception e) {\n        IRequestHandler handler = handleException(e);\n        if (handler != null) {\n            executeExceptionRequestHandler(handler, getExceptionRetryCount());\n        } else {\n            log.error(\"Error during request processing. URL=\" + request.getUrl(), e);\n        }\n        return true;\n    } finally {\n        set(null);\n    }\n    return false;\n}", "code_comment": "/**\n *  Processes the request.\n *\n *  @return <code>true</code> if the request resolved to a Wicket request, <code>false</code>\n *          otherwise.\n */\n", "code_no_comment": "public boolean processRequest() {\n    try {\n        set(this);\n        IRequestHandler handler = resolveRequestHandler();\n        if (handler != null) {\n            executeRequestHandler(handler);\n            return true;\n        }\n                log.debug(\"No suitable handler found for URL {}, falling back to container to process this request\", request.getUrl());\n    } catch (Exception e) {\n        IRequestHandler handler = handleException(e);\n        if (handler != null) {\n            executeExceptionRequestHandler(handler, getExceptionRetryCount());\n        } else {\n            log.error(\"Error during request processing. URL=\" + request.getUrl(), e);\n        }\n        return true;\n    } finally {\n        set(null);\n    }\n    return false;\n}", "lc": 0.36363636363636365, "pi": 0.1938775510204081, "ma": 0.0, "nbd": 0.0, "ml": -0.16666666666666666, "d": -0.04844290657439445, "mi": -0.2216805276742187, "fo": 0.4166666666666667, "r": -0.028571428571428574, "e": -0.023732123813072596}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3260_6968a57a", "label": 0, "code": "public void cancel() {\n    // successful atomic state transition\n    while (true) {\n        ExecutionState current = this.state;\n        if (current == CANCELING || current == CANCELED) {\n            // already taken care of, no need to cancel again\n            return;\n        } else // these two are the common cases where we need to send a cancel call\n        if (current == RUNNING || current == DEPLOYING) {\n            // try to transition to canceling, if successful, send the cancel call\n            if (transitionState(current, CANCELING)) {\n                sendCancelRpcCall();\n                return;\n            }\n        // else: fall through the loop\n        } else if (current == FINISHED || current == FAILED) {\n            // nothing to do any more. finished failed before it could be cancelled.\n            // in any case, the task is removed from the TaskManager already\n            sendFailIntermediateResultPartitionsRpcCall();\n            return;\n        } else if (current == CREATED || current == SCHEDULED) {\n            // from here, we can directly switch to cancelled, because the no task has been deployed\n            if (transitionState(current, CANCELED)) {\n                // we skip the canceling state. set the timestamp, for a consistent appearance\n                markTimestamp(CANCELING, getStateTimestamp(CANCELED));\n                try {\n                    vertex.getExecutionGraph().deregisterExecution(this);\n                    if (assignedResource != null) {\n                        assignedResource.releaseSlot();\n                    }\n                } finally {\n                    vertex.executionCanceled();\n                }\n                return;\n            }\n        // else: fall through the loop\n        } else {\n            throw new IllegalStateException(current.name());\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "public void cancel() {\n        while (true) {\n        ExecutionState current = this.state;\n        if (current == CANCELING || current == CANCELED) {\n                        return;\n        } else         if (current == RUNNING || current == DEPLOYING) {\n                        if (transitionState(current, CANCELING)) {\n                sendCancelRpcCall();\n                return;\n            }\n                } else if (current == FINISHED || current == FAILED) {\n                                    sendFailIntermediateResultPartitionsRpcCall();\n            return;\n        } else if (current == CREATED || current == SCHEDULED) {\n                        if (transitionState(current, CANCELED)) {\n                                markTimestamp(CANCELING, getStateTimestamp(CANCELED));\n                try {\n                    vertex.getExecutionGraph().deregisterExecution(this);\n                    if (assignedResource != null) {\n                        assignedResource.releaseSlot();\n                    }\n                } finally {\n                    vertex.executionCanceled();\n                }\n                return;\n            }\n                } else {\n            throw new IllegalStateException(current.name());\n        }\n    }\n}", "lc": 0.8181818181818182, "pi": 1.3877551020408165, "ma": 1.0, "nbd": 3.0, "ml": 0.9166666666666666, "d": 0.2698961937716264, "mi": -0.4992830513335246, "fo": 0.4166666666666667, "r": -0.028571428571428574, "e": 0.25795246722431375}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5656_f539c18c", "label": 1, "code": "boolean isRequired() {\n    List<NotNull> constraints = findNotNullConstraints();\n    if (constraints.isEmpty()) {\n        return false;\n    }\n    HashSet<Class<?>> validatorGroups = new HashSet<Class<?>>();\n    validatorGroups.addAll(Arrays.asList(getGroups()));\n    for (NotNull constraint : constraints) {\n        if (constraint.groups().length == 0 && validatorGroups.isEmpty()) {\n            return true;\n        }\n        for (Class<?> constraintGroup : constraint.groups()) {\n            if (validatorGroups.contains(constraintGroup)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "code_comment": NaN, "code_no_comment": "boolean isRequired() {\n    List<NotNull> constraints = findNotNullConstraints();\n    if (constraints.isEmpty()) {\n        return false;\n    }\n    HashSet<Class<?>> validatorGroups = new HashSet<Class<?>>();\n    validatorGroups.addAll(Arrays.asList(getGroups()));\n    for (NotNull constraint : constraints) {\n        if (constraint.groups().length == 0 && validatorGroups.isEmpty()) {\n            return true;\n        }\n        for (Class<?> constraintGroup : constraint.groups()) {\n            if (validatorGroups.contains(constraintGroup)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "lc": 0.22727272727272727, "pi": 0.5765306122448981, "ma": 0.3333333333333333, "nbd": 0.5, "ml": 0.3333333333333333, "d": -0.0385565991102323, "mi": -0.16661887008890175, "fo": 0.25, "r": 0.028571428571428574, "e": -0.019937382485084445}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1025_a96b455c", "label": 1, "code": "@Override\npublic Level toLevel(final java.util.logging.Level javaLevel) {\n    return julToLog4j.get(javaLevel);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Level toLevel(final java.util.logging.Level javaLevel) {\n    return julToLog4j.get(javaLevel);\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8270719816461145, "fo": -0.4166666666666667, "r": 0.39999999999999997, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-612_df9e6913", "label": 1, "code": "@Override\npublic Node perform() throws RepositoryException {\n    String oakPath = sessionDelegate.getOakPathKeepIndexOrThrowNotFound(relPath);\n    String oakName = PathUtils.getName(oakPath);\n    String parentPath = sessionDelegate.getOakPath(PathUtils.getParentPath(oakPath));\n    // handle index\n    if (oakName.contains(\"[\")) {\n        throw new RepositoryException(\"Cannot create a new node using a name including an index\");\n    }\n    NodeDelegate parent = dlg.getChild(parentPath);\n    if (parent == null) {\n        // is it a property?\n        String grandParentPath = PathUtils.getParentPath(parentPath);\n        NodeDelegate grandParent = dlg.getChild(grandParentPath);\n        if (grandParent != null) {\n            String propName = PathUtils.getName(parentPath);\n            if (grandParent.getProperty(propName) != null) {\n                throw new ConstraintViolationException(\"Can't add new node to property.\");\n            }\n        }\n        throw new PathNotFoundException(relPath);\n    }\n    if (parent.getChild(oakName) != null) {\n        throw new ItemExistsException(relPath);\n    }\n    String ntName = primaryNodeTypeName;\n    if (ntName == null) {\n        DefinitionProvider dp = sessionDelegate.getDefinitionProvider();\n        try {\n            String childName = sessionDelegate.getOakName(PathUtils.getName(relPath));\n            NodeDefinition def = dp.getDefinition(new NodeImpl<NodeDelegate>(parent), childName);\n            ntName = def.getDefaultPrimaryTypeName();\n        } catch (RepositoryException e) {\n            throw new ConstraintViolationException(\"no matching child node definition found for \" + relPath);\n        }\n    }\n    // TODO: figure out the right place for this check\n    NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();\n    // throws on not found\n    NodeType nt = ntm.getNodeType(ntName);\n    if (nt.isAbstract() || nt.isMixin()) {\n        throw new ConstraintViolationException();\n    }\n    // TODO: END\n    NodeDelegate added = parent.addChild(oakName);\n    if (added == null) {\n        throw new ItemExistsException();\n    }\n    NodeImpl<?> childNode = new NodeImpl<NodeDelegate>(added);\n    childNode.internalSetPrimaryType(ntName);\n    childNode.autoCreateItems();\n    return childNode;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Node perform() throws RepositoryException {\n    String oakPath = sessionDelegate.getOakPathKeepIndexOrThrowNotFound(relPath);\n    String oakName = PathUtils.getName(oakPath);\n    String parentPath = sessionDelegate.getOakPath(PathUtils.getParentPath(oakPath));\n        if (oakName.contains(\"[\")) {\n        throw new RepositoryException(\"Cannot create a new node using a name including an index\");\n    }\n    NodeDelegate parent = dlg.getChild(parentPath);\n    if (parent == null) {\n                String grandParentPath = PathUtils.getParentPath(parentPath);\n        NodeDelegate grandParent = dlg.getChild(grandParentPath);\n        if (grandParent != null) {\n            String propName = PathUtils.getName(parentPath);\n            if (grandParent.getProperty(propName) != null) {\n                throw new ConstraintViolationException(\"Can't add new node to property.\");\n            }\n        }\n        throw new PathNotFoundException(relPath);\n    }\n    if (parent.getChild(oakName) != null) {\n        throw new ItemExistsException(relPath);\n    }\n    String ntName = primaryNodeTypeName;\n    if (ntName == null) {\n        DefinitionProvider dp = sessionDelegate.getDefinitionProvider();\n        try {\n            String childName = sessionDelegate.getOakName(PathUtils.getName(relPath));\n            NodeDefinition def = dp.getDefinition(new NodeImpl<NodeDelegate>(parent), childName);\n            ntName = def.getDefaultPrimaryTypeName();\n        } catch (RepositoryException e) {\n            throw new ConstraintViolationException(\"no matching child node definition found for \" + relPath);\n        }\n    }\n        NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();\n        NodeType nt = ntm.getNodeType(ntName);\n    if (nt.isAbstract() || nt.isMixin()) {\n        throw new ConstraintViolationException();\n    }\n        NodeDelegate added = parent.addChild(oakName);\n    if (added == null) {\n        throw new ItemExistsException();\n    }\n    NodeImpl<?> childNode = new NodeImpl<NodeDelegate>(added);\n    childNode.internalSetPrimaryType(ntName);\n    childNode.autoCreateItems();\n    return childNode;\n}", "lc": 1.5454545454545454, "pi": 0.27040816326530603, "ma": 2.1666666666666665, "nbd": 0.5, "ml": 1.25, "d": 0.4913494809688583, "mi": -0.9016346429595643, "fo": 1.4166666666666667, "r": -0.028571428571428574, "e": 1.579751671442216}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1096_faf99727", "label": 0, "code": "/**\n * Compute enclosing ball using G\u00e4rtner's pivoting heuristic.\n * @param points points to be enclosed\n * @return enclosing ball\n */\nprivate EnclosingBall<S, P> pivotingBall(final List<P> points) {\n    List<P> extreme = new ArrayList<P>(max);\n    List<P> support = new ArrayList<P>(max);\n    // start with only first point selected as a candidate support\n    extreme.add(points.get(0));\n    EnclosingBall<S, P> ball = moveToFrontBall(extreme, support);\n    while (true) {\n        // select the point farthest to current ball\n        final P farthest = selectFarthest(points, ball);\n        if (ball.contains(farthest, tolerance)) {\n            // we have found a ball containing all points\n            return ball;\n        }\n        // recurse search, restricted to the small subset containing support and farthest point\n        support.clear();\n        support.add(farthest);\n        EnclosingBall<S, P> savedBall = ball;\n        ball = moveToFrontBall(extreme, support);\n        if (ball.getRadius() < savedBall.getRadius()) {\n            // TODO: fix this, it should never happen but it does!\n            throw new MathInternalError();\n        }\n        // it was an interesting point, move it to the front\n        // according to G\u00e4rtner's heuristic\n        extreme.add(0, farthest);\n        // prune the least interesting points\n        extreme.subList(ball.getSupportSize(), extreme.size()).clear();\n    }\n}", "code_comment": "/**\n * Compute enclosing ball using G\u00e4rtner's pivoting heuristic.\n * @param points points to be enclosed\n * @return enclosing ball\n */\n", "code_no_comment": "private EnclosingBall<S, P> pivotingBall(final List<P> points) {\n    List<P> extreme = new ArrayList<P>(max);\n    List<P> support = new ArrayList<P>(max);\n        extreme.add(points.get(0));\n    EnclosingBall<S, P> ball = moveToFrontBall(extreme, support);\n    while (true) {\n                final P farthest = selectFarthest(points, ball);\n        if (ball.contains(farthest, tolerance)) {\n                        return ball;\n        }\n                support.clear();\n        support.add(farthest);\n        EnclosingBall<S, P> savedBall = ball;\n        ball = moveToFrontBall(extreme, support);\n        if (ball.getRadius() < savedBall.getRadius()) {\n                        throw new MathInternalError();\n        }\n                        extreme.add(0, farthest);\n                extreme.subList(ball.getSupportSize(), extreme.size()).clear();\n    }\n}", "lc": 0.3181818181818182, "pi": 0.06122448979591842, "ma": 0.16666666666666666, "nbd": 0.0, "ml": 0.25, "d": 0.1354424122590213, "mi": -0.31086894178376845, "fo": 0.75, "r": -0.028571428571428574, "e": 0.27411224039643484}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8146_17475d80", "label": 3, "code": "@Override\nprotected void doStop() throws Exception {\n    ServiceHelper.stopService(scheduler);\n    // clear counters\n    backoffCounter = 0;\n    idleCounter = 0;\n    errorCounter = 0;\n    super.doStop();\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected void doStop() throws Exception {\n    ServiceHelper.stopService(scheduler);\n        backoffCounter = 0;\n    idleCounter = 0;\n    errorCounter = 0;\n    super.doStop();\n}", "lc": -0.2727272727272727, "pi": -0.5510204081632654, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.44164037854889576, "fo": -0.3333333333333333, "r": 2.0, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1269_b8fe2ded", "label": 1, "code": "/**\n * Returns <code>true</code> if a node type index lookup exists at the given\n * <code>path</code> or further up the tree.\n *\n * @param path the path to check.\n * @return <code>true</code> if a node type index exists; <code>false</code>\n *         otherwise.\n */\npublic boolean isIndexed(String path) {\n    PropertyIndexLookup lookup = new PropertyIndexLookup(root);\n    if (lookup.isIndexed(JCR_PRIMARYTYPE, path, null) && lookup.isIndexed(JCR_MIXINTYPES, path, null)) {\n        return true;\n    }\n    if (path.startsWith(\"/\")) {\n        path = path.substring(1);\n    }\n    int slash = path.indexOf('/');\n    if (slash == -1) {\n        return false;\n    }\n    NodeState child = root.getChildNode(path.substring(0, slash));\n    return new NodeTypeIndexLookup(child).isIndexed(path.substring(slash));\n}", "code_comment": "/**\n * Returns <code>true</code> if a node type index lookup exists at the given\n * <code>path</code> or further up the tree.\n *\n * @param path the path to check.\n * @return <code>true</code> if a node type index exists; <code>false</code>\n *         otherwise.\n */\n", "code_no_comment": "public boolean isIndexed(String path) {\n    PropertyIndexLookup lookup = new PropertyIndexLookup(root);\n    if (lookup.isIndexed(JCR_PRIMARYTYPE, path, null) && lookup.isIndexed(JCR_MIXINTYPES, path, null)) {\n        return true;\n    }\n    if (path.startsWith(\"/\")) {\n        path = path.substring(1);\n    }\n    int slash = path.indexOf('/');\n    if (slash == -1) {\n        return false;\n    }\n    NodeState child = root.getChildNode(path.substring(0, slash));\n    return new NodeTypeIndexLookup(child).isIndexed(path.substring(slash));\n}", "lc": 0.045454545454545456, "pi": -0.37244897959183676, "ma": 0.0, "nbd": -0.5, "ml": 0.3333333333333333, "d": 0.42807711319822056, "mi": -0.0845999426441068, "fo": 0.25, "r": -0.028571428571428574, "e": 0.28522235214000285}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-369_4e245a76", "label": 3, "code": "/**\n * Get a property\n * @param relPath  oak path\n * @return  property at the path given by {@code relPath} or {@code null} if\n * no such property exists\n */\n@CheckForNull\npublic PropertyDelegate getProperty(String relPath) throws InvalidItemStateException {\n    TreeLocation propertyLocation = getChildLocation(relPath);\n    PropertyState propertyState = propertyLocation.getProperty();\n    return propertyState == null ? null : new PropertyDelegate(sessionDelegate, propertyLocation);\n}", "code_comment": "/**\n * Get a property\n * @param relPath  oak path\n * @return  property at the path given by {@code relPath} or {@code null} if\n * no such property exists\n */\n", "code_no_comment": "@CheckForNull\npublic PropertyDelegate getProperty(String relPath) throws InvalidItemStateException {\n    TreeLocation propertyLocation = getChildLocation(relPath);\n    PropertyState propertyState = propertyLocation.getProperty();\n    return propertyState == null ? null : new PropertyDelegate(sessionDelegate, propertyLocation);\n}", "lc": -0.36363636363636365, "pi": -0.5204081632653061, "ma": -0.3333333333333333, "nbd": -1.0, "ml": -0.25, "d": -0.08403361344537813, "mi": 0.5010037281330658, "fo": -0.3333333333333333, "r": 2.7714285714285714, "e": -0.10255224193831618}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-766_6fc5ea9d", "label": 1, "code": "@Override\npublic TreeImpl getChild(@Nonnull String name) {\n    checkNotNull(name);\n    enter();\n    TreeImpl child = internalGetChild(name);\n    if (child != null && canRead(child)) {\n        return child;\n    } else {\n        return null;\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic TreeImpl getChild(@Nonnull String name) {\n    checkNotNull(name);\n    enter();\n    TreeImpl child = internalGetChild(name);\n    if (child != null && canRead(child)) {\n        return child;\n    } else {\n        return null;\n    }\n}", "lc": -0.13636363636363635, "pi": -0.17857142857142863, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.07612456747404842, "mi": 0.2256954402064814, "fo": -0.16666666666666666, "r": 1.7428571428571429, "e": -0.10360586086233999}
{"project_name": "Math", "project_version": 65, "label": 1, "code": "/**\n * Get the Root Mean Square value.\n * Get the Root Mean Square value, i.e. the root of the arithmetic\n * mean of the square of all weighted residuals. This is related to the\n * criterion that is minimized by the optimizer as follows: if\n * <em>c</em> if the criterion, and <em>n</em> is the number of\n * measurements, then the RMS is <em>sqrt (c/n)</em>.\n *\n * @return RMS value\n */\npublic double getRMS() {\n    double criterion = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        criterion += residual * residual * residualsWeights[i];\n    }\n    return Math.sqrt(criterion / rows);\n}", "code_comment": "/**\n * Get the Root Mean Square value.\n * Get the Root Mean Square value, i.e. the root of the arithmetic\n * mean of the square of all weighted residuals. This is related to the\n * criterion that is minimized by the optimizer as follows: if\n * <em>c</em> if the criterion, and <em>n</em> is the number of\n * measurements, then the RMS is <em>sqrt (c/n)</em>.\n *\n * @return RMS value\n */\n", "code_no_comment": "public double getRMS() {\n    double criterion = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        criterion += residual * residual * residualsWeights[i];\n    }\n    return Math.sqrt(criterion / rows);\n}", "lc": -0.2727272727272727, "pi": -0.09693877551020405, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.16666666666666666, "d": 0.7523479980227388, "mi": 0.3358187553771149, "fo": -0.4166666666666667, "r": 0.05714285714285714, "e": 0.12654134597676042}
{"project_name": "Math", "project_version": 6, "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\nprotected PointValuePair doOptimize() {\n    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n    final double[] point = getStartPoint();\n    final GoalType goal = getGoalType();\n    final int n = point.length;\n    double[] r = computeObjectiveGradient(point);\n    if (goal == GoalType.MINIMIZE) {\n        for (int i = 0; i < n; i++) {\n            r[i] = -r[i];\n        }\n    }\n    // Initial search direction.\n    double[] steepestDescent = preconditioner.precondition(point, r);\n    double[] searchDirection = steepestDescent.clone();\n    double delta = 0;\n    for (int i = 0; i < n; ++i) {\n        delta += r[i] * searchDirection[i];\n    }\n    PointValuePair current = null;\n    int iter = 0;\n    int maxEval = getMaxEvaluations();\n    while (true) {\n        ++iter;\n        final double objective = computeObjectiveValue(point);\n        PointValuePair previous = current;\n        current = new PointValuePair(point, objective);\n        if (previous != null) {\n            if (checker.converged(iter, previous, current)) {\n                // We have found an optimum.\n                return current;\n            }\n        }\n        // Find the optimal step in the search direction.\n        final UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);\n        final double uB = findUpperBound(lsf, 0, initialStep);\n        // XXX Last parameters is set to a value close to zero in order to\n        // work around the divergence problem in the \"testCircleFitting\"\n        // unit test (see MATH-439).\n        final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);\n        // Subtract used up evaluations.\n        maxEval -= solver.getEvaluations();\n        // Validate new point.\n        for (int i = 0; i < point.length; ++i) {\n            point[i] += step * searchDirection[i];\n        }\n        r = computeObjectiveGradient(point);\n        if (goal == GoalType.MINIMIZE) {\n            for (int i = 0; i < n; ++i) {\n                r[i] = -r[i];\n            }\n        }\n        // Compute beta.\n        final double deltaOld = delta;\n        final double[] newSteepestDescent = preconditioner.precondition(point, r);\n        delta = 0;\n        for (int i = 0; i < n; ++i) {\n            delta += r[i] * newSteepestDescent[i];\n        }\n        final double beta;\n        switch(updateFormula) {\n            case FLETCHER_REEVES:\n                beta = delta / deltaOld;\n                break;\n            case POLAK_RIBIERE:\n                double deltaMid = 0;\n                for (int i = 0; i < r.length; ++i) {\n                    deltaMid += r[i] * steepestDescent[i];\n                }\n                beta = (delta - deltaMid) / deltaOld;\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n        }\n        steepestDescent = newSteepestDescent;\n        // Compute conjugate search direction.\n        if (iter % n == 0 || beta < 0) {\n            // Break conjugation: reset search direction.\n            searchDirection = steepestDescent.clone();\n        } else {\n            // Compute new conjugate search direction.\n            for (int i = 0; i < n; ++i) {\n                searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];\n            }\n        }\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\nprotected PointValuePair doOptimize() {\n    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n    final double[] point = getStartPoint();\n    final GoalType goal = getGoalType();\n    final int n = point.length;\n    double[] r = computeObjectiveGradient(point);\n    if (goal == GoalType.MINIMIZE) {\n        for (int i = 0; i < n; i++) {\n            r[i] = -r[i];\n        }\n    }\n        double[] steepestDescent = preconditioner.precondition(point, r);\n    double[] searchDirection = steepestDescent.clone();\n    double delta = 0;\n    for (int i = 0; i < n; ++i) {\n        delta += r[i] * searchDirection[i];\n    }\n    PointValuePair current = null;\n    int iter = 0;\n    int maxEval = getMaxEvaluations();\n    while (true) {\n        ++iter;\n        final double objective = computeObjectiveValue(point);\n        PointValuePair previous = current;\n        current = new PointValuePair(point, objective);\n        if (previous != null) {\n            if (checker.converged(iter, previous, current)) {\n                                return current;\n            }\n        }\n                final UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);\n        final double uB = findUpperBound(lsf, 0, initialStep);\n                                final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);\n                maxEval -= solver.getEvaluations();\n                for (int i = 0; i < point.length; ++i) {\n            point[i] += step * searchDirection[i];\n        }\n        r = computeObjectiveGradient(point);\n        if (goal == GoalType.MINIMIZE) {\n            for (int i = 0; i < n; ++i) {\n                r[i] = -r[i];\n            }\n        }\n                final double deltaOld = delta;\n        final double[] newSteepestDescent = preconditioner.precondition(point, r);\n        delta = 0;\n        for (int i = 0; i < n; ++i) {\n            delta += r[i] * newSteepestDescent[i];\n        }\n        final double beta;\n        switch(updateFormula) {\n            case FLETCHER_REEVES:\n                beta = delta / deltaOld;\n                break;\n            case POLAK_RIBIERE:\n                double deltaMid = 0;\n                for (int i = 0; i < r.length; ++i) {\n                    deltaMid += r[i] * steepestDescent[i];\n                }\n                beta = (delta - deltaMid) / deltaOld;\n                break;\n            default:\n                                throw new MathInternalError();\n        }\n        steepestDescent = newSteepestDescent;\n                if (iter % n == 0 || beta < 0) {\n                        searchDirection = steepestDescent.clone();\n        } else {\n                        for (int i = 0; i < n; ++i) {\n                searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];\n            }\n        }\n    }\n}", "lc": 2.772727272727273, "pi": 0.7193877551020407, "ma": 2.6666666666666665, "nbd": 1.0, "ml": 1.8333333333333333, "d": 3.8151260504201683, "mi": -1.211356466876972, "fo": 0.75, "r": -0.028571428571428574, "e": 14.447244101233077}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2047_a0a495f0", "label": 0, "code": "/**\n * Copies the full content from the source to the target repository.\n * <p>\n * The source repository <strong>must not be modified</strong> while\n * the copy operation is running to avoid an inconsistent copy.\n * <p>\n * Note that both the source and the target repository must be closed\n * during the copy operation as this method requires exclusive access\n * to the repositories.\n *\n * @param initializer optional extra repository initializer to use\n * @throws RepositoryException if the copy operation fails\n */\npublic void copy(RepositoryInitializer initializer) throws RepositoryException {\n    RepositoryConfig config = source.getRepositoryConfig();\n    logger.info(\"Copying repository content from {} to Oak\", config.getHomeDir());\n    try {\n        NodeState base = target.getRoot();\n        NodeBuilder builder = base.builder();\n        String workspaceName = source.getRepositoryConfig().getDefaultWorkspaceName();\n        SecurityProviderImpl security = new SecurityProviderImpl(mapSecurityConfig(config.getSecurityConfig()));\n        // init target repository first\n        new InitialContent().initialize(builder);\n        if (initializer != null) {\n            initializer.initialize(builder);\n        }\n        for (SecurityConfiguration sc : security.getConfigurations()) {\n            sc.getRepositoryInitializer().initialize(builder);\n        }\n        for (SecurityConfiguration sc : security.getConfigurations()) {\n            sc.getWorkspaceInitializer().initialize(builder, workspaceName);\n        }\n        HashBiMap<String, String> uriToPrefix = HashBiMap.create();\n        Map<Integer, String> idxToPrefix = newHashMap();\n        copyNamespaces(builder, uriToPrefix, idxToPrefix);\n        copyNodeTypes(builder, uriToPrefix.inverse());\n        copyPrivileges(builder);\n        // Triggers compilation of type information, which we need for\n        // the type predicates used by the bulk  copy operations below.\n        new TypeEditorProvider(false).getRootEditor(base, builder.getNodeState(), builder, null);\n        Map<String, String> versionablePaths = newHashMap();\n        NodeState root = builder.getNodeState();\n        copyWorkspace(builder, root, workspaceName, uriToPrefix, idxToPrefix, versionablePaths);\n        copyVersionStore(builder, root, workspaceName, uriToPrefix, idxToPrefix, versionablePaths);\n        logger.info(\"Applying default commit hooks\");\n        // TODO: default hooks?\n        List<CommitHook> hooks = newArrayList();\n        UserConfiguration userConf = security.getConfiguration(UserConfiguration.class);\n        String groupsPath = userConf.getParameters().getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);\n        // hooks specific to the upgrade, need to run first\n        hooks.add(new EditorHook(new CompositeEditorProvider(new RestrictionEditorProvider(), new GroupEditorProvider(groupsPath))));\n        // security-related hooks\n        for (SecurityConfiguration sc : security.getConfigurations()) {\n            hooks.addAll(sc.getCommitHooks(workspaceName));\n        }\n        // type validation, reference and indexing hooks\n        hooks.add(new EditorHook(new CompositeEditorProvider(createTypeEditorProvider(), createIndexEditorProvider())));\n        target.merge(builder, CompositeHook.compose(hooks), CommitInfo.EMPTY);\n    } catch (Exception e) {\n        throw new RepositoryException(\"Failed to copy content\", e);\n    }\n}", "code_comment": "/**\n * Copies the full content from the source to the target repository.\n * <p>\n * The source repository <strong>must not be modified</strong> while\n * the copy operation is running to avoid an inconsistent copy.\n * <p>\n * Note that both the source and the target repository must be closed\n * during the copy operation as this method requires exclusive access\n * to the repositories.\n *\n * @param initializer optional extra repository initializer to use\n * @throws RepositoryException if the copy operation fails\n */\n", "code_no_comment": "public void copy(RepositoryInitializer initializer) throws RepositoryException {\n    RepositoryConfig config = source.getRepositoryConfig();\n    logger.info(\"Copying repository content from {} to Oak\", config.getHomeDir());\n    try {\n        NodeState base = target.getRoot();\n        NodeBuilder builder = base.builder();\n        String workspaceName = source.getRepositoryConfig().getDefaultWorkspaceName();\n        SecurityProviderImpl security = new SecurityProviderImpl(mapSecurityConfig(config.getSecurityConfig()));\n                new InitialContent().initialize(builder);\n        if (initializer != null) {\n            initializer.initialize(builder);\n        }\n        for (SecurityConfiguration sc : security.getConfigurations()) {\n            sc.getRepositoryInitializer().initialize(builder);\n        }\n        for (SecurityConfiguration sc : security.getConfigurations()) {\n            sc.getWorkspaceInitializer().initialize(builder, workspaceName);\n        }\n        HashBiMap<String, String> uriToPrefix = HashBiMap.create();\n        Map<Integer, String> idxToPrefix = newHashMap();\n        copyNamespaces(builder, uriToPrefix, idxToPrefix);\n        copyNodeTypes(builder, uriToPrefix.inverse());\n        copyPrivileges(builder);\n                        new TypeEditorProvider(false).getRootEditor(base, builder.getNodeState(), builder, null);\n        Map<String, String> versionablePaths = newHashMap();\n        NodeState root = builder.getNodeState();\n        copyWorkspace(builder, root, workspaceName, uriToPrefix, idxToPrefix, versionablePaths);\n        copyVersionStore(builder, root, workspaceName, uriToPrefix, idxToPrefix, versionablePaths);\n        logger.info(\"Applying default commit hooks\");\n                List<CommitHook> hooks = newArrayList();\n        UserConfiguration userConf = security.getConfiguration(UserConfiguration.class);\n        String groupsPath = userConf.getParameters().getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);\n                hooks.add(new EditorHook(new CompositeEditorProvider(new RestrictionEditorProvider(), new GroupEditorProvider(groupsPath))));\n                for (SecurityConfiguration sc : security.getConfigurations()) {\n            hooks.addAll(sc.getCommitHooks(workspaceName));\n        }\n                hooks.add(new EditorHook(new CompositeEditorProvider(createTypeEditorProvider(), createIndexEditorProvider())));\n        target.merge(builder, CompositeHook.compose(hooks), CommitInfo.EMPTY);\n    } catch (Exception e) {\n        throw new RepositoryException(\"Failed to copy content\", e);\n    }\n}", "lc": 1.2727272727272727, "pi": -0.2653061224489796, "ma": 0.5, "nbd": 0.0, "ml": -0.25, "d": 0.010874938210578382, "mi": -0.8064238600516207, "fo": 3.0833333333333335, "r": -0.028571428571428574, "e": 0.8093892008343292}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3517_24f7f60a", "label": 1, "code": "@Nonnull\n@Override\npublic Node perform() throws RepositoryException {\n    String oakName = PathUtils.getName(oakPath);\n    String parentPath = PathUtils.getParentPath(oakPath);\n    NodeDelegate parent = dlg.getChild(parentPath);\n    if (parent == null) {\n        // is it a property?\n        String grandParentPath = PathUtils.getParentPath(parentPath);\n        NodeDelegate grandParent = dlg.getChild(grandParentPath);\n        if (grandParent != null) {\n            String propName = PathUtils.getName(parentPath);\n            if (grandParent.getPropertyOrNull(propName) != null) {\n                throw new ConstraintViolationException(\"Can't add new node to property.\");\n            }\n        }\n        throw new PathNotFoundException(relPath);\n    }\n    if (parent.getChild(oakName) != null) {\n        throw new ItemExistsException(relPath);\n    }\n    // modification of that property in the PermissionValidator\n    if (oakTypeName != null) {\n        PropertyState prop = PropertyStates.createProperty(JCR_PRIMARYTYPE, oakTypeName, NAME);\n        sessionContext.getAccessManager().checkPermissions(dlg.getTree(), prop, Permissions.NODE_TYPE_MANAGEMENT);\n    }\n    NodeDelegate added = parent.addChild(oakName, oakTypeName);\n    if (added == null) {\n        throw new ItemExistsException();\n    }\n    return createNode(added, sessionContext);\n}", "code_comment": NaN, "code_no_comment": "@Nonnull\n@Override\npublic Node perform() throws RepositoryException {\n    String oakName = PathUtils.getName(oakPath);\n    String parentPath = PathUtils.getParentPath(oakPath);\n    NodeDelegate parent = dlg.getChild(parentPath);\n    if (parent == null) {\n                String grandParentPath = PathUtils.getParentPath(parentPath);\n        NodeDelegate grandParent = dlg.getChild(grandParentPath);\n        if (grandParent != null) {\n            String propName = PathUtils.getName(parentPath);\n            if (grandParent.getPropertyOrNull(propName) != null) {\n                throw new ConstraintViolationException(\"Can't add new node to property.\");\n            }\n        }\n        throw new PathNotFoundException(relPath);\n    }\n    if (parent.getChild(oakName) != null) {\n        throw new ItemExistsException(relPath);\n    }\n        if (oakTypeName != null) {\n        PropertyState prop = PropertyStates.createProperty(JCR_PRIMARYTYPE, oakTypeName, NAME);\n        sessionContext.getAccessManager().checkPermissions(dlg.getTree(), prop, Permissions.NODE_TYPE_MANAGEMENT);\n    }\n    NodeDelegate added = parent.addChild(oakName, oakTypeName);\n    if (added == null) {\n        throw new ItemExistsException();\n    }\n    return createNode(added, sessionContext);\n}", "lc": 0.7272727272727273, "pi": 0.413265306122449, "ma": 1.1666666666666667, "nbd": 0.5, "ml": 0.75, "d": 0.0009886307464162364, "mi": -0.5623745339833669, "fo": 0.6666666666666666, "r": -0.028571428571428574, "e": 0.2787164694343437}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-43_668f08f2", "label": 1, "code": "public void removeNode(String nodePath) throws NotFoundException, Exception {\n    String parentPath = PathUtils.getParentPath(nodePath);\n    String nodeName = PathUtils.getName(nodePath);\n    MutableNode parent = getOrCreateStagedNode(parentPath);\n    if (parent.remove(nodeName) == null) {\n        throw new NotFoundException(nodePath);\n    }\n    // update staging area\n    removeStagedNodes(nodePath);\n    // update change log\n    changeLog.add(new RemoveNode(nodePath));\n}", "code_comment": NaN, "code_no_comment": "public void removeNode(String nodePath) throws NotFoundException, Exception {\n    String parentPath = PathUtils.getParentPath(nodePath);\n    String nodeName = PathUtils.getName(nodePath);\n    MutableNode parent = getOrCreateStagedNode(parentPath);\n    if (parent.remove(nodeName) == null) {\n        throw new NotFoundException(nodePath);\n    }\n        removeStagedNodes(nodePath);\n        changeLog.add(new RemoveNode(nodePath));\n}", "lc": -0.18181818181818182, "pi": -0.4438775510204082, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.16666666666666666, "d": -0.06426099851705384, "mi": 0.18038428448523067, "fo": 0.0, "r": 0.6, "e": -0.05421426154590737}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2621_c849f986", "label": 1, "code": "@Override\npublic void onFormComponent(FormComponent<?> formComponent) {\n    if (formComponent.isVisible() && formComponent.isMultiPart()) {\n        setMultiPart(true);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void onFormComponent(FormComponent<?> formComponent) {\n    if (formComponent.isVisible() && formComponent.isMultiPart()) {\n        setMultiPart(true);\n    }\n}", "lc": -0.36363636363636365, "pi": -0.02040816326530614, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.3806228373702422, "mi": 0.6320619443647835, "fo": -0.25, "r": 0.0, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 81, "label": 2, "code": "@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.LP);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}", "code_comment": NaN, "code_no_comment": "@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n                        newName.setLineno(functionNode.getLineno());\n                                int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.LP);\n                            Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}", "lc": 0.9545454545454546, "pi": -0.3979591836734693, "ma": 0.16666666666666666, "nbd": -0.5, "ml": 0.08333333333333333, "d": 0.5882352941176473, "mi": -0.6157155147691427, "fo": 1.9166666666666667, "r": -0.028571428571428574, "e": 1.130477426428703}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3318_e12e2052", "label": 3, "code": "/**\n * Returns <code>true</code> if this rule applies to the given node\n * <code>state</code>.\n *\n * @param state the state to check.\n * @return <code>true</code> the rule applies to the given node;\n *         <code>false</code> otherwise.\n */\npublic boolean appliesTo(Tree state) {\n    if (!nodeTypeName.equals(getPrimaryTypeName(state))) {\n        return false;\n    }\n    // return condition == null || condition.evaluate(state);\n    return true;\n}", "code_comment": "/**\n * Returns <code>true</code> if this rule applies to the given node\n * <code>state</code>.\n *\n * @param state the state to check.\n * @return <code>true</code> the rule applies to the given node;\n *         <code>false</code> otherwise.\n */\n", "code_no_comment": "public boolean appliesTo(Tree state) {\n    if (!nodeTypeName.equals(getPrimaryTypeName(state))) {\n        return false;\n    }\n        return true;\n}", "lc": -0.36363636363636365, "pi": -0.13775510204081634, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.3806228373702422, "mi": 0.6449670203613421, "fo": -0.3333333333333333, "r": 1.0857142857142859, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 155, "label": 2, "code": "/**\n * For all variables in this scope, see if they are only used once.\n * If it looks safe to do so, inline them.\n */\nprivate void doInlinesForScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) {\n    for (Iterator<Var> it = t.getScope().getVars(); it.hasNext(); ) {\n        Var v = it.next();\n        ReferenceCollection referenceInfo = referenceMap.get(v);\n        // and the variable is not a constant.\n        if (referenceInfo == null || isVarInlineForbidden(v)) {\n            // were not collected or variables that have already been inlined.\n            continue;\n        } else if (isInlineableDeclaredConstant(v, referenceInfo)) {\n            Reference init = referenceInfo.getInitializingReferenceForConstants();\n            Node value = init.getAssignedValue();\n            inlineDeclaredConstant(v, value, referenceInfo.references);\n            staleVars.add(v);\n        } else if (mode == Mode.CONSTANTS_ONLY) {\n            // inlining heuristics. See InlineConstantsTest.\n            continue;\n        } else {\n            inlineNonConstants(v, referenceInfo);\n        }\n    }\n}", "code_comment": "/**\n * For all variables in this scope, see if they are only used once.\n * If it looks safe to do so, inline them.\n */\n", "code_no_comment": "private void doInlinesForScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) {\n    for (Iterator<Var> it = t.getScope().getVars(); it.hasNext(); ) {\n        Var v = it.next();\n        ReferenceCollection referenceInfo = referenceMap.get(v);\n                if (referenceInfo == null || isVarInlineForbidden(v)) {\n                        continue;\n        } else if (isInlineableDeclaredConstant(v, referenceInfo)) {\n            Reference init = referenceInfo.getInitializingReferenceForConstants();\n            Node value = init.getAssignedValue();\n            inlineDeclaredConstant(v, value, referenceInfo.references);\n            staleVars.add(v);\n        } else if (mode == Mode.CONSTANTS_ONLY) {\n                        continue;\n        } else {\n            inlineNonConstants(v, referenceInfo);\n        }\n    }\n}", "lc": 0.18181818181818182, "pi": 0.43877551020408156, "ma": 0.5, "nbd": 1.0, "ml": 0.5, "d": -0.06623826000988627, "mi": -0.2234012044737599, "fo": 0.5, "r": -0.028571428571428574, "e": 0.0554820306577409}
{"project_name": "Compress", "project_version": 23, "label": 3, "code": "@Override\nInputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n        dictSize |= (coder.properties[i + 1] << (8 * i));\n    }\n    if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n        throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n    }\n    return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n}", "code_comment": NaN, "code_no_comment": "@Override\nInputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n        dictSize |= (coder.properties[i + 1] << (8 * i));\n    }\n    if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n        throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n    }\n    return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n}", "lc": -0.09090909090909091, "pi": -0.2346938775510204, "ma": 0.0, "nbd": -0.5, "ml": -0.08333333333333333, "d": 1.2011863568956997, "mi": 0.024376254660166175, "fo": -0.5, "r": 0.0, "e": 0.6846895464727323}
{"project_name": "Math", "project_version": 34, "label": 1, "code": "/**\n * Returns an iterator over the unmodifiable list of chromosomes.\n * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n *\n * @return chromosome iterator\n */\npublic Iterator<Chromosome> iterator() {\n    return chromosomes.iterator();\n}", "code_comment": "/**\n * Returns an iterator over the unmodifiable list of chromosomes.\n * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n *\n * @return chromosome iterator\n */\n", "code_no_comment": "public Iterator<Chromosome> iterator() {\n    return chromosomes.iterator();\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.1172928018353891, "fo": -0.4166666666666667, "r": 2.8000000000000003, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 64, "label": 2, "code": "/**\n * Generates JavaScript source code for an AST.\n */\nprivate String toSource(Node n, SourceMap sourceMap) {\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\n    builder.setPrettyPrint(options.prettyPrint);\n    builder.setLineBreak(options.lineBreak);\n    builder.setSourceMap(sourceMap);\n    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    builder.setTagAsStrict(options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n    builder.setLineLengthThreshold(options.lineLengthThreshold);\n    Charset charset = options.outputCharset != null ? Charset.forName(options.outputCharset) : null;\n    builder.setOutputCharset(charset);\n    return builder.build();\n}", "code_comment": "/**\n * Generates JavaScript source code for an AST.\n */\n", "code_no_comment": "private String toSource(Node n, SourceMap sourceMap) {\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\n    builder.setPrettyPrint(options.prettyPrint);\n    builder.setLineBreak(options.lineBreak);\n    builder.setSourceMap(sourceMap);\n    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    builder.setTagAsStrict(options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n    builder.setLineLengthThreshold(options.lineLengthThreshold);\n    Charset charset = options.outputCharset != null ? Charset.forName(options.outputCharset) : null;\n    builder.setOutputCharset(charset);\n    return builder.build();\n}", "lc": -0.09090909090909091, "pi": -0.7806122448979592, "ma": -0.3333333333333333, "nbd": -1.0, "ml": -0.25, "d": -0.042511122095897164, "mi": 0.014052193862919272, "fo": 0.3333333333333333, "r": -0.028571428571428574, "e": 0.04811526419708669}
{"project_name": "Math", "project_version": 99, "label": 3, "code": "/**\n * <p>\n * Gets the greatest common divisor of the absolute value of two numbers,\n * using the \"binary gcd\" method which avoids division and modulo\n * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n * Stein (1961).\n * </p>\n * Special cases:\n * <ul>\n * <li>The invocations\n * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,\n * <code>gcd(Integer.MIN_VALUE, 0)</code> and\n * <code>gcd(0, Integer.MIN_VALUE)</code> throw an\n * <code>ArithmeticException</code>, because the result would be 2^31, which\n * is too large for an int value.</li>\n * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and\n * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except\n * for the special cases above.\n * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns\n * <code>0</code>.</li>\n * </ul>\n *\n * @param u any number\n * @param v any number\n * @return the greatest common divisor, never negative\n * @throws ArithmeticException\n *             if the result cannot be represented as a nonnegative int\n *             value\n * @since 1.1\n */\npublic static int gcd(final int p, final int q) {\n    int u = p;\n    int v = q;\n    if ((u == 0) || (v == 0)) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    /* assert u!=0 && v!=0; */\n    if (u > 0) {\n        u = -u;\n    }\n    // make u negative\n    if (v > 0) {\n        v = -v;\n    }\n    // make v negative\n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n        // while u and v are\n        // both even...\n        u /= 2;\n        v /= 2;\n        // cast out twos.\n        k++;\n    }\n    if (k == 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    // one is odd.\n    int t = ((u & 1) == 1) ? v : -(u / 2);\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        // B4/B3: cast out twos from t.\n        while ((t & 1) == 0) {\n            // while t is even..\n            // cast out twos\n            t /= 2;\n        }\n        // B5 [reset max(u,v)]\n        if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        t = (v - u) / 2;\n    // |u| larger: t positive (replace u)\n    // |v| larger: t negative (replace v)\n    } while (t != 0);\n    // gcd is u*2^k\n    return -u * (1 << k);\n}", "code_comment": "/**\n * <p>\n * Gets the greatest common divisor of the absolute value of two numbers,\n * using the \"binary gcd\" method which avoids division and modulo\n * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n * Stein (1961).\n * </p>\n * Special cases:\n * <ul>\n * <li>The invocations\n * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,\n * <code>gcd(Integer.MIN_VALUE, 0)</code> and\n * <code>gcd(0, Integer.MIN_VALUE)</code> throw an\n * <code>ArithmeticException</code>, because the result would be 2^31, which\n * is too large for an int value.</li>\n * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and\n * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except\n * for the special cases above.\n * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns\n * <code>0</code>.</li>\n * </ul>\n *\n * @param u any number\n * @param v any number\n * @return the greatest common divisor, never negative\n * @throws ArithmeticException\n *             if the result cannot be represented as a nonnegative int\n *             value\n * @since 1.1\n */\n", "code_no_comment": "public static int gcd(final int p, final int q) {\n    int u = p;\n    int v = q;\n    if ((u == 0) || (v == 0)) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n        if (u > 0) {\n        u = -u;\n    }\n        if (v > 0) {\n        v = -v;\n    }\n            int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n                        u /= 2;\n        v /= 2;\n                k++;\n    }\n    if (k == 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n    }\n            int t = ((u & 1) == 1) ? v : -(u / 2);\n        do {\n                while ((t & 1) == 0) {\n                                    t /= 2;\n        }\n                if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n                t = (v - u) / 2;\n            } while (t != 0);\n        return -u * (1 << k);\n}", "lc": 0.9545454545454546, "pi": -0.0459183673469387, "ma": 1.1666666666666667, "nbd": 0.0, "ml": 0.9166666666666666, "d": 5.464162135442413, "mi": -0.6509893891597365, "fo": -0.25, "r": -0.028571428571428574, "e": 7.434544995095961}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5681_78c73502", "label": 1, "code": "@Override\nprotected boolean processNext(final Exchange exchange, final AsyncCallback callback) {\n    final Exception caught = exchange.getException();\n    if (caught == null) {\n        return true;\n    }\n    // store the last to endpoint as the failure endpoint\n    if (exchange.getProperty(Exchange.FAILURE_ENDPOINT) == null) {\n        exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));\n    }\n    // give the rest of the pipeline another chance\n    exchange.setProperty(Exchange.EXCEPTION_CAUGHT, caught);\n    exchange.setException(null);\n    // is the exception handled by the catch clause\n    final Boolean handled = catchClause.handles(exchange);\n    if (LOG.isDebugEnabled()) {\n        LOG.debug(\"The exception is handled: {} for the exception: {} caused by: {}\", new Object[] { handled, caught.getClass().getName(), caught.getMessage() });\n    }\n    boolean sync = super.processNext(exchange, new AsyncCallback() {\n\n        public void done(boolean doneSync) {\n            // we only have to handle async completion of the pipeline\n            if (doneSync) {\n                return;\n            }\n            if (!handled) {\n                if (exchange.getException() == null) {\n                    exchange.setException(exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class));\n                }\n            }\n            // always clear redelivery exhausted in a catch clause\n            exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED);\n            // signal callback to continue routing async\n            ExchangeHelper.prepareOutToIn(exchange);\n            callback.done(false);\n        }\n    });\n    if (sync) {\n        // set exception back on exchange\n        if (!handled) {\n            if (exchange.getException() == null) {\n                exchange.setException(exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class));\n            }\n        }\n        // always clear redelivery exhausted in a catch clause\n        exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED);\n    }\n    return sync;\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected boolean processNext(final Exchange exchange, final AsyncCallback callback) {\n    final Exception caught = exchange.getException();\n    if (caught == null) {\n        return true;\n    }\n        if (exchange.getProperty(Exchange.FAILURE_ENDPOINT) == null) {\n        exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));\n    }\n        exchange.setProperty(Exchange.EXCEPTION_CAUGHT, caught);\n    exchange.setException(null);\n        final Boolean handled = catchClause.handles(exchange);\n    if (LOG.isDebugEnabled()) {\n        LOG.debug(\"The exception is handled: {} for the exception: {} caused by: {}\", new Object[] { handled, caught.getClass().getName(), caught.getMessage() });\n    }\n    boolean sync = super.processNext(exchange, new AsyncCallback() {\n\n        public void done(boolean doneSync) {\n                        if (doneSync) {\n                return;\n            }\n            if (!handled) {\n                if (exchange.getException() == null) {\n                    exchange.setException(exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class));\n                }\n            }\n                        exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED);\n                        ExchangeHelper.prepareOutToIn(exchange);\n            callback.done(false);\n        }\n    });\n    if (sync) {\n                if (!handled) {\n            if (exchange.getException() == null) {\n                exchange.setException(exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class));\n            }\n        }\n                exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED);\n    }\n    return sync;\n}", "lc": 1.1818181818181819, "pi": 0.9795918367346941, "ma": 1.0, "nbd": 0.5, "ml": 0.9166666666666666, "d": 0.12357884330202672, "mi": -0.6983080011471183, "fo": 1.4166666666666667, "r": -0.028571428571428574, "e": 0.45665386048543566}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3498_b4606700", "label": 1, "code": "public Object next() {\n    Object part = iterator.next();\n    Exchange newExchange = ExchangeHelper.createCopy(exchange, true);\n    if (part instanceof Message) {\n        newExchange.setIn((Message) part);\n    } else {\n        Message in = newExchange.getIn();\n        in.setBody(part);\n    }\n    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);\n}", "code_comment": NaN, "code_no_comment": "public Object next() {\n    Object part = iterator.next();\n    Exchange newExchange = ExchangeHelper.createCopy(exchange, true);\n    if (part instanceof Message) {\n        newExchange.setIn((Message) part);\n    } else {\n        Message in = newExchange.getIn();\n        in.setBody(part);\n    }\n    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);\n}", "lc": -0.13636363636363635, "pi": -0.17857142857142863, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.04844290657439445, "mi": 0.14482363062804698, "fo": 0.25, "r": 0.05714285714285714, "e": -0.05016682299630377}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-844_692efde2", "label": 0, "code": "@Override\npublic boolean accept(Key k, Value v) {\n    Text testVis = k.getColumnVisibility(tmpVis);\n    if (testVis.getLength() == 0 && defaultVisibility.getLength() == 0)\n        return true;\n    else if (testVis.getLength() == 0)\n        testVis = defaultVisibility;\n    Boolean b = (Boolean) cache.get(testVis);\n    if (b != null)\n        return b;\n    try {\n        Boolean bb = ve.evaluate(new ColumnVisibility(testVis));\n        cache.put(new Text(testVis), bb);\n        return bb;\n    } catch (VisibilityParseException e) {\n        log.error(\"Parse Error\", e);\n        return false;\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean accept(Key k, Value v) {\n    Text testVis = k.getColumnVisibility(tmpVis);\n    if (testVis.getLength() == 0 && defaultVisibility.getLength() == 0)\n        return true;\n    else if (testVis.getLength() == 0)\n        testVis = defaultVisibility;\n    Boolean b = (Boolean) cache.get(testVis);\n    if (b != null)\n        return b;\n    try {\n        Boolean bb = ve.evaluate(new ColumnVisibility(testVis));\n        cache.put(new Text(testVis), bb);\n        return bb;\n    } catch (VisibilityParseException e) {\n        log.error(\"Parse Error\", e);\n        return false;\n    }\n}", "lc": 0.22727272727272727, "pi": -0.08163265306122457, "ma": 0.16666666666666666, "nbd": -0.5, "ml": 0.16666666666666666, "d": 0.28175976272862097, "mi": -0.23057069113851472, "fo": 0.16666666666666666, "r": 0.0, "e": 0.28535084225268864}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2899_31aea2ad", "label": 0, "code": "private int removeMetadataEntries(Map<String, Path> nameToFileMap, Map<String, Path> sortedWALogs, GCStatus status) throws IOException, KeeperException, InterruptedException {\n    int count = 0;\n    Iterator<LogEntry> iterator = MetadataTableUtil.getLogEntries(SystemCredentials.get());\n    while (iterator.hasNext()) {\n        for (String entry : iterator.next().logSet) {\n            String uuid = new Path(entry).getName();\n            if (!isUUID(uuid)) {\n                // fully expect this to be a uuid, if its not then something is wrong and walog GC should not proceed!\n                throw new IllegalArgumentException(\"Expected uuid, but got \" + uuid + \" from \" + entry);\n            }\n            Path pathFromNN = nameToFileMap.remove(uuid);\n            if (pathFromNN != null) {\n                status.currentLog.inUse++;\n                sortedWALogs.remove(uuid);\n            }\n            count++;\n        }\n    }\n    return count;\n}", "code_comment": NaN, "code_no_comment": "private int removeMetadataEntries(Map<String, Path> nameToFileMap, Map<String, Path> sortedWALogs, GCStatus status) throws IOException, KeeperException, InterruptedException {\n    int count = 0;\n    Iterator<LogEntry> iterator = MetadataTableUtil.getLogEntries(SystemCredentials.get());\n    while (iterator.hasNext()) {\n        for (String entry : iterator.next().logSet) {\n            String uuid = new Path(entry).getName();\n            if (!isUUID(uuid)) {\n                                throw new IllegalArgumentException(\"Expected uuid, but got \" + uuid + \" from \" + entry);\n            }\n            Path pathFromNN = nameToFileMap.remove(uuid);\n            if (pathFromNN != null) {\n                status.currentLog.inUse++;\n                sortedWALogs.remove(uuid);\n            }\n            count++;\n        }\n    }\n    return count;\n}", "lc": 0.22727272727272727, "pi": 1.0714285714285714, "ma": 0.3333333333333333, "nbd": 0.5, "ml": 0.16666666666666666, "d": 0.2560553633217994, "mi": -0.25752796099799274, "fo": 0.16666666666666666, "r": -0.028571428571428574, "e": 0.33116185042894286}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3028_89317b28", "label": 0, "code": "/**\n * Creates an update operation for the document with the given id. The\n * changes are shared with the this update operation.\n *\n * @param id the primary key.\n */\npublic UpdateOp shallowCopy(String id) {\n    return new UpdateOp(id, isNew, isDelete, changes);\n}", "code_comment": "/**\n * Creates an update operation for the document with the given id. The\n * changes are shared with the this update operation.\n *\n * @param id the primary key.\n */\n", "code_no_comment": "public UpdateOp shallowCopy(String id) {\n    return new UpdateOp(id, isNew, isDelete, changes);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.003154574132492, "fo": -0.5, "r": 2.6, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2181_d79d0192", "label": 1, "code": "/**\n *  Gets the index of the current page being displayed by this list view.\n *\n *  @return Returns the currentPage.\n */\npublic final int getCurrentPage() {\n    // If first cell is out of range, bring page back into range\n    while ((currentPage * rowsPerPage) >= getList().size()) {\n        currentPage--;\n    }\n    return currentPage;\n}", "code_comment": "/**\n *  Gets the index of the current page being displayed by this list view.\n *\n *  @return Returns the currentPage.\n */\n", "code_no_comment": "public final int getCurrentPage() {\n        while ((currentPage * rowsPerPage) >= getList().size()) {\n        currentPage--;\n    }\n    return currentPage;\n}", "lc": -0.36363636363636365, "pi": -0.13775510204081634, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.11764705882352938, "mi": 0.6521365070260969, "fo": -0.3333333333333333, "r": 2.657142857142857, "e": -0.14431581156496673}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-9444_baece126", "label": 1, "code": "private AggregationStrategy createAggregationStrategy(RouteContext routeContext) {\n    AggregationStrategy strategy = getAggregationStrategy();\n    if (strategy == null && strategyRef != null) {\n        Object aggStrategy = routeContext.lookup(strategyRef, Object.class);\n        if (aggStrategy instanceof AggregationStrategy) {\n            strategy = (AggregationStrategy) aggStrategy;\n        } else if (aggStrategy != null) {\n            AggregationStrategyBeanAdapter adapter = new AggregationStrategyBeanAdapter(aggStrategy, getStrategyMethodName());\n            if (getStrategyMethodAllowNull() != null) {\n                adapter.setAllowNullNewExchange(getStrategyMethodAllowNull());\n                adapter.setAllowNullOldExchange(getStrategyMethodAllowNull());\n            }\n            strategy = adapter;\n        } else {\n            throw new IllegalArgumentException(\"Cannot find AggregationStrategy in Registry with name: \" + strategyRef);\n        }\n    }\n    if (strategy != null && strategy instanceof CamelContextAware) {\n        ((CamelContextAware) strategy).setCamelContext(routeContext.getCamelContext());\n    }\n    return strategy;\n}", "code_comment": NaN, "code_no_comment": "private AggregationStrategy createAggregationStrategy(RouteContext routeContext) {\n    AggregationStrategy strategy = getAggregationStrategy();\n    if (strategy == null && strategyRef != null) {\n        Object aggStrategy = routeContext.lookup(strategyRef, Object.class);\n        if (aggStrategy instanceof AggregationStrategy) {\n            strategy = (AggregationStrategy) aggStrategy;\n        } else if (aggStrategy != null) {\n            AggregationStrategyBeanAdapter adapter = new AggregationStrategyBeanAdapter(aggStrategy, getStrategyMethodName());\n            if (getStrategyMethodAllowNull() != null) {\n                adapter.setAllowNullNewExchange(getStrategyMethodAllowNull());\n                adapter.setAllowNullOldExchange(getStrategyMethodAllowNull());\n            }\n            strategy = adapter;\n        } else {\n            throw new IllegalArgumentException(\"Cannot find AggregationStrategy in Registry with name: \" + strategyRef);\n        }\n    }\n    if (strategy != null && strategy instanceof CamelContextAware) {\n        ((CamelContextAware) strategy).setCamelContext(routeContext.getCamelContext());\n    }\n    return strategy;\n}", "lc": 0.36363636363636365, "pi": 0.760204081632653, "ma": 0.5, "nbd": 1.0, "ml": 0.5, "d": 0.5308947108255069, "mi": -0.31402351591626054, "fo": 0.3333333333333333, "r": -0.028571428571428574, "e": 0.46206329422950904}
{"project_name": "JxPath", "project_version": 15, "label": 1, "code": "public boolean setPosition(int position) {\n    if (!prepared) {\n        prepared = true;\n        BasicNodeSet nodeSet = (BasicNodeSet) getNodeSet();\n        ArrayList pointers = new ArrayList();\n        for (int i = 0; i < contexts.length; i++) {\n            EvalContext ctx = (EvalContext) contexts[i];\n            while (ctx.nextSet()) {\n                while (ctx.nextNode()) {\n                    NodePointer ptr = ctx.getCurrentNodePointer();\n                    if (!pointers.contains(ptr)) {\n                        nodeSet.add(ptr);\n                        pointers.add(ptr);\n                    }\n                }\n            }\n        }\n    }\n    return super.setPosition(position);\n}", "code_comment": NaN, "code_no_comment": "public boolean setPosition(int position) {\n    if (!prepared) {\n        prepared = true;\n        BasicNodeSet nodeSet = (BasicNodeSet) getNodeSet();\n        ArrayList pointers = new ArrayList();\n        for (int i = 0; i < contexts.length; i++) {\n            EvalContext ctx = (EvalContext) contexts[i];\n            while (ctx.nextSet()) {\n                while (ctx.nextNode()) {\n                    NodePointer ptr = ctx.getCurrentNodePointer();\n                    if (!pointers.contains(ptr)) {\n                        nodeSet.add(ptr);\n                        pointers.add(ptr);\n                    }\n                }\n            }\n        }\n    }\n    return super.setPosition(position);\n}", "lc": 0.2727272727272727, "pi": 2.1836734693877546, "ma": 0.3333333333333333, "nbd": 1.5, "ml": 0.5833333333333334, "d": 0.35887296094908566, "mi": -0.22856323487238317, "fo": 0.16666666666666666, "r": 0.14285714285714285, "e": 0.2393556649149181}
{"project_name": "JxPath", "project_version": 19, "label": 1, "code": "/**\n * Get relative position of this among like-named siblings.\n * @return 1..n\n */\nprivate int getRelativePositionByQName() {\n    if (node instanceof Element) {\n        Object parent = ((Element) node).getParent();\n        if (!(parent instanceof Element)) {\n            return 1;\n        }\n        List children = ((Element) parent).getContent();\n        int count = 0;\n        String name = ((Element) node).getQualifiedName();\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if ((child instanceof Element) && ((Element) child).getQualifiedName().equals(name)) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n    return 1;\n}", "code_comment": "/**\n * Get relative position of this among like-named siblings.\n * @return 1..n\n */\n", "code_no_comment": "private int getRelativePositionByQName() {\n    if (node instanceof Element) {\n        Object parent = ((Element) node).getParent();\n        if (!(parent instanceof Element)) {\n            return 1;\n        }\n        List children = ((Element) parent).getContent();\n        int count = 0;\n        String name = ((Element) node).getQualifiedName();\n        for (int i = 0; i < children.size(); i++) {\n            Object child = children.get(i);\n            if ((child instanceof Element) && ((Element) child).getQualifiedName().equals(name)) {\n                count++;\n            }\n            if (child == node) {\n                break;\n            }\n        }\n        return count;\n    }\n    return 1;\n}", "lc": 0.36363636363636365, "pi": 0.6173469387755104, "ma": 0.5, "nbd": 0.5, "ml": 0.6666666666666666, "d": 0.9461196243203165, "mi": -0.29566963005448826, "fo": 0.08333333333333333, "r": 0.08571428571428572, "e": 0.6425233744929993}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5400_6cefb9f8", "label": 3, "code": "private void internalAdd(final Behavior behavior) {\n    component.data_add(behavior);\n    if (behavior.getStatelessHint(component)) {\n        getBehaviorId(behavior);\n    }\n}", "code_comment": NaN, "code_no_comment": "private void internalAdd(final Behavior behavior) {\n    component.data_add(behavior);\n    if (behavior.getStatelessHint(component)) {\n        getBehaviorId(behavior);\n    }\n}", "lc": -0.36363636363636365, "pi": -0.13775510204081634, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.16666666666666666, "d": -0.3806228373702422, "mi": 0.6472612560940636, "fo": -0.25, "r": 0.8571428571428572, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2434_8159fc21", "label": 1, "code": "static Query getFullTextQuery(FullTextExpression ft, final Analyzer analyzer, final IndexReader reader) {\n    // a reference to the query, so it can be set in the visitor\n    // (a \"non-local return\")\n    final AtomicReference<Query> result = new AtomicReference<Query>();\n    ft.accept(new FullTextVisitor() {\n\n        @Override\n        public boolean visit(FullTextContains contains) {\n            return contains.getBase().accept(this);\n        }\n\n        @Override\n        public boolean visit(FullTextOr or) {\n            BooleanQuery q = new BooleanQuery();\n            for (FullTextExpression e : or.list) {\n                Query x = getFullTextQuery(e, analyzer, reader);\n                q.add(x, SHOULD);\n            }\n            result.set(q);\n            return true;\n        }\n\n        @Override\n        public boolean visit(FullTextAnd and) {\n            BooleanQuery q = new BooleanQuery();\n            for (FullTextExpression e : and.list) {\n                Query x = getFullTextQuery(e, analyzer, reader);\n                // Lucene can't deal with \"must(must_not(x))\"\n                if (x instanceof BooleanQuery) {\n                    BooleanQuery bq = (BooleanQuery) x;\n                    for (BooleanClause c : bq.clauses()) {\n                        q.add(c);\n                    }\n                } else {\n                    q.add(x, MUST);\n                }\n            }\n            result.set(q);\n            return true;\n        }\n\n        @Override\n        public boolean visit(FullTextTerm term) {\n            return visitTerm(term.getPropertyName(), term.getText(), term.getBoost(), term.isNot());\n        }\n\n        private boolean visitTerm(String propertyName, String text, String boost, boolean not) {\n            String p = propertyName;\n            if (p != null && p.indexOf('/') >= 0) {\n                p = getName(p);\n            }\n            Query q = tokenToQuery(text, p, analyzer, reader);\n            if (q == null) {\n                return false;\n            }\n            if (boost != null) {\n                q.setBoost(Float.parseFloat(boost));\n            }\n            if (not) {\n                BooleanQuery bq = new BooleanQuery();\n                bq.add(q, MUST_NOT);\n                result.set(bq);\n            } else {\n                result.set(q);\n            }\n            return true;\n        }\n    });\n    return result.get();\n}", "code_comment": NaN, "code_no_comment": "static Query getFullTextQuery(FullTextExpression ft, final Analyzer analyzer, final IndexReader reader) {\n            final AtomicReference<Query> result = new AtomicReference<Query>();\n    ft.accept(new FullTextVisitor() {\n\n        @Override\n        public boolean visit(FullTextContains contains) {\n            return contains.getBase().accept(this);\n        }\n\n        @Override\n        public boolean visit(FullTextOr or) {\n            BooleanQuery q = new BooleanQuery();\n            for (FullTextExpression e : or.list) {\n                Query x = getFullTextQuery(e, analyzer, reader);\n                q.add(x, SHOULD);\n            }\n            result.set(q);\n            return true;\n        }\n\n        @Override\n        public boolean visit(FullTextAnd and) {\n            BooleanQuery q = new BooleanQuery();\n            for (FullTextExpression e : and.list) {\n                Query x = getFullTextQuery(e, analyzer, reader);\n                                if (x instanceof BooleanQuery) {\n                    BooleanQuery bq = (BooleanQuery) x;\n                    for (BooleanClause c : bq.clauses()) {\n                        q.add(c);\n                    }\n                } else {\n                    q.add(x, MUST);\n                }\n            }\n            result.set(q);\n            return true;\n        }\n\n        @Override\n        public boolean visit(FullTextTerm term) {\n            return visitTerm(term.getPropertyName(), term.getText(), term.getBoost(), term.isNot());\n        }\n\n        private boolean visitTerm(String propertyName, String text, String boost, boolean not) {\n            String p = propertyName;\n            if (p != null && p.indexOf('/') >= 0) {\n                p = getName(p);\n            }\n            Query q = tokenToQuery(text, p, analyzer, reader);\n            if (q == null) {\n                return false;\n            }\n            if (boost != null) {\n                q.setBoost(Float.parseFloat(boost));\n            }\n            if (not) {\n                BooleanQuery bq = new BooleanQuery();\n                bq.add(q, MUST_NOT);\n                result.set(bq);\n            } else {\n                result.set(q);\n            }\n            return true;\n        }\n    });\n    return result.get();\n}", "lc": 2.1818181818181817, "pi": 0.8571428571428572, "ma": 0.8333333333333334, "nbd": 1.0, "ml": 0.5833333333333334, "d": 0.6178942165101335, "mi": -0.9827932320045887, "fo": 1.5833333333333333, "r": -0.028571428571428574, "e": 2.0448387663235983}
{"project_name": "Lang", "project_version": 7, "label": 1, "code": "/**\n * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n *\n * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n *\n * @param str  a <code>String</code> to convert, may be null\n * @return converted <code>BigDecimal</code> (or null if the input is null)\n * @throws NumberFormatException if the value cannot be converted\n */\npublic static BigDecimal createBigDecimal(String str) {\n    if (str == null) {\n        return null;\n    }\n    // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    // a wrong value.\n    return new BigDecimal(str);\n}", "code_comment": "/**\n * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n *\n * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n *\n * @param str  a <code>String</code> to convert, may be null\n * @return converted <code>BigDecimal</code> (or null if the input is null)\n * @throws NumberFormatException if the value cannot be converted\n */\n", "code_no_comment": "public static BigDecimal createBigDecimal(String str) {\n    if (str == null) {\n        return null;\n    }\n        if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n        return new BigDecimal(str);\n}", "lc": -0.22727272727272727, "pi": -0.17857142857142863, "ma": 0.0, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.3806228373702422, "mi": 0.3814166905649556, "fo": -0.4166666666666667, "r": 0.0, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-4486_f98ac676", "label": 1, "code": "private boolean doRoutingSlip(Exchange exchange, AsyncCallback callback) {\n    Exchange current = exchange;\n    RoutingSlipIterator iter;\n    try {\n        iter = createRoutingSlipIterator(exchange);\n    } catch (Exception e) {\n        exchange.setException(e);\n        callback.done(true);\n        return true;\n    }\n    // ensure the slip is empty when we start\n    if (current.hasProperties()) {\n        current.setProperty(Exchange.SLIP_ENDPOINT, null);\n    }\n    while (iter.hasNext(current)) {\n        Endpoint endpoint;\n        try {\n            endpoint = resolveEndpoint(iter, exchange);\n            // if no endpoint was resolved then try the next\n            if (endpoint == null) {\n                continue;\n            }\n        } catch (Exception e) {\n            // error resolving endpoint so we should break out\n            exchange.setException(e);\n            return true;\n        }\n        // prepare and process the routing slip\n        Exchange copy = prepareExchangeForRoutingSlip(current, endpoint);\n        boolean sync = processExchange(endpoint, copy, exchange, callback, iter);\n        current = copy;\n        if (!sync) {\n            log.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n            // so we break out now, then the callback will be invoked which then continue routing from where we left here\n            return false;\n        }\n        log.trace(\"Processing exchangeId: {} is continued being processed synchronously\", exchange.getExchangeId());\n        // we ignore some kind of exceptions and allow us to continue\n        if (isIgnoreInvalidEndpoints()) {\n            FailedToCreateProducerException e = current.getException(FailedToCreateProducerException.class);\n            if (e != null) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Endpoint uri is invalid: \" + endpoint + \". This exception will be ignored.\", e);\n                }\n                current.setException(null);\n            }\n        }\n        // check for error if so we should break out\n        if (!continueProcessing(current, \"so breaking out of the routing slip\", log)) {\n            break;\n        }\n    }\n    // logging nextExchange as it contains the exchange that might have altered the payload and since\n    // we are logging the completion if will be confusing if we log the original instead\n    // we could also consider logging the original and the nextExchange then we have *before* and *after* snapshots\n    log.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), current);\n    // copy results back to the original exchange\n    ExchangeHelper.copyResults(exchange, current);\n    callback.done(true);\n    return true;\n}", "code_comment": NaN, "code_no_comment": "private boolean doRoutingSlip(Exchange exchange, AsyncCallback callback) {\n    Exchange current = exchange;\n    RoutingSlipIterator iter;\n    try {\n        iter = createRoutingSlipIterator(exchange);\n    } catch (Exception e) {\n        exchange.setException(e);\n        callback.done(true);\n        return true;\n    }\n        if (current.hasProperties()) {\n        current.setProperty(Exchange.SLIP_ENDPOINT, null);\n    }\n    while (iter.hasNext(current)) {\n        Endpoint endpoint;\n        try {\n            endpoint = resolveEndpoint(iter, exchange);\n                        if (endpoint == null) {\n                continue;\n            }\n        } catch (Exception e) {\n                        exchange.setException(e);\n            return true;\n        }\n                Exchange copy = prepareExchangeForRoutingSlip(current, endpoint);\n        boolean sync = processExchange(endpoint, copy, exchange, callback, iter);\n        current = copy;\n        if (!sync) {\n            log.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n                        return false;\n        }\n        log.trace(\"Processing exchangeId: {} is continued being processed synchronously\", exchange.getExchangeId());\n                if (isIgnoreInvalidEndpoints()) {\n            FailedToCreateProducerException e = current.getException(FailedToCreateProducerException.class);\n            if (e != null) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Endpoint uri is invalid: \" + endpoint + \". This exception will be ignored.\", e);\n                }\n                current.setException(null);\n            }\n        }\n                if (!continueProcessing(current, \"so breaking out of the routing slip\", log)) {\n            break;\n        }\n    }\n                log.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), current);\n        ExchangeHelper.copyResults(exchange, current);\n    callback.done(true);\n    return true;\n}", "lc": 1.6363636363636365, "pi": 0.6275510204081632, "ma": 1.5, "nbd": 1.0, "ml": 1.0833333333333333, "d": 0.5862580326248147, "mi": -0.8503011184399201, "fo": 1.5, "r": -0.028571428571428574, "e": 1.2775386434013902}
{"project_name": "Closure", "project_version": 65, "label": 2, "code": "/**\n * Helper to escape javascript string as well as regular expression\n */\nstatic String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n        char c = s.charAt(i);\n        switch(c) {\n            case '\\0':\n                sb.append(\"\\\\0\");\n                break;\n            case '\\n':\n                sb.append(\"\\\\n\");\n                break;\n            case '\\r':\n                sb.append(\"\\\\r\");\n                break;\n            case '\\t':\n                sb.append(\"\\\\t\");\n                break;\n            case '\\\\':\n                sb.append(backslashEscape);\n                break;\n            case '\\\"':\n                sb.append(doublequoteEscape);\n                break;\n            case '\\'':\n                sb.append(singlequoteEscape);\n                break;\n            case // Break --> into --\\> or ]]> into ]]\\>\n            '>':\n                if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n                    sb.append(\"\\\\>\");\n                } else {\n                    sb.append(c);\n                }\n                break;\n            case '<':\n                // Break </script into <\\/script\n                final String END_SCRIPT = \"/script\";\n                // Break <!-- into <\\!--\n                final String START_COMMENT = \"!--\";\n                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {\n                    sb.append(\"<\\\\\");\n                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {\n                    sb.append(\"<\\\\\");\n                } else {\n                    sb.append(c);\n                }\n                break;\n            default:\n                // character can be represented in this character set.\n                if (outputCharsetEncoder != null) {\n                    if (outputCharsetEncoder.canEncode(c)) {\n                        sb.append(c);\n                    } else {\n                        // Unicode-escape the character.\n                        appendHexJavaScriptRepresentation(sb, c);\n                    }\n                } else {\n                    // check is measurably faster than using the CharsetEncoder.\n                    if (c > 0x1f && c < 0x7f) {\n                        sb.append(c);\n                    } else {\n                        // Other characters can be misinterpreted by some js parsers,\n                        // or perhaps mangled by proxies along the way,\n                        // so we play it safe and unicode escape them.\n                        appendHexJavaScriptRepresentation(sb, c);\n                    }\n                }\n        }\n    }\n    sb.append(quote);\n    return sb.toString();\n}", "code_comment": "/**\n * Helper to escape javascript string as well as regular expression\n */\n", "code_no_comment": "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n        char c = s.charAt(i);\n        switch(c) {\n            case '\\0':\n                sb.append(\"\\\\0\");\n                break;\n            case '\\n':\n                sb.append(\"\\\\n\");\n                break;\n            case '\\r':\n                sb.append(\"\\\\r\");\n                break;\n            case '\\t':\n                sb.append(\"\\\\t\");\n                break;\n            case '\\\\':\n                sb.append(backslashEscape);\n                break;\n            case '\\\"':\n                sb.append(doublequoteEscape);\n                break;\n            case '\\'':\n                sb.append(singlequoteEscape);\n                break;\n            case             '>':\n                if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n                    sb.append(\"\\\\>\");\n                } else {\n                    sb.append(c);\n                }\n                break;\n            case '<':\n                                final String END_SCRIPT = \"/script\";\n                                final String START_COMMENT = \"!--\";\n                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {\n                    sb.append(\"<\\\\\");\n                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {\n                    sb.append(\"<\\\\\");\n                } else {\n                    sb.append(c);\n                }\n                break;\n            default:\n                                if (outputCharsetEncoder != null) {\n                    if (outputCharsetEncoder.canEncode(c)) {\n                        sb.append(c);\n                    } else {\n                                                appendHexJavaScriptRepresentation(sb, c);\n                    }\n                } else {\n                                        if (c > 0x1f && c < 0x7f) {\n                        sb.append(c);\n                    } else {\n                                                                                                appendHexJavaScriptRepresentation(sb, c);\n                    }\n                }\n        }\n    }\n    sb.append(quote);\n    return sb.toString();\n}", "lc": 2.3181818181818183, "pi": 1.3112244897959182, "ma": 3.8333333333333335, "nbd": 1.5, "ml": 2.25, "d": 2.605042016806723, "mi": -1.1284772010324065, "fo": 2.0833333333333335, "r": -0.028571428571428574, "e": 6.663154603586587}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-43_668f08f2", "label": 1, "code": "void apply() throws Exception {\n    removeNode(nodePath);\n}", "code_comment": NaN, "code_no_comment": "void apply() throws Exception {\n    removeNode(nodePath);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.144536851161457, "fo": -0.4166666666666667, "r": 2.5142857142857147, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 24, "label": 2, "code": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        int type = n.getType();\n        Node parent = n.getParent();\n        if (parent.isVar()) {\n            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n                String name = n.getString();\n                Var aliasVar = scope.getVar(name);\n                aliases.put(name, aliasVar);\n                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n                transformation.addAlias(name, qualifiedName);\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n            } else {\n                // TODO(robbyw): Support using locals for private variables.\n                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n            }\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        int type = n.getType();\n        Node parent = n.getParent();\n        if (parent.isVar()) {\n            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n                String name = n.getString();\n                Var aliasVar = scope.getVar(name);\n                aliases.put(name, aliasVar);\n                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n                transformation.addAlias(name, qualifiedName);\n                                                            } else {\n                                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n            }\n        }\n    }\n}", "lc": 0.22727272727272727, "pi": 1.2142857142857144, "ma": 0.0, "nbd": 0.5, "ml": 0.08333333333333333, "d": -0.05239742956005931, "mi": -0.23802695726985945, "fo": 0.9166666666666666, "r": 0.028571428571428574, "e": 0.07980520898916828}
{"project_name": "Closure", "project_version": 43, "label": 2, "code": "private void attachLiteralTypes(NodeTraversal t, Node n) {\n    switch(n.getType()) {\n        case Token.NULL:\n            n.setJSType(getNativeType(NULL_TYPE));\n            break;\n        case Token.VOID:\n            n.setJSType(getNativeType(VOID_TYPE));\n            break;\n        case Token.STRING:\n            // Defer keys to the Token.OBJECTLIT case\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                n.setJSType(getNativeType(STRING_TYPE));\n            }\n            break;\n        case Token.NUMBER:\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            n.setJSType(getNativeType(BOOLEAN_TYPE));\n            break;\n        case Token.REGEXP:\n            n.setJSType(getNativeType(REGEXP_TYPE));\n            break;\n        case Token.OBJECTLIT:\n            defineObjectLiteral(n);\n            break;\n    }\n}", "code_comment": NaN, "code_no_comment": "private void attachLiteralTypes(NodeTraversal t, Node n) {\n    switch(n.getType()) {\n        case Token.NULL:\n            n.setJSType(getNativeType(NULL_TYPE));\n            break;\n        case Token.VOID:\n            n.setJSType(getNativeType(VOID_TYPE));\n            break;\n        case Token.STRING:\n                        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                n.setJSType(getNativeType(STRING_TYPE));\n            }\n            break;\n        case Token.NUMBER:\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            n.setJSType(getNativeType(BOOLEAN_TYPE));\n            break;\n        case Token.REGEXP:\n            n.setJSType(getNativeType(REGEXP_TYPE));\n            break;\n        case Token.OBJECTLIT:\n            defineObjectLiteral(n);\n            break;\n    }\n}", "lc": 0.6363636363636364, "pi": 0.37755102040816313, "ma": 2.1666666666666665, "nbd": 0.5, "ml": 0.6666666666666666, "d": -0.3806228373702422, "mi": -0.46888442787496454, "fo": 0.8333333333333334, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1705_5308ac83", "label": 1, "code": "/**\n *  Returns the host name of the instance. If the host name could not be determined, the return value will be a\n *  textual representation of the instance's IP address.\n *\n *  @return the host name of the instance\n */\npublic String getFQDNHostname() {\n    return this.fqdnHostName;\n}", "code_comment": "/**\n *  Returns the host name of the instance. If the host name could not be determined, the return value will be a\n *  textual representation of the instance's IP address.\n *\n *  @return the host name of the instance\n */\n", "code_no_comment": "public String getFQDNHostname() {\n    return this.fqdnHostName;\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.2001720676799543, "fo": -0.5, "r": 2.628571428571429, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1287_14849e22", "label": 1, "code": "public List<RecordId> getEntries() {\n    if (size == 0) {\n        return emptyList();\n    } else if (size == 1) {\n        return singletonList(getRecordId());\n    } else {\n        List<RecordId> list = newArrayListWithCapacity(size);\n        Segment segment = getSegment();\n        int offset = getOffset();\n        for (int i = 0; i < size; i += bucketSize) {\n            RecordId id = segment.readRecordId(offset);\n            if (bucketSize == 1) {\n                list.add(id);\n            } else {\n                ListRecord bucket = new ListRecord(segment, id, Math.min(bucketSize, size - offset));\n                list.addAll(bucket.getEntries());\n            }\n            offset += Segment.RECORD_ID_BYTES;\n        }\n        return list;\n    }\n}", "code_comment": NaN, "code_no_comment": "public List<RecordId> getEntries() {\n    if (size == 0) {\n        return emptyList();\n    } else if (size == 1) {\n        return singletonList(getRecordId());\n    } else {\n        List<RecordId> list = newArrayListWithCapacity(size);\n        Segment segment = getSegment();\n        int offset = getOffset();\n        for (int i = 0; i < size; i += bucketSize) {\n            RecordId id = segment.readRecordId(offset);\n            if (bucketSize == 1) {\n                list.add(id);\n            } else {\n                ListRecord bucket = new ListRecord(segment, id, Math.min(bucketSize, size - offset));\n                list.addAll(bucket.getEntries());\n            }\n            offset += Segment.RECORD_ID_BYTES;\n        }\n        return list;\n    }\n}", "lc": 0.36363636363636365, "pi": 0.7857142857142855, "ma": 0.16666666666666666, "nbd": 1.0, "ml": 0.16666666666666666, "d": 0.39644092931290176, "mi": -0.31230283911671936, "fo": 0.4166666666666667, "r": 0.028571428571428574, "e": 0.4129372411459604}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2082_0cfa43d7", "label": 3, "code": "public StreamingRuntimeContext createRuntimeContext(String taskName) {\n    Environment env = getEnvironment();\n    return new StreamingRuntimeContext(taskName, env, getUserCodeClassLoader(), getExecutionConfig());\n}", "code_comment": NaN, "code_no_comment": "public StreamingRuntimeContext createRuntimeContext(String taskName) {\n    Environment env = getEnvironment();\n    return new StreamingRuntimeContext(taskName, env, getUserCodeClassLoader(), getExecutionConfig());\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7981072555205045, "fo": -0.25, "r": 0.5714285714285714, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1822_3e83a4c1", "label": 1, "code": "@Override\npublic <T extends Document> boolean create(Collection<T> collection, List<UpdateOp> updateOps) {\n    log(\"create\", updateOps);\n    List<T> docs = new ArrayList<T>();\n    DBObject[] inserts = new DBObject[updateOps.size()];\n    for (int i = 0; i < updateOps.size(); i++) {\n        inserts[i] = new BasicDBObject();\n        UpdateOp update = updateOps.get(i);\n        T target = collection.newDocument(this);\n        UpdateUtils.applyChanges(target, update, comparator);\n        docs.add(target);\n        for (Entry<Key, Operation> entry : update.getChanges().entrySet()) {\n            Key k = entry.getKey();\n            Operation op = entry.getValue();\n            switch(op.type) {\n                case SET:\n                case INCREMENT:\n                    {\n                        inserts[i].put(k.toString(), op.value);\n                        break;\n                    }\n                case SET_MAP_ENTRY:\n                    {\n                        Revision r = k.getRevision();\n                        if (r == null) {\n                            throw new IllegalStateException(\"SET_MAP_ENTRY must not have null revision\");\n                        }\n                        DBObject value = new RevisionEntry(r, op.value);\n                        inserts[i].put(k.getName(), value);\n                        break;\n                    }\n                case REMOVE_MAP_ENTRY:\n                    // nothing to do for new entries\n                    break;\n                case CONTAINS_MAP_ENTRY:\n                    // no effect\n                    break;\n            }\n        }\n        if (!inserts[i].containsField(Document.MOD_COUNT)) {\n            inserts[i].put(Document.MOD_COUNT, 1L);\n            target.put(Document.MOD_COUNT, 1L);\n        }\n    }\n    DBCollection dbCollection = getDBCollection(collection);\n    long start = start();\n    try {\n        try {\n            WriteResult writeResult = dbCollection.insert(inserts, WriteConcern.SAFE);\n            if (writeResult.getError() != null) {\n                return false;\n            }\n            if (collection == Collection.NODES) {\n                for (T doc : docs) {\n                    Lock lock = getAndLock(doc.getId());\n                    try {\n                        addToCache((NodeDocument) doc);\n                    } finally {\n                        lock.unlock();\n                    }\n                }\n            }\n            return true;\n        } catch (MongoException e) {\n            return false;\n        }\n    } finally {\n        end(\"create\", start);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic <T extends Document> boolean create(Collection<T> collection, List<UpdateOp> updateOps) {\n    log(\"create\", updateOps);\n    List<T> docs = new ArrayList<T>();\n    DBObject[] inserts = new DBObject[updateOps.size()];\n    for (int i = 0; i < updateOps.size(); i++) {\n        inserts[i] = new BasicDBObject();\n        UpdateOp update = updateOps.get(i);\n        T target = collection.newDocument(this);\n        UpdateUtils.applyChanges(target, update, comparator);\n        docs.add(target);\n        for (Entry<Key, Operation> entry : update.getChanges().entrySet()) {\n            Key k = entry.getKey();\n            Operation op = entry.getValue();\n            switch(op.type) {\n                case SET:\n                case INCREMENT:\n                    {\n                        inserts[i].put(k.toString(), op.value);\n                        break;\n                    }\n                case SET_MAP_ENTRY:\n                    {\n                        Revision r = k.getRevision();\n                        if (r == null) {\n                            throw new IllegalStateException(\"SET_MAP_ENTRY must not have null revision\");\n                        }\n                        DBObject value = new RevisionEntry(r, op.value);\n                        inserts[i].put(k.getName(), value);\n                        break;\n                    }\n                case REMOVE_MAP_ENTRY:\n                                        break;\n                case CONTAINS_MAP_ENTRY:\n                                        break;\n            }\n        }\n        if (!inserts[i].containsField(Document.MOD_COUNT)) {\n            inserts[i].put(Document.MOD_COUNT, 1L);\n            target.put(Document.MOD_COUNT, 1L);\n        }\n    }\n    DBCollection dbCollection = getDBCollection(collection);\n    long start = start();\n    try {\n        try {\n            WriteResult writeResult = dbCollection.insert(inserts, WriteConcern.SAFE);\n            if (writeResult.getError() != null) {\n                return false;\n            }\n            if (collection == Collection.NODES) {\n                for (T doc : docs) {\n                    Lock lock = getAndLock(doc.getId());\n                    try {\n                        addToCache((NodeDocument) doc);\n                    } finally {\n                        lock.unlock();\n                    }\n                }\n            }\n            return true;\n        } catch (MongoException e) {\n            return false;\n        }\n    } finally {\n        end(\"create\", start);\n    }\n}", "lc": 2.4545454545454546, "pi": 2.198979591836735, "ma": 2.5, "nbd": 1.5, "ml": 1.0, "d": 0.7543252595155712, "mi": -1.1063951821049618, "fo": 1.8333333333333333, "r": -0.028571428571428574, "e": 2.6080623262706606}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-705_645d642b", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic void writeExternal(final ObjectOutput out) throws IOException {\n    // save the state of the base class\n    writeBaseExternal(out);\n    // save the local attributes\n    final int n = (currentState == null) ? -1 : currentState.length;\n    final int kMax = (yDotK == null) ? -1 : yDotK.length;\n    out.writeInt(kMax);\n    for (int k = 0; k < kMax; ++k) {\n        for (int i = 0; i < n; ++i) {\n            out.writeDouble(yDotK[k][i]);\n        }\n    }\n// we do not save any reference to the equations\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic void writeExternal(final ObjectOutput out) throws IOException {\n        writeBaseExternal(out);\n        final int n = (currentState == null) ? -1 : currentState.length;\n    final int kMax = (yDotK == null) ? -1 : yDotK.length;\n    out.writeInt(kMax);\n    for (int k = 0; k < kMax; ++k) {\n        for (int i = 0; i < n; ++i) {\n            out.writeDouble(yDotK[k][i]);\n        }\n    }\n}", "lc": -0.09090909090909091, "pi": 0.2193877551020409, "ma": 0.16666666666666666, "nbd": 0.0, "ml": 0.4166666666666667, "d": 0.41028175976272874, "mi": 0.02925150559219949, "fo": -0.25, "r": 2.142857142857143, "e": 0.22851966541174656}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1516_7c62bd81", "label": 1, "code": "private static Term[] extractMatchingTokens(IndexReader reader, String token) {\n    if (reader == null) {\n        // getPlan call\n        return null;\n    }\n    try {\n        List<Term> terms = new ArrayList<Term>();\n        Terms t = MultiFields.getTerms(reader, FieldNames.FULLTEXT);\n        Automaton a = WildcardQuery.toAutomaton(newFulltextTerm(token));\n        CompiledAutomaton ca = new CompiledAutomaton(a);\n        TermsEnum te = ca.getTermsEnum(t);\n        BytesRef text;\n        while ((text = te.next()) != null) {\n            terms.add(newFulltextTerm(text.utf8ToString()));\n        }\n        return terms.toArray(new Term[terms.size()]);\n    } catch (IOException e) {\n        LOG.error(\"Building fulltext query failed\", e.getMessage());\n        return null;\n    }\n}", "code_comment": NaN, "code_no_comment": "private static Term[] extractMatchingTokens(IndexReader reader, String token) {\n    if (reader == null) {\n                return null;\n    }\n    try {\n        List<Term> terms = new ArrayList<Term>();\n        Terms t = MultiFields.getTerms(reader, FieldNames.FULLTEXT);\n        Automaton a = WildcardQuery.toAutomaton(newFulltextTerm(token));\n        CompiledAutomaton ca = new CompiledAutomaton(a);\n        TermsEnum te = ca.getTermsEnum(t);\n        BytesRef text;\n        while ((text = te.next()) != null) {\n            terms.add(newFulltextTerm(text.utf8ToString()));\n        }\n        return terms.toArray(new Term[terms.size()]);\n    } catch (IOException e) {\n        LOG.error(\"Building fulltext query failed\", e.getMessage());\n        return null;\n    }\n}", "lc": 0.2727272727272727, "pi": -0.04081632653061228, "ma": 0.0, "nbd": 0.0, "ml": -0.16666666666666666, "d": -0.08007909045971327, "mi": -0.27444794952681417, "fo": 0.5, "r": 0.028571428571428574, "e": 0.0803234524436678}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-177_f91ce934", "label": 1, "code": "@Override\npublic synchronized void flush() throws IOException {\n    if (this.ds != null && this.address != null) {\n        final DatagramPacket packet = new DatagramPacket(data, data.length, address, port);\n        ds.send(packet);\n    }\n    data = null;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic synchronized void flush() throws IOException {\n    if (this.ds != null && this.address != null) {\n        final DatagramPacket packet = new DatagramPacket(data, data.length, address, port);\n        ds.send(packet);\n    }\n    data = null;\n}", "lc": -0.2727272727272727, "pi": 0.051020408163265356, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.06030647553138898, "mi": 0.35531975910524816, "fo": -0.4166666666666667, "r": 0.4285714285714286, "e": -0.09227303292344988}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5853_b80f6640", "label": 3, "code": "/**\n *  @see org.apache.wicket.util.convert.converter.AbstractConverter#getTargetType()\n */\n@Override\nprotected Class<Integer> getTargetType() {\n    return Integer.class;\n}", "code_comment": "/**\n *  @see org.apache.wicket.util.convert.converter.AbstractConverter#getTargetType()\n */\n", "code_no_comment": "@Override\nprotected Class<Integer> getTargetType() {\n    return Integer.class;\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9836535704043596, "fo": -0.5, "r": 2.2571428571428576, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-412_5594b2e0", "label": 1, "code": "public AssignmentStats importFiles(List<String> files, Path failureDir) throws IOException, AccumuloException, AccumuloSecurityException, ThriftTableOperationException {\n    int numThreads = acuConf.getCount(Property.TSERV_BULK_PROCESS_THREADS);\n    int numAssignThreads = acuConf.getCount(Property.TSERV_BULK_ASSIGNMENT_THREADS);\n    timer = new StopWatch<Timers>(Timers.class);\n    timer.start(Timers.TOTAL);\n    Configuration conf = CachedConfiguration.getInstance();\n    final FileSystem fs = FileSystem.get(conf);\n    Set<Path> paths = new HashSet<Path>();\n    for (String file : files) {\n        paths.add(new Path(file));\n    }\n    AssignmentStats assignmentStats = new AssignmentStats(paths.size());\n    final Map<Path, List<KeyExtent>> completeFailures = Collections.synchronizedSortedMap(new TreeMap<Path, List<KeyExtent>>());\n    if (!fs.exists(failureDir)) {\n        log.error(failureDir + \" does not exist\");\n        throw new RuntimeException(\"Directory does not exist \" + failureDir);\n    }\n    ClientService.Iface client = null;\n    final TabletLocator locator = TabletLocator.getInstance(instance, credentials, new Text(tableId));\n    try {\n        final Map<Path, List<TabletLocation>> assignments = Collections.synchronizedSortedMap(new TreeMap<Path, List<TabletLocation>>());\n        timer.start(Timers.EXAMINE_MAP_FILES);\n        ExecutorService threadPool = Executors.newFixedThreadPool(numThreads);\n        for (Path path : paths) {\n            final Path mapFile = path;\n            Runnable getAssignments = new Runnable() {\n\n                public void run() {\n                    List<TabletLocation> tabletsToAssignMapFileTo = Collections.emptyList();\n                    try {\n                        tabletsToAssignMapFileTo = findOverlappingTablets(instance.getConfiguration(), fs, locator, mapFile);\n                    } catch (Exception ex) {\n                        log.warn(\"Unable to find tablets that overlap file \" + mapFile.toString());\n                    }\n                    if (tabletsToAssignMapFileTo.size() == 0) {\n                        List<KeyExtent> empty = Collections.emptyList();\n                        completeFailures.put(mapFile, empty);\n                    } else\n                        assignments.put(mapFile, tabletsToAssignMapFileTo);\n                }\n            };\n            threadPool.submit(new TraceRunnable(new LoggingRunnable(log, getAssignments)));\n        }\n        threadPool.shutdown();\n        while (!threadPool.isTerminated()) {\n            try {\n                threadPool.awaitTermination(60, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        timer.stop(Timers.EXAMINE_MAP_FILES);\n        assignmentStats.attemptingAssignments(assignments);\n        Map<Path, List<KeyExtent>> assignmentFailures = assignMapFiles(acuConf, instance, conf, credentials, fs, tableId, assignments, paths, numAssignThreads, numThreads);\n        assignmentStats.assignmentsFailed(assignmentFailures);\n        Map<Path, Integer> failureCount = new TreeMap<Path, Integer>();\n        for (Entry<Path, List<KeyExtent>> entry : assignmentFailures.entrySet()) failureCount.put(entry.getKey(), 1);\n        while (assignmentFailures.size() > 0) {\n            locator.invalidateCache();\n            // assumption about assignment failures is that it caused by a split\n            // happening or a missing location\n            // \n            // for splits we need to find children key extents that cover the\n            // same key range and are contiguous (no holes, no overlap)\n            timer.start(Timers.SLEEP);\n            UtilWaitThread.sleep(4000);\n            timer.stop(Timers.SLEEP);\n            log.debug(\"Trying to assign \" + assignmentFailures.size() + \" map files that previously failed on some key extents\");\n            assignments.clear();\n            // assign to\n            for (Entry<Path, List<KeyExtent>> entry : assignmentFailures.entrySet()) {\n                Iterator<KeyExtent> keListIter = entry.getValue().iterator();\n                List<TabletLocation> tabletsToAssignMapFileTo = new ArrayList<TabletLocation>();\n                while (keListIter.hasNext()) {\n                    KeyExtent ke = keListIter.next();\n                    try {\n                        timer.start(Timers.QUERY_METADATA);\n                        tabletsToAssignMapFileTo.addAll(findOverlappingTablets(instance.getConfiguration(), fs, locator, entry.getKey(), ke));\n                        timer.stop(Timers.QUERY_METADATA);\n                        keListIter.remove();\n                    } catch (Exception ex) {\n                        log.warn(\"Exception finding overlapping tablets, will retry tablet \" + ke);\n                    }\n                }\n                if (tabletsToAssignMapFileTo.size() > 0)\n                    assignments.put(entry.getKey(), tabletsToAssignMapFileTo);\n            }\n            assignmentStats.attemptingAssignments(assignments);\n            Map<Path, List<KeyExtent>> assignmentFailures2 = assignMapFiles(acuConf, instance, conf, credentials, fs, tableId, assignments, paths, numAssignThreads, numThreads);\n            assignmentStats.assignmentsFailed(assignmentFailures2);\n            // merge assignmentFailures2 into assignmentFailures\n            for (Entry<Path, List<KeyExtent>> entry : assignmentFailures2.entrySet()) {\n                assignmentFailures.get(entry.getKey()).addAll(entry.getValue());\n                Integer fc = failureCount.get(entry.getKey());\n                if (fc == null)\n                    fc = 0;\n                failureCount.put(entry.getKey(), fc + 1);\n            }\n            // remove map files that have no more key extents to assign\n            Iterator<Entry<Path, List<KeyExtent>>> afIter = assignmentFailures.entrySet().iterator();\n            while (afIter.hasNext()) {\n                Entry<Path, List<KeyExtent>> entry = afIter.next();\n                if (entry.getValue().size() == 0)\n                    afIter.remove();\n            }\n            Set<Entry<Path, Integer>> failureIter = failureCount.entrySet();\n            for (Entry<Path, Integer> entry : failureIter) {\n                if (entry.getValue() > acuConf.getCount(Property.TSERV_BULK_RETRY) && assignmentFailures.get(entry.getKey()) != null) {\n                    log.error(\"Map file \" + entry.getKey() + \" failed more than three times, giving up.\");\n                    completeFailures.put(entry.getKey(), assignmentFailures.get(entry.getKey()));\n                    assignmentFailures.remove(entry.getKey());\n                }\n            }\n        }\n        assignmentStats.assignmentsAbandoned(completeFailures);\n        Set<Path> failedFailures = processFailures(conf, fs, failureDir, completeFailures);\n        assignmentStats.unrecoveredMapFiles(failedFailures);\n        timer.stop(Timers.TOTAL);\n        printReport();\n        return assignmentStats;\n    } finally {\n        if (client != null)\n            ServerClient.close(client);\n        locator.invalidateCache();\n    }\n}", "code_comment": NaN, "code_no_comment": "public AssignmentStats importFiles(List<String> files, Path failureDir) throws IOException, AccumuloException, AccumuloSecurityException, ThriftTableOperationException {\n    int numThreads = acuConf.getCount(Property.TSERV_BULK_PROCESS_THREADS);\n    int numAssignThreads = acuConf.getCount(Property.TSERV_BULK_ASSIGNMENT_THREADS);\n    timer = new StopWatch<Timers>(Timers.class);\n    timer.start(Timers.TOTAL);\n    Configuration conf = CachedConfiguration.getInstance();\n    final FileSystem fs = FileSystem.get(conf);\n    Set<Path> paths = new HashSet<Path>();\n    for (String file : files) {\n        paths.add(new Path(file));\n    }\n    AssignmentStats assignmentStats = new AssignmentStats(paths.size());\n    final Map<Path, List<KeyExtent>> completeFailures = Collections.synchronizedSortedMap(new TreeMap<Path, List<KeyExtent>>());\n    if (!fs.exists(failureDir)) {\n        log.error(failureDir + \" does not exist\");\n        throw new RuntimeException(\"Directory does not exist \" + failureDir);\n    }\n    ClientService.Iface client = null;\n    final TabletLocator locator = TabletLocator.getInstance(instance, credentials, new Text(tableId));\n    try {\n        final Map<Path, List<TabletLocation>> assignments = Collections.synchronizedSortedMap(new TreeMap<Path, List<TabletLocation>>());\n        timer.start(Timers.EXAMINE_MAP_FILES);\n        ExecutorService threadPool = Executors.newFixedThreadPool(numThreads);\n        for (Path path : paths) {\n            final Path mapFile = path;\n            Runnable getAssignments = new Runnable() {\n\n                public void run() {\n                    List<TabletLocation> tabletsToAssignMapFileTo = Collections.emptyList();\n                    try {\n                        tabletsToAssignMapFileTo = findOverlappingTablets(instance.getConfiguration(), fs, locator, mapFile);\n                    } catch (Exception ex) {\n                        log.warn(\"Unable to find tablets that overlap file \" + mapFile.toString());\n                    }\n                    if (tabletsToAssignMapFileTo.size() == 0) {\n                        List<KeyExtent> empty = Collections.emptyList();\n                        completeFailures.put(mapFile, empty);\n                    } else\n                        assignments.put(mapFile, tabletsToAssignMapFileTo);\n                }\n            };\n            threadPool.submit(new TraceRunnable(new LoggingRunnable(log, getAssignments)));\n        }\n        threadPool.shutdown();\n        while (!threadPool.isTerminated()) {\n            try {\n                threadPool.awaitTermination(60, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        timer.stop(Timers.EXAMINE_MAP_FILES);\n        assignmentStats.attemptingAssignments(assignments);\n        Map<Path, List<KeyExtent>> assignmentFailures = assignMapFiles(acuConf, instance, conf, credentials, fs, tableId, assignments, paths, numAssignThreads, numThreads);\n        assignmentStats.assignmentsFailed(assignmentFailures);\n        Map<Path, Integer> failureCount = new TreeMap<Path, Integer>();\n        for (Entry<Path, List<KeyExtent>> entry : assignmentFailures.entrySet()) failureCount.put(entry.getKey(), 1);\n        while (assignmentFailures.size() > 0) {\n            locator.invalidateCache();\n                                                                        timer.start(Timers.SLEEP);\n            UtilWaitThread.sleep(4000);\n            timer.stop(Timers.SLEEP);\n            log.debug(\"Trying to assign \" + assignmentFailures.size() + \" map files that previously failed on some key extents\");\n            assignments.clear();\n                        for (Entry<Path, List<KeyExtent>> entry : assignmentFailures.entrySet()) {\n                Iterator<KeyExtent> keListIter = entry.getValue().iterator();\n                List<TabletLocation> tabletsToAssignMapFileTo = new ArrayList<TabletLocation>();\n                while (keListIter.hasNext()) {\n                    KeyExtent ke = keListIter.next();\n                    try {\n                        timer.start(Timers.QUERY_METADATA);\n                        tabletsToAssignMapFileTo.addAll(findOverlappingTablets(instance.getConfiguration(), fs, locator, entry.getKey(), ke));\n                        timer.stop(Timers.QUERY_METADATA);\n                        keListIter.remove();\n                    } catch (Exception ex) {\n                        log.warn(\"Exception finding overlapping tablets, will retry tablet \" + ke);\n                    }\n                }\n                if (tabletsToAssignMapFileTo.size() > 0)\n                    assignments.put(entry.getKey(), tabletsToAssignMapFileTo);\n            }\n            assignmentStats.attemptingAssignments(assignments);\n            Map<Path, List<KeyExtent>> assignmentFailures2 = assignMapFiles(acuConf, instance, conf, credentials, fs, tableId, assignments, paths, numAssignThreads, numThreads);\n            assignmentStats.assignmentsFailed(assignmentFailures2);\n                        for (Entry<Path, List<KeyExtent>> entry : assignmentFailures2.entrySet()) {\n                assignmentFailures.get(entry.getKey()).addAll(entry.getValue());\n                Integer fc = failureCount.get(entry.getKey());\n                if (fc == null)\n                    fc = 0;\n                failureCount.put(entry.getKey(), fc + 1);\n            }\n                        Iterator<Entry<Path, List<KeyExtent>>> afIter = assignmentFailures.entrySet().iterator();\n            while (afIter.hasNext()) {\n                Entry<Path, List<KeyExtent>> entry = afIter.next();\n                if (entry.getValue().size() == 0)\n                    afIter.remove();\n            }\n            Set<Entry<Path, Integer>> failureIter = failureCount.entrySet();\n            for (Entry<Path, Integer> entry : failureIter) {\n                if (entry.getValue() > acuConf.getCount(Property.TSERV_BULK_RETRY) && assignmentFailures.get(entry.getKey()) != null) {\n                    log.error(\"Map file \" + entry.getKey() + \" failed more than three times, giving up.\");\n                    completeFailures.put(entry.getKey(), assignmentFailures.get(entry.getKey()));\n                    assignmentFailures.remove(entry.getKey());\n                }\n            }\n        }\n        assignmentStats.assignmentsAbandoned(completeFailures);\n        Set<Path> failedFailures = processFailures(conf, fs, failureDir, completeFailures);\n        assignmentStats.unrecoveredMapFiles(failedFailures);\n        timer.stop(Timers.TOTAL);\n        printReport();\n        return assignmentStats;\n    } finally {\n        if (client != null)\n            ServerClient.close(client);\n        locator.invalidateCache();\n    }\n}", "lc": 4.681818181818182, "pi": 1.6581632653061222, "ma": 3.1666666666666665, "nbd": 1.5, "ml": 1.75, "d": 1.4740484429065748, "mi": -1.5557786062517929, "fo": 7.583333333333333, "r": -0.028571428571428574, "e": 14.076528711115678}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3455_f30bd1cb", "label": 1, "code": "/**\n *  Removes all children from this container.\n *  <p>\n *  Note: implementation does not call {@link MarkupContainer#remove(Component) } for each\n *  component.\n */\npublic final void removeAll() {\n    if (children != null) {\n        addStateChange();\n        // Loop through child components\n        int size = children_size();\n        for (int i = 0; i < size; i++) {\n            Object childObject = children_get(i, false);\n            if (childObject instanceof Component) {\n                // Get next child\n                final Component child = (Component) childObject;\n                // Do not call remove() because the state change would than be\n                // recorded twice.\n                child.detachModel();\n                child.setParent(null);\n            }\n        }\n        children = null;\n    }\n}", "code_comment": "/**\n *  Removes all children from this container.\n *  <p>\n *  Note: implementation does not call {@link MarkupContainer#remove(Component) } for each\n *  component.\n */\n", "code_no_comment": "public final void removeAll() {\n    if (children != null) {\n        addStateChange();\n                int size = children_size();\n        for (int i = 0; i < size; i++) {\n            Object childObject = children_get(i, false);\n            if (childObject instanceof Component) {\n                                final Component child = (Component) childObject;\n                                                child.detachModel();\n                child.setParent(null);\n            }\n        }\n        children = null;\n    }\n}", "lc": 0.045454545454545456, "pi": 1.0612244897959182, "ma": 0.0, "nbd": 0.5, "ml": 0.16666666666666666, "d": 0.3173504695996046, "mi": -0.020361342127903876, "fo": -0.08333333333333333, "r": 1.885714285714286, "e": 0.08807997224613567}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-949_f83bbc1d", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\nprotected PointValuePair doOptimize() {\n    checkParameters();\n    final GoalType goal = getGoalType();\n    final double[] guess = getStartPoint();\n    final int n = guess.length;\n    final double[][] direc = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        direc[i][i] = 1;\n    }\n    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n    double[] x = guess;\n    double fVal = computeObjectiveValue(x);\n    double[] x1 = x.clone();\n    int iter = 0;\n    while (true) {\n        ++iter;\n        double fX = fVal;\n        double fX2 = 0;\n        double delta = 0;\n        int bigInd = 0;\n        double alphaMin = 0;\n        for (int i = 0; i < n; i++) {\n            final double[] d = MathArrays.copyOf(direc[i]);\n            fX2 = fVal;\n            final UnivariatePointValuePair optimum = line.search(x, d);\n            fVal = optimum.getValue();\n            alphaMin = optimum.getPoint();\n            final double[][] result = newPointAndDirection(x, d, alphaMin);\n            x = result[0];\n            if ((fX2 - fVal) > delta) {\n                delta = fX2 - fVal;\n                bigInd = i;\n            }\n        }\n        // Default convergence check.\n        boolean stop = 2 * (fX - fVal) <= (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) + absoluteThreshold);\n        final PointValuePair previous = new PointValuePair(x1, fX);\n        final PointValuePair current = new PointValuePair(x, fVal);\n        if (!stop) {\n            // User-defined stopping criteria.\n            if (checker != null) {\n                stop = checker.converged(iter, previous, current);\n            }\n        }\n        if (stop) {\n            if (goal == GoalType.MINIMIZE) {\n                return (fVal < fX) ? current : previous;\n            } else {\n                return (fVal > fX) ? current : previous;\n            }\n        }\n        final double[] d = new double[n];\n        final double[] x2 = new double[n];\n        for (int i = 0; i < n; i++) {\n            d[i] = x[i] - x1[i];\n            x2[i] = 2 * x[i] - x1[i];\n        }\n        x1 = x.clone();\n        fX2 = computeObjectiveValue(x2);\n        if (fX > fX2) {\n            double t = 2 * (fX + fX2 - 2 * fVal);\n            double temp = fX - fVal - delta;\n            t *= temp * temp;\n            temp = fX - fX2;\n            t -= delta * temp * temp;\n            if (t < 0.0) {\n                final UnivariatePointValuePair optimum = line.search(x, d);\n                fVal = optimum.getValue();\n                alphaMin = optimum.getPoint();\n                final double[][] result = newPointAndDirection(x, d, alphaMin);\n                x = result[0];\n                final int lastInd = n - 1;\n                direc[bigInd] = direc[lastInd];\n                direc[lastInd] = result[1];\n            }\n        }\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\nprotected PointValuePair doOptimize() {\n    checkParameters();\n    final GoalType goal = getGoalType();\n    final double[] guess = getStartPoint();\n    final int n = guess.length;\n    final double[][] direc = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        direc[i][i] = 1;\n    }\n    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n    double[] x = guess;\n    double fVal = computeObjectiveValue(x);\n    double[] x1 = x.clone();\n    int iter = 0;\n    while (true) {\n        ++iter;\n        double fX = fVal;\n        double fX2 = 0;\n        double delta = 0;\n        int bigInd = 0;\n        double alphaMin = 0;\n        for (int i = 0; i < n; i++) {\n            final double[] d = MathArrays.copyOf(direc[i]);\n            fX2 = fVal;\n            final UnivariatePointValuePair optimum = line.search(x, d);\n            fVal = optimum.getValue();\n            alphaMin = optimum.getPoint();\n            final double[][] result = newPointAndDirection(x, d, alphaMin);\n            x = result[0];\n            if ((fX2 - fVal) > delta) {\n                delta = fX2 - fVal;\n                bigInd = i;\n            }\n        }\n                boolean stop = 2 * (fX - fVal) <= (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) + absoluteThreshold);\n        final PointValuePair previous = new PointValuePair(x1, fX);\n        final PointValuePair current = new PointValuePair(x, fVal);\n        if (!stop) {\n                        if (checker != null) {\n                stop = checker.converged(iter, previous, current);\n            }\n        }\n        if (stop) {\n            if (goal == GoalType.MINIMIZE) {\n                return (fVal < fX) ? current : previous;\n            } else {\n                return (fVal > fX) ? current : previous;\n            }\n        }\n        final double[] d = new double[n];\n        final double[] x2 = new double[n];\n        for (int i = 0; i < n; i++) {\n            d[i] = x[i] - x1[i];\n            x2[i] = 2 * x[i] - x1[i];\n        }\n        x1 = x.clone();\n        fX2 = computeObjectiveValue(x2);\n        if (fX > fX2) {\n            double t = 2 * (fX + fX2 - 2 * fVal);\n            double temp = fX - fVal - delta;\n            t *= temp * temp;\n            temp = fX - fX2;\n            t -= delta * temp * temp;\n            if (t < 0.0) {\n                final UnivariatePointValuePair optimum = line.search(x, d);\n                fVal = optimum.getValue();\n                alphaMin = optimum.getPoint();\n                final double[][] result = newPointAndDirection(x, d, alphaMin);\n                x = result[0];\n                final int lastInd = n - 1;\n                direc[bigInd] = direc[lastInd];\n                direc[lastInd] = result[1];\n            }\n        }\n    }\n}", "lc": 2.8636363636363638, "pi": 0.6683673469387755, "ma": 1.6666666666666667, "nbd": 0.5, "ml": 1.5, "d": 4.058329214038557, "mi": -1.205620877545168, "fo": 1.1666666666666667, "r": -0.028571428571428574, "e": 17.69224476509866}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5147_184e51e9", "label": 1, "code": "/**\n *  @see javax.servlet.Filter#destroy()\n */\n@Override\npublic void destroy() {\n    if (application != null) {\n        try {\n            ThreadContext.setApplication(application);\n            application.internalDestroy();\n        } finally {\n            ThreadContext.detach();\n            application = null;\n        }\n    }\n    if (applicationFactory != null) {\n        applicationFactory.destroy(this);\n    }\n}", "code_comment": "/**\n *  @see javax.servlet.Filter#destroy()\n */\n", "code_no_comment": "@Override\npublic void destroy() {\n    if (application != null) {\n        try {\n            ThreadContext.setApplication(application);\n            application.internalDestroy();\n        } finally {\n            ThreadContext.detach();\n            application = null;\n        }\n    }\n    if (applicationFactory != null) {\n        applicationFactory.destroy(this);\n    }\n}", "lc": 0.045454545454545456, "pi": 0.6683673469387755, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.0247157686604053, "mi": 0.10496128477201025, "fo": -0.16666666666666666, "r": 1.2857142857142858, "e": -0.10618851212732514}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1075_79467350", "label": 1, "code": "public static boolean match(PropertyValue p1, PropertyValue p2) {\n    if (p1.getType().tag() != p2.getType().tag()) {\n        return false;\n    }\n    switch(p1.getType().tag()) {\n        case PropertyType.BINARY:\n            if (p1.isArray() && !p2.isArray()) {\n                return contains(p1.getValue(Type.BINARIES), p2.getValue(Type.BINARY));\n            }\n            if (!p1.isArray() && p2.isArray()) {\n                return contains(p2.getValue(Type.BINARIES), p2.getValue(Type.BINARY));\n            }\n            break;\n        default:\n            if (p1.isArray() && !p2.isArray()) {\n                return contains(p1.getValue(Type.STRINGS), p2.getValue(Type.STRING));\n            }\n            if (!p1.isArray() && p2.isArray()) {\n                return contains(p2.getValue(Type.STRINGS), p1.getValue(Type.STRING));\n            }\n    }\n    // both arrays or both single values\n    return p1.compareTo(p2) == 0;\n}", "code_comment": NaN, "code_no_comment": "public static boolean match(PropertyValue p1, PropertyValue p2) {\n    if (p1.getType().tag() != p2.getType().tag()) {\n        return false;\n    }\n    switch(p1.getType().tag()) {\n        case PropertyType.BINARY:\n            if (p1.isArray() && !p2.isArray()) {\n                return contains(p1.getValue(Type.BINARIES), p2.getValue(Type.BINARY));\n            }\n            if (!p1.isArray() && p2.isArray()) {\n                return contains(p2.getValue(Type.BINARIES), p2.getValue(Type.BINARY));\n            }\n            break;\n        default:\n            if (p1.isArray() && !p2.isArray()) {\n                return contains(p1.getValue(Type.STRINGS), p2.getValue(Type.STRING));\n            }\n            if (!p1.isArray() && p2.isArray()) {\n                return contains(p2.getValue(Type.STRINGS), p1.getValue(Type.STRING));\n            }\n    }\n        return p1.compareTo(p2) == 0;\n}", "lc": 0.4090909090909091, "pi": 0.9846938775510206, "ma": 0.8333333333333334, "nbd": 0.5, "ml": 0.75, "d": 1.1596638655462188, "mi": -0.3745339833667911, "fo": 1.75, "r": -0.028571428571428574, "e": 1.103473087745898}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-305_ef9b639a", "label": 1, "code": "/**\n * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>2</sub> distance between the two points\n */\npublic static double distance(int[] p1, int[] p2) {\n    int sum = 0;\n    for (int i = 0; i < p1.length; i++) {\n        final int dp = p1[i] - p2[i];\n        sum += dp * dp;\n    }\n    return Math.sqrt(sum);\n}", "code_comment": "/**\n * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>2</sub> distance between the two points\n */\n", "code_no_comment": "public static double distance(int[] p1, int[] p2) {\n    int sum = 0;\n    for (int i = 0; i < p1.length; i++) {\n        final int dp = p1[i] - p2[i];\n        sum += dp * dp;\n    }\n    return Math.sqrt(sum);\n}", "lc": -0.2727272727272727, "pi": -0.09693877551020405, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.16666666666666666, "d": 0.8591201186356896, "mi": 0.3260682535130487, "fo": -0.4166666666666667, "r": 2.142857142857143, "e": 0.17619849152607708}
{"project_name": "Csv", "project_version": 9, "label": 1, "code": "/**\n * Puts all values of this record into the given Map.\n *\n * @param map The Map to populate.\n * @return the given map.\n */\n<M extends Map<String, String>> M putIn(final M map) {\n    for (final Entry<String, Integer> entry : mapping.entrySet()) {\n        final int col = entry.getValue().intValue();\n        if (col < values.length) {\n            map.put(entry.getKey(), values[col]);\n        }\n    }\n    return map;\n}", "code_comment": "/**\n * Puts all values of this record into the given Map.\n *\n * @param map The Map to populate.\n * @return the given map.\n */\n", "code_no_comment": "<M extends Map<String, String>> M putIn(final M map) {\n    for (final Entry<String, Integer> entry : mapping.entrySet()) {\n        final int col = entry.getValue().intValue();\n        if (col < values.length) {\n            map.put(entry.getKey(), values[col]);\n        }\n    }\n    return map;\n}", "lc": -0.22727272727272727, "pi": 0.3826530612244898, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.16666666666666666, "d": -0.06228373702422141, "mi": 0.2563808431316318, "fo": -0.08333333333333333, "r": 0.6285714285714287, "e": -0.07177457694630397}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3634_90ad50da", "label": 1, "code": "@CheckForNull\nprivate <T extends Document> void internalUpdate(Collection<T> collection, List<String> ids, UpdateOp update) {\n    if (isAppendableUpdate(update) && !requiresPreviousState(update)) {\n        Operation modOperation = update.getChanges().get(MODIFIEDKEY);\n        long modified = getModifiedFromOperation(modOperation);\n        boolean modifiedIsConditional = modOperation == null || modOperation.type != UpdateOp.Operation.Type.SET;\n        String appendData = ser.asString(update);\n        for (List<String> chunkedIds : Lists.partition(ids, CHUNKSIZE)) {\n            Set<QueryContext> seenQueryContext = Collections.emptySet();\n            Map<String, NodeDocument> cachedDocs = Collections.emptyMap();\n            if (collection == Collection.NODES) {\n                // remember what we already have in the cache\n                cachedDocs = new HashMap<String, NodeDocument>();\n                for (String key : chunkedIds) {\n                    cachedDocs.put(key, nodesCache.getIfPresent(key));\n                }\n                // keep concurrently running queries from updating\n                // the cache entry for this key\n                seenQueryContext = new HashSet<QueryContext>();\n                for (QueryContext qc : qmap.values()) {\n                    qc.addKeys(chunkedIds);\n                    seenQueryContext.add(qc);\n                }\n            }\n            Connection connection = null;\n            RDBTableMetaData tmd = getTable(collection);\n            boolean success = false;\n            try {\n                connection = this.ch.getRWConnection();\n                success = db.batchedAppendingUpdate(connection, tmd, chunkedIds, modified, modifiedIsConditional, appendData);\n                connection.commit();\n            } catch (SQLException ex) {\n                success = false;\n                this.ch.rollbackConnection(connection);\n            } finally {\n                this.ch.closeConnection(connection);\n            }\n            if (success) {\n                if (collection == Collection.NODES) {\n                    // the cache entry for this key\n                    for (QueryContext qc : qmap.values()) {\n                        if (!seenQueryContext.contains(qc)) {\n                            qc.addKeys(chunkedIds);\n                        }\n                    }\n                }\n                for (Entry<String, NodeDocument> entry : cachedDocs.entrySet()) {\n                    T oldDoc = castAsT(entry.getValue());\n                    String id = entry.getKey();\n                    Lock lock = locks.acquire(id);\n                    try {\n                        if (oldDoc == null) {\n                            // make sure concurrently loaded document is\n                            // invalidated\n                            nodesCache.invalidate(id);\n                        } else {\n                            addUpdateCounters(update);\n                            T newDoc = createNewDocument(collection, oldDoc, update);\n                            nodesCache.replaceCachedDocument((NodeDocument) oldDoc, (NodeDocument) newDoc);\n                        }\n                    } finally {\n                        lock.unlock();\n                    }\n                }\n            } else {\n                for (String id : chunkedIds) {\n                    UpdateOp up = update.copy();\n                    up = up.shallowCopy(id);\n                    internalCreateOrUpdate(collection, up, false, true);\n                }\n            }\n        }\n    } else {\n        for (String id : ids) {\n            UpdateOp up = update.copy();\n            up = up.shallowCopy(id);\n            internalCreateOrUpdate(collection, up, false, true);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@CheckForNull\nprivate <T extends Document> void internalUpdate(Collection<T> collection, List<String> ids, UpdateOp update) {\n    if (isAppendableUpdate(update) && !requiresPreviousState(update)) {\n        Operation modOperation = update.getChanges().get(MODIFIEDKEY);\n        long modified = getModifiedFromOperation(modOperation);\n        boolean modifiedIsConditional = modOperation == null || modOperation.type != UpdateOp.Operation.Type.SET;\n        String appendData = ser.asString(update);\n        for (List<String> chunkedIds : Lists.partition(ids, CHUNKSIZE)) {\n            Set<QueryContext> seenQueryContext = Collections.emptySet();\n            Map<String, NodeDocument> cachedDocs = Collections.emptyMap();\n            if (collection == Collection.NODES) {\n                                cachedDocs = new HashMap<String, NodeDocument>();\n                for (String key : chunkedIds) {\n                    cachedDocs.put(key, nodesCache.getIfPresent(key));\n                }\n                                                seenQueryContext = new HashSet<QueryContext>();\n                for (QueryContext qc : qmap.values()) {\n                    qc.addKeys(chunkedIds);\n                    seenQueryContext.add(qc);\n                }\n            }\n            Connection connection = null;\n            RDBTableMetaData tmd = getTable(collection);\n            boolean success = false;\n            try {\n                connection = this.ch.getRWConnection();\n                success = db.batchedAppendingUpdate(connection, tmd, chunkedIds, modified, modifiedIsConditional, appendData);\n                connection.commit();\n            } catch (SQLException ex) {\n                success = false;\n                this.ch.rollbackConnection(connection);\n            } finally {\n                this.ch.closeConnection(connection);\n            }\n            if (success) {\n                if (collection == Collection.NODES) {\n                                        for (QueryContext qc : qmap.values()) {\n                        if (!seenQueryContext.contains(qc)) {\n                            qc.addKeys(chunkedIds);\n                        }\n                    }\n                }\n                for (Entry<String, NodeDocument> entry : cachedDocs.entrySet()) {\n                    T oldDoc = castAsT(entry.getValue());\n                    String id = entry.getKey();\n                    Lock lock = locks.acquire(id);\n                    try {\n                        if (oldDoc == null) {\n                                                                                    nodesCache.invalidate(id);\n                        } else {\n                            addUpdateCounters(update);\n                            T newDoc = createNewDocument(collection, oldDoc, update);\n                            nodesCache.replaceCachedDocument((NodeDocument) oldDoc, (NodeDocument) newDoc);\n                        }\n                    } finally {\n                        lock.unlock();\n                    }\n                }\n            } else {\n                for (String id : chunkedIds) {\n                    UpdateOp up = update.copy();\n                    up = up.shallowCopy(id);\n                    internalCreateOrUpdate(collection, up, false, true);\n                }\n            }\n        }\n    } else {\n        for (String id : ids) {\n            UpdateOp up = update.copy();\n            up = up.shallowCopy(id);\n            internalCreateOrUpdate(collection, up, false, true);\n        }\n    }\n}", "lc": 2.727272727272727, "pi": 1.8520408163265307, "ma": 1.8333333333333333, "nbd": 2.0, "ml": 0.8333333333333334, "d": 0.9263470093919923, "mi": -1.169773444221394, "fo": 2.75, "r": -0.028571428571428574, "e": 4.309909585790707}
{"project_name": "JxPath", "project_version": 9, "label": 1, "code": "protected boolean equal(Object l, Object r) {\n    if (l instanceof Pointer && r instanceof Pointer) {\n        if (l.equals(r)) {\n            return true;\n        }\n    }\n    if (l instanceof Pointer) {\n        l = ((Pointer) l).getValue();\n    }\n    if (r instanceof Pointer) {\n        r = ((Pointer) r).getValue();\n    }\n    if (l == r) {\n        return true;\n    }\n    if (l instanceof Boolean || r instanceof Boolean) {\n        return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));\n    }\n    // if either side is NaN, no comparison returns true:\n    if (l instanceof Number || r instanceof Number) {\n        return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));\n    }\n    if (l instanceof String || r instanceof String) {\n        return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));\n    }\n    return l != null && l.equals(r);\n}", "code_comment": NaN, "code_no_comment": "protected boolean equal(Object l, Object r) {\n    if (l instanceof Pointer && r instanceof Pointer) {\n        if (l.equals(r)) {\n            return true;\n        }\n    }\n    if (l instanceof Pointer) {\n        l = ((Pointer) l).getValue();\n    }\n    if (r instanceof Pointer) {\n        r = ((Pointer) r).getValue();\n    }\n    if (l == r) {\n        return true;\n    }\n    if (l instanceof Boolean || r instanceof Boolean) {\n        return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));\n    }\n        if (l instanceof Number || r instanceof Number) {\n        return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));\n    }\n    if (l instanceof String || r instanceof String) {\n        return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));\n    }\n    return l != null && l.equals(r);\n}", "lc": 0.5454545454545454, "pi": -0.18367346938775503, "ma": 0.8333333333333334, "nbd": 0.0, "ml": 0.8333333333333334, "d": 1.1319822046465648, "mi": -0.41468310868941816, "fo": 0.4166666666666667, "r": -0.028571428571428574, "e": 0.9458071534728735}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5398_19e7c1cd", "label": 3, "code": "/**\n *  Reads and parses markup from an input stream\n *\n *  @param inputStream\n *             The input stream to read and parse\n *  @param encoding\n *             The default character encoding of the input\n *  @throws IOException\n */\n@Override\npublic void parse(final InputStream inputStream, final String encoding) throws IOException {\n    Args.notNull(inputStream, \"inputStream\");\n    try {\n        xmlReader = new XmlReader(new BufferedInputStream(inputStream, 4000), encoding);\n        input = new FullyBufferedReader(xmlReader);\n    } finally {\n        IOUtils.closeQuietly(inputStream);\n        IOUtils.closeQuietly(xmlReader);\n    }\n}", "code_comment": "/**\n *  Reads and parses markup from an input stream\n *\n *  @param inputStream\n *             The input stream to read and parse\n *  @param encoding\n *             The default character encoding of the input\n *  @throws IOException\n */\n", "code_no_comment": "@Override\npublic void parse(final InputStream inputStream, final String encoding) throws IOException {\n    Args.notNull(inputStream, \"inputStream\");\n    try {\n        xmlReader = new XmlReader(new BufferedInputStream(inputStream, 4000), encoding);\n        input = new FullyBufferedReader(xmlReader);\n    } finally {\n        IOUtils.closeQuietly(inputStream);\n        IOUtils.closeQuietly(xmlReader);\n    }\n}", "lc": -0.13636363636363635, "pi": 0.07653061224489792, "ma": -0.5, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.18870088901634643, "fo": -0.25, "r": 1.8285714285714287, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-293_59a0da9c", "label": 1, "code": "/**\n * Get the original number of decision variables.\n * @return original number of decision variables\n * @see #getNumDecisionVariables()\n */\nprotected final int getOriginalNumDecisionVariables() {\n    return restrictToNonNegative ? numDecisionVariables : numDecisionVariables - 1;\n}", "code_comment": "/**\n * Get the original number of decision variables.\n * @return original number of decision variables\n * @see #getNumDecisionVariables()\n */\n", "code_no_comment": "protected final int getOriginalNumDecisionVariables() {\n    return restrictToNonNegative ? numDecisionVariables : numDecisionVariables - 1;\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.3333333333333333, "nbd": -1.0, "ml": -0.25, "d": -0.3806228373702422, "mi": 1.0719816461141385, "fo": -0.5, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "Math", "project_version": 4, "label": 1, "code": "/**\n * Get the intersection of the instance and another sub-line.\n * <p>\n * This method is related to the {@link Line#intersection(Line)\n * intersection} method in the {@link Line Line} class, but in addition\n * to compute the point along infinite lines, it also checks the point\n * lies on both sub-line ranges.\n * </p>\n * @param subLine other sub-line which may intersect instance\n * @param includeEndPoints if true, endpoints are considered to belong to\n * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\n * are considered to not belong to instance (i.e. they are open sets) and intersection\n * occurring on endpoints lead to null being returned\n * @return the intersection point if there is one, null if the sub-lines don't intersect\n */\npublic Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {\n    // compute the intersection on infinite line\n    Vector3D v1D = line.intersection(subLine.line);\n    // check location of point with respect to first sub-line\n    Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n    // check location of point with respect to second sub-line\n    Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\n    if (includeEndPoints) {\n        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;\n    } else {\n        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;\n    }\n}", "code_comment": "/**\n * Get the intersection of the instance and another sub-line.\n * <p>\n * This method is related to the {@link Line#intersection(Line)\n * intersection} method in the {@link Line Line} class, but in addition\n * to compute the point along infinite lines, it also checks the point\n * lies on both sub-line ranges.\n * </p>\n * @param subLine other sub-line which may intersect instance\n * @param includeEndPoints if true, endpoints are considered to belong to\n * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\n * are considered to not belong to instance (i.e. they are open sets) and intersection\n * occurring on endpoints lead to null being returned\n * @return the intersection point if there is one, null if the sub-lines don't intersect\n */\n", "code_no_comment": "public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {\n        Vector3D v1D = line.intersection(subLine.line);\n        Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n        Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\n    if (includeEndPoints) {\n        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;\n    } else {\n        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;\n    }\n}", "lc": -0.18181818181818182, "pi": -0.2500000000000001, "ma": 0.0, "nbd": -0.5, "ml": 0.25, "d": 0.6653484923381119, "mi": 0.1155721250358475, "fo": -0.08333333333333333, "r": -0.028571428571428574, "e": 0.3735850026340473}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1093_7cfbc0da", "label": 1, "code": "/**\n * Add an arc limit to a BSP tree under construction.\n * @param tree BSP tree under construction\n * @param alpha arc limit\n * @param isStart if true, the limit is the start of an arc\n */\nprivate void addArcLimit(final BSPTree<Sphere1D> tree, final double alpha, final boolean isStart) {\n    final LimitAngle limit = new LimitAngle(new S1Point(alpha), !isStart, getTolerance());\n    final BSPTree<Sphere1D> node = tree.getCell(limit.getLocation(), getTolerance());\n    if (node.getCut() != null) {\n        // we find again an already added limit,\n        // this means we have done a full turn around the circle\n        leafBefore(node).setAttribute(Boolean.valueOf(!isStart));\n    } else {\n        // it's a new node\n        node.insertCut(limit);\n        node.setAttribute(null);\n        node.getPlus().setAttribute(Boolean.FALSE);\n        node.getMinus().setAttribute(Boolean.TRUE);\n    }\n}", "code_comment": "/**\n * Add an arc limit to a BSP tree under construction.\n * @param tree BSP tree under construction\n * @param alpha arc limit\n * @param isStart if true, the limit is the start of an arc\n */\n", "code_no_comment": "private void addArcLimit(final BSPTree<Sphere1D> tree, final double alpha, final boolean isStart) {\n    final LimitAngle limit = new LimitAngle(new S1Point(alpha), !isStart, getTolerance());\n    final BSPTree<Sphere1D> node = tree.getCell(limit.getLocation(), getTolerance());\n    if (node.getCut() != null) {\n                        leafBefore(node).setAttribute(Boolean.valueOf(!isStart));\n    } else {\n                node.insertCut(limit);\n        node.setAttribute(null);\n        node.getPlus().setAttribute(Boolean.FALSE);\n        node.getMinus().setAttribute(Boolean.TRUE);\n    }\n}", "lc": -0.09090909090909091, "pi": -0.06632653061224485, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.00889767671774591, "mi": 0.03613421279036396, "fo": 0.6666666666666666, "r": -0.028571428571428574, "e": 0.03706083150234924}
{"project_name": "Chart", "project_version": 2, "label": 3, "code": "/**\n * Iterates over the items in an {@link XYDataset} to find\n * the range of x-values.\n *\n * @param dataset  the dataset (<code>null</code> not permitted).\n * @param includeInterval  a flag that determines, for an\n *          {@link IntervalXYDataset}, whether the x-interval or just the\n *          x-value is used to determine the overall range.\n *\n * @return The range (possibly <code>null</code>).\n */\npublic static Range iterateDomainBounds(XYDataset dataset, boolean includeInterval) {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    double lvalue;\n    double uvalue;\n    if (includeInterval && dataset instanceof IntervalXYDataset) {\n        IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                lvalue = intervalXYData.getStartXValue(series, item);\n                uvalue = intervalXYData.getEndXValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                }\n                if (!Double.isNaN(uvalue)) {\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    } else {\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                lvalue = dataset.getXValue(series, item);\n                uvalue = lvalue;\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    }\n    if (minimum > maximum) {\n        return null;\n    } else {\n        return new Range(minimum, maximum);\n    }\n}", "code_comment": "/**\n * Iterates over the items in an {@link XYDataset} to find\n * the range of x-values.\n *\n * @param dataset  the dataset (<code>null</code> not permitted).\n * @param includeInterval  a flag that determines, for an\n *          {@link IntervalXYDataset}, whether the x-interval or just the\n *          x-value is used to determine the overall range.\n *\n * @return The range (possibly <code>null</code>).\n */\n", "code_no_comment": "public static Range iterateDomainBounds(XYDataset dataset, boolean includeInterval) {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    double lvalue;\n    double uvalue;\n    if (includeInterval && dataset instanceof IntervalXYDataset) {\n        IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                lvalue = intervalXYData.getStartXValue(series, item);\n                uvalue = intervalXYData.getEndXValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                }\n                if (!Double.isNaN(uvalue)) {\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    } else {\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                lvalue = dataset.getXValue(series, item);\n                uvalue = lvalue;\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    }\n    if (minimum > maximum) {\n        return null;\n    } else {\n        return new Range(minimum, maximum);\n    }\n}", "lc": 1.3181818181818181, "pi": 1.4540816326530612, "ma": 1.3333333333333333, "nbd": 1.0, "ml": 1.5, "d": 1.6203657933761744, "mi": -0.7846286205907659, "fo": 0.5833333333333334, "r": -0.028571428571428574, "e": 3.044624616135789}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1822_016df669", "label": 1, "code": "public static void setModified(@Nonnull UpdateOp op, @Nonnull Revision revision) {\n    checkNotNull(op).set(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));\n}", "code_comment": NaN, "code_no_comment": "public static void setModified(@Nonnull UpdateOp op, @Nonnull Revision revision) {\n    checkNotNull(op).set(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9065098938915972, "fo": -0.08333333333333333, "r": 0.14285714285714285, "e": -0.16422749602751402}
{"project_name": "JxPath", "project_version": 18, "label": 3, "code": "public boolean nextNode() {\n    super.setPosition(getCurrentPosition() + 1);\n    if (!setStarted) {\n        setStarted = true;\n        if (!(nodeTest instanceof NodeNameTest)) {\n            return false;\n        }\n        QName name = ((NodeNameTest) nodeTest).getNodeName();\n        iterator = parentContext.getCurrentNodePointer().attributeIterator(name);\n    }\n    if (iterator == null) {\n        return false;\n    }\n    if (!iterator.setPosition(iterator.getPosition() + 1)) {\n        return false;\n    }\n    currentNodePointer = iterator.getNodePointer();\n    return true;\n}", "code_comment": NaN, "code_no_comment": "public boolean nextNode() {\n    super.setPosition(getCurrentPosition() + 1);\n    if (!setStarted) {\n        setStarted = true;\n        if (!(nodeTest instanceof NodeNameTest)) {\n            return false;\n        }\n        QName name = ((NodeNameTest) nodeTest).getNodeName();\n        iterator = parentContext.getCurrentNodePointer().attributeIterator(name);\n    }\n    if (iterator == null) {\n        return false;\n    }\n    if (!iterator.setPosition(iterator.getPosition() + 1)) {\n        return false;\n    }\n    currentNodePointer = iterator.getNodePointer();\n    return true;\n}", "lc": 0.22727272727272727, "pi": -0.03061224489795921, "ma": 0.16666666666666666, "nbd": 0.0, "ml": 0.3333333333333333, "d": 0.2600098863074643, "mi": -0.16690564955549209, "fo": 0.16666666666666666, "r": 0.028571428571428574, "e": 0.11915316449732526}
{"project_name": "Closure", "project_version": 130, "label": 2, "code": "/**\n * For each qualified name N in the global scope, we check if:\n * (a) No ancestor of N is ever aliased or assigned an unknown value type.\n *     (If N = \"a.b.c\", \"a\" and \"a.b\" are never aliased).\n * (b) N has exactly one write, and it lives in the global scope.\n * (c) N is aliased in a local scope.\n *\n * If (a) is true, then GlobalNamespace must know all the writes to N.\n * If (a) and (b) are true, then N cannot change during the execution of\n *    a local scope.\n * If (a) and (b) and (c) are true, then the alias can be inlined if the\n *    alias obeys the usual rules for how we decide whether a variable is\n *    inlineable.\n * @see InlineVariables\n */\nprivate void inlineAliases(GlobalNamespace namespace) {\n    // Invariant: All the names in the worklist meet condition (a).\n    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n        Name name = workList.pop();\n        // Don't attempt to inline a getter or setter property as a variable.\n        if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n            continue;\n        }\n        if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {\n            // {@code name} meets condition (b). Find all of its local aliases\n            // and try to inline them.\n            List<Ref> refs = Lists.newArrayList(name.getRefs());\n            for (Ref ref : refs) {\n                if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n                    // {@code name} meets condition (c). Try to inline it.\n                    if (inlineAliasIfPossible(ref, namespace)) {\n                        name.removeRef(ref);\n                    }\n                }\n            }\n        }\n        // local-alias-inlining above.\n        if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) {\n            // All of {@code name}'s children meet condition (a), so they can be\n            // added to the worklist.\n            workList.addAll(name.props);\n        }\n    }\n}", "code_comment": "/**\n * For each qualified name N in the global scope, we check if:\n * (a) No ancestor of N is ever aliased or assigned an unknown value type.\n *     (If N = \"a.b.c\", \"a\" and \"a.b\" are never aliased).\n * (b) N has exactly one write, and it lives in the global scope.\n * (c) N is aliased in a local scope.\n *\n * If (a) is true, then GlobalNamespace must know all the writes to N.\n * If (a) and (b) are true, then N cannot change during the execution of\n *    a local scope.\n * If (a) and (b) and (c) are true, then the alias can be inlined if the\n *    alias obeys the usual rules for how we decide whether a variable is\n *    inlineable.\n * @see InlineVariables\n */\n", "code_no_comment": "private void inlineAliases(GlobalNamespace namespace) {\n        Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n        Name name = workList.pop();\n                if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n            continue;\n        }\n        if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {\n                                    List<Ref> refs = Lists.newArrayList(name.getRefs());\n            for (Ref ref : refs) {\n                if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n                                        if (inlineAliasIfPossible(ref, namespace)) {\n                        name.removeRef(ref);\n                    }\n                }\n            }\n        }\n                if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) {\n                                    workList.addAll(name.props);\n        }\n    }\n}", "lc": 0.36363636363636365, "pi": 1.5816326530612246, "ma": 0.8333333333333334, "nbd": 1.5, "ml": 1.5833333333333333, "d": 0.8531883341571925, "mi": -0.40894751935761425, "fo": 0.25, "r": -0.028571428571428574, "e": 1.3027783845366432}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3684_e3759a5e", "label": 1, "code": "@Override\npublic void processWatermark(Watermark mark) throws Exception {\n    while (!priorityQueue.isEmpty() && priorityQueue.peek().getTimestamp() <= mark.getTimestamp()) {\n        StreamRecord<IN> streamRecord = priorityQueue.poll();\n        processEvent(nfa, streamRecord.getValue(), streamRecord.getTimestamp());\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void processWatermark(Watermark mark) throws Exception {\n    while (!priorityQueue.isEmpty() && priorityQueue.peek().getTimestamp() <= mark.getTimestamp()) {\n        StreamRecord<IN> streamRecord = priorityQueue.poll();\n        processEvent(nfa, streamRecord.getValue(), streamRecord.getTimestamp());\n    }\n}", "lc": -0.3181818181818182, "pi": 0.15816326530612249, "ma": -0.3333333333333333, "nbd": -0.5, "ml": 0.0, "d": 0.17696490360850226, "mi": 0.3923143102953828, "fo": 0.16666666666666666, "r": 0.0, "e": -0.01550019059366715}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-414_116d5928", "label": 1, "code": "@Override\nprotected void consume() throws IOException {\n    while (getSource().hasTop()) {\n        Key k = getSource().getTopKey();\n        Value v = getSource().getTopValue();\n        if (match(v.get()) || match(k.getRowData()) || match(k.getColumnFamilyData()) || match(k.getColumnQualifierData())) {\n            break;\n        }\n        getSource().next();\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected void consume() throws IOException {\n    while (getSource().hasTop()) {\n        Key k = getSource().getTopKey();\n        Value v = getSource().getTopValue();\n        if (match(v.get()) || match(k.getRowData()) || match(k.getColumnFamilyData()) || match(k.getColumnQualifierData())) {\n            break;\n        }\n        getSource().next();\n    }\n}", "lc": -0.13636363636363635, "pi": 0.4591836734693877, "ma": 0.0, "nbd": 0.0, "ml": 0.75, "d": -0.07217004448838356, "mi": 0.15658158875824477, "fo": 0.8333333333333334, "r": 0.2285714285714286, "e": -0.07496541474466874}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-727_69273dca", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic void integrate(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException {\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n    // create some internal working arrays\n    final double[] y0 = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n        yDotK[i] = new double[y0.length];\n    }\n    final double[] yTmp = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n    // main integration loop\n    isLastStep = false;\n    do {\n        interpolator.shift();\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n            for (int j = 0; j < y0.length; ++j) {\n                double sum = a[k - 1][0] * yDotK[0][j];\n                for (int l = 1; l < k; ++l) {\n                    sum += a[k - 1][l] * yDotK[l][j];\n                }\n                yTmp[j] = y[j] + stepSize * sum;\n            }\n            computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n        }\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n            double sum = b[0] * yDotK[0][j];\n            for (int l = 1; l < stages; ++l) {\n                sum += b[l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n        }\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\n        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n        stepStart = acceptStep(interpolator, y, yDotTmp, t);\n        if (!isLastStep) {\n            // prepare next step\n            interpolator.storeTime(stepStart);\n            // stepsize control for next step\n            final double nextT = stepStart + stepSize;\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n            if (nextIsLast) {\n                stepSize = t - stepStart;\n            }\n        }\n    } while (!isLastStep);\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n    stepStart = Double.NaN;\n    stepSize = Double.NaN;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic void integrate(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException {\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n        final double[] y0 = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n        yDotK[i] = new double[y0.length];\n    }\n    final double[] yTmp = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n        final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n        stepStart = equations.getTime();\n    stepSize = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n        isLastStep = false;\n    do {\n        interpolator.shift();\n                computeDerivatives(stepStart, y, yDotK[0]);\n                for (int k = 1; k < stages; ++k) {\n            for (int j = 0; j < y0.length; ++j) {\n                double sum = a[k - 1][0] * yDotK[0][j];\n                for (int l = 1; l < k; ++l) {\n                    sum += a[k - 1][l] * yDotK[l][j];\n                }\n                yTmp[j] = y[j] + stepSize * sum;\n            }\n            computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n        }\n                for (int j = 0; j < y0.length; ++j) {\n            double sum = b[0] * yDotK[0][j];\n            for (int l = 1; l < stages; ++l) {\n                sum += b[l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n        }\n                interpolator.storeTime(stepStart + stepSize);\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\n        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n        stepStart = acceptStep(interpolator, y, yDotTmp, t);\n        if (!isLastStep) {\n                        interpolator.storeTime(stepStart);\n                        final double nextT = stepStart + stepSize;\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n            if (nextIsLast) {\n                stepSize = t - stepStart;\n            }\n        }\n    } while (!isLastStep);\n        equations.setTime(stepStart);\n    equations.setCompleteState(y);\n    stepStart = Double.NaN;\n    stepSize = Double.NaN;\n}", "lc": 2.0454545454545454, "pi": 0.8469387755102039, "ma": 1.3333333333333333, "nbd": 1.0, "ml": 1.25, "d": 3.35244686109738, "mi": -1.05907657011758, "fo": 1.5833333333333333, "r": -0.028571428571428574, "e": 13.912956514662865}
