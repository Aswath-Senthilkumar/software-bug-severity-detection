{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2249_6dde8e9d", "label": 1, "code": "@Override\npublic void restrict(FilterImpl f) {\n    if (propertyName != null) {\n        if (f.getSelector().equals(selector)) {\n            String pn = normalizePropertyName(propertyName);\n            f.restrictProperty(pn, Operator.NOT_EQUAL, null);\n        }\n    }\n    f.restrictFulltextCondition(fullTextSearchExpression.currentValue().getValue(Type.STRING));\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void restrict(FilterImpl f) {\n    if (propertyName != null) {\n        if (f.getSelector().equals(selector)) {\n            String pn = normalizePropertyName(propertyName);\n            f.restrictProperty(pn, Operator.NOT_EQUAL, null);\n        }\n    }\n    f.restrictFulltextCondition(fullTextSearchExpression.currentValue().getValue(Type.STRING));\n}", "lc": -0.18181818181818182, "pi": 0.7040816326530615, "ma": -0.16666666666666666, "nbd": 0.0, "ml": 0.0, "d": -0.12951062778052397, "mi": 0.2033266418124464, "fo": 0.08333333333333333, "r": 0.20000000000000004, "e": -0.0892492322715767}
{"project_name": "Compress", "project_version": 24, "label": 0, "code": "/**\n * Parse an octal string from a buffer.\n *\n * <p>Leading spaces are ignored.\n * The buffer must contain a trailing space or NUL,\n * and may contain an additional trailing space or NUL.</p>\n *\n * <p>The input buffer is allowed to contain all NULs,\n * in which case the method returns 0L\n * (this allows for missing fields).</p>\n *\n * <p>To work-around some tar implementations that insert a\n * leading NUL this method returns 0 if it detects a leading NUL\n * since Commons Compress 1.4.</p>\n *\n * @param buffer The buffer from which to parse.\n * @param offset The offset into the buffer from which to parse.\n * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n * @return The long value of the octal string.\n * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n */\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    // Skip leading spaces\n    while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n    // Trim all trailing NULs and spaces.\n    // The ustar and POSIX tar specs require a trailing NUL or\n    // space but some implementations use the extra digit for big\n    // sizes/uids/gids ...\n    byte trailer = buffer[end - 1];\n    if (trailer == 0 || trailer == ' ') {\n        end--;\n    } else {\n        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));\n    }\n    trailer = buffer[end - 1];\n    while (start < end - 1 && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        // CheckStyle:MagicNumber OFF\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        // convert from ASCII\n        result = (result << 3) + (currentByte - '0');\n    // CheckStyle:MagicNumber ON\n    }\n    return result;\n}", "code_comment": "/**\n * Parse an octal string from a buffer.\n *\n * <p>Leading spaces are ignored.\n * The buffer must contain a trailing space or NUL,\n * and may contain an additional trailing space or NUL.</p>\n *\n * <p>The input buffer is allowed to contain all NULs,\n * in which case the method returns 0L\n * (this allows for missing fields).</p>\n *\n * <p>To work-around some tar implementations that insert a\n * leading NUL this method returns 0 if it detects a leading NUL\n * since Commons Compress 1.4.</p>\n *\n * @param buffer The buffer from which to parse.\n * @param offset The offset into the buffer from which to parse.\n * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n * @return The long value of the octal string.\n * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n */\n", "code_no_comment": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n        while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n                    byte trailer = buffer[end - 1];\n    if (trailer == 0 || trailer == ' ') {\n        end--;\n    } else {\n        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));\n    }\n    trailer = buffer[end - 1];\n    while (start < end - 1 && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n                if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n                result = (result << 3) + (currentByte - '0');\n        }\n    return result;\n}", "lc": 1.0454545454545454, "pi": -0.0714285714285715, "ma": 1.5, "nbd": 0.0, "ml": 1.0, "d": 3.5739001482946122, "mi": -0.6925724118153144, "fo": -0.3333333333333333, "r": -0.028571428571428574, "e": 5.061037086529525}
{"project_name": "Closure", "project_version": 43, "label": 2, "code": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    inputId = t.getInputId();\n    attachLiteralTypes(t, n);\n    switch(n.getType()) {\n        case Token.CALL:\n            checkForClassDefiningCalls(t, n, parent);\n            checkForCallingConventionDefiningCalls(n, delegateCallingConventions);\n            break;\n        case Token.FUNCTION:\n            if (t.getInput() == null || !t.getInput().isExtern()) {\n                nonExternFunctions.add(n);\n            }\n            // Hoisted functions are handled during pre-traversal.\n            if (!NodeUtil.isHoistedFunctionDeclaration(n)) {\n                defineFunctionLiteral(n, parent);\n            }\n            break;\n        case Token.ASSIGN:\n            // Handle initialization of properties.\n            Node firstChild = n.getFirstChild();\n            if (firstChild.isGetProp() && firstChild.isQualifiedName()) {\n                maybeDeclareQualifiedName(t, n.getJSDocInfo(), firstChild, n, firstChild.getNext());\n            }\n            break;\n        case Token.CATCH:\n            defineCatch(n, parent);\n            break;\n        case Token.VAR:\n            defineVar(n, parent);\n            break;\n        case Token.GETPROP:\n            // Handle stubbed properties.\n            if (parent.isExprResult() && n.isQualifiedName()) {\n                maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\n            }\n            break;\n    }\n// Analyze any @lends object literals in this statement.\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    inputId = t.getInputId();\n    attachLiteralTypes(t, n);\n    switch(n.getType()) {\n        case Token.CALL:\n            checkForClassDefiningCalls(t, n, parent);\n            checkForCallingConventionDefiningCalls(n, delegateCallingConventions);\n            break;\n        case Token.FUNCTION:\n            if (t.getInput() == null || !t.getInput().isExtern()) {\n                nonExternFunctions.add(n);\n            }\n                        if (!NodeUtil.isHoistedFunctionDeclaration(n)) {\n                defineFunctionLiteral(n, parent);\n            }\n            break;\n        case Token.ASSIGN:\n                        Node firstChild = n.getFirstChild();\n            if (firstChild.isGetProp() && firstChild.isQualifiedName()) {\n                maybeDeclareQualifiedName(t, n.getJSDocInfo(), firstChild, n, firstChild.getNext());\n            }\n            break;\n        case Token.CATCH:\n            defineCatch(n, parent);\n            break;\n        case Token.VAR:\n            defineVar(n, parent);\n            break;\n        case Token.GETPROP:\n                        if (parent.isExprResult() && n.isQualifiedName()) {\n                maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\n            }\n            break;\n    }\n}", "lc": 1.0, "pi": 0.6887755102040817, "ma": 2.1666666666666665, "nbd": 0.5, "ml": 1.4166666666666667, "d": 0.4498269896193773, "mi": -0.6779466590192145, "fo": 1.4166666666666667, "r": -0.028571428571428574, "e": 0.7446473160556962}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2494_0dc92ca1", "label": 1, "code": "public void clear() {\n    sum = 0;\n    count = 0;\n    partialStdDev = 0;\n}", "code_comment": NaN, "code_no_comment": "public void clear() {\n    sum = 0;\n    count = 0;\n    partialStdDev = 0;\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7613994837969603, "fo": -0.5, "r": 2.6, "e": -0.16422749602751402}
{"project_name": "Math", "project_version": 90, "label": 1, "code": "/**\n * Adds 1 to the frequency count for v.\n * <p>\n * If other objects have already been added to this Frequency, v must\n * be comparable to those that have already been added.\n * </p>\n *\n * @param v the value to add.\n * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n * @throws ClassCastException if <code>v</code> is not Comparable\n * @deprecated use {@link #addValue(Comparable)} instead\n */\n@Deprecated\npublic void addValue(Object v) {\n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     *\n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     */\n    Object obj = v;\n    if (v instanceof Integer) {\n        obj = Long.valueOf(((Integer) v).longValue());\n    }\n    try {\n        Long count = (Long) freqTable.get(obj);\n        if (count == null) {\n            freqTable.put(obj, Long.valueOf(1));\n        } else {\n            freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n        }\n    } catch (ClassCastException ex) {\n        // TreeMap will throw ClassCastException if v is not comparable\n        throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n    }\n}", "code_comment": "/**\n * Adds 1 to the frequency count for v.\n * <p>\n * If other objects have already been added to this Frequency, v must\n * be comparable to those that have already been added.\n * </p>\n *\n * @param v the value to add.\n * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n * @throws ClassCastException if <code>v</code> is not Comparable\n * @deprecated use {@link #addValue(Comparable)} instead\n */\n/**\n * Adds 1 to the frequency count for v.\n * <p>\n * If other objects have already been added to this Frequency, v must\n * be comparable to those that have already been added.\n * </p>\n *\n * @param v the value to add.\n * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n */\n", "code_no_comment": "@Deprecated\npublic void addValue(Object v) {\n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     *\n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     */\n    Object obj = v;\n    if (v instanceof Integer) {\n        obj = Long.valueOf(((Integer) v).longValue());\n    }\n    try {\n        Long count = (Long) freqTable.get(obj);\n        if (count == null) {\n            freqTable.put(obj, Long.valueOf(1));\n        } else {\n            freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n        }\n    } catch (ClassCastException ex) {\n                throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n    }\n}", "lc": 0.5909090909090909, "pi": -0.051020408163265356, "ma": 0.16666666666666666, "nbd": 0.0, "ml": -0.08333333333333333, "d": 0.03460207612456753, "mi": -0.33610553484370526, "fo": 0.16666666666666666, "r": 0.0, "e": 0.02700005567904884}
{"project_name": "Cli", "project_version": 13, "label": 1, "code": "public void processValues(final WriteableCommandLine commandLine, final ListIterator arguments, final Option option) throws OptionException {\n    // count of arguments processed for this option.\n    int argumentCount = 0;\n    while (arguments.hasNext() && (argumentCount < maximum)) {\n        final String allValuesQuoted = (String) arguments.next();\n        final String allValues = stripBoundaryQuotes(allValuesQuoted);\n        // should we ignore things that look like options?\n        if (allValuesQuoted.equals(consumeRemaining)) {\n            while (arguments.hasNext() && (argumentCount < maximum)) {\n                ++argumentCount;\n                commandLine.addValue(option, arguments.next());\n            }\n        } else // does it look like an option?\n        if (commandLine.looksLikeOption(allValuesQuoted)) {\n            arguments.previous();\n            break;\n        } else // should we split the string up?\n        if (subsequentSplit) {\n            final StringTokenizer values = new StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n            arguments.remove();\n            while (values.hasMoreTokens() && (argumentCount < maximum)) {\n                ++argumentCount;\n                final String token = values.nextToken();\n                commandLine.addValue(option, token);\n                arguments.add(token);\n            }\n            if (values.hasMoreTokens()) {\n                throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE, values.nextToken());\n            }\n        } else // it must be a value as it is\n        {\n            ++argumentCount;\n            commandLine.addValue(option, allValues);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "public void processValues(final WriteableCommandLine commandLine, final ListIterator arguments, final Option option) throws OptionException {\n        int argumentCount = 0;\n    while (arguments.hasNext() && (argumentCount < maximum)) {\n        final String allValuesQuoted = (String) arguments.next();\n        final String allValues = stripBoundaryQuotes(allValuesQuoted);\n                if (allValuesQuoted.equals(consumeRemaining)) {\n            while (arguments.hasNext() && (argumentCount < maximum)) {\n                ++argumentCount;\n                commandLine.addValue(option, arguments.next());\n            }\n        } else         if (commandLine.looksLikeOption(allValuesQuoted)) {\n            arguments.previous();\n            break;\n        } else         if (subsequentSplit) {\n            final StringTokenizer values = new StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n            arguments.remove();\n            while (values.hasMoreTokens() && (argumentCount < maximum)) {\n                ++argumentCount;\n                final String token = values.nextToken();\n                commandLine.addValue(option, token);\n                arguments.add(token);\n            }\n            if (values.hasMoreTokens()) {\n                throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE, values.nextToken());\n            }\n        } else         {\n            ++argumentCount;\n            commandLine.addValue(option, allValues);\n        }\n    }\n}", "lc": 0.9090909090909091, "pi": 0.6836734693877553, "ma": 1.0, "nbd": 1.5, "ml": 1.1666666666666667, "d": 0.5348492338111717, "mi": -0.6042443361055352, "fo": 1.0, "r": -0.028571428571428574, "e": 0.8311725579383333}
{"project_name": "Lang", "project_version": 7, "label": 1, "code": "// -----------------------------------------------------------------------\n// must handle Long, Float, Integer, Float, Short,\n// BigDecimal, BigInteger and Byte\n// useful methods:\n// Byte.decode(String)\n// Byte.valueOf(String,int radix)\n// Byte.valueOf(String)\n// Double.valueOf(String)\n// Float.valueOf(String)\n// Float.valueOf(String)\n// Integer.valueOf(String,int radix)\n// Integer.valueOf(String)\n// Integer.decode(String)\n// Integer.getInteger(String)\n// Integer.getInteger(String,int val)\n// Integer.getInteger(String,Integer val)\n// Integer.valueOf(String)\n// Double.valueOf(String)\n// new Byte(String)\n// Long.valueOf(String)\n// Long.getLong(String)\n// Long.getLong(String,int)\n// Long.getLong(String,Integer)\n// Long.valueOf(String,int)\n// Long.valueOf(String)\n// Short.valueOf(String)\n// Short.decode(String)\n// Short.valueOf(String,int)\n// Short.valueOf(String)\n// new BigDecimal(String)\n// new BigInteger(String)\n// new BigInteger(String,int radix)\n// Possible inputs:\n// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd\n// plus minus everything. Prolly more. A lot are not separable.\n/**\n * <p>Turns a string value into a java.lang.Number.</p>\n *\n * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it\n * will be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x\n * prefix is more than 8.\n * Values with leading <code>0</code>'s will not be interpreted as octal.</p>\n *\n * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts\n * trying to create successively larger types from the type specified\n * until one is found that can represent the value.</p>\n *\n * <p>If a type specifier is not found, it will check for a decimal point\n * and then try successively larger types from <code>Integer</code> to\n * <code>BigInteger</code> and from <code>Float</code> to\n * <code>BigDecimal</code>.</p>\n *\n * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n *\n * <p>This method does not trim the input string, i.e., strings with leading\n * or trailing spaces will generate NumberFormatExceptions.</p>\n *\n * @param str  String containing a number, may be null\n * @return Number created from the string (or null if the input is null)\n * @throws NumberFormatException if the value cannot be converted\n */\npublic static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n        // drop 0x\n        int hexDigits = str.length() - 2;\n        if (str.startsWith(\"-\")) {\n            // drop -\n            hexDigits--;\n        }\n        if (hexDigits > 8) {\n            // too many for an int\n            return createLong(str);\n        }\n        return createInteger(str);\n    }\n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos || expPos > str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            if (expPos > str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        // Requesting a specific type..\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch(lastChar) {\n            case 'l':\n            case 'L':\n                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    // NOPMD\n                    // Too big for a long\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f':\n            case 'F':\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        // has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                // NOPMD\n                // ignore the bad number\n                }\n            // $FALL-THROUGH$\n            case 'd':\n            case 'D':\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                // NOPMD\n                // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                // NOPMD\n                // ignore the bad number\n                }\n            // $FALL-THROUGH$\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        // small and go from there...\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            // Must be an int,long,bigint\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            // NOPMD\n            // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            // NOPMD\n            // ignore the bad number\n            }\n            return createBigInteger(str);\n        } else {\n            // Must be a float,double,BigDec\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            // NOPMD\n            // ignore the bad number\n            }\n            try {\n                Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            // NOPMD\n            // ignore the bad number\n            }\n            return createBigDecimal(str);\n        }\n    }\n}", "code_comment": "/**\n * <p>Turns a string value into a java.lang.Number.</p>\n *\n * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it\n * will be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x\n * prefix is more than 8.\n * Values with leading <code>0</code>'s will not be interpreted as octal.</p>\n *\n * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts\n * trying to create successively larger types from the type specified\n * until one is found that can represent the value.</p>\n *\n * <p>If a type specifier is not found, it will check for a decimal point\n * and then try successively larger types from <code>Integer</code> to\n * <code>BigInteger</code> and from <code>Float</code> to\n * <code>BigDecimal</code>.</p>\n *\n * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n *\n * <p>This method does not trim the input string, i.e., strings with leading\n * or trailing spaces will generate NumberFormatExceptions.</p>\n *\n * @param str  String containing a number, may be null\n * @return Number created from the string (or null if the input is null)\n * @throws NumberFormatException if the value cannot be converted\n */\n", "code_no_comment": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n                int hexDigits = str.length() - 2;\n        if (str.startsWith(\"-\")) {\n                        hexDigits--;\n        }\n        if (hexDigits > 8) {\n                        return createLong(str);\n        }\n        return createInteger(str);\n    }\n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos || expPos > str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            if (expPos > str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n                String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch(lastChar) {\n            case 'l':\n            case 'L':\n                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                                                            }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f':\n            case 'F':\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                                                return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                                                }\n                        case 'd':\n            case 'D':\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                                                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                                                }\n                        default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n                if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n                        try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n                                    }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n                                    }\n            return createBigInteger(str);\n        } else {\n                        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                                    }\n            try {\n                Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                                    }\n            return createBigDecimal(str);\n        }\n    }\n}", "lc": 5.136363636363637, "pi": 1.1887755102040816, "ma": 6.166666666666667, "nbd": 1.5, "ml": 5.666666666666667, "d": 3.9199209095402874, "mi": -1.6466876971608837, "fo": 4.25, "r": -0.028571428571428574, "e": 21.06078438930791}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5965_31c88569", "label": 1, "code": "/**\n *  Insert &lt;head&gt; open and close tag (with empty body) to the current position.\n */\nprivate void insertHeadTag() {\n    // Note: only the open-tag must be a AutoComponentTag\n    final ComponentTag openTag = new ComponentTag(HEAD, TagType.OPEN);\n    openTag.setId(HEADER_ID);\n    openTag.setAutoComponentTag(true);\n    openTag.setModified(true);\n    final ComponentTag closeTag = new ComponentTag(HEAD, TagType.CLOSE);\n    closeTag.setOpenTag(openTag);\n    closeTag.setModified(true);\n    // insert the tags into the markup stream\n    markup.addMarkupElement(openTag);\n    markup.addMarkupElement(closeTag);\n}", "code_comment": "/**\n *  Insert &lt;head&gt; open and close tag (with empty body) to the current position.\n */\n", "code_no_comment": "private void insertHeadTag() {\n        final ComponentTag openTag = new ComponentTag(HEAD, TagType.OPEN);\n    openTag.setId(HEADER_ID);\n    openTag.setAutoComponentTag(true);\n    openTag.setModified(true);\n    final ComponentTag closeTag = new ComponentTag(HEAD, TagType.CLOSE);\n    closeTag.setOpenTag(openTag);\n    closeTag.setModified(true);\n        markup.addMarkupElement(openTag);\n    markup.addMarkupElement(closeTag);\n}", "lc": -0.13636363636363635, "pi": -0.7551020408163265, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.1551476914252939, "fo": 0.08333333333333333, "r": 0.3428571428571429, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5319_c863b032", "label": 3, "code": "/**\n *  Generate the next segment\n *\n *  @return segment\n */\npublic String next() {\n    char a = characters[Math.abs(hash % characters.length)];\n    hash++;\n    char b = characters[Math.abs(hash % characters.length)];\n    hash++;\n    char c = characters[Math.abs(hash % characters.length)];\n    String segment = \"\" + a + b + c;\n    hash = hashString(segment);\n    segment += String.format(\"%02x\", Math.abs(hash % 256));\n    hash = hashString(segment);\n    return segment;\n}", "code_comment": "/**\n *  Generate the next segment\n *\n *  @return segment\n */\n", "code_no_comment": "public String next() {\n    char a = characters[Math.abs(hash % characters.length)];\n    hash++;\n    char b = characters[Math.abs(hash % characters.length)];\n    hash++;\n    char c = characters[Math.abs(hash % characters.length)];\n    String segment = \"\" + a + b + c;\n    hash = hashString(segment);\n    segment += String.format(\"%02x\", Math.abs(hash % 256));\n    hash = hashString(segment);\n    return segment;\n}", "lc": -0.09090909090909091, "pi": -0.7806122448979592, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": 0.7128027681660901, "mi": 0.030111843991970103, "fo": 0.08333333333333333, "r": 0.6285714285714287, "e": 0.4799962309566946}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-358_061f5017", "label": 0, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\n    final int n = y0.length;\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n    // initialize working arrays\n    if (y != y0) {\n        System.arraycopy(y0, 0, y, 0, n);\n    }\n    final double[] yDot = new double[n];\n    final double[] yTmp = new double[y0.length];\n    // set up an interpolator sharing the integrator arrays\n    final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();\n    interpolator.reinitialize(y, forward);\n    final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator();\n    interpolatorTmp.reinitialize(yTmp, forward);\n    // set up integration control objects\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    // compute the initial Nordsieck vector using the configured starter integrator\n    start(t0, y, t);\n    interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n    interpolator.storeTime(stepStart);\n    final int lastRow = nordsieck.getRowDimension() - 1;\n    // reuse the step that was chosen by the starter integrator\n    double hNew = stepSize;\n    interpolator.rescale(hNew);\n    boolean lastStep = false;\n    while (!lastStep) {\n        // shift all data\n        interpolator.shift();\n        double error = 0;\n        for (boolean loop = true; loop; ) {\n            stepSize = hNew;\n            // evaluate error using the last term of the Taylor expansion\n            error = 0;\n            for (int i = 0; i < y0.length; ++i) {\n                final double yScale = Math.abs(y[i]);\n                final double tol = (vecAbsoluteTolerance == null) ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale) : (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);\n                final double ratio = nordsieck.getEntry(lastRow, i) / tol;\n                error += ratio * ratio;\n            }\n            error = Math.sqrt(error / y0.length);\n            if (error <= 1.0) {\n                // predict a first estimate of the state at step end\n                final double stepEnd = stepStart + stepSize;\n                interpolator.setInterpolatedTime(stepEnd);\n                System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);\n                // evaluate the derivative\n                computeDerivatives(stepEnd, yTmp, yDot);\n                // update Nordsieck vector\n                final double[] predictedScaled = new double[y0.length];\n                for (int j = 0; j < y0.length; ++j) {\n                    predictedScaled[j] = stepSize * yDot[j];\n                }\n                final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);\n                updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);\n                // discrete events handling\n                interpolatorTmp.reinitialize(stepEnd, stepSize, predictedScaled, nordsieckTmp);\n                interpolatorTmp.storeTime(stepStart);\n                interpolatorTmp.shift();\n                interpolatorTmp.storeTime(stepEnd);\n                if (manager.evaluateStep(interpolatorTmp)) {\n                    final double dt = manager.getEventTime() - stepStart;\n                    if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                        // rejecting the step would lead to a too small next step, we accept it\n                        loop = false;\n                    } else {\n                        // reject the step to match exactly the next switch time\n                        hNew = dt;\n                        interpolator.rescale(hNew);\n                    }\n                } else {\n                    // accept the step\n                    scaled = predictedScaled;\n                    nordsieck = nordsieckTmp;\n                    interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);\n                    loop = false;\n                }\n            } else {\n                // reject the step and attempt to reduce error by stepsize control\n                final double factor = computeStepGrowShrinkFactor(error);\n                hNew = filterStep(stepSize * factor, forward, false);\n                interpolator.rescale(hNew);\n            }\n        }\n        // the step has been accepted (may have been truncated)\n        final double nextStep = stepStart + stepSize;\n        System.arraycopy(yTmp, 0, y, 0, n);\n        interpolator.storeTime(nextStep);\n        manager.stepAccepted(nextStep, y);\n        lastStep = manager.stop();\n        // provide the step data to the step handler\n        for (StepHandler handler : stepHandlers) {\n            interpolator.setInterpolatedTime(nextStep);\n            handler.handleStep(interpolator, lastStep);\n        }\n        stepStart = nextStep;\n        if (!lastStep && manager.reset(stepStart, y)) {\n            // some events handler has triggered changes that\n            // invalidate the derivatives, we need to restart from scratch\n            start(stepStart, y, t);\n            interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n        }\n        if (!lastStep) {\n            // in some rare cases we may get here with stepSize = 0, for example\n            // when an event occurs at integration start, reducing the first step\n            // to zero; we have to reset the step to some safe non zero value\n            stepSize = filterStep(stepSize, forward, true);\n            // stepsize control for next step\n            final double factor = computeStepGrowShrinkFactor(error);\n            final double scaledH = stepSize * factor;\n            final double nextT = stepStart + scaledH;\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n            hNew = filterStep(scaledH, forward, nextIsLast);\n            interpolator.rescale(hNew);\n        }\n    }\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize = Double.NaN;\n    return stopTime;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\n    final int n = y0.length;\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n        if (y != y0) {\n        System.arraycopy(y0, 0, y, 0, n);\n    }\n    final double[] yDot = new double[n];\n    final double[] yTmp = new double[y0.length];\n        final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();\n    interpolator.reinitialize(y, forward);\n    final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator();\n    interpolatorTmp.reinitialize(yTmp, forward);\n        for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n        start(t0, y, t);\n    interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n    interpolator.storeTime(stepStart);\n    final int lastRow = nordsieck.getRowDimension() - 1;\n        double hNew = stepSize;\n    interpolator.rescale(hNew);\n    boolean lastStep = false;\n    while (!lastStep) {\n                interpolator.shift();\n        double error = 0;\n        for (boolean loop = true; loop; ) {\n            stepSize = hNew;\n                        error = 0;\n            for (int i = 0; i < y0.length; ++i) {\n                final double yScale = Math.abs(y[i]);\n                final double tol = (vecAbsoluteTolerance == null) ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale) : (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);\n                final double ratio = nordsieck.getEntry(lastRow, i) / tol;\n                error += ratio * ratio;\n            }\n            error = Math.sqrt(error / y0.length);\n            if (error <= 1.0) {\n                                final double stepEnd = stepStart + stepSize;\n                interpolator.setInterpolatedTime(stepEnd);\n                System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);\n                                computeDerivatives(stepEnd, yTmp, yDot);\n                                final double[] predictedScaled = new double[y0.length];\n                for (int j = 0; j < y0.length; ++j) {\n                    predictedScaled[j] = stepSize * yDot[j];\n                }\n                final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);\n                updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);\n                                interpolatorTmp.reinitialize(stepEnd, stepSize, predictedScaled, nordsieckTmp);\n                interpolatorTmp.storeTime(stepStart);\n                interpolatorTmp.shift();\n                interpolatorTmp.storeTime(stepEnd);\n                if (manager.evaluateStep(interpolatorTmp)) {\n                    final double dt = manager.getEventTime() - stepStart;\n                    if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                                                loop = false;\n                    } else {\n                                                hNew = dt;\n                        interpolator.rescale(hNew);\n                    }\n                } else {\n                                        scaled = predictedScaled;\n                    nordsieck = nordsieckTmp;\n                    interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);\n                    loop = false;\n                }\n            } else {\n                                final double factor = computeStepGrowShrinkFactor(error);\n                hNew = filterStep(stepSize * factor, forward, false);\n                interpolator.rescale(hNew);\n            }\n        }\n                final double nextStep = stepStart + stepSize;\n        System.arraycopy(yTmp, 0, y, 0, n);\n        interpolator.storeTime(nextStep);\n        manager.stepAccepted(nextStep, y);\n        lastStep = manager.stop();\n                for (StepHandler handler : stepHandlers) {\n            interpolator.setInterpolatedTime(nextStep);\n            handler.handleStep(interpolator, lastStep);\n        }\n        stepStart = nextStep;\n        if (!lastStep && manager.reset(stepStart, y)) {\n                                    start(stepStart, y, t);\n            interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n        }\n        if (!lastStep) {\n                                                stepSize = filterStep(stepSize, forward, true);\n                        final double factor = computeStepGrowShrinkFactor(error);\n            final double scaledH = stepSize * factor;\n            final double nextT = stepStart + scaledH;\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n            hNew = filterStep(scaledH, forward, nextIsLast);\n            interpolator.rescale(hNew);\n        }\n    }\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize = Double.NaN;\n    return stopTime;\n}", "lc": 4.090909090909091, "pi": 1.5306122448979589, "ma": 1.8333333333333333, "nbd": 1.5, "ml": 2.0833333333333335, "d": 4.493326742461691, "mi": -1.406940063091483, "fo": 3.5833333333333335, "r": -0.028571428571428574, "e": 28.23659741049593}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1312_d9ab8449", "label": 1, "code": "/**\n * Converts the current object to the relevant thrift type. The object returned from this contains a non-destroyable version of the\n * {@link AuthenticationToken}, so this should be used just before placing on the wire, and references to it should be tightly controlled.\n */\npublic TCredentials toThrift(Instance instance) {\n    return new TCredentials(principal, token.getClass().getName(), ByteBuffer.wrap(AuthenticationTokenSerializer.serialize(token)), instance.getInstanceID());\n}", "code_comment": "/**\n * Converts the current object to the relevant thrift type. The object returned from this contains a non-destroyable version of the\n * {@link AuthenticationToken}, so this should be used just before placing on the wire, and references to it should be tightly controlled.\n */\n", "code_no_comment": "public TCredentials toThrift(Instance instance) {\n    return new TCredentials(principal, token.getClass().getName(), ByteBuffer.wrap(AuthenticationTokenSerializer.serialize(token)), instance.getInstanceID());\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8884427874964153, "fo": -0.08333333333333333, "r": 0.1142857142857143, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2246_dcadb0e1", "label": 1, "code": "private void collectUUIDs(Tree tree) {\n    if (tree == null) {\n        return;\n    }\n    String uuid = TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n    if (uuid != null) {\n        uuids.add(uuid);\n    }\n    for (Tree child : tree.getChildren()) {\n        collectUUIDs(child);\n    }\n}", "code_comment": NaN, "code_no_comment": "private void collectUUIDs(Tree tree) {\n    if (tree == null) {\n        return;\n    }\n    String uuid = TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n    if (uuid != null) {\n        uuids.add(uuid);\n    }\n    for (Tree child : tree.getChildren()) {\n        collectUUIDs(child);\n    }\n}", "lc": -0.09090909090909091, "pi": -0.2346938775510204, "ma": 0.0, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.06426099851705384, "mi": 0.14195583596214523, "fo": -0.16666666666666666, "r": 0.4857142857142857, "e": -0.08707346636343001}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-320_c06cc933", "label": 1, "code": "/**\n * {@inheritDoc}\n */\npublic DecompositionSolver getSolver() {\n    return new Solver(singularValues, getUT(), getV(), getRank() == singularValues.length);\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public DecompositionSolver getSolver() {\n    return new Solver(singularValues, getUT(), getV(), getRank() == singularValues.length);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9736162890737022, "fo": -0.25, "r": 2.742857142857143, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2117_c7669f31", "label": 3, "code": "private void collectIndexEditors(NodeBuilder definitions, NodeState before) throws CommitFailedException {\n    for (String name : definitions.getChildNodeNames()) {\n        NodeBuilder definition = definitions.getChildNode(name);\n        if (Objects.equal(async, definition.getString(ASYNC_PROPERTY_NAME))) {\n            String type = definition.getString(TYPE_PROPERTY_NAME);\n            boolean shouldReindex = shouldReindex(definition, before, name);\n            Editor editor = provider.getIndexEditor(type, definition, root, updateCallback);\n            if (editor == null) {\n                // trigger reindexing when an indexer becomes available\n                definition.setProperty(REINDEX_PROPERTY_NAME, true);\n            } else if (shouldReindex) {\n                if (definition.getBoolean(REINDEX_ASYNC_PROPERTY_NAME) && definition.getString(ASYNC_PROPERTY_NAME) == null) {\n                    // switch index to an async update mode\n                    definition.setProperty(ASYNC_PROPERTY_NAME, ASYNC_REINDEX_VALUE);\n                } else {\n                    definition.setProperty(REINDEX_PROPERTY_NAME, false);\n                    // beforehand, we'll remove all child nodes\n                    for (String rm : definition.getChildNodeNames()) {\n                        definition.getChildNode(rm).remove();\n                    }\n                    reindex.put(concat(getPath(), INDEX_DEFINITIONS_NAME, name), editor);\n                }\n            } else {\n                editors.add(editor);\n            }\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private void collectIndexEditors(NodeBuilder definitions, NodeState before) throws CommitFailedException {\n    for (String name : definitions.getChildNodeNames()) {\n        NodeBuilder definition = definitions.getChildNode(name);\n        if (Objects.equal(async, definition.getString(ASYNC_PROPERTY_NAME))) {\n            String type = definition.getString(TYPE_PROPERTY_NAME);\n            boolean shouldReindex = shouldReindex(definition, before, name);\n            Editor editor = provider.getIndexEditor(type, definition, root, updateCallback);\n            if (editor == null) {\n                                definition.setProperty(REINDEX_PROPERTY_NAME, true);\n            } else if (shouldReindex) {\n                if (definition.getBoolean(REINDEX_ASYNC_PROPERTY_NAME) && definition.getString(ASYNC_PROPERTY_NAME) == null) {\n                                        definition.setProperty(ASYNC_PROPERTY_NAME, ASYNC_REINDEX_VALUE);\n                } else {\n                    definition.setProperty(REINDEX_PROPERTY_NAME, false);\n                                        for (String rm : definition.getChildNodeNames()) {\n                        definition.getChildNode(rm).remove();\n                    }\n                    reindex.put(concat(getPath(), INDEX_DEFINITIONS_NAME, name), editor);\n                }\n            } else {\n                editors.add(editor);\n            }\n        }\n    }\n}", "lc": 0.5, "pi": 1.673469387755102, "ma": 0.5, "nbd": 2.0, "ml": 0.5, "d": -0.012852199703410724, "mi": -0.43533123028391196, "fo": 1.0833333333333333, "r": -0.028571428571428574, "e": 0.21869445479503685}
{"project_name": "Closure", "project_version": 97, "label": 1, "code": "/**\n * Try to fold shift operations\n */\nprivate Node tryFoldShift(Node n, Node left, Node right) {\n    if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {\n        double result;\n        double lval = left.getDouble();\n        double rval = right.getDouble();\n        // a 32-bit range, since the user likely does not intend that.\n        if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n            error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n            return n;\n        }\n        // if the shift amount is outside [0,32)\n        if (!(rval >= 0 && rval < 32)) {\n            error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n            return n;\n        }\n        // Convert the numbers to ints\n        int lvalInt = (int) lval;\n        if (lvalInt != lval) {\n            error(FRACTIONAL_BITWISE_OPERAND, left);\n            return n;\n        }\n        int rvalInt = (int) rval;\n        if (rvalInt != rval) {\n            error(FRACTIONAL_BITWISE_OPERAND, right);\n            return n;\n        }\n        switch(n.getType()) {\n            case Token.LSH:\n                result = lvalInt << rvalInt;\n                break;\n            case Token.RSH:\n                result = lvalInt >> rvalInt;\n                break;\n            case Token.URSH:\n                // JavaScript handles zero shifts on signed numbers differently than\n                // Java as an Java int can not represent the unsigned 32-bit number\n                // where JavaScript can so use a long here.\n                result = lvalInt >>> rvalInt;\n                break;\n            default:\n                throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType()));\n        }\n        Node newNumber = Node.newNumber(result);\n        n.getParent().replaceChild(n, newNumber);\n        reportCodeChange();\n        return newNumber;\n    }\n    return n;\n}", "code_comment": "/**\n * Try to fold shift operations\n */\n", "code_no_comment": "private Node tryFoldShift(Node n, Node left, Node right) {\n    if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {\n        double result;\n        double lval = left.getDouble();\n        double rval = right.getDouble();\n                if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n            error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n            return n;\n        }\n                if (!(rval >= 0 && rval < 32)) {\n            error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n            return n;\n        }\n                int lvalInt = (int) lval;\n        if (lvalInt != lval) {\n            error(FRACTIONAL_BITWISE_OPERAND, left);\n            return n;\n        }\n        int rvalInt = (int) rval;\n        if (rvalInt != rval) {\n            error(FRACTIONAL_BITWISE_OPERAND, right);\n            return n;\n        }\n        switch(n.getType()) {\n            case Token.LSH:\n                result = lvalInt << rvalInt;\n                break;\n            case Token.RSH:\n                result = lvalInt >> rvalInt;\n                break;\n            case Token.URSH:\n                                                                result = lvalInt >>> rvalInt;\n                break;\n            default:\n                throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType()));\n        }\n        Node newNumber = Node.newNumber(result);\n        n.getParent().replaceChild(n, newNumber);\n        reportCodeChange();\n        return newNumber;\n    }\n    return n;\n}", "lc": 1.3181818181818181, "pi": 0.4897959183673469, "ma": 1.6666666666666667, "nbd": 0.5, "ml": 1.0833333333333333, "d": 2.899653979238755, "mi": -0.7800401491253229, "fo": 0.75, "r": -0.028571428571428574, "e": 4.505749932542691}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-3408_81d25bc2", "label": 3, "code": "public static String bigNumber(long big, String[] SUFFIXES, long base) {\n    return String.format(\"%,d\", big);\n}", "code_comment": NaN, "code_no_comment": "public static String bigNumber(long big, String[] SUFFIXES, long base) {\n    return String.format(\"%,d\", big);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9888156008029825, "fo": -0.4166666666666667, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1067_aff82362", "label": 1, "code": "/**\n * Returns the regularized beta function I(x, a, b).\n *\n * The implementation of this method is based on:\n * <ul>\n * <li>\n * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n * Regularized Beta Function</a>.</li>\n * <li>\n * <a href=\"http://functions.wolfram.com/06.21.10.0001.01\">\n * Regularized Beta Function</a>.</li>\n * </ul>\n *\n * @param x the value.\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return the regularized beta function I(x, a, b)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n */\npublic static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations) {\n    double ret;\n    if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || x < 0 || x > 1 || a <= 0.0 || b <= 0.0) {\n        ret = Double.NaN;\n    } else if (x > (a + 1.0) / (a + b + 2.0)) {\n        ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\n    } else {\n        ContinuedFraction fraction = new ContinuedFraction() {\n\n            @Override\n            protected double getB(int n, double x) {\n                double ret;\n                double m;\n                if (n % 2 == 0) {\n                    // even\n                    m = n / 2.0;\n                    ret = (m * (b - m) * x) / ((a + (2 * m) - 1) * (a + (2 * m)));\n                } else {\n                    m = (n - 1.0) / 2.0;\n                    ret = -((a + m) * (a + b + m) * x) / ((a + (2 * m)) * (a + (2 * m) + 1.0));\n                }\n                return ret;\n            }\n\n            @Override\n            protected double getA(int n, double x) {\n                return 1.0;\n            }\n        };\n        ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log1p(-x)) - FastMath.log(a) - logBeta(a, b)) * 1.0 / fraction.evaluate(x, epsilon, maxIterations);\n    }\n    return ret;\n}", "code_comment": "/**\n * Returns the regularized beta function I(x, a, b).\n *\n * The implementation of this method is based on:\n * <ul>\n * <li>\n * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n * Regularized Beta Function</a>.</li>\n * <li>\n * <a href=\"http://functions.wolfram.com/06.21.10.0001.01\">\n * Regularized Beta Function</a>.</li>\n * </ul>\n *\n * @param x the value.\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return the regularized beta function I(x, a, b)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n */\n", "code_no_comment": "public static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations) {\n    double ret;\n    if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || x < 0 || x > 1 || a <= 0.0 || b <= 0.0) {\n        ret = Double.NaN;\n    } else if (x > (a + 1.0) / (a + b + 2.0)) {\n        ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\n    } else {\n        ContinuedFraction fraction = new ContinuedFraction() {\n\n            @Override\n            protected double getB(int n, double x) {\n                double ret;\n                double m;\n                if (n % 2 == 0) {\n                                        m = n / 2.0;\n                    ret = (m * (b - m) * x) / ((a + (2 * m) - 1) * (a + (2 * m)));\n                } else {\n                    m = (n - 1.0) / 2.0;\n                    ret = -((a + m) * (a + b + m) * x) / ((a + (2 * m)) * (a + (2 * m) + 1.0));\n                }\n                return ret;\n            }\n\n            @Override\n            protected double getA(int n, double x) {\n                return 1.0;\n            }\n        };\n        ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log1p(-x)) - FastMath.log(a) - logBeta(a, b)) * 1.0 / fraction.evaluate(x, epsilon, maxIterations);\n    }\n    return ret;\n}", "lc": 0.7272727272727273, "pi": 1.5306122448979589, "ma": 0.0, "nbd": 1.0, "ml": 0.9166666666666666, "d": 3.508650519031143, "mi": -0.5970748494407804, "fo": 0.3333333333333333, "r": -0.028571428571428574, "e": 7.597778834252039}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4116_4624ab3d", "label": 1, "code": "/**\n *  @see org.apache.wicket.request.IRequestHandler#respond(org.apache.wicket.request.IRequestCycle)\n */\npublic void respond(final IRequestCycle requestCycle) {\n    final IRequestablePage page = getPage();\n    if (getComponent().getPage() == page) {\n        boolean isAjax = ((WebRequest) requestCycle.getRequest()).isAjax();\n        if (isAjax == false && listenerInterface.isRenderPageAfterInvocation()) {\n            // schedule page render after current request handler is done. this can be\n            // overridden during invocation of listener\n            // method (i.e. by calling RequestCycle#setResponsePage)\n            final IPageProvider pageProvider = new PageProvider(page);\n            final RedirectPolicy policy = page.isPageStateless() ? RedirectPolicy.NEVER_REDIRECT : RedirectPolicy.AUTO_REDIRECT;\n            requestCycle.scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(pageProvider, policy));\n        }\n        invokeListener();\n    } else {\n        throw new WicketRuntimeException(\"Component \" + getComponent() + \" has been removed from page.\");\n    }\n}", "code_comment": "/**\n *  @see org.apache.wicket.request.IRequestHandler#respond(org.apache.wicket.request.IRequestCycle)\n */\n", "code_no_comment": "public void respond(final IRequestCycle requestCycle) {\n    final IRequestablePage page = getPage();\n    if (getComponent().getPage() == page) {\n        boolean isAjax = ((WebRequest) requestCycle.getRequest()).isAjax();\n        if (isAjax == false && listenerInterface.isRenderPageAfterInvocation()) {\n                                                final IPageProvider pageProvider = new PageProvider(page);\n            final RedirectPolicy policy = page.isPageStateless() ? RedirectPolicy.NEVER_REDIRECT : RedirectPolicy.AUTO_REDIRECT;\n            requestCycle.scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(pageProvider, policy));\n        }\n        invokeListener();\n    } else {\n        throw new WicketRuntimeException(\"Component \" + getComponent() + \" has been removed from page.\");\n    }\n}", "lc": 0.0, "pi": 0.4438775510204082, "ma": 0.16666666666666666, "nbd": 0.0, "ml": 0.3333333333333333, "d": 0.19871478002965903, "mi": -0.0521938629194152, "fo": 0.3333333333333333, "r": -0.028571428571428574, "e": 0.1430780234794266}
{"project_name": "Codec", "project_version": 15, "label": 1, "code": "/**\n * Used internally by the Soundex algorithm.\n *\n * Consonants from the same code group separated by W or H are treated as one.\n *\n * @param str\n *                  the cleaned working string to encode (in upper case).\n * @param index\n *                  the character position to encode\n * @return Mapping code for a particular character\n * @throws IllegalArgumentException\n *                  if the character is not mapped\n */\nprivate char getMappingCode(final String str, final int index) {\n    // map() throws IllegalArgumentException\n    final char mappedChar = this.map(str.charAt(index));\n    // HW rule check\n    if (index > 1 && mappedChar != '0') {\n        final char hwChar = str.charAt(index - 1);\n        if ('H' == hwChar || 'W' == hwChar) {\n            final char preHWChar = str.charAt(index - 2);\n            final char firstCode = this.map(preHWChar);\n            if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n                return 0;\n            }\n        }\n    }\n    return mappedChar;\n}", "code_comment": "/**\n * Used internally by the Soundex algorithm.\n *\n * Consonants from the same code group separated by W or H are treated as one.\n *\n * @param str\n *                  the cleaned working string to encode (in upper case).\n * @param index\n *                  the character position to encode\n * @return Mapping code for a particular character\n * @throws IllegalArgumentException\n *                  if the character is not mapped\n */\n", "code_no_comment": "private char getMappingCode(final String str, final int index) {\n        final char mappedChar = this.map(str.charAt(index));\n        if (index > 1 && mappedChar != '0') {\n        final char hwChar = str.charAt(index - 1);\n        if ('H' == hwChar || 'W' == hwChar) {\n            final char preHWChar = str.charAt(index - 2);\n            final char firstCode = this.map(preHWChar);\n            if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n                return 0;\n            }\n        }\n    }\n    return mappedChar;\n}", "lc": 0.0, "pi": 0.8826530612244898, "ma": 0.0, "nbd": 0.5, "ml": 0.5833333333333334, "d": 1.0647553138902621, "mi": -0.050473186119873975, "fo": -0.08333333333333333, "r": 2.142857142857143, "e": 0.629156119769917}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-776_dc9f23d9", "label": 3, "code": "/**\n * A convenience method for setting the start timestamp accepted by the timestamp filter.\n *\n * @param is\n *          the iterator setting object to configure\n * @param start\n *          the start timestamp (yyyyMMddHHmmssz)\n * @param startInclusive\n *          boolean indicating whether the start is inclusive\n */\npublic static void setStart(IteratorSetting is, String start, boolean startInclusive) {\n    is.addOption(START, start);\n    is.addOption(START_INCL, Boolean.toString(startInclusive));\n}", "code_comment": "/**\n * A convenience method for setting the start timestamp accepted by the timestamp filter.\n *\n * @param is\n *          the iterator setting object to configure\n * @param start\n *          the start timestamp (yyyyMMddHHmmssz)\n * @param startInclusive\n *          boolean indicating whether the start is inclusive\n */\n", "code_no_comment": "public static void setStart(IteratorSetting is, String start, boolean startInclusive) {\n    is.addOption(START, start);\n    is.addOption(START_INCL, Boolean.toString(startInclusive));\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7636937195296818, "fo": -0.25, "r": 2.2571428571428576, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2899_31aea2ad", "label": 0, "code": "private Set<String> beginClearingUnusedLogs() {\n    Set<String> doomed = new HashSet<String>();\n    ArrayList<String> otherLogsCopy = new ArrayList<String>();\n    ArrayList<String> currentLogsCopy = new ArrayList<String>();\n    // do not hold tablet lock while acquiring the log lock\n    logLock.lock();\n    synchronized (this) {\n        if (removingLogs)\n            throw new IllegalStateException(\"Attempted to clear logs when removal of logs in progress\");\n        for (DfsLogger logger : otherLogs) {\n            otherLogsCopy.add(logger.toString());\n            doomed.add(logger.toString());\n        }\n        for (DfsLogger logger : currentLogs) {\n            currentLogsCopy.add(logger.toString());\n            doomed.remove(logger.toString());\n        }\n        otherLogs = Collections.emptySet();\n        if (doomed.size() > 0)\n            removingLogs = true;\n    }\n    // do debug logging outside tablet lock\n    for (String logger : otherLogsCopy) {\n        log.debug(\"Logs for memory compacted: \" + getExtent() + \" \" + logger.toString());\n    }\n    for (String logger : currentLogsCopy) {\n        log.debug(\"Logs for current memory: \" + getExtent() + \" \" + logger);\n    }\n    return doomed;\n}", "code_comment": NaN, "code_no_comment": "private Set<String> beginClearingUnusedLogs() {\n    Set<String> doomed = new HashSet<String>();\n    ArrayList<String> otherLogsCopy = new ArrayList<String>();\n    ArrayList<String> currentLogsCopy = new ArrayList<String>();\n        logLock.lock();\n    synchronized (this) {\n        if (removingLogs)\n            throw new IllegalStateException(\"Attempted to clear logs when removal of logs in progress\");\n        for (DfsLogger logger : otherLogs) {\n            otherLogsCopy.add(logger.toString());\n            doomed.add(logger.toString());\n        }\n        for (DfsLogger logger : currentLogs) {\n            currentLogsCopy.add(logger.toString());\n            doomed.remove(logger.toString());\n        }\n        otherLogs = Collections.emptySet();\n        if (doomed.size() > 0)\n            removingLogs = true;\n    }\n        for (String logger : otherLogsCopy) {\n        log.debug(\"Logs for memory compacted: \" + getExtent() + \" \" + logger.toString());\n    }\n    for (String logger : currentLogsCopy) {\n        log.debug(\"Logs for current memory: \" + getExtent() + \" \" + logger);\n    }\n    return doomed;\n}", "lc": 0.6363636363636364, "pi": 0.27040816326530603, "ma": 0.6666666666666666, "nbd": 0.0, "ml": -0.08333333333333333, "d": 0.0761245674740485, "mi": -0.47462001720676805, "fo": 0.8333333333333334, "r": -0.028571428571428574, "e": 0.25235458131496785}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1215_a9efe3c4", "label": 0, "code": "/**\n * Normalize the property name (including namespace remapping).\n *\n * @param propertyName the property name to normalize\n * @return the normalized property name\n */\nprotected String normalizePropertyName(String propertyName) {\n    // where possible)\n    if (query == null) {\n        return propertyName;\n    }\n    if (propertyName == null) {\n        return null;\n    }\n    int slash = propertyName.indexOf('/');\n    if (slash < 0) {\n        return normalizeNonRelativePropertyName(propertyName);\n    }\n    // relative properties\n    String relativePath = PathUtils.getParentPath(propertyName);\n    relativePath = query.getOakPath(relativePath);\n    propertyName = PathUtils.getName(propertyName);\n    propertyName = normalizeNonRelativePropertyName(propertyName);\n    return PathUtils.concat(relativePath, propertyName);\n}", "code_comment": "/**\n * Normalize the property name (including namespace remapping).\n *\n * @param propertyName the property name to normalize\n * @return the normalized property name\n */\n", "code_no_comment": "protected String normalizePropertyName(String propertyName) {\n        if (query == null) {\n        return propertyName;\n    }\n    if (propertyName == null) {\n        return null;\n    }\n    int slash = propertyName.indexOf('/');\n    if (slash < 0) {\n        return normalizeNonRelativePropertyName(propertyName);\n    }\n        String relativePath = PathUtils.getParentPath(propertyName);\n    relativePath = query.getOakPath(relativePath);\n    propertyName = PathUtils.getName(propertyName);\n    propertyName = normalizeNonRelativePropertyName(propertyName);\n    return PathUtils.concat(relativePath, propertyName);\n}", "lc": 0.13636363636363635, "pi": -0.43877551020408156, "ma": 0.0, "nbd": -0.5, "ml": 0.08333333333333333, "d": 0.07217004448838364, "mi": -0.10782907943791242, "fo": 0.08333333333333333, "r": 0.0, "e": 0.03536476201489629}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-846_7acb091a", "label": 3, "code": "/**\n * Try to create or update the node. If there was a conflict, this method\n * throws an exception, even though the change is still applied.\n *\n * @param store the store\n * @param op the operation\n */\nprivate void createOrUpdateNode(DocumentStore store, UpdateOp op) {\n    Map<String, Object> map = store.createOrUpdate(Collection.NODES, op);\n    if (baseRevision != null) {\n        final AtomicReference<List<Revision>> collisions = new AtomicReference<List<Revision>>();\n        Revision newestRev = mk.getNewestRevision(map, revision, new CollisionHandler() {\n\n            @Override\n            void uncommittedModification(Revision uncommitted) {\n                if (collisions.get() == null) {\n                    collisions.set(new ArrayList<Revision>());\n                }\n                collisions.get().add(uncommitted);\n            }\n        });\n        String conflictMessage = null;\n        if (newestRev == null) {\n            if (op.isDelete || !op.isNew) {\n                conflictMessage = \"The node \" + op.path + \" does not exist or is already deleted\";\n            }\n        } else {\n            if (op.isNew) {\n                conflictMessage = \"The node \" + op.path + \" was already added in revision\\n\" + newestRev;\n            } else if (mk.isRevisionNewer(newestRev, baseRevision) && (op.isDelete || isConflicting(map, op))) {\n                conflictMessage = \"The node \" + op.path + \" was changed in revision\\n\" + newestRev + \", which was applied after the base revision\\n\" + baseRevision;\n            }\n        }\n        if (conflictMessage != null) {\n            conflictMessage += \", before\\n\" + revision + \"; document:\\n\" + map.toString().replaceAll(\", _\", \",\\n_\").replaceAll(\"}, \", \"},\\n\") + \",\\nrevision order:\\n\" + mk.getRevisionComparator();\n            throw new MicroKernelException(conflictMessage);\n        }\n        // on a node are possible if property updates do not overlap)\n        if (collisions.get() != null && isConflicting(map, op)) {\n            for (Revision r : collisions.get()) {\n                // mark collisions on commit root\n                Collision c = new Collision(map, r, op, revision);\n                boolean success = c.mark(store);\n                if (!success) {\n                // TODO: fail this commit\n                }\n            }\n        }\n    }\n    int size = Utils.estimateMemoryUsage(map);\n    if (size > MAX_DOCUMENT_SIZE) {\n        UpdateOp[] split = splitDocument(map);\n        // TODO check if the new main document is actually smaller;\n        // otherwise, splitting doesn't make sense\n        // the old version\n        UpdateOp old = split[0];\n        if (old != null) {\n            store.createOrUpdate(Collection.NODES, old);\n        }\n        // the (shrunken) main document\n        UpdateOp main = split[1];\n        if (main != null) {\n            store.createOrUpdate(Collection.NODES, main);\n        }\n    }\n}", "code_comment": "/**\n * Try to create or update the node. If there was a conflict, this method\n * throws an exception, even though the change is still applied.\n *\n * @param store the store\n * @param op the operation\n */\n", "code_no_comment": "private void createOrUpdateNode(DocumentStore store, UpdateOp op) {\n    Map<String, Object> map = store.createOrUpdate(Collection.NODES, op);\n    if (baseRevision != null) {\n        final AtomicReference<List<Revision>> collisions = new AtomicReference<List<Revision>>();\n        Revision newestRev = mk.getNewestRevision(map, revision, new CollisionHandler() {\n\n            @Override\n            void uncommittedModification(Revision uncommitted) {\n                if (collisions.get() == null) {\n                    collisions.set(new ArrayList<Revision>());\n                }\n                collisions.get().add(uncommitted);\n            }\n        });\n        String conflictMessage = null;\n        if (newestRev == null) {\n            if (op.isDelete || !op.isNew) {\n                conflictMessage = \"The node \" + op.path + \" does not exist or is already deleted\";\n            }\n        } else {\n            if (op.isNew) {\n                conflictMessage = \"The node \" + op.path + \" was already added in revision\\n\" + newestRev;\n            } else if (mk.isRevisionNewer(newestRev, baseRevision) && (op.isDelete || isConflicting(map, op))) {\n                conflictMessage = \"The node \" + op.path + \" was changed in revision\\n\" + newestRev + \", which was applied after the base revision\\n\" + baseRevision;\n            }\n        }\n        if (conflictMessage != null) {\n            conflictMessage += \", before\\n\" + revision + \"; document:\\n\" + map.toString().replaceAll(\", _\", \",\\n_\").replaceAll(\"}, \", \"},\\n\") + \",\\nrevision order:\\n\" + mk.getRevisionComparator();\n            throw new MicroKernelException(conflictMessage);\n        }\n                if (collisions.get() != null && isConflicting(map, op)) {\n            for (Revision r : collisions.get()) {\n                                Collision c = new Collision(map, r, op, revision);\n                boolean success = c.mark(store);\n                if (!success) {\n                                }\n            }\n        }\n    }\n    int size = Utils.estimateMemoryUsage(map);\n    if (size > MAX_DOCUMENT_SIZE) {\n        UpdateOp[] split = splitDocument(map);\n                                UpdateOp old = split[0];\n        if (old != null) {\n            store.createOrUpdate(Collection.NODES, old);\n        }\n                UpdateOp main = split[1];\n        if (main != null) {\n            store.createOrUpdate(Collection.NODES, main);\n        }\n    }\n}", "lc": 1.6818181818181819, "pi": 0.7244897959183676, "ma": 1.8333333333333333, "nbd": 1.0, "ml": 2.0833333333333335, "d": 1.4562530894710826, "mi": -0.9544020648121597, "fo": 1.1666666666666667, "r": -0.028571428571428574, "e": 4.575520063731096}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1739_8188ef54", "label": 1, "code": "@Override\npublic boolean evaluate() {\n    // JCR 2.0 spec, 6.7.16 Comparison:\n    // \"operand1 may evaluate to an array of values\"\n    PropertyValue p1 = operand1.currentProperty();\n    if (p1 == null) {\n        return false;\n    }\n    PropertyValue p2 = operand2.currentValue();\n    if (p2 == null) {\n        // even for \"null <> 'x'\" (same as in SQL)\n        return false;\n    }\n    // property type of the value of operand1\"\n    try {\n        p2 = convertValueToType(p2, p1);\n    } catch (IllegalArgumentException ex) {\n        // unable to convert, just skip this node\n        return false;\n    }\n    return evaluate(p1, p2);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean evaluate() {\n            PropertyValue p1 = operand1.currentProperty();\n    if (p1 == null) {\n        return false;\n    }\n    PropertyValue p2 = operand2.currentValue();\n    if (p2 == null) {\n                return false;\n    }\n        try {\n        p2 = convertValueToType(p2, p1);\n    } catch (IllegalArgumentException ex) {\n                return false;\n    }\n    return evaluate(p1, p2);\n}", "lc": 0.13636363636363635, "pi": -0.2346938775510204, "ma": 0.0, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.0247157686604053, "mi": -0.04215658158875822, "fo": -0.16666666666666666, "r": 0.4857142857142857, "e": -0.06338845559167555}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5", "label": 3, "code": "public update_resultStandardScheme getScheme() {\n    return new update_resultStandardScheme();\n}", "code_comment": NaN, "code_no_comment": "public update_resultStandardScheme getScheme() {\n    return new update_resultStandardScheme();\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.2348723831373678, "fo": -0.5, "r": 2.142857142857143, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 106, "label": 2, "code": "boolean canCollapseUnannotatedChildNames() {\n    if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n        return false;\n    }\n    if (isClassOrEnum) {\n        return true;\n    }\n    return (type == Type.FUNCTION || aliasingGets == 0) && (parent == null || parent.canCollapseUnannotatedChildNames());\n}", "code_comment": NaN, "code_no_comment": "boolean canCollapseUnannotatedChildNames() {\n    if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n        return false;\n    }\n    if (isClassOrEnum) {\n        return true;\n    }\n    return (type == Type.FUNCTION || aliasingGets == 0) && (parent == null || parent.canCollapseUnannotatedChildNames());\n}", "lc": -0.22727272727272727, "pi": -0.17857142857142863, "ma": -0.16666666666666666, "nbd": -0.5, "ml": 0.25, "d": 0.13741967375185377, "mi": 0.25150559219959845, "fo": -0.4166666666666667, "r": 1.7428571428571429, "e": -0.00873732766263635}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2999_3bf07779", "label": 1, "code": "@Override\npublic void propertyDeleted(PropertyState before) {\n    markPropertyChanged(before.getName());\n    checkAggregates(before.getName());\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void propertyDeleted(PropertyState before) {\n    markPropertyChanged(before.getName());\n    checkAggregates(before.getName());\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7516489819328936, "fo": -0.16666666666666666, "r": 0.0, "e": -0.16422749602751402}
{"project_name": "Math", "project_version": 50, "label": 1, "code": "/**\n * {@inheritDoc}\n */\nprotected final double doSolve() {\n    // Get initial solution\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    // regardless of the allowed solutions.\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    // Verify bracketing of initial solution.\n    verifyBracketing(x0, x1);\n    // Get accuracies.\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    // Keep track of inverted intervals, meaning that the left bound is\n    // larger than the right bound.\n    boolean inverted = false;\n    // Keep finding better approximations.\n    while (true) {\n        // Calculate the next approximation.\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        // we can return it regardless of the allowed solutions.\n        if (fx == 0.0) {\n            return x;\n        }\n        // Update the bounds with the new approximation.\n        if (f1 * fx < 0) {\n            // The value of x1 has switched to the other bound, thus inverting\n            // the interval.\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch(method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n                    if (x == x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n            }\n        }\n        // Update from [x0, x1] to [x0, x].\n        x1 = x;\n        f1 = fx;\n        // the root than we already are.\n        if (FastMath.abs(f1) <= ftol) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n        // are satisfied with the current approximation.\n        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "protected final double doSolve() {\n        double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n        if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n        verifyBracketing(x0, x1);\n        final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n            boolean inverted = false;\n        while (true) {\n                final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n                if (fx == 0.0) {\n            return x;\n        }\n                if (f1 * fx < 0) {\n                                    x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch(method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                                        if (x == x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                                        throw new MathInternalError();\n            }\n        }\n                x1 = x;\n        f1 = fx;\n                if (FastMath.abs(f1) <= ftol) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n                if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}", "lc": 3.5454545454545454, "pi": 1.8775510204081634, "ma": 6.5, "nbd": 1.5, "ml": 3.3333333333333335, "d": 3.210084033613446, "mi": -1.392027530828793, "fo": 0.8333333333333334, "r": -0.028571428571428574, "e": 7.8702763822323885}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "public void recv_removeTableProperty() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\n    removeTableProperty_result result = new removeTableProperty_result();\n    receiveBase(result, \"removeTableProperty\");\n    if (result.ouch1 != null) {\n        throw result.ouch1;\n    }\n    if (result.ouch2 != null) {\n        throw result.ouch2;\n    }\n    return;\n}", "code_comment": NaN, "code_no_comment": "public void recv_removeTableProperty() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\n    removeTableProperty_result result = new removeTableProperty_result();\n    receiveBase(result, \"removeTableProperty\");\n    if (result.ouch1 != null) {\n        throw result.ouch1;\n    }\n    if (result.ouch2 != null) {\n        throw result.ouch2;\n    }\n    return;\n}", "lc": -0.13636363636363635, "pi": -0.3112244897959183, "ma": 0.16666666666666666, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.06426099851705384, "mi": 0.17866360768568987, "fo": -0.4166666666666667, "r": -0.028571428571428574, "e": -0.08859821570063517}
{"project_name": "Closure", "project_version": 17, "label": 2, "code": "/**\n * Look for a type declaration on a property assignment\n * (in an ASSIGN or an object literal key).\n *\n * @param info The doc info for this property.\n * @param lValue The l-value node.\n * @param rValue The node that {@code n} is being initialized to,\n *     or {@code null} if this is a stub declaration.\n */\nprivate JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n    if (info != null && info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    } else if (rValue != null && rValue.isFunction() && shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n        return rValue.getJSType();\n    } else if (info != null) {\n        if (info.hasEnumParameterType()) {\n            if (rValue != null && rValue.isObjectLit()) {\n                return rValue.getJSType();\n            } else {\n                return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n            }\n        } else if (info.isConstructor() || info.isInterface()) {\n            return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n        } else {\n            // Check if this is constant, and if it has a known type.\n            if (info.isConstant()) {\n                JSType knownType = null;\n                if (rValue != null) {\n                    if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n                        // then we can safely use that.\n                        return rValue.getJSType();\n                    } else if (rValue.isOr()) {\n                        // Check for a very specific JS idiom:\n                        // var x = x || TYPE;\n                        // This is used by Closure's base namespace for esoteric\n                        // reasons.\n                        Node firstClause = rValue.getFirstChild();\n                        Node secondClause = firstClause.getNext();\n                        boolean namesMatch = firstClause.isName() && lValue.isName() && firstClause.getString().equals(lValue.getString());\n                        if (namesMatch && secondClause.getJSType() != null && !secondClause.getJSType().isUnknownType()) {\n                            return secondClause.getJSType();\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n}", "code_comment": "/**\n * Look for a type declaration on a property assignment\n * (in an ASSIGN or an object literal key).\n *\n * @param info The doc info for this property.\n * @param lValue The l-value node.\n * @param rValue The node that {@code n} is being initialized to,\n *     or {@code null} if this is a stub declaration.\n */\n", "code_no_comment": "private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n    if (info != null && info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    } else if (rValue != null && rValue.isFunction() && shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n        return rValue.getJSType();\n    } else if (info != null) {\n        if (info.hasEnumParameterType()) {\n            if (rValue != null && rValue.isObjectLit()) {\n                return rValue.getJSType();\n            } else {\n                return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n            }\n        } else if (info.isConstructor() || info.isInterface()) {\n            return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n        } else {\n                        if (info.isConstant()) {\n                JSType knownType = null;\n                if (rValue != null) {\n                    if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n                                                return rValue.getJSType();\n                    } else if (rValue.isOr()) {\n                                                                                                                        Node firstClause = rValue.getFirstChild();\n                        Node secondClause = firstClause.getNext();\n                        boolean namesMatch = firstClause.isName() && lValue.isName() && firstClause.getString().equals(lValue.getString());\n                        if (namesMatch && secondClause.getJSType() != null && !secondClause.getJSType().isUnknownType()) {\n                            return secondClause.getJSType();\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n}", "lc": 0.9090909090909091, "pi": 2.408163265306123, "ma": 1.3333333333333333, "nbd": 4.0, "ml": 2.6666666666666665, "d": 0.7622343054869009, "mi": -0.6661887008890166, "fo": 2.3333333333333335, "r": -0.028571428571428574, "e": 1.5589319901833554}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4664_2fcb3417", "label": 1, "code": "/**\n *  Stringizes this url\n *\n *  @param mode\n *             {@link StringMode} that determins how to stringize the url\n *  @param charset\n *             charset\n *  @return sringized version of this url\n */\npublic String toString(StringMode mode, Charset charset) {\n    StringBuilder result = new StringBuilder();\n    final String path = getPath(charset);\n    if (StringMode.FULL == mode) {\n        if (Strings.isEmpty(host)) {\n            throw new IllegalStateException(\"Cannot render this url in \" + StringMode.FULL.name() + \" mode because it does not have a host set.\");\n        }\n        if (Strings.isEmpty(protocol) == false) {\n            result.append(protocol);\n            result.append(\"://\");\n        } else if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false) {\n            result.append(\"//\");\n        }\n        result.append(host);\n        if (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false) {\n            result.append(':');\n            result.append(port);\n        }\n        if (segments.contains(\"..\")) {\n            throw new IllegalStateException(\"Cannot render this url in \" + StringMode.FULL.name() + \" mode because it has a `..` segment: \" + toString());\n        }\n        if (!path.startsWith(\"/\")) {\n            result.append('/');\n        }\n    }\n    result.append(path);\n    result.append(getQueryString(charset));\n    return result.toString();\n}", "code_comment": "/**\n *  Stringizes this url\n *\n *  @param mode\n *             {@link StringMode} that determins how to stringize the url\n *  @param charset\n *             charset\n *  @return sringized version of this url\n */\n", "code_no_comment": "public String toString(StringMode mode, Charset charset) {\n    StringBuilder result = new StringBuilder();\n    final String path = getPath(charset);\n    if (StringMode.FULL == mode) {\n        if (Strings.isEmpty(host)) {\n            throw new IllegalStateException(\"Cannot render this url in \" + StringMode.FULL.name() + \" mode because it does not have a host set.\");\n        }\n        if (Strings.isEmpty(protocol) == false) {\n            result.append(protocol);\n            result.append(\"://\");\n        } else if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false) {\n            result.append(\"//\");\n        }\n        result.append(host);\n        if (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false) {\n            result.append(':');\n            result.append(port);\n        }\n        if (segments.contains(\"..\")) {\n            throw new IllegalStateException(\"Cannot render this url in \" + StringMode.FULL.name() + \" mode because it has a `..` segment: \" + toString());\n        }\n        if (!path.startsWith(\"/\")) {\n            result.append('/');\n        }\n    }\n    result.append(path);\n    result.append(getQueryString(charset));\n    return result.toString();\n}", "lc": 0.6818181818181818, "pi": 0.2653061224489796, "ma": 1.0, "nbd": 0.5, "ml": 1.1666666666666667, "d": 1.0528917449332675, "mi": -0.539718956122742, "fo": 1.4166666666666667, "r": -0.028571428571428574, "e": 1.4934405797473884}
{"project_name": "Closure", "project_version": 133, "label": 2, "code": "/**\n * Returns the remainder of the line.\n */\nprivate String getRemainingJSDocLine() {\n    String result = stream.getRemainingJSDocLine();\n    return result;\n}", "code_comment": "/**\n * Returns the remainder of the line.\n */\n", "code_no_comment": "private String getRemainingJSDocLine() {\n    String result = stream.getRemainingJSDocLine();\n    return result;\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9073702322913678, "fo": -0.4166666666666667, "r": 2.8000000000000003, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 88, "label": 1, "code": "/**\n * Give an expression and a variable. It returns READ, if the first\n * reference of that variable is a read. It returns KILL, if the first\n * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n */\nprivate VariableLiveness isVariableReadBeforeKill(Node n, String variable) {\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n        if (NodeUtil.isLhs(n, n.getParent())) {\n            // occurs after the RHS is evaluated.\n            return VariableLiveness.KILL;\n        } else {\n            return VariableLiveness.READ;\n        }\n    }\n    // Expressions are evaluated left-right, depth first.\n    for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n        if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n            // Not a FUNCTION\n            VariableLiveness state = isVariableReadBeforeKill(child, variable);\n            if (state != VariableLiveness.MAYBE_LIVE) {\n                return state;\n            }\n        }\n    }\n    return VariableLiveness.MAYBE_LIVE;\n}", "code_comment": "/**\n * Give an expression and a variable. It returns READ, if the first\n * reference of that variable is a read. It returns KILL, if the first\n * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n */\n", "code_no_comment": "private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n        if (NodeUtil.isLhs(n, n.getParent())) {\n                        return VariableLiveness.KILL;\n        } else {\n            return VariableLiveness.READ;\n        }\n    }\n        for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n        if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n                        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n            if (state != VariableLiveness.MAYBE_LIVE) {\n                return state;\n            }\n        }\n    }\n    return VariableLiveness.MAYBE_LIVE;\n}", "lc": 0.18181818181818182, "pi": 0.7040816326530615, "ma": 0.3333333333333333, "nbd": 0.5, "ml": 0.8333333333333334, "d": 0.41028175976272874, "mi": -0.1798107255520504, "fo": 0.25, "r": 0.0, "e": 0.26751641461189557}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7213_336663c9", "label": 1, "code": "@Converter\npublic static ByteBuffer toByteBuffer(Integer value) {\n    ByteBuffer buf = ByteBuffer.allocate(4);\n    buf.putInt(value);\n    return buf;\n}", "code_comment": NaN, "code_no_comment": "@Converter\npublic static ByteBuffer toByteBuffer(Integer value) {\n    ByteBuffer buf = ByteBuffer.allocate(4);\n    buf.putInt(value);\n    return buf;\n}", "lc": -0.36363636363636365, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.5896185833094353, "fo": -0.3333333333333333, "r": 1.2285714285714286, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 30, "label": 2, "code": "@Override\npublic void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverse(root);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverse(root);\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8468597648408377, "fo": -0.4166666666666667, "r": 0.3428571428571429, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 148, "label": 2, "code": "private void openLine() throws IOException {\n    out.append(\"[\");\n    this.firstChar = true;\n}", "code_comment": NaN, "code_no_comment": "private void openLine() throws IOException {\n    out.append(\"[\");\n    this.firstChar = true;\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8769716088328073, "fo": -0.4166666666666667, "r": 2.2285714285714286, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 137, "label": 2, "code": "/**\n * Prepare a set for the new scope.\n */\nprivate static String getNameSuffix(String name, int index) {\n    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n}", "code_comment": "/**\n * Prepare a set for the new scope.\n */\n", "code_no_comment": "private static String getNameSuffix(String name, int index) {\n    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9274447949526817, "fo": -0.25, "r": 1.657142857142857, "e": -0.16422749602751402}
{"project_name": "Math", "project_version": 59, "label": 1, "code": "/**\n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\npublic static float max(final float a, final float b) {\n    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n}", "code_comment": "/**\n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\n", "code_no_comment": "public static float max(final float a, final float b) {\n    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.16666666666666666, "nbd": -1.0, "ml": 0.0, "d": 0.01482946119624324, "mi": 0.9116719242902208, "fo": -0.4166666666666667, "r": 2.8000000000000003, "e": -0.1207807059246791}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-367_3a15d8ce", "label": 3, "code": "/**\n * Advance an entry up to the next non null one.\n * @param e entry to advance\n */\nprotected void advance(EntryImpl e) {\n    if (e == null) {\n        return;\n    }\n    do {\n        e.setIndex(e.getIndex() + 1);\n    } while (e.getIndex() < dim && e.getValue() == 0);\n    if (e.getIndex() >= dim) {\n        e.setIndex(-1);\n    }\n}", "code_comment": "/**\n * Advance an entry up to the next non null one.\n * @param e entry to advance\n */\n", "code_no_comment": "protected void advance(EntryImpl e) {\n    if (e == null) {\n        return;\n    }\n    do {\n        e.setIndex(e.getIndex() + 1);\n    } while (e.getIndex() < dim && e.getValue() == 0);\n    if (e.getIndex() >= dim) {\n        e.setIndex(-1);\n    }\n}", "lc": -0.13636363636363635, "pi": -0.17857142857142863, "ma": 0.0, "nbd": -0.5, "ml": 0.25, "d": 0.8591201186356896, "mi": 0.16977344422139384, "fo": 0.0, "r": 1.7714285714285716, "e": 0.16521686989519493}
{"project_name": "Math", "project_version": 6, "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\nprotected PointValuePair doOptimize() {\n    // -------------------- Initialization --------------------------------\n    isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n    final FitnessFunction fitfun = new FitnessFunction();\n    final double[] guess = getStartPoint();\n    // number of objective variables/problem dimension\n    dimension = guess.length;\n    initializeCMA(guess);\n    iterations = 0;\n    double bestValue = fitfun.value(guess);\n    push(fitnessHistory, bestValue);\n    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);\n    PointValuePair lastResult = null;\n    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {\n        // Generate and evaluate lambda offspring\n        final RealMatrix arz = randn1(dimension, lambda);\n        final RealMatrix arx = zeros(dimension, lambda);\n        final double[] fitness = new double[lambda];\n        // generate random offspring\n        for (int k = 0; k < lambda; k++) {\n            RealMatrix arxk = null;\n            for (int i = 0; i < checkFeasableCount + 1; i++) {\n                if (diagonalOnly <= 0) {\n                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(// m + sig * Normal(0,C)\n                    sigma));\n                } else {\n                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));\n                }\n                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {\n                    break;\n                }\n                // regenerate random arguments for row\n                arz.setColumn(k, randn(dimension));\n            }\n            copyColumn(arxk, 0, arx, k);\n            try {\n                // compute fitness\n                fitness[k] = fitfun.value(arx.getColumn(k));\n            } catch (TooManyEvaluationsException e) {\n                break generationLoop;\n            }\n        }\n        // Sort by fitness and compute weighted mean into xmean\n        final int[] arindex = sortedIndices(fitness);\n        // Calculate new xmean, this is selection and recombination\n        // for speed up of Eq. (2) and (3)\n        final RealMatrix xold = xmean;\n        final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n        xmean = bestArx.multiply(weights);\n        final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n        final RealMatrix zmean = bestArz.multiply(weights);\n        final boolean hsig = updateEvolutionPaths(zmean, xold);\n        if (diagonalOnly <= 0) {\n            updateCovariance(hsig, bestArx, arz, arindex, xold);\n        } else {\n            updateCovarianceDiagonalOnly(hsig, bestArz);\n        }\n        // Adapt step size sigma - Eq. (5)\n        sigma *= Math.exp(Math.min(1, (normps / chiN - 1) * cs / damps));\n        final double bestFitness = fitness[arindex[0]];\n        final double worstFitness = fitness[arindex[arindex.length - 1]];\n        if (bestValue > bestFitness) {\n            bestValue = bestFitness;\n            lastResult = optimum;\n            optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);\n            if (getConvergenceChecker() != null && lastResult != null) {\n                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                    break generationLoop;\n                }\n            }\n        }\n        // Break, if fitness is good enough\n        if (stopFitness != 0) {\n            // only if stopFitness is defined\n            if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n                break generationLoop;\n            }\n        }\n        final double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n        final double[] pcCol = pc.getColumn(0);\n        for (int i = 0; i < dimension; i++) {\n            if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {\n                break;\n            }\n            if (i >= dimension - 1) {\n                break generationLoop;\n            }\n        }\n        for (int i = 0; i < dimension; i++) {\n            if (sigma * sqrtDiagC[i] > stopTolUpX) {\n                break generationLoop;\n            }\n        }\n        final double historyBest = min(fitnessHistory);\n        final double historyWorst = max(fitnessHistory);\n        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {\n            break generationLoop;\n        }\n        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {\n            break generationLoop;\n        }\n        // condition number of the covariance matrix exceeds 1e14\n        if (max(diagD) / min(diagD) > 1e7) {\n            break generationLoop;\n        }\n        // user defined termination\n        if (getConvergenceChecker() != null) {\n            final PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);\n            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {\n                break generationLoop;\n            }\n            lastResult = current;\n        }\n        // Adjust step size in case of equal function values (flat fitness)\n        if (bestValue == fitness[arindex[(int) (0.1 + lambda / 4.)]]) {\n            sigma = sigma * Math.exp(0.2 + cs / damps);\n        }\n        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {\n            sigma = sigma * Math.exp(0.2 + cs / damps);\n        }\n        // store best in history\n        push(fitnessHistory, bestFitness);\n        fitfun.setValueRange(worstFitness - bestFitness);\n        if (generateStatistics) {\n            statisticsSigmaHistory.add(sigma);\n            statisticsFitnessHistory.add(bestFitness);\n            statisticsMeanHistory.add(xmean.transpose());\n            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n        }\n    }\n    return optimum;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\nprotected PointValuePair doOptimize() {\n        isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n    final FitnessFunction fitfun = new FitnessFunction();\n    final double[] guess = getStartPoint();\n        dimension = guess.length;\n    initializeCMA(guess);\n    iterations = 0;\n    double bestValue = fitfun.value(guess);\n    push(fitnessHistory, bestValue);\n    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);\n    PointValuePair lastResult = null;\n    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {\n                final RealMatrix arz = randn1(dimension, lambda);\n        final RealMatrix arx = zeros(dimension, lambda);\n        final double[] fitness = new double[lambda];\n                for (int k = 0; k < lambda; k++) {\n            RealMatrix arxk = null;\n            for (int i = 0; i < checkFeasableCount + 1; i++) {\n                if (diagonalOnly <= 0) {\n                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(                    sigma));\n                } else {\n                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));\n                }\n                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {\n                    break;\n                }\n                                arz.setColumn(k, randn(dimension));\n            }\n            copyColumn(arxk, 0, arx, k);\n            try {\n                                fitness[k] = fitfun.value(arx.getColumn(k));\n            } catch (TooManyEvaluationsException e) {\n                break generationLoop;\n            }\n        }\n                final int[] arindex = sortedIndices(fitness);\n                        final RealMatrix xold = xmean;\n        final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n        xmean = bestArx.multiply(weights);\n        final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n        final RealMatrix zmean = bestArz.multiply(weights);\n        final boolean hsig = updateEvolutionPaths(zmean, xold);\n        if (diagonalOnly <= 0) {\n            updateCovariance(hsig, bestArx, arz, arindex, xold);\n        } else {\n            updateCovarianceDiagonalOnly(hsig, bestArz);\n        }\n                sigma *= Math.exp(Math.min(1, (normps / chiN - 1) * cs / damps));\n        final double bestFitness = fitness[arindex[0]];\n        final double worstFitness = fitness[arindex[arindex.length - 1]];\n        if (bestValue > bestFitness) {\n            bestValue = bestFitness;\n            lastResult = optimum;\n            optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);\n            if (getConvergenceChecker() != null && lastResult != null) {\n                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                    break generationLoop;\n                }\n            }\n        }\n                if (stopFitness != 0) {\n                        if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n                break generationLoop;\n            }\n        }\n        final double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n        final double[] pcCol = pc.getColumn(0);\n        for (int i = 0; i < dimension; i++) {\n            if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {\n                break;\n            }\n            if (i >= dimension - 1) {\n                break generationLoop;\n            }\n        }\n        for (int i = 0; i < dimension; i++) {\n            if (sigma * sqrtDiagC[i] > stopTolUpX) {\n                break generationLoop;\n            }\n        }\n        final double historyBest = min(fitnessHistory);\n        final double historyWorst = max(fitnessHistory);\n        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {\n            break generationLoop;\n        }\n        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {\n            break generationLoop;\n        }\n                if (max(diagD) / min(diagD) > 1e7) {\n            break generationLoop;\n        }\n                if (getConvergenceChecker() != null) {\n            final PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);\n            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {\n                break generationLoop;\n            }\n            lastResult = current;\n        }\n                if (bestValue == fitness[arindex[(int) (0.1 + lambda / 4.)]]) {\n            sigma = sigma * Math.exp(0.2 + cs / damps);\n        }\n        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {\n            sigma = sigma * Math.exp(0.2 + cs / damps);\n        }\n                push(fitnessHistory, bestFitness);\n        fitfun.setValueRange(worstFitness - bestFitness);\n        if (generateStatistics) {\n            statisticsSigmaHistory.add(sigma);\n            statisticsFitnessHistory.add(bestFitness);\n            statisticsMeanHistory.add(xmean.transpose());\n            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n        }\n    }\n    return optimum;\n}", "lc": 4.681818181818182, "pi": 0.6377551020408161, "ma": 6.166666666666667, "nbd": 1.0, "ml": 5.583333333333333, "d": 4.171033119130005, "mi": -1.6624605678233442, "fo": 5.25, "r": -0.028571428571428574, "e": 32.09659030070969}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2065_9da430fb", "label": 1, "code": "protected void appendParameters(AppendingStringBuffer url, Map parameters) {\n    int i = 0;\n    while (parameters.containsKey(String.valueOf(i))) {\n        String value = (String) parameters.get(String.valueOf(i));\n        if (!url.endsWith(\"/\")) {\n            url.append(\"/\");\n        }\n        url.append(urlEncodePathComponent(value)).append(\"/\");\n        i++;\n    }\n    String pageMap = (String) parameters.get(WebRequestCodingStrategy.PAGEMAP);\n    if (pageMap != null) {\n        i++;\n        pageMap = WebRequestCodingStrategy.encodePageMapName(pageMap);\n        if (!url.endsWith(\"/\")) {\n            url.append(\"/\");\n        }\n        url.append(WebRequestCodingStrategy.PAGEMAP).append(\"/\").append(urlEncodePathComponent(pageMap)).append(\"/\");\n    }\n    if (i != parameters.size()) {\n        throw new WicketRuntimeException(\"Not all parameters were encoded. Make sure all parameter names are integers in consecutive order starting with zero. Current parameter names are: \" + parameters.keySet().toString());\n    }\n}", "code_comment": NaN, "code_no_comment": "protected void appendParameters(AppendingStringBuffer url, Map parameters) {\n    int i = 0;\n    while (parameters.containsKey(String.valueOf(i))) {\n        String value = (String) parameters.get(String.valueOf(i));\n        if (!url.endsWith(\"/\")) {\n            url.append(\"/\");\n        }\n        url.append(urlEncodePathComponent(value)).append(\"/\");\n        i++;\n    }\n    String pageMap = (String) parameters.get(WebRequestCodingStrategy.PAGEMAP);\n    if (pageMap != null) {\n        i++;\n        pageMap = WebRequestCodingStrategy.encodePageMapName(pageMap);\n        if (!url.endsWith(\"/\")) {\n            url.append(\"/\");\n        }\n        url.append(WebRequestCodingStrategy.PAGEMAP).append(\"/\").append(urlEncodePathComponent(pageMap)).append(\"/\");\n    }\n    if (i != parameters.size()) {\n        throw new WicketRuntimeException(\"Not all parameters were encoded. Make sure all parameter names are integers in consecutive order starting with zero. Current parameter names are: \" + parameters.keySet().toString());\n    }\n}", "lc": 0.4090909090909091, "pi": 0.03061224489795921, "ma": 0.5, "nbd": 0.0, "ml": 0.5, "d": 0.6890756302521011, "mi": -0.3762546601663323, "fo": 1.25, "r": -0.028571428571428574, "e": 0.8084897700455284}
{"project_name": "Lang", "project_version": 6, "label": 3, "code": "/**\n * Translate an input onto a Writer. This is intentionally final as its algorithm is\n * tightly coupled with the abstract method of this class.\n *\n * @param input CharSequence that is being translated\n * @param out Writer to translate the text to\n * @throws IOException if and only if the Writer produces an IOException\n */\npublic final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos += c.length;\n            continue;\n        }\n        // // and they just took care of a surrogate pair\n        for (int pt = 0; pt < consumed; pt++) {\n            pos += Character.charCount(Character.codePointAt(input, pos));\n        }\n    }\n}", "code_comment": "/**\n * Translate an input onto a Writer. This is intentionally final as its algorithm is\n * tightly coupled with the abstract method of this class.\n *\n * @param input CharSequence that is being translated\n * @param out Writer to translate the text to\n * @throws IOException if and only if the Writer produces an IOException\n */\n", "code_no_comment": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos += c.length;\n            continue;\n        }\n                for (int pt = 0; pt < consumed; pt++) {\n            pos += Character.charCount(Character.codePointAt(input, pos));\n        }\n    }\n}", "lc": 0.36363636363636365, "pi": 0.34183673469387754, "ma": 0.6666666666666666, "nbd": 0.0, "ml": 0.5, "d": 0.554621848739496, "mi": -0.3166045311155724, "fo": 0.08333333333333333, "r": 0.0, "e": 0.4615407677712533}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2695_0598498e", "label": 0, "code": "@Nonnull\n@Override\npublic NodeState getChildNode(@Nonnull String name) {\n    if (!hasChildren) {\n        checkValidName(name);\n        return EmptyNodeState.MISSING_NODE;\n    }\n    String p = PathUtils.concat(getPath(), name);\n    DocumentNodeState child = store.getNode(p, lastRevision);\n    if (child == null) {\n        checkValidName(name);\n        return EmptyNodeState.MISSING_NODE;\n    } else {\n        return child;\n    }\n}", "code_comment": NaN, "code_no_comment": "@Nonnull\n@Override\npublic NodeState getChildNode(@Nonnull String name) {\n    if (!hasChildren) {\n        checkValidName(name);\n        return EmptyNodeState.MISSING_NODE;\n    }\n    String p = PathUtils.concat(getPath(), name);\n    DocumentNodeState child = store.getNode(p, lastRevision);\n    if (child == null) {\n        checkValidName(name);\n        return EmptyNodeState.MISSING_NODE;\n    } else {\n        return child;\n    }\n}", "lc": 0.09090909090909091, "pi": -0.015306122448979493, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.08007909045971327, "mi": -0.04215658158875822, "fo": -0.08333333333333333, "r": 0.39999999999999997, "e": -0.056501385551715126}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1183_cfbf5999", "label": 3, "code": "@Override\npublic String createBatchScanner(ByteBuffer login, String tableName, BatchScanOptions opts) throws TException {\n    try {\n        Connector connector = getConnector(login);\n        int threads = 10;\n        Authorizations auth;\n        if (opts != null && opts.isSetAuthorizations()) {\n            auth = getAuthorizations(opts.authorizations);\n        } else {\n            auth = connector.securityOperations().getUserAuthorizations(connector.whoami());\n        }\n        if (opts != null && opts.threads > 0)\n            threads = opts.threads;\n        BatchScanner scanner = connector.createBatchScanner(tableName, auth, threads);\n        if (opts != null) {\n            if (opts.iterators != null) {\n                for (org.apache.accumulo.proxy.thrift.IteratorSetting iter : opts.iterators) {\n                    IteratorSetting is = new IteratorSetting(iter.getPriority(), iter.getName(), iter.getIteratorClass(), iter.getProperties());\n                    scanner.addScanIterator(is);\n                }\n            }\n            ArrayList<Range> ranges = new ArrayList<Range>();\n            if (opts.ranges == null) {\n                ranges.add(new Range());\n            } else {\n                for (org.apache.accumulo.proxy.thrift.Range range : opts.ranges) {\n                    Range aRange = new Range(range.getStart() == null ? null : Util.fromThrift(range.getStart()), true, range.getStop() == null ? null : Util.fromThrift(range.getStop()), false);\n                    ranges.add(aRange);\n                }\n            }\n            scanner.setRanges(ranges);\n        }\n        UUID uuid = UUID.randomUUID();\n        ScannerPlusIterator spi = new ScannerPlusIterator();\n        spi.scanner = scanner;\n        spi.iterator = scanner.iterator();\n        scannerCache.put(uuid, spi);\n        return uuid.toString();\n    } catch (Exception e) {\n        throw translateException(e);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic String createBatchScanner(ByteBuffer login, String tableName, BatchScanOptions opts) throws TException {\n    try {\n        Connector connector = getConnector(login);\n        int threads = 10;\n        Authorizations auth;\n        if (opts != null && opts.isSetAuthorizations()) {\n            auth = getAuthorizations(opts.authorizations);\n        } else {\n            auth = connector.securityOperations().getUserAuthorizations(connector.whoami());\n        }\n        if (opts != null && opts.threads > 0)\n            threads = opts.threads;\n        BatchScanner scanner = connector.createBatchScanner(tableName, auth, threads);\n        if (opts != null) {\n            if (opts.iterators != null) {\n                for (org.apache.accumulo.proxy.thrift.IteratorSetting iter : opts.iterators) {\n                    IteratorSetting is = new IteratorSetting(iter.getPriority(), iter.getName(), iter.getIteratorClass(), iter.getProperties());\n                    scanner.addScanIterator(is);\n                }\n            }\n            ArrayList<Range> ranges = new ArrayList<Range>();\n            if (opts.ranges == null) {\n                ranges.add(new Range());\n            } else {\n                for (org.apache.accumulo.proxy.thrift.Range range : opts.ranges) {\n                    Range aRange = new Range(range.getStart() == null ? null : Util.fromThrift(range.getStart()), true, range.getStop() == null ? null : Util.fromThrift(range.getStop()), false);\n                    ranges.add(aRange);\n                }\n            }\n            scanner.setRanges(ranges);\n        }\n        UUID uuid = UUID.randomUUID();\n        ScannerPlusIterator spi = new ScannerPlusIterator();\n        spi.scanner = scanner;\n        spi.iterator = scanner.iterator();\n        scannerCache.put(uuid, spi);\n        return uuid.toString();\n    } catch (Exception e) {\n        throw translateException(e);\n    }\n}", "lc": 1.2727272727272727, "pi": 1.0612244897959182, "ma": 1.3333333333333333, "nbd": 1.0, "ml": 0.9166666666666666, "d": 0.49925852694018796, "mi": -0.8250645253799829, "fo": 1.6666666666666667, "r": -0.028571428571428574, "e": 1.8303844852471938}
{"project_name": "Lang", "project_version": 49, "label": 1, "code": "// Calculations\n// -------------------------------------------------------------------\n/**\n * <p>Reduce the fraction to the smallest values for the numerator and\n * denominator, returning the result.</p>\n *\n * <p>For example, if this fraction represents 2/4, then the result\n * will be 1/2.</p>\n *\n * @return a new reduced fraction instance, or this if no simplification possible\n */\npublic Fraction reduce() {\n    int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n    if (gcd == 1) {\n        return this;\n    }\n    return Fraction.getFraction(numerator / gcd, denominator / gcd);\n}", "code_comment": "/**\n * <p>Reduce the fraction to the smallest values for the numerator and\n * denominator, returning the result.</p>\n *\n * <p>For example, if this fraction represents 2/4, then the result\n * will be 1/2.</p>\n *\n * @return a new reduced fraction instance, or this if no simplification possible\n */\n", "code_no_comment": "public Fraction reduce() {\n    int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n    if (gcd == 1) {\n        return this;\n    }\n    return Fraction.getFraction(numerator / gcd, denominator / gcd);\n}", "lc": -0.3181818181818182, "pi": -0.2346938775510204, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.07414730598121598, "mi": 0.45655291081158605, "fo": -0.25, "r": 2.1142857142857143, "e": -0.11130241861222112}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1096_19c1c3bb", "label": 0, "code": "/**\n * {@inheritDoc}\n */\npublic EnclosingBall<Euclidean2D, Vector2D> ballOnSupport(final List<Vector2D> support) {\n    if (support.size() < 1) {\n        return new EnclosingBall<Euclidean2D, Vector2D>(Vector2D.ZERO, -1.0);\n    } else {\n        final Vector2D vA = support.get(0);\n        if (support.size() < 2) {\n            return new EnclosingBall<Euclidean2D, Vector2D>(vA, 0, vA);\n        } else {\n            final Vector2D vB = support.get(1);\n            if (support.size() < 3) {\n                return new EnclosingBall<Euclidean2D, Vector2D>(new Vector2D(0.5, vA, 0.5, vB), 0.5 * vA.distance(vB), vA, vB);\n            } else {\n                final Vector2D vC = support.get(2);\n                // a disk is 2D can be defined as:\n                // (1)   (x - x_0)^2 + (y - y_0)^2 = r^2\n                // which can be written:\n                // (2)   (x^2 + y^2) - 2 x_0 x - 2 y_0 y + (x_0^2 + y_0^2 - r^2) = 0\n                // or simply:\n                // (3)   (x^2 + y^2) + a x + b y + c= 0\n                // with disk center coordinates -a/2, -b/2\n                // If the sphere exists, a, b and c are a non zero solution to\n                // [ (x^2  + y^2 )   x    y   1 ]   [ 1 ]   [ 0 ]\n                // [ (xA^2 + yA^2)   xA   yA  1 ]   [ a ]   [ 0 ]\n                // [ (xB^2 + yB^2)   xB   yB  1 ] * [ b ] = [ 0 ]\n                // [ (xC^2 + yC^2)   xC   yC  1 ]   [ c ]   [ 0 ]\n                // So the determinant of the matrix is zero. Computing this determinant\n                // by expanding it using the minors m_ij of first row leads to\n                // (4)   m_11 (x^2 + y^2) - m_12 x + m_13 y - m_14 = 0\n                // So by identifying equations (2) and (4) we get the coordinates\n                // of center as:\n                // x_0 = +m_12 / (2 m_11)\n                // y_0 = -m_13 / (2 m_11)\n                // Note that the minors m_11, m_12 and m_13 all have the last column\n                // filled with 1.0, hence simplifying the computation\n                final double[] c1 = new double[] { vA.getNormSq(), vB.getNormSq(), vC.getNormSq() };\n                final double[] c2 = new double[] { vA.getX(), vB.getX(), vC.getX() };\n                final double[] c3 = new double[] { vA.getY(), vB.getY(), vC.getY() };\n                final double m11 = minor(c2, c3);\n                final double m12 = minor(c1, c3);\n                final double m13 = minor(c1, c2);\n                final Vector2D center = new Vector2D(0.5 * m12 / m11, -0.5 * m13 / m11);\n                return new EnclosingBall<Euclidean2D, Vector2D>(center, center.distance(vA), vA, vB, vC);\n            }\n        }\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public EnclosingBall<Euclidean2D, Vector2D> ballOnSupport(final List<Vector2D> support) {\n    if (support.size() < 1) {\n        return new EnclosingBall<Euclidean2D, Vector2D>(Vector2D.ZERO, -1.0);\n    } else {\n        final Vector2D vA = support.get(0);\n        if (support.size() < 2) {\n            return new EnclosingBall<Euclidean2D, Vector2D>(vA, 0, vA);\n        } else {\n            final Vector2D vB = support.get(1);\n            if (support.size() < 3) {\n                return new EnclosingBall<Euclidean2D, Vector2D>(new Vector2D(0.5, vA, 0.5, vB), 0.5 * vA.distance(vB), vA, vB);\n            } else {\n                final Vector2D vC = support.get(2);\n                                                                                                                                                                                                                                                                                                                                                                final double[] c1 = new double[] { vA.getNormSq(), vB.getNormSq(), vC.getNormSq() };\n                final double[] c2 = new double[] { vA.getX(), vB.getX(), vC.getX() };\n                final double[] c3 = new double[] { vA.getY(), vB.getY(), vC.getY() };\n                final double m11 = minor(c2, c3);\n                final double m12 = minor(c1, c3);\n                final double m13 = minor(c1, c2);\n                final Vector2D center = new Vector2D(0.5 * m12 / m11, -0.5 * m13 / m11);\n                return new EnclosingBall<Euclidean2D, Vector2D>(center, center.distance(vA), vA, vB, vC);\n            }\n        }\n    }\n}", "lc": 0.5, "pi": 1.1377551020408163, "ma": 0.0, "nbd": 0.5, "ml": -0.08333333333333333, "d": 1.0232328225407812, "mi": -0.4654430742758821, "fo": 1.1666666666666667, "r": -0.028571428571428574, "e": 1.8786239565532101}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3514_2b6da516", "label": 1, "code": "private Url encryptUrl(final Url url) {\n    if (url.getSegments().isEmpty() && url.getQueryParameters().isEmpty()) {\n        return url;\n    }\n    String encryptedUrlString = getCrypt().encryptUrlSafe(url.toString());\n    Url encryptedUrl = new Url(url.getCharset());\n    encryptedUrl.getSegments().add(encryptedUrlString);\n    int numberOfSegments = url.getSegments().size();\n    if (numberOfSegments == 0 && !url.getQueryParameters().isEmpty()) {\n        numberOfSegments = 1;\n    }\n    char[] encryptedChars = encryptedUrlString.toCharArray();\n    int hash = 0;\n    for (int segNo = 0; segNo < numberOfSegments; segNo++) {\n        char a = encryptedChars[Math.abs(hash % encryptedChars.length)];\n        hash++;\n        char b = encryptedChars[Math.abs(hash % encryptedChars.length)];\n        hash++;\n        char c = encryptedChars[Math.abs(hash % encryptedChars.length)];\n        String segment = \"\" + a + b + c;\n        hash = hashString(segment);\n        segment += String.format(\"%02x\", Math.abs(hash % 256));\n        encryptedUrl.getSegments().add(segment);\n        hash = hashString(segment);\n    }\n    return encryptedUrl;\n}", "code_comment": NaN, "code_no_comment": "private Url encryptUrl(final Url url) {\n    if (url.getSegments().isEmpty() && url.getQueryParameters().isEmpty()) {\n        return url;\n    }\n    String encryptedUrlString = getCrypt().encryptUrlSafe(url.toString());\n    Url encryptedUrl = new Url(url.getCharset());\n    encryptedUrl.getSegments().add(encryptedUrlString);\n    int numberOfSegments = url.getSegments().size();\n    if (numberOfSegments == 0 && !url.getQueryParameters().isEmpty()) {\n        numberOfSegments = 1;\n    }\n    char[] encryptedChars = encryptedUrlString.toCharArray();\n    int hash = 0;\n    for (int segNo = 0; segNo < numberOfSegments; segNo++) {\n        char a = encryptedChars[Math.abs(hash % encryptedChars.length)];\n        hash++;\n        char b = encryptedChars[Math.abs(hash % encryptedChars.length)];\n        hash++;\n        char c = encryptedChars[Math.abs(hash % encryptedChars.length)];\n        String segment = \"\" + a + b + c;\n        hash = hashString(segment);\n        segment += String.format(\"%02x\", Math.abs(hash % 256));\n        encryptedUrl.getSegments().add(segment);\n        hash = hashString(segment);\n    }\n    return encryptedUrl;\n}", "lc": 0.5909090909090909, "pi": -0.2806122448979591, "ma": 0.0, "nbd": -0.5, "ml": 0.3333333333333333, "d": 1.788433020266931, "mi": -0.5010037281330658, "fo": 1.5, "r": -0.028571428571428574, "e": 2.991241257318583}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3511_4a875f46", "label": 1, "code": "/**\n *  {@inheritDoc}\n *\n *  Checks for {@link IResourceStreamReference} in the cache and returns <code>null</code> if the\n *  result is {@link NullResourceStreamReference#INSTANCE}, or {@link FileResourceStream} /\n *  {@link UrlResourceStream} if there is an entry in the cache. Otherwise asks the delegate to\n *  find one and puts it in the cache.\n */\npublic IResourceStream locate(Class<?> clazz, String path) {\n    Key key = new Key(clazz.getName(), path, null, null, null);\n    IResourceStream resourceStream = getCopyFromCache(key);\n    if (resourceStream == null) {\n        resourceStream = delegate.locate(clazz, path);\n        updateCache(key, resourceStream);\n    }\n    return resourceStream;\n}", "code_comment": "/**\n *  {@inheritDoc}\n *\n *  Checks for {@link IResourceStreamReference} in the cache and returns <code>null</code> if the\n *  result is {@link NullResourceStreamReference#INSTANCE}, or {@link FileResourceStream} /\n *  {@link UrlResourceStream} if there is an entry in the cache. Otherwise asks the delegate to\n *  find one and puts it in the cache.\n */\n", "code_no_comment": "public IResourceStream locate(Class<?> clazz, String path) {\n    Key key = new Key(clazz.getName(), path, null, null, null);\n    IResourceStream resourceStream = getCopyFromCache(key);\n    if (resourceStream == null) {\n        resourceStream = delegate.locate(clazz, path);\n        updateCache(key, resourceStream);\n    }\n    return resourceStream;\n}", "lc": -0.22727272727272727, "pi": -0.17857142857142863, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": 0.0286702916460702, "mi": 0.2532262689991397, "fo": -0.16666666666666666, "r": 0.17142857142857146, "e": -0.037596206971873505}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-843_65390f8c", "label": 3, "code": "@Override\npublic void compact(String tableName, Text start, Text end, List<IteratorSetting> iterators, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException {\n    throw new NotImplementedException();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void compact(String tableName, Text start, Text end, List<IteratorSetting> iterators, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException {\n    throw new NotImplementedException();\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.3333333333333333, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7289934040722686, "fo": -0.5, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1899_df59fb45", "label": 1, "code": "@Override\nvoid prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final String key) {\n    for (NodeBuilder node : builders) {\n        if (node.hasProperty(\"match\") || node.getChildNodeCount(1) > 0) {\n            return;\n        } else if (node.exists()) {\n            if (node.hasProperty(NEXT)) {\n                ChildNodeEntry[] walkedLanes = new ChildNodeEntry[OrderedIndex.LANES];\n                ChildNodeEntry entry;\n                String lane0Next, prevNext, currNext;\n                // to keep searching and update\n                do {\n                    entry = seek(index.getNodeState(), new PredicateEquals(key), walkedLanes);\n                    lane0Next = getPropertyNext(walkedLanes[0]);\n                    for (int lane = walkedLanes.length - 1; lane >= 0; lane--) {\n                        prevNext = getPropertyNext(walkedLanes[lane], lane);\n                        if (key.equals(prevNext)) {\n                            // if it's actually pointing to us let's deal with it\n                            currNext = getPropertyNext(node, lane);\n                            setPropertyNext(index.getChildNode(walkedLanes[lane].getName()), currNext, lane);\n                        }\n                    }\n                } while (entry != null && !key.equals(lane0Next));\n            }\n            node.remove();\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\nvoid prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final String key) {\n    for (NodeBuilder node : builders) {\n        if (node.hasProperty(\"match\") || node.getChildNodeCount(1) > 0) {\n            return;\n        } else if (node.exists()) {\n            if (node.hasProperty(NEXT)) {\n                ChildNodeEntry[] walkedLanes = new ChildNodeEntry[OrderedIndex.LANES];\n                ChildNodeEntry entry;\n                String lane0Next, prevNext, currNext;\n                                do {\n                    entry = seek(index.getNodeState(), new PredicateEquals(key), walkedLanes);\n                    lane0Next = getPropertyNext(walkedLanes[0]);\n                    for (int lane = walkedLanes.length - 1; lane >= 0; lane--) {\n                        prevNext = getPropertyNext(walkedLanes[lane], lane);\n                        if (key.equals(prevNext)) {\n                                                        currNext = getPropertyNext(node, lane);\n                            setPropertyNext(index.getChildNode(walkedLanes[lane].getName()), currNext, lane);\n                        }\n                    }\n                } while (entry != null && !key.equals(lane0Next));\n            }\n            node.remove();\n        }\n    }\n}", "lc": 0.5454545454545454, "pi": 2.663265306122449, "ma": 0.6666666666666666, "nbd": 2.5, "ml": 1.0833333333333333, "d": 1.3514582303509641, "mi": -0.47318611987381715, "fo": 0.75, "r": -0.028571428571428574, "e": 1.8038170129475206}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1215_a9efe3c4", "label": 0, "code": "private boolean matchesPropertyType(PropertyValue value) {\n    if (value == null) {\n        return false;\n    }\n    if (propertyType == PropertyType.UNDEFINED) {\n        return true;\n    }\n    return value.getType().tag() == propertyType;\n}", "code_comment": NaN, "code_no_comment": "private boolean matchesPropertyType(PropertyValue value) {\n    if (value == null) {\n        return false;\n    }\n    if (propertyType == PropertyType.UNDEFINED) {\n        return true;\n    }\n    return value.getType().tag() == propertyType;\n}", "lc": -0.22727272727272727, "pi": -0.17857142857142863, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.3806228373702422, "mi": 0.36048178950387144, "fo": -0.3333333333333333, "r": 1.1714285714285715, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-395_962315ba", "label": 1, "code": "/**\n * {@inheritDoc}\n */\npublic double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    return localMin(f, goalType, min, startValue, max, getRelativeAccuracy(), getAbsoluteAccuracy());\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    return localMin(f, goalType, min, startValue, max, getRelativeAccuracy(), getAbsoluteAccuracy());\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7266991683395472, "fo": -0.16666666666666666, "r": 0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3314_4badd9c5", "label": 1, "code": "/**\n * Creates the processor and wraps it in any necessary interceptors and error handlers\n */\nprotected Processor makeProcessor(RouteContext routeContext) throws Exception {\n    Processor processor = null;\n    // resolve properties before we create the processor\n    resolvePropertyPlaceholders(routeContext);\n    // at first use custom factory\n    if (routeContext.getCamelContext().getProcessorFactory() != null) {\n        processor = routeContext.getCamelContext().getProcessorFactory().createProcessor(routeContext, this);\n    }\n    // fallback to default implementation if factory did not create the processor\n    if (processor == null) {\n        processor = createProcessor(routeContext);\n    }\n    if (processor == null) {\n        // no processor to make\n        return null;\n    }\n    return wrapProcessor(routeContext, processor);\n}", "code_comment": "/**\n * Creates the processor and wraps it in any necessary interceptors and error handlers\n */\n", "code_no_comment": "protected Processor makeProcessor(RouteContext routeContext) throws Exception {\n    Processor processor = null;\n        resolvePropertyPlaceholders(routeContext);\n        if (routeContext.getCamelContext().getProcessorFactory() != null) {\n        processor = routeContext.getCamelContext().getProcessorFactory().createProcessor(routeContext, this);\n    }\n        if (processor == null) {\n        processor = createProcessor(routeContext);\n    }\n    if (processor == null) {\n                return null;\n    }\n    return wrapProcessor(routeContext, processor);\n}", "lc": 0.0, "pi": -0.33163265306122447, "ma": 0.0, "nbd": -0.5, "ml": 0.0, "d": 0.1057834898665349, "mi": 0.025523372526527123, "fo": 0.16666666666666666, "r": 0.028571428571428574, "e": -0.0039789104895045085}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7418_cabee0e9", "label": 3, "code": "public <T> Set<T> findByType(Class<T> type) {\n    Set<T> answer = new LinkedHashSet<T>();\n    try {\n        NamingEnumeration<NameClassPair> list = getContext().list(\"\");\n        while (list.hasMore()) {\n            NameClassPair pair = list.next();\n            if (type.isInstance(pair.getClass()) || type.getName().equals(pair.getClassName())) {\n                Object instance = context.lookup(pair.getName());\n                answer.add(type.cast(instance));\n            }\n        }\n    } catch (NamingException e) {\n    // ignore\n    }\n    return answer;\n}", "code_comment": NaN, "code_no_comment": "public <T> Set<T> findByType(Class<T> type) {\n    Set<T> answer = new LinkedHashSet<T>();\n    try {\n        NamingEnumeration<NameClassPair> list = getContext().list(\"\");\n        while (list.hasMore()) {\n            NameClassPair pair = list.next();\n            if (type.isInstance(pair.getClass()) || type.getName().equals(pair.getClassName())) {\n                Object instance = context.lookup(pair.getName());\n                answer.add(type.cast(instance));\n            }\n        }\n    } catch (NamingException e) {\n        }\n    return answer;\n}", "lc": 0.045454545454545456, "pi": 1.0255102040816328, "ma": 0.0, "nbd": 0.5, "ml": 0.25, "d": -0.05239742956005931, "mi": -0.08804129624318922, "fo": 0.5833333333333334, "r": 0.05714285714285714, "e": 0.021911847216690022}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2713_63d9800e", "label": 1, "code": "@SuppressWarnings(\"unchecked\")\npublic void restoreState(StateHandle<Serializable> snapshot, ClassLoader userCodeClassLoader) throws Exception {\n    update(checkpointer.restoreState((C) snapshot.getState(userCodeClassLoader)));\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings(\"unchecked\")\npublic void restoreState(StateHandle<Serializable> snapshot, ClassLoader userCodeClassLoader) throws Exception {\n    update(checkpointer.restoreState((C) snapshot.getState(userCodeClassLoader)));\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7548035560653857, "fo": -0.25, "r": 0.6857142857142857, "e": -0.16422749602751402}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-395_a19ecc9e", "label": 1, "code": "/**\n * Default Factory Constructor.\n * @param name The configuration name.\n * @param configLocation The configuration location.\n * @return The Configuration.\n */\n@Override\npublic Configuration getConfiguration(final String name, final URI configLocation) {\n    if (configLocation == null) {\n        final String config = PropertiesUtil.getProperties().getStringProperty(CONFIGURATION_FILE_PROPERTY);\n        if (config != null) {\n            final ClassLoader loader = this.getClass().getClassLoader();\n            final ConfigurationSource source = getInputFromString(config, loader);\n            if (source != null) {\n                for (final ConfigurationFactory factory : factories) {\n                    final String[] types = factory.getSupportedTypes();\n                    if (types != null) {\n                        for (final String type : types) {\n                            if (type.equals(\"*\") || config.endsWith(type)) {\n                                final Configuration c = factory.getConfiguration(source);\n                                if (c != null) {\n                                    return c;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        for (final ConfigurationFactory factory : factories) {\n            final String[] types = factory.getSupportedTypes();\n            if (types != null) {\n                for (final String type : types) {\n                    if (type.equals(\"*\") || configLocation.toString().endsWith(type)) {\n                        final Configuration config = factory.getConfiguration(name, configLocation);\n                        if (config != null) {\n                            return config;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    Configuration config = getConfiguration(true, name);\n    if (config == null) {\n        config = getConfiguration(true, null);\n        if (config == null) {\n            config = getConfiguration(false, name);\n            if (config == null) {\n                config = getConfiguration(false, null);\n            }\n        }\n    }\n    return config != null ? config : new DefaultConfiguration();\n}", "code_comment": "/**\n * Default Factory Constructor.\n * @param name The configuration name.\n * @param configLocation The configuration location.\n * @return The Configuration.\n */\n", "code_no_comment": "@Override\npublic Configuration getConfiguration(final String name, final URI configLocation) {\n    if (configLocation == null) {\n        final String config = PropertiesUtil.getProperties().getStringProperty(CONFIGURATION_FILE_PROPERTY);\n        if (config != null) {\n            final ClassLoader loader = this.getClass().getClassLoader();\n            final ConfigurationSource source = getInputFromString(config, loader);\n            if (source != null) {\n                for (final ConfigurationFactory factory : factories) {\n                    final String[] types = factory.getSupportedTypes();\n                    if (types != null) {\n                        for (final String type : types) {\n                            if (type.equals(\"*\") || config.endsWith(type)) {\n                                final Configuration c = factory.getConfiguration(source);\n                                if (c != null) {\n                                    return c;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        for (final ConfigurationFactory factory : factories) {\n            final String[] types = factory.getSupportedTypes();\n            if (types != null) {\n                for (final String type : types) {\n                    if (type.equals(\"*\") || configLocation.toString().endsWith(type)) {\n                        final Configuration config = factory.getConfiguration(name, configLocation);\n                        if (config != null) {\n                            return config;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    Configuration config = getConfiguration(true, name);\n    if (config == null) {\n        config = getConfiguration(true, null);\n        if (config == null) {\n            config = getConfiguration(false, name);\n            if (config == null) {\n                config = getConfiguration(false, null);\n            }\n        }\n    }\n    return config != null ? config : new DefaultConfiguration();\n}", "lc": 1.6363636363636365, "pi": 3.214285714285715, "ma": 2.3333333333333335, "nbd": 3.0, "ml": 1.5833333333333333, "d": 0.8630746416213546, "mi": -0.887582449096645, "fo": 1.0, "r": -0.028571428571428574, "e": 1.7424886821625742}
{"project_name": "Closure", "project_version": 79, "label": 1, "code": "/**\n * Create a new variable in a synthetic script. This will prevent\n * subsequent compiler passes from crashing.\n */\nprivate void createSynthesizedExternVar(String varName) {\n    Node nameNode = Node.newString(Token.NAME, varName);\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n    varsToDeclareInExterns.remove(varName);\n}", "code_comment": "/**\n * Create a new variable in a synthetic script. This will prevent\n * subsequent compiler passes from crashing.\n */\n", "code_no_comment": "private void createSynthesizedExternVar(String varName) {\n    Node nameNode = Node.newString(Token.NAME, varName);\n        if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n    varsToDeclareInExterns.remove(varName);\n}", "lc": -0.2727272727272727, "pi": -0.31632653061224497, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.16666666666666666, "d": -0.3806228373702422, "mi": 0.3200458847146544, "fo": 0.08333333333333333, "r": 0.2285714285714286, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2172_ea4a3f8a", "label": 3, "code": "/**\n *  @see IValueMap#getAsDuration(String, Duration)\n */\npublic Duration getAsDuration(String key, Duration defaultValue) {\n    if (!containsKey(key))\n        return defaultValue;\n    try {\n        return getDuration(key);\n    } catch (StringValueConversionException ignored) {\n        return defaultValue;\n    }\n}", "code_comment": "/**\n *  @see IValueMap#getAsDuration(String, Duration)\n */\n", "code_no_comment": "public Duration getAsDuration(String key, Duration defaultValue) {\n    if (!containsKey(key))\n        return defaultValue;\n    try {\n        return getDuration(key);\n    } catch (StringValueConversionException ignored) {\n        return defaultValue;\n    }\n}", "lc": -0.22727272727272727, "pi": -0.035714285714285636, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.16666666666666666, "d": -0.3806228373702422, "mi": 0.3880126182965301, "fo": -0.3333333333333333, "r": 2.4571428571428573, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3598_7c364566", "label": 1, "code": "/**\n *  @return formatter The formatter for the current conversion\n */\n@Override\nprotected DateTimeFormatter getFormat(Locale locale) {\n    return DateTimeFormat.forPattern(getDatePattern(locale)).withPivotYear(2000);\n}", "code_comment": "/**\n *  @return formatter The formatter for the current conversion\n */\n", "code_no_comment": "@Override\nprotected DateTimeFormatter getFormat(Locale locale) {\n    return DateTimeFormat.forPattern(getDatePattern(locale)).withPivotYear(2000);\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8210496128477202, "fo": -0.25, "r": 1.8, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-412_be2fdba7", "label": 1, "code": "private List<List<String>> groupFiles(List<String> files, int groups) {\n    List<List<String>> result = new ArrayList<List<String>>();\n    Iterator<String> iter = files.iterator();\n    for (int i = 0; i < groups && iter.hasNext(); i++) {\n        List<String> group = new ArrayList<String>();\n        for (int j = 0; j < Math.ceil(files.size() / (double) groups) && iter.hasNext(); j++) {\n            group.add(iter.next());\n        }\n        result.add(group);\n    }\n    return result;\n}", "code_comment": NaN, "code_no_comment": "private List<List<String>> groupFiles(List<String> files, int groups) {\n    List<List<String>> result = new ArrayList<List<String>>();\n    Iterator<String> iter = files.iterator();\n    for (int i = 0; i < groups && iter.hasNext(); i++) {\n        List<String> group = new ArrayList<String>();\n        for (int j = 0; j < Math.ceil(files.size() / (double) groups) && iter.hasNext(); j++) {\n            group.add(iter.next());\n        }\n        result.add(group);\n    }\n    return result;\n}", "lc": -0.09090909090909091, "pi": 0.1938775510204081, "ma": -0.16666666666666666, "nbd": 0.0, "ml": 0.4166666666666667, "d": 0.5981216015818094, "mi": 0.00200745626613115, "fo": 0.16666666666666666, "r": -0.028571428571428574, "e": 0.47386296957782426}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-466_7b9e48e8", "label": 3, "code": "/**\n * Tries to convert the specified URL to a file object. If this fails,\n * <b>null</b> is returned.\n *\n * @param uri the URI\n * @return the resulting file object\n */\npublic static File fileFromURI(URI uri) {\n    if (uri == null || (uri.getScheme() != null && (!PROTOCOL_FILE.equals(uri.getScheme()) && !JBOSS_FILE.equals(uri.getScheme())))) {\n        return null;\n    }\n    if (uri.getScheme() == null) {\n        try {\n            uri = new File(uri.getPath()).toURI();\n        } catch (final Exception ex) {\n            LOGGER.warn(\"Invalid URI \" + uri);\n            return null;\n        }\n    }\n    try {\n        return new File(URLDecoder.decode(uri.toURL().getFile(), \"UTF8\"));\n    } catch (final MalformedURLException ex) {\n        LOGGER.warn(\"Invalid URL \" + uri, ex);\n    } catch (final UnsupportedEncodingException uee) {\n        LOGGER.warn(\"Invalid encoding: UTF8\", uee);\n    }\n    return null;\n}", "code_comment": "/**\n * Tries to convert the specified URL to a file object. If this fails,\n * <b>null</b> is returned.\n *\n * @param uri the URI\n * @return the resulting file object\n */\n", "code_no_comment": "public static File fileFromURI(URI uri) {\n    if (uri == null || (uri.getScheme() != null && (!PROTOCOL_FILE.equals(uri.getScheme()) && !JBOSS_FILE.equals(uri.getScheme())))) {\n        return null;\n    }\n    if (uri.getScheme() == null) {\n        try {\n            uri = new File(uri.getPath()).toURI();\n        } catch (final Exception ex) {\n            LOGGER.warn(\"Invalid URI \" + uri);\n            return null;\n        }\n    }\n    try {\n        return new File(URLDecoder.decode(uri.toURL().getFile(), \"UTF8\"));\n    } catch (final MalformedURLException ex) {\n        LOGGER.warn(\"Invalid URL \" + uri, ex);\n    } catch (final UnsupportedEncodingException uee) {\n        LOGGER.warn(\"Invalid encoding: UTF8\", uee);\n    }\n    return null;\n}", "lc": 0.3181818181818182, "pi": 0.19897959183673475, "ma": 0.3333333333333333, "nbd": 0.0, "ml": 0.3333333333333333, "d": 0.827483934750371, "mi": -0.29423573272153736, "fo": 0.6666666666666666, "r": -0.028571428571428574, "e": 0.714619176721018}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-579_7d72e6ed", "label": 3, "code": "public abstract void restrict(FilterImpl f);", "code_comment": NaN, "code_no_comment": "public abstract void restrict(FilterImpl f);", "lc": -0.5909090909090909, "pi": -1.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.7106395182104968, "fo": -0.5, "r": 2.7714285714285714, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3989_6a8fc1cc", "label": 1, "code": "/**\n *  Search for the child's markup in the associated markup file.\n *\n *  @param parent\n *             The container expected to contain the markup for child\n *  @param child\n *             The child component to find the markup for\n *  @return The markup associated with the child\n */\n@Override\npublic IMarkupFragment getMarkup(final MarkupContainer parent, final Component child) {\n    Args.notNull(tagName, \"tagName\");\n    IMarkupFragment associatedMarkup = parent.getAssociatedMarkup();\n    if (associatedMarkup == null) {\n        throw new MarkupNotFoundException(\"Failed to find markup file associated. \" + parent.getClass().getSimpleName() + \": \" + parent.toString());\n    }\n    // Find <wicket:panel>\n    IMarkupFragment markup = findStartTag(associatedMarkup);\n    if (markup == null) {\n        throw new MarkupNotFoundException(\"Expected to find <wicket:\" + tagName + \"> in associated markup file. Markup: \" + associatedMarkup.toString());\n    }\n    // If child == null, than return the markup fragment starting with <wicket:panel>\n    if (child == null) {\n        return markup;\n    }\n    // Find the markup for the child component\n    associatedMarkup = markup.find(child.getId());\n    if (associatedMarkup != null) {\n        return associatedMarkup;\n    }\n    return findMarkupInAssociatedFileHeader(parent, child);\n}", "code_comment": "/**\n *  Search for the child's markup in the associated markup file.\n *\n *  @param parent\n *             The container expected to contain the markup for child\n *  @param child\n *             The child component to find the markup for\n *  @return The markup associated with the child\n */\n", "code_no_comment": "@Override\npublic IMarkupFragment getMarkup(final MarkupContainer parent, final Component child) {\n    Args.notNull(tagName, \"tagName\");\n    IMarkupFragment associatedMarkup = parent.getAssociatedMarkup();\n    if (associatedMarkup == null) {\n        throw new MarkupNotFoundException(\"Failed to find markup file associated. \" + parent.getClass().getSimpleName() + \": \" + parent.toString());\n    }\n        IMarkupFragment markup = findStartTag(associatedMarkup);\n    if (markup == null) {\n        throw new MarkupNotFoundException(\"Expected to find <wicket:\" + tagName + \"> in associated markup file. Markup: \" + associatedMarkup.toString());\n    }\n        if (child == null) {\n        return markup;\n    }\n        associatedMarkup = markup.find(child.getId());\n    if (associatedMarkup != null) {\n        return associatedMarkup;\n    }\n    return findMarkupInAssociatedFileHeader(parent, child);\n}", "lc": 0.2727272727272727, "pi": -0.3367346938775511, "ma": 0.5, "nbd": -0.5, "ml": 0.16666666666666666, "d": 0.38062283737024233, "mi": -0.262403211930026, "fo": 0.3333333333333333, "r": -0.028571428571428574, "e": 0.3343355562122828}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-678_6c54045d", "label": 1, "code": "/**\n * Determine whether this child exists at its direct parent.\n * @return  {@code true} iff this child exists at its direct parent.\n */\nprivate boolean exists() {\n    // retrieved from the base state.\n    return isRoot() || parent.writeState == null || parent.writeState.hasChildNode(name);\n}", "code_comment": "/**\n * Determine whether this child exists at its direct parent.\n * @return  {@code true} iff this child exists at its direct parent.\n */\n", "code_no_comment": "private boolean exists() {\n        return isRoot() || parent.writeState == null || parent.writeState.hasChildNode(name);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.1334651507661888, "mi": 0.9486664754803554, "fo": -0.3333333333333333, "r": 2.7714285714285714, "e": -0.1411078417515772}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4877_6470c3f7", "label": 3, "code": "/**\n *  Parses the given URL string.\n *\n *  @param _url\n *             absolute or relative url with query string\n *  @param charset\n *  @return Url object\n */\npublic static Url parse(CharSequence _url, Charset charset) {\n    Args.notNull(_url, \"_url\");\n    final Url result = new Url(charset);\n    // the url object resolved the charset, use that\n    charset = result.getCharset();\n    String url = _url.toString();\n    // extract query string part\n    final String queryString;\n    final String absoluteUrl;\n    final int queryAt = url.indexOf('?');\n    if (queryAt == -1) {\n        queryString = \"\";\n        absoluteUrl = url;\n    } else {\n        absoluteUrl = url.substring(0, queryAt);\n        queryString = url.substring(queryAt + 1);\n    }\n    // get absolute / relative part of url\n    String relativeUrl;\n    // absolute urls contain a scheme://\n    final int idxOfFirstSlash = absoluteUrl.indexOf('/');\n    final int protocolAt = absoluteUrl.indexOf(\"://\");\n    if (protocolAt > -1 && (protocolAt < idxOfFirstSlash)) {\n        result.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);\n        final String afterProto = absoluteUrl.substring(protocolAt + 3);\n        final String hostAndPort;\n        final int relativeAt = afterProto.indexOf('/');\n        if (relativeAt == -1) {\n            relativeUrl = \"\";\n            hostAndPort = afterProto;\n        } else {\n            relativeUrl = afterProto.substring(relativeAt);\n            hostAndPort = afterProto.substring(0, relativeAt);\n        }\n        final int portAt = hostAndPort.lastIndexOf(':');\n        if (portAt == -1) {\n            result.host = hostAndPort;\n            result.port = getDefaultPortForProtocol(result.protocol);\n        } else {\n            result.host = hostAndPort.substring(0, portAt);\n            result.port = Integer.parseInt(hostAndPort.substring(portAt + 1));\n        }\n        if (relativeAt < 0) {\n            relativeUrl = \"/\";\n        }\n    } else {\n        relativeUrl = absoluteUrl;\n    }\n    if (relativeUrl.length() > 0) {\n        boolean removeLast = false;\n        if (relativeUrl.endsWith(\"/\")) {\n            // we need to append something and remove it after splitting\n            // because otherwise the\n            // trailing slashes will be lost\n            relativeUrl += \"/x\";\n            removeLast = true;\n        }\n        String[] segmentArray = Strings.split(relativeUrl, '/');\n        if (removeLast) {\n            segmentArray[segmentArray.length - 1] = null;\n        }\n        for (String s : segmentArray) {\n            if (s != null) {\n                result.segments.add(decodeSegment(s, charset));\n            }\n        }\n    }\n    if (queryString.length() > 0) {\n        String[] queryArray = Strings.split(queryString, '&');\n        for (String s : queryArray) {\n            if (Strings.isEmpty(s) == false) {\n                result.parameters.add(parseQueryParameter(s, charset));\n            }\n        }\n    }\n    return result;\n}", "code_comment": "/**\n *  Parses the given URL string.\n *\n *  @param _url\n *             absolute or relative url with query string\n *  @param charset\n *  @return Url object\n */\n", "code_no_comment": "public static Url parse(CharSequence _url, Charset charset) {\n    Args.notNull(_url, \"_url\");\n    final Url result = new Url(charset);\n        charset = result.getCharset();\n    String url = _url.toString();\n        final String queryString;\n    final String absoluteUrl;\n    final int queryAt = url.indexOf('?');\n    if (queryAt == -1) {\n        queryString = \"\";\n        absoluteUrl = url;\n    } else {\n        absoluteUrl = url.substring(0, queryAt);\n        queryString = url.substring(queryAt + 1);\n    }\n        String relativeUrl;\n        final int idxOfFirstSlash = absoluteUrl.indexOf('/');\n    final int protocolAt = absoluteUrl.indexOf(\"://\");\n    if (protocolAt > -1 && (protocolAt < idxOfFirstSlash)) {\n        result.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);\n        final String afterProto = absoluteUrl.substring(protocolAt + 3);\n        final String hostAndPort;\n        final int relativeAt = afterProto.indexOf('/');\n        if (relativeAt == -1) {\n            relativeUrl = \"\";\n            hostAndPort = afterProto;\n        } else {\n            relativeUrl = afterProto.substring(relativeAt);\n            hostAndPort = afterProto.substring(0, relativeAt);\n        }\n        final int portAt = hostAndPort.lastIndexOf(':');\n        if (portAt == -1) {\n            result.host = hostAndPort;\n            result.port = getDefaultPortForProtocol(result.protocol);\n        } else {\n            result.host = hostAndPort.substring(0, portAt);\n            result.port = Integer.parseInt(hostAndPort.substring(portAt + 1));\n        }\n        if (relativeAt < 0) {\n            relativeUrl = \"/\";\n        }\n    } else {\n        relativeUrl = absoluteUrl;\n    }\n    if (relativeUrl.length() > 0) {\n        boolean removeLast = false;\n        if (relativeUrl.endsWith(\"/\")) {\n                                                relativeUrl += \"/x\";\n            removeLast = true;\n        }\n        String[] segmentArray = Strings.split(relativeUrl, '/');\n        if (removeLast) {\n            segmentArray[segmentArray.length - 1] = null;\n        }\n        for (String s : segmentArray) {\n            if (s != null) {\n                result.segments.add(decodeSegment(s, charset));\n            }\n        }\n    }\n    if (queryString.length() > 0) {\n        String[] queryArray = Strings.split(queryString, '&');\n        for (String s : queryArray) {\n            if (Strings.isEmpty(s) == false) {\n                result.parameters.add(parseQueryParameter(s, charset));\n            }\n        }\n    }\n    return result;\n}", "lc": 2.5454545454545454, "pi": 0.22959183673469397, "ma": 1.6666666666666667, "nbd": 0.5, "ml": 1.5, "d": 1.980227385071676, "mi": -1.1256094063665045, "fo": 1.9166666666666667, "r": -0.028571428571428574, "e": 7.311507146191767}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443", "label": 1, "code": "@Override\npublic void create(String tableName, boolean versioningIter, TimeType timeType) throws AccumuloException, AccumuloSecurityException, TableExistsException {\n    if (!tableName.matches(Constants.VALID_TABLE_NAME_REGEX)) {\n        throw new IllegalArgumentException();\n    }\n    acu.createTable(username, tableName, versioningIter, timeType);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void create(String tableName, boolean versioningIter, TimeType timeType) throws AccumuloException, AccumuloSecurityException, TableExistsException {\n    if (!tableName.matches(Constants.VALID_TABLE_NAME_REGEX)) {\n        throw new IllegalArgumentException();\n    }\n    acu.createTable(username, tableName, versioningIter, timeType);\n}", "lc": -0.3181818181818182, "pi": -0.11224489795918377, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.25, "d": -0.3806228373702422, "mi": 0.42013191855463133, "fo": -0.3333333333333333, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1820_39d526e6", "label": 0, "code": "@Override\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Byte reusable) {\n    int val = 0;\n    boolean neg = false;\n    final int delimLimit = limit - delimiter.length + 1;\n    if (bytes[startPos] == '-') {\n        neg = true;\n        startPos++;\n        // check for empty field with only the sign\n        if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\n            return -1;\n        }\n    }\n    for (int i = startPos; i < limit; i++) {\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n            this.result = (byte) (neg ? -val : val);\n            return i + delimiter.length;\n        }\n        if (bytes[i] < 48 || bytes[i] > 57) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);\n            return -1;\n        }\n        val *= 10;\n        val += bytes[i] - 48;\n        if (val > Byte.MAX_VALUE && (!neg || val > -Byte.MIN_VALUE)) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\n            return -1;\n        }\n    }\n    this.result = (byte) (neg ? -val : val);\n    return limit;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Byte reusable) {\n    int val = 0;\n    boolean neg = false;\n    final int delimLimit = limit - delimiter.length + 1;\n    if (bytes[startPos] == '-') {\n        neg = true;\n        startPos++;\n                if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\n            return -1;\n        }\n    }\n    for (int i = startPos; i < limit; i++) {\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n            this.result = (byte) (neg ? -val : val);\n            return i + delimiter.length;\n        }\n        if (bytes[i] < 48 || bytes[i] > 57) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);\n            return -1;\n        }\n        val *= 10;\n        val += bytes[i] - 48;\n        if (val > Byte.MAX_VALUE && (!neg || val > -Byte.MIN_VALUE)) {\n            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\n            return -1;\n        }\n    }\n    this.result = (byte) (neg ? -val : val);\n    return limit;\n}", "lc": 0.8181818181818182, "pi": 0.3520408163265306, "ma": 0.8333333333333334, "nbd": 0.0, "ml": 1.5833333333333333, "d": 2.9115175481957487, "mi": -0.6119873817034703, "fo": -0.08333333333333333, "r": -0.028571428571428574, "e": 4.5939712439127804}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4260_925cae5c", "label": 1, "code": "@Override\npublic void sendRedirect(String url) {\n    try {\n        redirect = true;\n        url = encodeRedirectURL(url);\n        // wicket redirects should never be cached\n        disableCaching();\n        if (webRequest.isAjax()) {\n            httpServletResponse.addHeader(\"Ajax-Location\", url);\n            /*\n\t\t\t\t * usually the Ajax-Location header is enough and we do not need to the redirect url\n\t\t\t\t * into the response, but sometimes the response is processed via an iframe (eg\n\t\t\t\t * using multipart ajax handling) and the headers are not available because XHR is\n\t\t\t\t * not used and that is the only way javascript has access to response headers.\n\t\t\t\t */\n            httpServletResponse.getWriter().write(\"<ajax-response><redirect><![CDATA[\" + url + \"]]></redirect></ajax-response>\");\n            setContentType(\"text/xml;charset=\" + webRequest.getContainerRequest().getCharacterEncoding());\n            disableCaching();\n        } else {\n            httpServletResponse.sendRedirect(url);\n        }\n    } catch (IOException e) {\n        throw new WicketRuntimeException(e);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void sendRedirect(String url) {\n    try {\n        redirect = true;\n        url = encodeRedirectURL(url);\n                disableCaching();\n        if (webRequest.isAjax()) {\n            httpServletResponse.addHeader(\"Ajax-Location\", url);\n                        httpServletResponse.getWriter().write(\"<ajax-response><redirect><![CDATA[\" + url + \"]]></redirect></ajax-response>\");\n            setContentType(\"text/xml;charset=\" + webRequest.getContainerRequest().getCharacterEncoding());\n            disableCaching();\n        } else {\n            httpServletResponse.sendRedirect(url);\n        }\n    } catch (IOException e) {\n        throw new WicketRuntimeException(e);\n    }\n}", "lc": 0.18181818181818182, "pi": 0.5612244897959184, "ma": 0.0, "nbd": 0.0, "ml": -0.25, "d": -0.0958971824023727, "mi": -0.12446228850014353, "fo": 0.4166666666666667, "r": 0.0, "e": -0.04692458915286469}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3906_aadaa4e9", "label": 1, "code": "/**\n *  @see org.apache.wicket.request.mapper.parameter.INamedParameters#set(java.lang.String,\n *       java.lang.Object)\n */\npublic PageParameters set(final String name, final Object value) {\n    set(name, value, -1);\n    return this;\n}", "code_comment": "/**\n *  @see org.apache.wicket.request.mapper.parameter.INamedParameters#set(java.lang.String,\n *       java.lang.Object)\n */\n", "code_no_comment": "public PageParameters set(final String name, final Object value) {\n    set(name, value, -1);\n    return this;\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8339546888442785, "fo": -0.4166666666666667, "r": 0.4285714285714286, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-294_2c8a114f", "label": 1, "code": "/**\n * {@inheritDoc}\n * <p>\n * <strong>Algorithm Description</strong>: For small means, uses simulation\n * of a Poisson process using Uniform deviates, as described <a\n * href=\"http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm\"> here.</a>\n * </p>\n * <p>\n * The Poisson process (and hence value returned) is bounded by 1000 * mean.\n * </p>\n *\n * <p>\n * For large means, uses a reject method as described in <a\n * href=\"http://cg.scs.carleton.ca/~luc/rnbookindex.html\">Non-Uniform Random\n * Variate Generation</a>\n * </p>\n *\n * <p>\n * References:\n * <ul>\n * <li>Devroye, Luc. (1986). <i>Non-Uniform Random Variate Generation</i>.\n * New York, NY. Springer-Verlag</li>\n * </ul>\n * </p>\n *\n * @param mean\n *            mean of the Poisson distribution.\n * @return the random Poisson value.\n */\npublic long nextPoisson(double mean) {\n    if (mean <= 0) {\n        throw MathRuntimeException.createIllegalArgumentException(\"the Poisson mean must be positive ({0})\", mean);\n    }\n    final RandomGenerator generator = getRan();\n    double pivot = 6.0;\n    if (mean < pivot) {\n        double p = Math.exp(-mean);\n        long n = 0;\n        double r = 1.0d;\n        double rnd = 1.0d;\n        while (n < 1000 * mean) {\n            rnd = generator.nextDouble();\n            r = r * rnd;\n            if (r >= p) {\n                n++;\n            } else {\n                return n;\n            }\n        }\n        return n;\n    } else {\n        double mu = Math.floor(mean);\n        // integer\n        double delta = Math.floor(pivot + (mu - pivot) / 2.0);\n        // between 6\n        // and mean\n        double mu2delta = 2.0 * mu + delta;\n        double muDeltaHalf = mu + delta / 2.0;\n        double logMeanMu = Math.log(mean / mu);\n        double muFactorialLog = MathUtils.factorialLog((int) mu);\n        double c1 = Math.sqrt(Math.PI * mu / 2.0);\n        double c2 = c1 + Math.sqrt(Math.PI * muDeltaHalf / (2.0 * Math.exp(1.0 / mu2delta)));\n        double c3 = c2 + 2.0;\n        double c4 = c3 + Math.exp(1.0 / 78.0);\n        double c = c4 + 2.0 / delta * mu2delta * Math.exp(-delta / mu2delta * (1.0 + delta / 2.0));\n        double y = 0.0;\n        double x = 0.0;\n        double w = Double.POSITIVE_INFINITY;\n        boolean accept = false;\n        while (!accept) {\n            double u = nextUniform(0.0, c);\n            double e = nextExponential(mean);\n            if (u <= c1) {\n                double z = nextGaussian(0.0, 1.0);\n                y = -Math.abs(z) * Math.sqrt(mu) - 1.0;\n                x = Math.floor(y);\n                w = -z * z / 2.0 - e - x * logMeanMu;\n                if (x < -mu) {\n                    w = Double.POSITIVE_INFINITY;\n                }\n            } else if (c1 < u && u <= c2) {\n                double z = nextGaussian(0.0, 1.0);\n                y = 1.0 + Math.abs(z) * Math.sqrt(muDeltaHalf);\n                x = Math.ceil(y);\n                w = (-y * y + 2.0 * y) / mu2delta - e - x * logMeanMu;\n                if (x > delta) {\n                    w = Double.POSITIVE_INFINITY;\n                }\n            } else if (c2 < u && u <= c3) {\n                x = 0.0;\n                w = -e;\n            } else if (c3 < u && u <= c4) {\n                x = 1.0;\n                w = -e - logMeanMu;\n            } else if (c4 < u) {\n                double v = nextExponential(mean);\n                y = delta + v * 2.0 / delta * mu2delta;\n                x = Math.ceil(y);\n                w = -delta / mu2delta * (1.0 + y / 2.0) - e - x * logMeanMu;\n            }\n            accept = w <= x * Math.log(mu) - MathUtils.factorialLog((int) (mu + x)) / muFactorialLog;\n        }\n        // numbers.\n        return (long) (x + mu);\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n * <p>\n * <strong>Algorithm Description</strong>: For small means, uses simulation\n * of a Poisson process using Uniform deviates, as described <a\n * href=\"http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm\"> here.</a>\n * </p>\n * <p>\n * The Poisson process (and hence value returned) is bounded by 1000 * mean.\n * </p>\n *\n * <p>\n * For large means, uses a reject method as described in <a\n * href=\"http://cg.scs.carleton.ca/~luc/rnbookindex.html\">Non-Uniform Random\n * Variate Generation</a>\n * </p>\n *\n * <p>\n * References:\n * <ul>\n * <li>Devroye, Luc. (1986). <i>Non-Uniform Random Variate Generation</i>.\n * New York, NY. Springer-Verlag</li>\n * </ul>\n * </p>\n *\n * @param mean\n *            mean of the Poisson distribution.\n * @return the random Poisson value.\n */\n", "code_no_comment": "public long nextPoisson(double mean) {\n    if (mean <= 0) {\n        throw MathRuntimeException.createIllegalArgumentException(\"the Poisson mean must be positive ({0})\", mean);\n    }\n    final RandomGenerator generator = getRan();\n    double pivot = 6.0;\n    if (mean < pivot) {\n        double p = Math.exp(-mean);\n        long n = 0;\n        double r = 1.0d;\n        double rnd = 1.0d;\n        while (n < 1000 * mean) {\n            rnd = generator.nextDouble();\n            r = r * rnd;\n            if (r >= p) {\n                n++;\n            } else {\n                return n;\n            }\n        }\n        return n;\n    } else {\n        double mu = Math.floor(mean);\n                double delta = Math.floor(pivot + (mu - pivot) / 2.0);\n                        double mu2delta = 2.0 * mu + delta;\n        double muDeltaHalf = mu + delta / 2.0;\n        double logMeanMu = Math.log(mean / mu);\n        double muFactorialLog = MathUtils.factorialLog((int) mu);\n        double c1 = Math.sqrt(Math.PI * mu / 2.0);\n        double c2 = c1 + Math.sqrt(Math.PI * muDeltaHalf / (2.0 * Math.exp(1.0 / mu2delta)));\n        double c3 = c2 + 2.0;\n        double c4 = c3 + Math.exp(1.0 / 78.0);\n        double c = c4 + 2.0 / delta * mu2delta * Math.exp(-delta / mu2delta * (1.0 + delta / 2.0));\n        double y = 0.0;\n        double x = 0.0;\n        double w = Double.POSITIVE_INFINITY;\n        boolean accept = false;\n        while (!accept) {\n            double u = nextUniform(0.0, c);\n            double e = nextExponential(mean);\n            if (u <= c1) {\n                double z = nextGaussian(0.0, 1.0);\n                y = -Math.abs(z) * Math.sqrt(mu) - 1.0;\n                x = Math.floor(y);\n                w = -z * z / 2.0 - e - x * logMeanMu;\n                if (x < -mu) {\n                    w = Double.POSITIVE_INFINITY;\n                }\n            } else if (c1 < u && u <= c2) {\n                double z = nextGaussian(0.0, 1.0);\n                y = 1.0 + Math.abs(z) * Math.sqrt(muDeltaHalf);\n                x = Math.ceil(y);\n                w = (-y * y + 2.0 * y) / mu2delta - e - x * logMeanMu;\n                if (x > delta) {\n                    w = Double.POSITIVE_INFINITY;\n                }\n            } else if (c2 < u && u <= c3) {\n                x = 0.0;\n                w = -e;\n            } else if (c3 < u && u <= c4) {\n                x = 1.0;\n                w = -e - logMeanMu;\n            } else if (c4 < u) {\n                double v = nextExponential(mean);\n                y = delta + v * 2.0 / delta * mu2delta;\n                x = Math.ceil(y);\n                w = -delta / mu2delta * (1.0 + y / 2.0) - e - x * logMeanMu;\n            }\n            accept = w <= x * Math.log(mu) - MathUtils.factorialLog((int) (mu + x)) / muFactorialLog;\n        }\n                return (long) (x + mu);\n    }\n}", "lc": 2.6818181818181817, "pi": 0.8061224489795916, "ma": 1.6666666666666667, "nbd": 2.5, "ml": 2.0, "d": 4.5902125556104805, "mi": -1.2133639231431033, "fo": 1.75, "r": -0.028571428571428574, "e": 24.714550648660918}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1705_5308ac83", "label": 1, "code": "public String getHostname() {\n    if (hostName == null) {\n        String fqdn = getFQDNHostname();\n        if (this.fqdnHostNameIsIP) {\n            // fqdn to hostname translation is pointless if FQDN is an ip address.\n            hostName = fqdn;\n        } else {\n            hostName = NetUtils.getHostnameFromFQDN(fqdn);\n        }\n    }\n    return hostName;\n}", "code_comment": NaN, "code_no_comment": "public String getHostname() {\n    if (hostName == null) {\n        String fqdn = getFQDNHostname();\n        if (this.fqdnHostNameIsIP) {\n                        hostName = fqdn;\n        } else {\n            hostName = NetUtils.getHostnameFromFQDN(fqdn);\n        }\n    }\n    return hostName;\n}", "lc": -0.13636363636363635, "pi": 0.47448979591836743, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.06426099851705384, "mi": 0.2563808431316318, "fo": -0.3333333333333333, "r": 1.885714285714286, "e": -0.11509287693645309}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2999_3bf07779", "label": 1, "code": "private Document makeDocument(String path, NodeState state, boolean isUpdate) {\n    if (!isIndexable()) {\n        return null;\n    }\n    List<Field> fields = new ArrayList<Field>();\n    boolean dirty = false;\n    for (PropertyState property : state.getProperties()) {\n        String pname = property.getName();\n        if (!isVisible(pname)) {\n            continue;\n        }\n        PropertyDefinition pd = indexingRule.getConfig(pname);\n        if (pd == null || !pd.index) {\n            continue;\n        }\n        if (pd.ordered) {\n            dirty |= addTypedOrderedFields(fields, property, pname, pd);\n        }\n        dirty |= indexProperty(path, fields, state, property, pname, pd);\n    }\n    dirty |= indexAggregates(path, fields, state);\n    dirty |= indexNullCheckEnabledProps(path, fields, state);\n    dirty |= indexNotNullCheckEnabledProps(path, fields, state);\n    if (isUpdate && !dirty) {\n        // updated the state but had no relevant changes\n        return null;\n    }\n    // none of the properties are indexed\n    if (!indexingRule.isFulltextEnabled() && !dirty) {\n        return null;\n    }\n    Document document = new Document();\n    document.add(newPathField(path));\n    String name = getName(path);\n    // TODO Possibly index nodeName without tokenization for node name based queries\n    if (indexingRule.isFulltextEnabled()) {\n        document.add(newFulltextField(name));\n    }\n    if (getDefinition().evaluatePathRestrictions()) {\n        document.add(newAncestorsField(PathUtils.getParentPath(path)));\n        document.add(newDepthField(path));\n    }\n    // because of LUCENE-5833 we have to merge the suggest fields into a single one\n    Field suggestField = null;\n    for (Field f : fields) {\n        if (FieldNames.SUGGEST.endsWith(f.name())) {\n            if (suggestField == null) {\n                suggestField = FieldFactory.newSuggestField(f.stringValue());\n            } else {\n                suggestField = FieldFactory.newSuggestField(suggestField.stringValue(), f.stringValue());\n            }\n        } else {\n            document.add(f);\n        }\n    }\n    if (suggestField != null) {\n        document.add(suggestField);\n    }\n    return document;\n}", "code_comment": NaN, "code_no_comment": "private Document makeDocument(String path, NodeState state, boolean isUpdate) {\n    if (!isIndexable()) {\n        return null;\n    }\n    List<Field> fields = new ArrayList<Field>();\n    boolean dirty = false;\n    for (PropertyState property : state.getProperties()) {\n        String pname = property.getName();\n        if (!isVisible(pname)) {\n            continue;\n        }\n        PropertyDefinition pd = indexingRule.getConfig(pname);\n        if (pd == null || !pd.index) {\n            continue;\n        }\n        if (pd.ordered) {\n            dirty |= addTypedOrderedFields(fields, property, pname, pd);\n        }\n        dirty |= indexProperty(path, fields, state, property, pname, pd);\n    }\n    dirty |= indexAggregates(path, fields, state);\n    dirty |= indexNullCheckEnabledProps(path, fields, state);\n    dirty |= indexNotNullCheckEnabledProps(path, fields, state);\n    if (isUpdate && !dirty) {\n                return null;\n    }\n        if (!indexingRule.isFulltextEnabled() && !dirty) {\n        return null;\n    }\n    Document document = new Document();\n    document.add(newPathField(path));\n    String name = getName(path);\n        if (indexingRule.isFulltextEnabled()) {\n        document.add(newFulltextField(name));\n    }\n    if (getDefinition().evaluatePathRestrictions()) {\n        document.add(newAncestorsField(PathUtils.getParentPath(path)));\n        document.add(newDepthField(path));\n    }\n        Field suggestField = null;\n    for (Field f : fields) {\n        if (FieldNames.SUGGEST.endsWith(f.name())) {\n            if (suggestField == null) {\n                suggestField = FieldFactory.newSuggestField(f.stringValue());\n            } else {\n                suggestField = FieldFactory.newSuggestField(suggestField.stringValue(), f.stringValue());\n            }\n        } else {\n            document.add(f);\n        }\n    }\n    if (suggestField != null) {\n        document.add(suggestField);\n    }\n    return document;\n}", "lc": 1.9090909090909092, "pi": 0.23979591836734704, "ma": 2.0, "nbd": 0.5, "ml": 1.8333333333333333, "d": 1.151754819574889, "mi": -0.9727559506739321, "fo": 2.25, "r": -0.028571428571428574, "e": 3.0336429945049064}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3684_e3759a5e", "label": 1, "code": "@Override\npublic void processWatermark(Watermark mark) throws Exception {\n    // iterate over all keys to trigger the execution of the buffered elements\n    for (KEY key : keys) {\n        setKeyContext(key);\n        PriorityQueue<StreamRecord<IN>> priorityQueue = getPriorityQueue();\n        NFA<IN> nfa = getNFA();\n        while (!priorityQueue.isEmpty() && priorityQueue.peek().getTimestamp() <= mark.getTimestamp()) {\n            StreamRecord<IN> streamRecord = priorityQueue.poll();\n            processEvent(nfa, streamRecord.getValue(), streamRecord.getTimestamp());\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void processWatermark(Watermark mark) throws Exception {\n        for (KEY key : keys) {\n        setKeyContext(key);\n        PriorityQueue<StreamRecord<IN>> priorityQueue = getPriorityQueue();\n        NFA<IN> nfa = getNFA();\n        while (!priorityQueue.isEmpty() && priorityQueue.peek().getTimestamp() <= mark.getTimestamp()) {\n            StreamRecord<IN> streamRecord = priorityQueue.poll();\n            processEvent(nfa, streamRecord.getValue(), streamRecord.getTimestamp());\n        }\n    }\n}", "lc": -0.09090909090909091, "pi": 0.5816326530612246, "ma": -0.16666666666666666, "nbd": 0.0, "ml": 0.0, "d": 0.2204646564508157, "mi": 0.053054201319185396, "fo": 0.4166666666666667, "r": 0.0, "e": 0.1140820880499912}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-4370_7345fefc", "label": 1, "code": "/**\n * Bind this GenericFile to an Exchange\n */\npublic void bindToExchange(Exchange exchange) {\n    exchange.setProperty(FileComponent.FILE_EXCHANGE_FILE, this);\n    GenericFileMessage<T> in = new GenericFileMessage<T>(this);\n    exchange.setIn(in);\n    populateHeaders(in);\n}", "code_comment": "/**\n * Bind this GenericFile to an Exchange\n */\n", "code_no_comment": "public void bindToExchange(Exchange exchange) {\n    exchange.setProperty(FileComponent.FILE_EXCHANGE_FILE, this);\n    GenericFileMessage<T> in = new GenericFileMessage<T>(this);\n    exchange.setIn(in);\n    populateHeaders(in);\n}", "lc": -0.36363636363636365, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.5540579294522512, "fo": -0.25, "r": 2.1714285714285717, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 151, "label": 2, "code": "private void initConfigFromFlags(String[] args, PrintStream err) {\n    // Args4j has a different format that the old command-line parser.\n    // So we use some voodoo to get the args into the format that args4j\n    // expects.\n    Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n    Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n    List<String> processedArgs = Lists.newArrayList();\n    for (String arg : args) {\n        Matcher matcher = argPattern.matcher(arg);\n        if (matcher.matches()) {\n            processedArgs.add(matcher.group(1));\n            String value = matcher.group(2);\n            Matcher quotesMatcher = quotesPattern.matcher(value);\n            if (quotesMatcher.matches()) {\n                processedArgs.add(quotesMatcher.group(1));\n            } else {\n                processedArgs.add(value);\n            }\n        } else {\n            processedArgs.add(arg);\n        }\n    }\n    CmdLineParser parser = new CmdLineParser(flags);\n    isConfigValid = true;\n    try {\n        parser.parseArgument(processedArgs.toArray(new String[] {}));\n    } catch (CmdLineException e) {\n        err.println(e.getMessage());\n        isConfigValid = false;\n    }\n    if (!isConfigValid || flags.display_help) {\n        isConfigValid = false;\n        parser.printUsage(err);\n    } else {\n        getCommandLineConfig().setPrintTree(flags.print_tree).setComputePhaseOrdering(flags.compute_phase_ordering).setPrintAst(flags.print_ast).setPrintPassGraph(flags.print_pass_graph).setJscompDevMode(flags.jscomp_dev_mode).setLoggingLevel(flags.logging_level).setExterns(flags.externs).setJs(flags.js).setJsOutputFile(flags.js_output_file).setModule(flags.module).setVariableMapInputFile(flags.variable_map_input_file).setPropertyMapInputFile(flags.property_map_input_file).setVariableMapOutputFile(flags.variable_map_output_file).setCreateNameMapFiles(flags.create_name_map_files).setPropertyMapOutputFile(flags.property_map_output_file).setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()).setSummaryDetailLevel(flags.summary_detail_level).setOutputWrapper(flags.output_wrapper).setOutputWrapperMarker(flags.output_wrapper_marker).setModuleWrapper(flags.module_wrapper).setModuleOutputPathPrefix(flags.module_output_path_prefix).setCreateSourceMap(flags.create_source_map).setJscompError(flags.jscomp_error).setJscompWarning(flags.jscomp_warning).setJscompOff(flags.jscomp_off).setDefine(flags.define).setCharset(flags.charset).setManageClosureDependencies(flags.manage_closure_dependencies).setOutputManifest(flags.output_manifest);\n    }\n}", "code_comment": NaN, "code_no_comment": "private void initConfigFromFlags(String[] args, PrintStream err) {\n                Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n    Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n    List<String> processedArgs = Lists.newArrayList();\n    for (String arg : args) {\n        Matcher matcher = argPattern.matcher(arg);\n        if (matcher.matches()) {\n            processedArgs.add(matcher.group(1));\n            String value = matcher.group(2);\n            Matcher quotesMatcher = quotesPattern.matcher(value);\n            if (quotesMatcher.matches()) {\n                processedArgs.add(quotesMatcher.group(1));\n            } else {\n                processedArgs.add(value);\n            }\n        } else {\n            processedArgs.add(arg);\n        }\n    }\n    CmdLineParser parser = new CmdLineParser(flags);\n    isConfigValid = true;\n    try {\n        parser.parseArgument(processedArgs.toArray(new String[] {}));\n    } catch (CmdLineException e) {\n        err.println(e.getMessage());\n        isConfigValid = false;\n    }\n    if (!isConfigValid || flags.display_help) {\n        isConfigValid = false;\n        parser.printUsage(err);\n    } else {\n        getCommandLineConfig().setPrintTree(flags.print_tree).setComputePhaseOrdering(flags.compute_phase_ordering).setPrintAst(flags.print_ast).setPrintPassGraph(flags.print_pass_graph).setJscompDevMode(flags.jscomp_dev_mode).setLoggingLevel(flags.logging_level).setExterns(flags.externs).setJs(flags.js).setJsOutputFile(flags.js_output_file).setModule(flags.module).setVariableMapInputFile(flags.variable_map_input_file).setPropertyMapInputFile(flags.property_map_input_file).setVariableMapOutputFile(flags.variable_map_output_file).setCreateNameMapFiles(flags.create_name_map_files).setPropertyMapOutputFile(flags.property_map_output_file).setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()).setSummaryDetailLevel(flags.summary_detail_level).setOutputWrapper(flags.output_wrapper).setOutputWrapperMarker(flags.output_wrapper_marker).setModuleWrapper(flags.module_wrapper).setModuleOutputPathPrefix(flags.module_output_path_prefix).setCreateSourceMap(flags.create_source_map).setJscompError(flags.jscomp_error).setJscompWarning(flags.jscomp_warning).setJscompOff(flags.jscomp_off).setDefine(flags.define).setCharset(flags.charset).setManageClosureDependencies(flags.manage_closure_dependencies).setOutputManifest(flags.output_manifest);\n    }\n}", "lc": 0.9090909090909091, "pi": 0.5255102040816325, "ma": 0.5, "nbd": 0.5, "ml": 0.4166666666666667, "d": -0.03657933761739987, "mi": -0.7218239174075138, "fo": 3.5833333333333335, "r": -0.028571428571428574, "e": 0.7759303754909394}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4121_8967eb2b", "label": 1, "code": "/**\n *  @see org.apache.wicket.extensions.wizard.IWizardModel#reset()\n */\npublic void reset() {\n    history.clear();\n    activeStep = null;\n    setActiveStep(findNextVisibleStep());\n}", "code_comment": "/**\n *  @see org.apache.wicket.extensions.wizard.IWizardModel#reset()\n */\n", "code_no_comment": "public void reset() {\n    history.clear();\n    activeStep = null;\n    setActiveStep(findNextVisibleStep());\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7731574419271581, "fo": -0.25, "r": 2.628571428571429, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 153, "label": 2, "code": "/**\n * Remove duplicate VAR declarations encountered discovered during\n * scope creation.\n */\n@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n    // If name is \"arguments\", Var maybe null.\n    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n    } else if (v != null && parent.getType() == Token.FUNCTION) {\n        if (v.getParentNode().getType() == Token.VAR) {\n            s.undeclare(v);\n            s.declare(name, n, n.getJSType(), v.input);\n            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n        }\n    } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n        replaceVarWithAssignment(n, parent, gramps);\n    }\n}", "code_comment": "/**\n * Remove duplicate VAR declarations encountered discovered during\n * scope creation.\n */\n", "code_no_comment": "@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n        if (v != null && v.getParentNode().getType() == Token.CATCH) {\n                                                                                                                name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n    } else if (v != null && parent.getType() == Token.FUNCTION) {\n        if (v.getParentNode().getType() == Token.VAR) {\n            s.undeclare(v);\n            s.declare(name, n, n.getJSType(), v.input);\n            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n        }\n    } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n        replaceVarWithAssignment(n, parent, gramps);\n    }\n}", "lc": 0.18181818181818182, "pi": 0.413265306122449, "ma": 0.16666666666666666, "nbd": 0.5, "ml": 0.3333333333333333, "d": 0.44784972812654494, "mi": -0.29251505592199617, "fo": 1.5, "r": -0.028571428571428574, "e": 0.8416059550884225}
{"project_name": "Math", "project_version": 100, "label": 0, "code": "/**\n * Guess the errors in unbound estimated parameters.\n * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>\n * @param problem estimation problem\n * @return errors in estimated parameters\n * @exception EstimationException if the covariances matrix cannot be computed\n * or the number of degrees of freedom is not positive (number of measurements\n * lesser or equal to number of parameters)\n */\npublic double[] guessParametersErrors(EstimationProblem problem) throws EstimationException {\n    int m = problem.getMeasurements().length;\n    int p = problem.getAllParameters().length;\n    if (m <= p) {\n        throw new EstimationException(\"no degrees of freedom ({0} measurements, {1} parameters)\", new Object[] { new Integer(m), new Integer(p) });\n    }\n    double[] errors = new double[problem.getAllParameters().length];\n    final double c = Math.sqrt(getChiSquare(problem) / (m - p));\n    double[][] covar = getCovariances(problem);\n    for (int i = 0; i < errors.length; ++i) {\n        errors[i] = Math.sqrt(covar[i][i]) * c;\n    }\n    return errors;\n}", "code_comment": "/**\n * Guess the errors in unbound estimated parameters.\n * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>\n * @param problem estimation problem\n * @return errors in estimated parameters\n * @exception EstimationException if the covariances matrix cannot be computed\n * or the number of degrees of freedom is not positive (number of measurements\n * lesser or equal to number of parameters)\n */\n", "code_no_comment": "public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException {\n    int m = problem.getMeasurements().length;\n    int p = problem.getAllParameters().length;\n    if (m <= p) {\n        throw new EstimationException(\"no degrees of freedom ({0} measurements, {1} parameters)\", new Object[] { new Integer(m), new Integer(p) });\n    }\n    double[] errors = new double[problem.getAllParameters().length];\n    final double c = Math.sqrt(getChiSquare(problem) / (m - p));\n    double[][] covar = getCovariances(problem);\n    for (int i = 0; i < errors.length; ++i) {\n        errors[i] = Math.sqrt(covar[i][i]) * c;\n    }\n    return errors;\n}", "lc": 0.0, "pi": -0.44897959183673464, "ma": 0.0, "nbd": -0.5, "ml": 0.08333333333333333, "d": 0.9935739001482948, "mi": -0.08115858904502435, "fo": 0.08333333333333333, "r": -0.028571428571428574, "e": 0.7618607081518409}
{"project_name": "Math", "project_version": 39, "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n    // create some internal working arrays\n    final double[] y0 = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][y.length];\n    final double[] yTmp = y0.clone();\n    final double[] yDotTmp = new double[y.length];\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n    // set up integration control objects\n    stepStart = equations.getTime();\n    double hNew = 0;\n    boolean firstTime = true;\n    initIntegration(equations.getTime(), y0, t);\n    // main integration loop\n    isLastStep = false;\n    do {\n        interpolator.shift();\n        // iterate over step size, ensuring local normalized error is smaller than 1\n        double error = 10;\n        while (error >= 1.0) {\n            if (firstTime || !fsal) {\n                // first stage\n                computeDerivatives(stepStart, y, yDotK[0]);\n            }\n            if (firstTime) {\n                final double[] scale = new double[mainSetDimension];\n                if (vecAbsoluteTolerance == null) {\n                    for (int i = 0; i < scale.length; ++i) {\n                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n                    }\n                } else {\n                    for (int i = 0; i < scale.length; ++i) {\n                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n                    }\n                }\n                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);\n                firstTime = false;\n            }\n            stepSize = hNew;\n            // next stages\n            for (int k = 1; k < stages; ++k) {\n                for (int j = 0; j < y0.length; ++j) {\n                    double sum = a[k - 1][0] * yDotK[0][j];\n                    for (int l = 1; l < k; ++l) {\n                        sum += a[k - 1][l] * yDotK[l][j];\n                    }\n                    yTmp[j] = y[j] + stepSize * sum;\n                }\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n            }\n            // estimate the state at the end of the step\n            for (int j = 0; j < y0.length; ++j) {\n                double sum = b[0] * yDotK[0][j];\n                for (int l = 1; l < stages; ++l) {\n                    sum += b[l] * yDotK[l][j];\n                }\n                yTmp[j] = y[j] + stepSize * sum;\n            }\n            // estimate the error at the end of the step\n            error = estimateError(yDotK, y, yTmp, stepSize);\n            if (error >= 1.0) {\n                // reject the step and attempt to reduce error by stepsize control\n                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n                hNew = filterStep(stepSize * factor, forward, false);\n            }\n        }\n        // local error is small enough: accept the step, trigger events and step handlers\n        interpolator.storeTime(stepStart + stepSize);\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\n        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n        stepStart = acceptStep(interpolator, y, yDotTmp, t);\n        System.arraycopy(y, 0, yTmp, 0, y.length);\n        if (!isLastStep) {\n            // prepare next step\n            interpolator.storeTime(stepStart);\n            if (fsal) {\n                // save the last evaluation for the next step\n                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n            }\n            // stepsize control for next step\n            final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n            final double scaledH = stepSize * factor;\n            final double nextT = stepStart + scaledH;\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n            hNew = filterStep(scaledH, forward, nextIsLast);\n            final double filteredNextT = stepStart + hNew;\n            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n            if (filteredNextIsLast) {\n                hNew = t - stepStart;\n            }\n        }\n    } while (!isLastStep);\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n    resetInternalState();\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n        final double[] y0 = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][y.length];\n    final double[] yTmp = y0.clone();\n    final double[] yDotTmp = new double[y.length];\n        final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n        stepStart = equations.getTime();\n    double hNew = 0;\n    boolean firstTime = true;\n    initIntegration(equations.getTime(), y0, t);\n        isLastStep = false;\n    do {\n        interpolator.shift();\n                double error = 10;\n        while (error >= 1.0) {\n            if (firstTime || !fsal) {\n                                computeDerivatives(stepStart, y, yDotK[0]);\n            }\n            if (firstTime) {\n                final double[] scale = new double[mainSetDimension];\n                if (vecAbsoluteTolerance == null) {\n                    for (int i = 0; i < scale.length; ++i) {\n                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n                    }\n                } else {\n                    for (int i = 0; i < scale.length; ++i) {\n                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n                    }\n                }\n                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);\n                firstTime = false;\n            }\n            stepSize = hNew;\n                        for (int k = 1; k < stages; ++k) {\n                for (int j = 0; j < y0.length; ++j) {\n                    double sum = a[k - 1][0] * yDotK[0][j];\n                    for (int l = 1; l < k; ++l) {\n                        sum += a[k - 1][l] * yDotK[l][j];\n                    }\n                    yTmp[j] = y[j] + stepSize * sum;\n                }\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n            }\n                        for (int j = 0; j < y0.length; ++j) {\n                double sum = b[0] * yDotK[0][j];\n                for (int l = 1; l < stages; ++l) {\n                    sum += b[l] * yDotK[l][j];\n                }\n                yTmp[j] = y[j] + stepSize * sum;\n            }\n                        error = estimateError(yDotK, y, yTmp, stepSize);\n            if (error >= 1.0) {\n                                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n                hNew = filterStep(stepSize * factor, forward, false);\n            }\n        }\n                interpolator.storeTime(stepStart + stepSize);\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\n        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n        stepStart = acceptStep(interpolator, y, yDotTmp, t);\n        System.arraycopy(y, 0, yTmp, 0, y.length);\n        if (!isLastStep) {\n                        interpolator.storeTime(stepStart);\n            if (fsal) {\n                                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n            }\n                        final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n            final double scaledH = stepSize * factor;\n            final double nextT = stepStart + scaledH;\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n            hNew = filterStep(scaledH, forward, nextIsLast);\n            final double filteredNextT = stepStart + hNew;\n            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n            if (filteredNextIsLast) {\n                hNew = t - stepStart;\n            }\n        }\n    } while (!isLastStep);\n        equations.setTime(stepStart);\n    equations.setCompleteState(y);\n    resetInternalState();\n}", "lc": 3.4545454545454546, "pi": 1.5255102040816326, "ma": 2.5, "nbd": 1.5, "ml": 2.3333333333333335, "d": 4.295600593178448, "mi": -1.3753943217665618, "fo": 2.9166666666666665, "r": -0.028571428571428574, "e": 28.777210993614037}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1505_994df698", "label": 1, "code": "@Override\npublic void addMutation(Mutation m) throws MutationsRejectedException {\n    acu.addMutation(tablename, m);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void addMutation(Mutation m) throws MutationsRejectedException {\n    acu.addMutation(tablename, m);\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8695153427014626, "fo": -0.4166666666666667, "r": 1.2, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4520_b91154ea", "label": 1, "code": "/**\n *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT OVERRIDE OR CALL.\n *\n *  Internal initialization.\n */\nprotected void internalInit() {\n    settingsAccessible = true;\n    IPageSettings pageSettings = getPageSettings();\n    // Install default component resolvers\n    pageSettings.addComponentResolver(new MarkupInheritanceResolver());\n    pageSettings.addComponentResolver(new HtmlHeaderResolver());\n    pageSettings.addComponentResolver(new WicketLinkTagHandler());\n    pageSettings.addComponentResolver(new WicketMessageResolver());\n    pageSettings.addComponentResolver(new WicketMessageTagHandler());\n    pageSettings.addComponentResolver(new FragmentResolver());\n    pageSettings.addComponentResolver(new RelativePathPrefixHandler());\n    pageSettings.addComponentResolver(new EnclosureHandler());\n    pageSettings.addComponentResolver(new InlineEnclosureHandler());\n    pageSettings.addComponentResolver(new WicketContainerResolver());\n    // Install button image resource factory\n    getResourceSettings().addResourceFactory(\"buttonFactory\", new DefaultButtonImageResourceFactory());\n    String applicationKey = getApplicationKey();\n    applicationKeyToApplication.put(applicationKey, this);\n    converterLocator = newConverterLocator();\n    setPageManagerProvider(new DefaultPageManagerProvider(this));\n    resourceReferenceRegistry = newResourceReferenceRegistry();\n    sharedResources = newSharedResources(resourceReferenceRegistry);\n    resourceBundles = newResourceBundles(resourceReferenceRegistry);\n    // set up default request mapper\n    setRootRequestMapper(new SystemMapper(this));\n    pageFactory = newPageFactory();\n    requestCycleProvider = new DefaultRequestCycleProvider();\n    exceptionMapperProvider = new DefaultExceptionMapperProvider();\n    // add a request cycle listener that logs each request for the requestlogger.\n    getRequestCycleListeners().add(new RequestLoggerRequestCycleListener());\n}", "code_comment": "/**\n *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT OVERRIDE OR CALL.\n *\n *  Internal initialization.\n */\n", "code_no_comment": "protected void internalInit() {\n    settingsAccessible = true;\n    IPageSettings pageSettings = getPageSettings();\n        pageSettings.addComponentResolver(new MarkupInheritanceResolver());\n    pageSettings.addComponentResolver(new HtmlHeaderResolver());\n    pageSettings.addComponentResolver(new WicketLinkTagHandler());\n    pageSettings.addComponentResolver(new WicketMessageResolver());\n    pageSettings.addComponentResolver(new WicketMessageTagHandler());\n    pageSettings.addComponentResolver(new FragmentResolver());\n    pageSettings.addComponentResolver(new RelativePathPrefixHandler());\n    pageSettings.addComponentResolver(new EnclosureHandler());\n    pageSettings.addComponentResolver(new InlineEnclosureHandler());\n    pageSettings.addComponentResolver(new WicketContainerResolver());\n        getResourceSettings().addResourceFactory(\"buttonFactory\", new DefaultButtonImageResourceFactory());\n    String applicationKey = getApplicationKey();\n    applicationKeyToApplication.put(applicationKey, this);\n    converterLocator = newConverterLocator();\n    setPageManagerProvider(new DefaultPageManagerProvider(this));\n    resourceReferenceRegistry = newResourceReferenceRegistry();\n    sharedResources = newSharedResources(resourceReferenceRegistry);\n    resourceBundles = newResourceBundles(resourceReferenceRegistry);\n        setRootRequestMapper(new SystemMapper(this));\n    pageFactory = newPageFactory();\n    requestCycleProvider = new DefaultRequestCycleProvider();\n    exceptionMapperProvider = new DefaultExceptionMapperProvider();\n        getRequestCycleListeners().add(new RequestLoggerRequestCycleListener());\n}", "lc": 0.5909090909090909, "pi": -1.0051020408163265, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": -0.4212790364209923, "fo": 1.5, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1008_0c20bfd8", "label": 1, "code": "/**\n * Finds matching classes within a jar files that contains a folder structure\n * matching the package structure.  If the File is not a JarFile or does not exist a warning\n * will be logged, but no error will be raised.\n *\n * @param test a Test used to filter the classes that are discovered\n * @param parent the parent package under which classes must be in order to be considered\n * @param stream The jar InputStream\n */\nprivate void loadImplementationsInJar(final Test test, final String parent, final String path, final JarInputStream stream) {\n    try {\n        JarEntry entry;\n        while ((entry = stream.getNextJarEntry()) != null) {\n            final String name = entry.getName();\n            if (!entry.isDirectory() && name.startsWith(parent) && isTestApplicable(test, name)) {\n                addIfMatching(test, name);\n            }\n        }\n    } catch (final IOException ioe) {\n        LOGGER.error(\"Could not search jar file '\" + path + \"' for classes matching criteria: \" + test + \" due to an IOException\", ioe);\n    }\n}", "code_comment": "/**\n * Finds matching classes within a jar files that contains a folder structure\n * matching the package structure.  If the File is not a JarFile or does not exist a warning\n * will be logged, but no error will be raised.\n *\n * @param test a Test used to filter the classes that are discovered\n * @param parent the parent package under which classes must be in order to be considered\n * @param stream The jar InputStream\n */\n", "code_no_comment": "private void loadImplementationsInJar(final Test test, final String parent, final String path, final JarInputStream stream) {\n    try {\n        JarEntry entry;\n        while ((entry = stream.getNextJarEntry()) != null) {\n            final String name = entry.getName();\n            if (!entry.isDirectory() && name.startsWith(parent) && isTestApplicable(test, name)) {\n                addIfMatching(test, name);\n            }\n        }\n    } catch (final IOException ioe) {\n        LOGGER.error(\"Could not search jar file '\" + path + \"' for classes matching criteria: \" + test + \" due to an IOException\", ioe);\n    }\n}", "lc": -0.045454545454545456, "pi": 0.8418367346938775, "ma": 0.0, "nbd": 0.5, "ml": 0.4166666666666667, "d": 0.24221453287197237, "mi": -0.003441353599082437, "fo": 0.08333333333333333, "r": 0.1142857142857143, "e": 0.15029916781237018}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3110_d10362c0", "label": 1, "code": "public Directory wrapForWrite(IndexDefinition definition, Directory remote, boolean reindexMode) throws IOException {\n    Directory local = createLocalDirForIndexWriter(definition);\n    return new CopyOnWriteDirectory(remote, local, reindexMode, getIndexPathForLogging(definition));\n}", "code_comment": NaN, "code_no_comment": "public Directory wrapForWrite(IndexDefinition definition, Directory remote, boolean reindexMode) throws IOException {\n    Directory local = createLocalDirForIndexWriter(definition);\n    return new CopyOnWriteDirectory(remote, local, reindexMode, getIndexPathForLogging(definition));\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7347289934040726, "fo": -0.3333333333333333, "r": 0.05714285714285714, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2350_cd281092", "label": 1, "code": "/**\n *  @see org.apache.wicket.validation.IErrorMessageSource#getMessage(java.lang.String)\n */\npublic String getMessage(String key) {\n    final FormComponent<T> formComponent = FormComponent.this;\n    // Use the following log4j config for detailed logging on the property resolution\n    // process\n    // log4j.logger.org.apache.wicket.resource.loader=DEBUG\n    // log4j.logger.org.apache.wicket.Localizer=DEBUG\n    final Localizer localizer = formComponent.getLocalizer();\n    // retrieve prefix that will be used to construct message keys\n    String prefix = formComponent.getValidatorKeyPrefix();\n    String message = null;\n    // first try the full form of key [prefix].[form-component-id].[key]\n    String resource = prefix(prefix, getId() + \".\" + key);\n    message = getString(localizer, resource, formComponent);\n    // if not found, try a more general form (without prefix) [form-component-id].[key]\n    if (Strings.isEmpty(message) && Strings.isEmpty(prefix)) {\n        resource = getId() + \".\" + key;\n        message = getString(localizer, resource, formComponent);\n    }\n    // If not found try a more general form [prefix].[key]\n    if (Strings.isEmpty(message)) {\n        resource = prefix(prefix, key);\n        message = getString(localizer, key, formComponent);\n    }\n    // If not found try the most general form [key]\n    if (Strings.isEmpty(message) && Strings.isEmpty(prefix)) {\n        // Try a variation of the resource key\n        message = getString(localizer, key, formComponent);\n    }\n    // returned from localizer\n    if (Strings.isEmpty(message)) {\n        message = null;\n    }\n    return message;\n}", "code_comment": "/**\n *  @see org.apache.wicket.validation.IErrorMessageSource#getMessage(java.lang.String)\n */\n", "code_no_comment": "public String getMessage(String key) {\n    final FormComponent<T> formComponent = FormComponent.this;\n                    final Localizer localizer = formComponent.getLocalizer();\n        String prefix = formComponent.getValidatorKeyPrefix();\n    String message = null;\n        String resource = prefix(prefix, getId() + \".\" + key);\n    message = getString(localizer, resource, formComponent);\n        if (Strings.isEmpty(message) && Strings.isEmpty(prefix)) {\n        resource = getId() + \".\" + key;\n        message = getString(localizer, resource, formComponent);\n    }\n        if (Strings.isEmpty(message)) {\n        resource = prefix(prefix, key);\n        message = getString(localizer, key, formComponent);\n    }\n        if (Strings.isEmpty(message) && Strings.isEmpty(prefix)) {\n                message = getString(localizer, key, formComponent);\n    }\n        if (Strings.isEmpty(message)) {\n        message = null;\n    }\n    return message;\n}", "lc": 0.4090909090909091, "pi": -0.39285714285714285, "ma": 0.16666666666666666, "nbd": -0.5, "ml": 0.4166666666666667, "d": 0.37073652990608014, "mi": -0.36191568683682274, "fo": 0.8333333333333334, "r": -0.028571428571428574, "e": 0.5131038499920765}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5265_0eb596df", "label": 1, "code": "@Override\nprotected boolean shouldRecurseInto(Component component) {\n    return component.getMetaData(FENCE_KEY) == null;\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected boolean shouldRecurseInto(Component component) {\n    return component.getMetaData(FENCE_KEY) == null;\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8611987381703473, "fo": -0.4166666666666667, "r": 2.342857142857143, "e": -0.16422749602751402}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3260_6968a57a", "label": 0, "code": "// --------------------------------------------------------------------------------------------\n// Internal Actions\n// --------------------------------------------------------------------------------------------\nprivate boolean processFail(Throwable t, boolean isCallback) {\n    // atomically switch to failed\n    while (true) {\n        ExecutionState current = this.state;\n        if (current == FAILED) {\n            // already failed. It is enough to remember once that we failed (its sad enough)\n            return false;\n        }\n        if (current == CANCELED) {\n            // we are already aborting or are already aborted\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(String.format(\"Ignoring transition of vertex %s to %s while being %s\", getVertexWithAttempt(), FAILED, CANCELED));\n            }\n            return false;\n        }\n        if (transitionState(current, FAILED, t)) {\n            // success (in a manner of speaking)\n            this.failureCause = t;\n            try {\n                if (assignedResource != null) {\n                    assignedResource.releaseSlot();\n                }\n                vertex.getExecutionGraph().deregisterExecution(this);\n            } finally {\n                vertex.executionFailed(t);\n            }\n            if (!isCallback && (current == RUNNING || current == DEPLOYING)) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Sending out cancel request, to remove task execution from TaskManager.\");\n                }\n                try {\n                    if (assignedResource != null) {\n                        sendCancelRpcCall();\n                    }\n                } catch (Throwable tt) {\n                    // no reason this should ever happen, but log it to be safe\n                    LOG.error(\"Error triggering cancel call while marking task as failed.\", tt);\n                }\n            }\n            // leave the loop\n            return true;\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private boolean processFail(Throwable t, boolean isCallback) {\n        while (true) {\n        ExecutionState current = this.state;\n        if (current == FAILED) {\n                        return false;\n        }\n        if (current == CANCELED) {\n                        if (LOG.isDebugEnabled()) {\n                LOG.debug(String.format(\"Ignoring transition of vertex %s to %s while being %s\", getVertexWithAttempt(), FAILED, CANCELED));\n            }\n            return false;\n        }\n        if (transitionState(current, FAILED, t)) {\n                        this.failureCause = t;\n            try {\n                if (assignedResource != null) {\n                    assignedResource.releaseSlot();\n                }\n                vertex.getExecutionGraph().deregisterExecution(this);\n            } finally {\n                vertex.executionFailed(t);\n            }\n            if (!isCallback && (current == RUNNING || current == DEPLOYING)) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Sending out cancel request, to remove task execution from TaskManager.\");\n                }\n                try {\n                    if (assignedResource != null) {\n                        sendCancelRpcCall();\n                    }\n                } catch (Throwable tt) {\n                                        LOG.error(\"Error triggering cancel call while marking task as failed.\", tt);\n                }\n            }\n                        return true;\n        }\n    }\n}", "lc": 1.0909090909090908, "pi": 1.2499999999999998, "ma": 1.1666666666666667, "nbd": 1.5, "ml": 1.0, "d": 0.6534849233811174, "mi": -0.6234585603670781, "fo": 0.5833333333333334, "r": -0.028571428571428574, "e": 0.699607248555557}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-4682_1e54865c", "label": 3, "code": "protected synchronized void doStop() throws Exception {\n    stopWatch.restart();\n    log.info(\"Apache Camel \" + getVersion() + \" (CamelContext:\" + getName() + \") is shutting down\");\n    EventHelper.notifyCamelContextStopping(this);\n    // stop route inputs in the same order as they was started so we stop the very first inputs first\n    try {\n        shutdownStrategy.shutdown(this, getRouteStartupOrder());\n    } catch (Throwable e) {\n        log.warn(\"Error occurred while shutting down routes. This exception will be ignored.\", e);\n    }\n    getRouteStartupOrder().clear();\n    shutdownServices(routeServices.values());\n    // do not clear route services or startup listeners as we can start Camel again and get the route back as before\n    // but clear any suspend routes\n    suspendedRouteServices.clear();\n    // the stop order is important\n    // shutdown debugger\n    ServiceHelper.stopAndShutdownService(getDebugger());\n    shutdownServices(endpoints.values());\n    endpoints.clear();\n    shutdownServices(components.values());\n    components.clear();\n    try {\n        for (LifecycleStrategy strategy : lifecycleStrategies) {\n            strategy.onContextStop(this);\n        }\n    } catch (Throwable e) {\n        log.warn(\"Error occurred while stopping lifecycle strategies. This exception will be ignored.\", e);\n    }\n    // shutdown services as late as possible\n    shutdownServices(servicesToClose);\n    servicesToClose.clear();\n    // must notify that we are stopped before stopping the management strategy\n    EventHelper.notifyCamelContextStopped(this);\n    // stop the notifier service\n    for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {\n        shutdownServices(notifier);\n    }\n    // shutdown management as the last one\n    shutdownServices(managementStrategy);\n    shutdownServices(lifecycleStrategies);\n    lifecycleStrategies.clear();\n    // stop the lazy created so they can be re-created on restart\n    forceStopLazyInitialization();\n    stopWatch.stop();\n    if (log.isInfoEnabled()) {\n        log.info(\"Uptime: \" + getUptime());\n        log.info(\"Apache Camel \" + getVersion() + \" (CamelContext: \" + getName() + \") is shutdown in \" + TimeUtils.printDuration(stopWatch.taken()));\n    }\n    // and clear start date\n    startDate = null;\n}", "code_comment": NaN, "code_no_comment": "protected synchronized void doStop() throws Exception {\n    stopWatch.restart();\n    log.info(\"Apache Camel \" + getVersion() + \" (CamelContext:\" + getName() + \") is shutting down\");\n    EventHelper.notifyCamelContextStopping(this);\n        try {\n        shutdownStrategy.shutdown(this, getRouteStartupOrder());\n    } catch (Throwable e) {\n        log.warn(\"Error occurred while shutting down routes. This exception will be ignored.\", e);\n    }\n    getRouteStartupOrder().clear();\n    shutdownServices(routeServices.values());\n            suspendedRouteServices.clear();\n            ServiceHelper.stopAndShutdownService(getDebugger());\n    shutdownServices(endpoints.values());\n    endpoints.clear();\n    shutdownServices(components.values());\n    components.clear();\n    try {\n        for (LifecycleStrategy strategy : lifecycleStrategies) {\n            strategy.onContextStop(this);\n        }\n    } catch (Throwable e) {\n        log.warn(\"Error occurred while stopping lifecycle strategies. This exception will be ignored.\", e);\n    }\n        shutdownServices(servicesToClose);\n    servicesToClose.clear();\n        EventHelper.notifyCamelContextStopped(this);\n        for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {\n        shutdownServices(notifier);\n    }\n        shutdownServices(managementStrategy);\n    shutdownServices(lifecycleStrategies);\n    lifecycleStrategies.clear();\n        forceStopLazyInitialization();\n    stopWatch.stop();\n    if (log.isInfoEnabled()) {\n        log.info(\"Uptime: \" + getUptime());\n        log.info(\"Apache Camel \" + getVersion() + \" (CamelContext: \" + getName() + \") is shutdown in \" + TimeUtils.printDuration(stopWatch.taken()));\n    }\n        startDate = null;\n}", "lc": 1.2272727272727273, "pi": -0.4183673469387754, "ma": 0.3333333333333333, "nbd": 0.0, "ml": -0.25, "d": -0.042511122095897164, "mi": -0.6842558072841987, "fo": 3.0, "r": -0.028571428571428574, "e": 0.25420483893764373}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2062_5c4589bd", "label": 1, "code": "private void readOakProperties(ArrayList<PropertyValue> target, Tree t, String oakPropertyName, Integer propertyType) {\n    boolean skipCurrentNode = false;\n    while (true) {\n        if (t == null || !t.exists()) {\n            return;\n        }\n        int slash = oakPropertyName.indexOf('/');\n        if (slash < 0) {\n            break;\n        }\n        String parent = oakPropertyName.substring(0, slash);\n        oakPropertyName = oakPropertyName.substring(slash + 1);\n        if (parent.equals(\"..\")) {\n            t = t.isRoot() ? null : t.getParent();\n        } else if (parent.equals(\".\")) {\n        // same node\n        } else if (parent.equals(\"*\")) {\n            for (Tree child : t.getChildren()) {\n                readOakProperties(target, child, oakPropertyName, propertyType);\n            }\n            skipCurrentNode = true;\n        } else {\n            t = t.getChild(parent);\n        }\n    }\n    if (skipCurrentNode) {\n        return;\n    }\n    if (!\"*\".equals(oakPropertyName)) {\n        PropertyValue value = currentOakProperty(t, oakPropertyName, propertyType);\n        if (value != null) {\n            target.add(value);\n        }\n        return;\n    }\n    for (PropertyState p : t.getProperties()) {\n        if (propertyType == null || p.getType().tag() == propertyType) {\n            PropertyValue v = PropertyValues.create(p);\n            target.add(v);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private void readOakProperties(ArrayList<PropertyValue> target, Tree t, String oakPropertyName, Integer propertyType) {\n    boolean skipCurrentNode = false;\n    while (true) {\n        if (t == null || !t.exists()) {\n            return;\n        }\n        int slash = oakPropertyName.indexOf('/');\n        if (slash < 0) {\n            break;\n        }\n        String parent = oakPropertyName.substring(0, slash);\n        oakPropertyName = oakPropertyName.substring(slash + 1);\n        if (parent.equals(\"..\")) {\n            t = t.isRoot() ? null : t.getParent();\n        } else if (parent.equals(\".\")) {\n                } else if (parent.equals(\"*\")) {\n            for (Tree child : t.getChildren()) {\n                readOakProperties(target, child, oakPropertyName, propertyType);\n            }\n            skipCurrentNode = true;\n        } else {\n            t = t.getChild(parent);\n        }\n    }\n    if (skipCurrentNode) {\n        return;\n    }\n    if (!\"*\".equals(oakPropertyName)) {\n        PropertyValue value = currentOakProperty(t, oakPropertyName, propertyType);\n        if (value != null) {\n            target.add(value);\n        }\n        return;\n    }\n    for (PropertyState p : t.getProperties()) {\n        if (propertyType == null || p.getType().tag() == propertyType) {\n            PropertyValue v = PropertyValues.create(p);\n            target.add(v);\n        }\n    }\n}", "lc": 1.2272727272727273, "pi": 0.2346938775510204, "ma": 1.8333333333333333, "nbd": 1.5, "ml": 1.75, "d": 0.971824023727138, "mi": -0.7651276168626331, "fo": 1.1666666666666667, "r": -0.028571428571428574, "e": 1.7694716058265985}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-757_76b7413d", "label": 1, "code": "/**\n * The contraction criterion defines when the internal array will contract\n * to store only the number of elements in the element array.\n * If  the <code>expansionMode</code> is <code>MULTIPLICATIVE_MODE</code>,\n * contraction is triggered when the ratio between storage array length\n * and <code>numElements</code> exceeds <code>contractionFactor</code>.\n * If the <code>expansionMode</code> is <code>ADDITIVE_MODE</code>, the\n * number of excess storage locations is compared to\n * <code>contractionFactor.</code>\n *\n * @return the contraction criterion used to reclaim memory.\n * @since 3.1\n */\npublic double getContractionCriterion() {\n    return contractionCriterion;\n}", "code_comment": "/**\n * The contraction criterion defines when the internal array will contract\n * to store only the number of elements in the element array.\n * If  the <code>expansionMode</code> is <code>MULTIPLICATIVE_MODE</code>,\n * contraction is triggered when the ratio between storage array length\n * and <code>numElements</code> exceeds <code>contractionFactor</code>.\n * If the <code>expansionMode</code> is <code>ADDITIVE_MODE</code>, the\n * number of excess storage locations is compared to\n * <code>contractionFactor.</code>\n *\n * @return the contraction criterion used to reclaim memory.\n * @since 3.1\n */\n", "code_no_comment": "public double getContractionCriterion() {\n    return contractionCriterion;\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.2776025236593067, "fo": -0.5, "r": 0.0, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5359_61122bab", "label": 3, "code": "/**\n *  Convert to character, returning default value if text is inconvertible.\n *\n *  @param defaultValue\n *             the default value\n *  @return the converted text as a primitive char or the default value if text is not a single character\n */\npublic final char toChar(final char defaultValue) {\n    if (text != null) {\n        try {\n            return toChar();\n        } catch (StringValueConversionException x) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(String.format(\"An error occurred while converting '%s' to a character: %s\", text, x.getMessage()), x);\n            }\n        }\n    }\n    return defaultValue;\n}", "code_comment": "/**\n *  Convert to character, returning default value if text is inconvertible.\n *\n *  @param defaultValue\n *             the default value\n *  @return the converted text as a primitive char or the default value if text is not a single character\n */\n", "code_no_comment": "public final char toChar(final char defaultValue) {\n    if (text != null) {\n        try {\n            return toChar();\n        } catch (StringValueConversionException x) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(String.format(\"An error occurred while converting '%s' to a character: %s\", text, x.getMessage()), x);\n            }\n        }\n    }\n    return defaultValue;\n}", "lc": -0.09090909090909091, "pi": 0.933673469387755, "ma": 0.0, "nbd": 0.5, "ml": -0.08333333333333333, "d": -0.3806228373702422, "mi": 0.1892744479495267, "fo": -0.08333333333333333, "r": 1.1714285714285715, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-442_246d53c5", "label": 1, "code": "/**\n *  Registers a debug feedback message for this component\n *\n *  @param message\n *             The feedback message\n */\npublic final void debug(final String message) {\n    getPage().getFeedbackMessages().debug(this, message);\n}", "code_comment": "/**\n *  Registers a debug feedback message for this component\n *\n *  @param message\n *             The feedback message\n */\n", "code_no_comment": "public final void debug(final String message) {\n    getPage().getFeedbackMessages().debug(this, message);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.0585030111843994, "fo": -0.25, "r": 2.7714285714285714, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-555_328513f3", "label": 3, "code": "/**\n * Round the given value to the specified number of decimal places. The\n * value is rounded using the given method which is any method defined in\n * {@link BigDecimal}.\n *\n * @param x the value to round.\n * @param scale the number of digits to the right of the decimal point.\n * @param roundingMethod the rounding method as defined in\n *        {@link BigDecimal}.\n * @return the rounded value.\n * @since 1.1\n */\npublic static double round(double x, int scale, int roundingMethod) {\n    try {\n        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();\n    } catch (NumberFormatException ex) {\n        if (Double.isInfinite(x)) {\n            return x;\n        } else {\n            return Double.NaN;\n        }\n    } catch (RuntimeException ex) {\n        throw new MathRuntimeException(ex);\n    }\n}", "code_comment": "/**\n * Round the given value to the specified number of decimal places. The\n * value is rounded using the given method which is any method defined in\n * {@link BigDecimal}.\n *\n * @param x the value to round.\n * @param scale the number of digits to the right of the decimal point.\n * @param roundingMethod the rounding method as defined in\n *        {@link BigDecimal}.\n * @return the rounded value.\n * @since 1.1\n */\n", "code_no_comment": "public static double round(double x, int scale, int roundingMethod) {\n    try {\n        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();\n    } catch (NumberFormatException ex) {\n        if (Double.isInfinite(x)) {\n            return x;\n        } else {\n            return Double.NaN;\n        }\n    } catch (RuntimeException ex) {\n        throw new MathRuntimeException(ex);\n    }\n}", "lc": -0.045454545454545456, "pi": 0.35714285714285726, "ma": 0.16666666666666666, "nbd": 0.0, "ml": -0.16666666666666666, "d": -0.3806228373702422, "mi": 0.11585890450243742, "fo": -0.16666666666666666, "r": 0.1142857142857143, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3333_194999ed", "label": 1, "code": "/**\n * Collect _revisions and _commitRoot entries that can be moved to a\n * previous document.\n */\nprivate void collectRevisionsAndCommitRoot() {\n    NavigableMap<Revision, String> revisions = new TreeMap<Revision, String>(context.getRevisionComparator());\n    for (Map.Entry<Revision, String> entry : doc.getLocalRevisions().entrySet()) {\n        if (splitRevs.contains(entry.getKey())) {\n            revisions.put(entry.getKey(), entry.getValue());\n            numValues++;\n        } else {\n            // local changes\n            if (context.getClusterId() != entry.getKey().getClusterId()) {\n                // only consider local changes\n                continue;\n            }\n            if (doc.isCommitted(entry.getKey()) && !mostRecentRevs.contains(entry.getKey())) {\n                // this is a commit root for changes in other documents\n                revisions.put(entry.getKey(), entry.getValue());\n                numValues++;\n                trackHigh(entry.getKey());\n                trackLow(entry.getKey());\n            }\n        }\n    }\n    committedChanges.put(REVISIONS, revisions);\n    NavigableMap<Revision, String> commitRoot = new TreeMap<Revision, String>(context.getRevisionComparator());\n    for (Map.Entry<Revision, String> entry : doc.getLocalCommitRoot().entrySet()) {\n        Revision r = entry.getKey();\n        if (splitRevs.contains(r)) {\n            commitRoot.put(r, entry.getValue());\n            numValues++;\n        } else if (r.getClusterId() == context.getClusterId() && !changes.contains(r)) {\n            // OAK-2528: _commitRoot entry without associated\n            // change -> consider as garbage\n            addGarbage(r, COMMIT_ROOT);\n        }\n    }\n    committedChanges.put(COMMIT_ROOT, commitRoot);\n}", "code_comment": "/**\n * Collect _revisions and _commitRoot entries that can be moved to a\n * previous document.\n */\n", "code_no_comment": "private void collectRevisionsAndCommitRoot() {\n    NavigableMap<Revision, String> revisions = new TreeMap<Revision, String>(context.getRevisionComparator());\n    for (Map.Entry<Revision, String> entry : doc.getLocalRevisions().entrySet()) {\n        if (splitRevs.contains(entry.getKey())) {\n            revisions.put(entry.getKey(), entry.getValue());\n            numValues++;\n        } else {\n                        if (context.getClusterId() != entry.getKey().getClusterId()) {\n                                continue;\n            }\n            if (doc.isCommitted(entry.getKey()) && !mostRecentRevs.contains(entry.getKey())) {\n                                revisions.put(entry.getKey(), entry.getValue());\n                numValues++;\n                trackHigh(entry.getKey());\n                trackLow(entry.getKey());\n            }\n        }\n    }\n    committedChanges.put(REVISIONS, revisions);\n    NavigableMap<Revision, String> commitRoot = new TreeMap<Revision, String>(context.getRevisionComparator());\n    for (Map.Entry<Revision, String> entry : doc.getLocalCommitRoot().entrySet()) {\n        Revision r = entry.getKey();\n        if (splitRevs.contains(r)) {\n            commitRoot.put(r, entry.getValue());\n            numValues++;\n        } else if (r.getClusterId() == context.getClusterId() && !changes.contains(r)) {\n                                    addGarbage(r, COMMIT_ROOT);\n        }\n    }\n    committedChanges.put(COMMIT_ROOT, commitRoot);\n}", "lc": 0.7727272727272727, "pi": 0.872448979591837, "ma": 0.8333333333333334, "nbd": 0.5, "ml": 1.0, "d": 1.434503213049926, "mi": -0.5856036707771726, "fo": 2.4166666666666665, "r": -0.028571428571428574, "e": 2.262111263871579}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1364_05c89637", "label": 1, "code": "@Override\npublic ConcurrentMap<K, V> asMap() {\n    return new ConcurrentMap<K, V>() {\n\n        @Override\n        public int size() {\n            long size = CacheLIRS.this.size();\n            return (int) Math.min(size, Integer.MAX_VALUE);\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return CacheLIRS.this.size() == 0;\n        }\n\n        @Override\n        public boolean containsKey(Object key) {\n            return CacheLIRS.this.containsKey(key);\n        }\n\n        @Override\n        public boolean containsValue(Object value) {\n            return CacheLIRS.this.containsValue(value);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public V get(Object key) {\n            return CacheLIRS.this.getUnchecked((K) key);\n        }\n\n        @Override\n        public V put(K key, V value) {\n            return CacheLIRS.this.put(key, value, sizeOf(key, value));\n        }\n\n        @Override\n        public V remove(Object key) {\n            @SuppressWarnings(\"unchecked\")\n            V old = CacheLIRS.this.getUnchecked((K) key);\n            CacheLIRS.this.invalidate(key);\n            return old;\n        }\n\n        @Override\n        public void putAll(Map<? extends K, ? extends V> m) {\n            for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n                put(e.getKey(), e.getValue());\n            }\n        }\n\n        @Override\n        public void clear() {\n            CacheLIRS.this.clear();\n        }\n\n        @Override\n        public Set<K> keySet() {\n            return CacheLIRS.this.keySet();\n        }\n\n        @Override\n        public Collection<V> values() {\n            return CacheLIRS.this.values();\n        }\n\n        @Override\n        public Set<java.util.Map.Entry<K, V>> entrySet() {\n            return CacheLIRS.this.entrySet();\n        }\n\n        @Override\n        public V putIfAbsent(K key, V value) {\n            return CacheLIRS.this.putIfAbsent(key, value);\n        }\n\n        @Override\n        public boolean remove(Object key, Object value) {\n            return CacheLIRS.this.remove(key, value);\n        }\n\n        @Override\n        public boolean replace(K key, V oldValue, V newValue) {\n            return CacheLIRS.this.replace(key, oldValue, newValue);\n        }\n\n        @Override\n        public V replace(K key, V value) {\n            return CacheLIRS.this.replace(key, value);\n        }\n    };\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic ConcurrentMap<K, V> asMap() {\n    return new ConcurrentMap<K, V>() {\n\n        @Override\n        public int size() {\n            long size = CacheLIRS.this.size();\n            return (int) Math.min(size, Integer.MAX_VALUE);\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return CacheLIRS.this.size() == 0;\n        }\n\n        @Override\n        public boolean containsKey(Object key) {\n            return CacheLIRS.this.containsKey(key);\n        }\n\n        @Override\n        public boolean containsValue(Object value) {\n            return CacheLIRS.this.containsValue(value);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public V get(Object key) {\n            return CacheLIRS.this.getUnchecked((K) key);\n        }\n\n        @Override\n        public V put(K key, V value) {\n            return CacheLIRS.this.put(key, value, sizeOf(key, value));\n        }\n\n        @Override\n        public V remove(Object key) {\n            @SuppressWarnings(\"unchecked\")\n            V old = CacheLIRS.this.getUnchecked((K) key);\n            CacheLIRS.this.invalidate(key);\n            return old;\n        }\n\n        @Override\n        public void putAll(Map<? extends K, ? extends V> m) {\n            for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n                put(e.getKey(), e.getValue());\n            }\n        }\n\n        @Override\n        public void clear() {\n            CacheLIRS.this.clear();\n        }\n\n        @Override\n        public Set<K> keySet() {\n            return CacheLIRS.this.keySet();\n        }\n\n        @Override\n        public Collection<V> values() {\n            return CacheLIRS.this.values();\n        }\n\n        @Override\n        public Set<java.util.Map.Entry<K, V>> entrySet() {\n            return CacheLIRS.this.entrySet();\n        }\n\n        @Override\n        public V putIfAbsent(K key, V value) {\n            return CacheLIRS.this.putIfAbsent(key, value);\n        }\n\n        @Override\n        public boolean remove(Object key, Object value) {\n            return CacheLIRS.this.remove(key, value);\n        }\n\n        @Override\n        public boolean replace(K key, V oldValue, V newValue) {\n            return CacheLIRS.this.replace(key, oldValue, newValue);\n        }\n\n        @Override\n        public V replace(K key, V value) {\n            return CacheLIRS.this.replace(key, value);\n        }\n    };\n}", "lc": 2.8181818181818183, "pi": -0.13775510204081634, "ma": -0.3333333333333333, "nbd": 0.0, "ml": -0.4166666666666667, "d": 0.3351458230350965, "mi": -1.0238026957269863, "fo": 1.3333333333333333, "r": -0.028571428571428574, "e": 1.3405501946625207}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "public boolean equals(setTableProperty_result that) {\n    if (that == null)\n        return false;\n    boolean this_present_ouch1 = true && this.isSetOuch1();\n    boolean that_present_ouch1 = true && that.isSetOuch1();\n    if (this_present_ouch1 || that_present_ouch1) {\n        if (!(this_present_ouch1 && that_present_ouch1))\n            return false;\n        if (!this.ouch1.equals(that.ouch1))\n            return false;\n    }\n    boolean this_present_ouch2 = true && this.isSetOuch2();\n    boolean that_present_ouch2 = true && that.isSetOuch2();\n    if (this_present_ouch2 || that_present_ouch2) {\n        if (!(this_present_ouch2 && that_present_ouch2))\n            return false;\n        if (!this.ouch2.equals(that.ouch2))\n            return false;\n    }\n    return true;\n}", "code_comment": NaN, "code_no_comment": "public boolean equals(setTableProperty_result that) {\n    if (that == null)\n        return false;\n    boolean this_present_ouch1 = true && this.isSetOuch1();\n    boolean that_present_ouch1 = true && that.isSetOuch1();\n    if (this_present_ouch1 || that_present_ouch1) {\n        if (!(this_present_ouch1 && that_present_ouch1))\n            return false;\n        if (!this.ouch1.equals(that.ouch1))\n            return false;\n    }\n    boolean this_present_ouch2 = true && this.isSetOuch2();\n    boolean that_present_ouch2 = true && that.isSetOuch2();\n    if (this_present_ouch2 || that_present_ouch2) {\n        if (!(this_present_ouch2 && that_present_ouch2))\n            return false;\n        if (!this.ouch2.equals(that.ouch2))\n            return false;\n    }\n    return true;\n}", "lc": 0.3181818181818182, "pi": 0.3061224489795919, "ma": 0.6666666666666666, "nbd": -0.5, "ml": 1.25, "d": 0.726643598615917, "mi": -0.26641812446228874, "fo": 0.0, "r": -0.028571428571428574, "e": 0.4473725913457626}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1123_a197ba85", "label": 1, "code": "/**\n * Fit a sub-hyperplane inside the cell defined by the instance.\n * <p>Fitting is done by chopping off the parts of the\n * sub-hyperplane that lie outside of the cell using the\n * cut-hyperplanes of the parent nodes of the instance.</p>\n * @param sub sub-hyperplane to fit\n * @return a new sub-hyperplane, guaranteed to have no part outside\n * of the instance cell\n */\nprivate SubHyperplane<S> fitToCell(final SubHyperplane<S> sub) {\n    SubHyperplane<S> s = sub;\n    for (BSPTree<S> tree = this; tree.parent != null; tree = tree.parent) {\n        if (tree == tree.parent.plus) {\n            s = s.split(tree.parent.cut.getHyperplane()).getPlus();\n        } else {\n            s = s.split(tree.parent.cut.getHyperplane()).getMinus();\n        }\n    }\n    return s;\n}", "code_comment": "/**\n * Fit a sub-hyperplane inside the cell defined by the instance.\n * <p>Fitting is done by chopping off the parts of the\n * sub-hyperplane that lie outside of the cell using the\n * cut-hyperplanes of the parent nodes of the instance.</p>\n * @param sub sub-hyperplane to fit\n * @return a new sub-hyperplane, guaranteed to have no part outside\n * of the instance cell\n */\n", "code_no_comment": "private SubHyperplane<S> fitToCell(final SubHyperplane<S> sub) {\n    SubHyperplane<S> s = sub;\n    for (BSPTree<S> tree = this; tree.parent != null; tree = tree.parent) {\n        if (tree == tree.parent.plus) {\n            s = s.split(tree.parent.cut.getHyperplane()).getPlus();\n        } else {\n            s = s.split(tree.parent.cut.getHyperplane()).getMinus();\n        }\n    }\n    return s;\n}", "lc": -0.13636363636363635, "pi": 0.47448979591836743, "ma": -0.16666666666666666, "nbd": 0.0, "ml": 0.0, "d": 0.12555610479485918, "mi": 0.10037281330656728, "fo": 0.0, "r": -0.028571428571428574, "e": 0.05955945023363786}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-579_7d72e6ed", "label": 3, "code": "@Override\npublic void execute(NodeState rootState) {\n    cursor = index.query(createFilter(), rootState);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void execute(NodeState rootState) {\n    cursor = index.query(createFilter(), rootState);\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8399770576426728, "fo": -0.3333333333333333, "r": 1.2857142857142858, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3989_6a8fc1cc", "label": 1, "code": "/**\n *  Get the markup for the child component, which is assumed to be a child of 'container'.\n */\npublic IMarkupFragment getMarkup(final MarkupContainer container, final Component child) {\n    // If the sourcing strategy did not provide one, than ask the component.\n    // Get the markup for the container\n    IMarkupFragment markup = container.getMarkup();\n    if (markup == null) {\n        return null;\n    }\n    if (child == null) {\n        return markup;\n    }\n    // Find the child's markup\n    markup = markup.find(child.getId());\n    if (markup != null) {\n        return markup;\n    }\n    // \"synchronous\" search possible.\n    for (Component ch : container) {\n        if ((ch != child) && (ch instanceof MarkupContainer) && (ch instanceof IComponentResolver)) {\n            markup = ((MarkupContainer) ch).getMarkup(child);\n            if (markup != null) {\n                return markup;\n            }\n        }\n    }\n    // This is to make migration for Items from 1.4 to 1.5 more easy\n    if (Character.isDigit(child.getId().charAt(0))) {\n        String id = child.getId();\n        boolean miss = false;\n        for (int i = 1; i < id.length(); i++) {\n            if (Character.isDigit(id.charAt(i)) == false) {\n                miss = true;\n                break;\n            }\n        }\n        if (miss == false) {\n            // The LoopItems markup is equal to the Loops markup\n            markup = container.getMarkup();\n            if (!(child instanceof AbstractItem) && log.isWarnEnabled()) {\n                log.warn(\"1.4 to 1.5 migration issue: the childs wicket-id contains decimals only. \" + \"By convention that \" + \"is only the case for children (Items) of Loop, ListView, \" + \"Tree etc.. To avoid the warning, the childs container should implement:\\n\" + \"@Override public IMarkupFragment getMarkup(Component child) {\\n\" + \"// The childs markup is always equal to the parents markup.\\n\" + \"return getMarkup(); }\\n\" + \"Child: \" + child.toString() + \"\\nContainer: \" + container.toString());\n            }\n        }\n    }\n    return markup;\n}", "code_comment": "/**\n *  Get the markup for the child component, which is assumed to be a child of 'container'.\n */\n", "code_no_comment": "public IMarkupFragment getMarkup(final MarkupContainer container, final Component child) {\n            IMarkupFragment markup = container.getMarkup();\n    if (markup == null) {\n        return null;\n    }\n    if (child == null) {\n        return markup;\n    }\n        markup = markup.find(child.getId());\n    if (markup != null) {\n        return markup;\n    }\n        for (Component ch : container) {\n        if ((ch != child) && (ch instanceof MarkupContainer) && (ch instanceof IComponentResolver)) {\n            markup = ((MarkupContainer) ch).getMarkup(child);\n            if (markup != null) {\n                return markup;\n            }\n        }\n    }\n        if (Character.isDigit(child.getId().charAt(0))) {\n        String id = child.getId();\n        boolean miss = false;\n        for (int i = 1; i < id.length(); i++) {\n            if (Character.isDigit(id.charAt(i)) == false) {\n                miss = true;\n                break;\n            }\n        }\n        if (miss == false) {\n                        markup = container.getMarkup();\n            if (!(child instanceof AbstractItem) && log.isWarnEnabled()) {\n                log.warn(\"1.4 to 1.5 migration issue: the childs wicket-id contains decimals only. \" + \"By convention that \" + \"is only the case for children (Items) of Loop, ListView, \" + \"Tree etc.. To avoid the warning, the childs container should implement:\\n\" + \"@Override public IMarkupFragment getMarkup(Component child) {\\n\" + \"// The childs markup is always equal to the parents markup.\\n\" + \"return getMarkup(); }\\n\" + \"Child: \" + child.toString() + \"\\nContainer: \" + container.toString());\n            }\n        }\n    }\n    return markup;\n}", "lc": 1.0909090909090908, "pi": 0.6785714285714284, "ma": 1.5, "nbd": 0.5, "ml": 1.5833333333333333, "d": 1.5056846267918933, "mi": -0.7117866360768573, "fo": 0.8333333333333334, "r": -0.028571428571428574, "e": 2.4453895606066447}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2839_15477252", "label": 1, "code": "/**\n *  Convenience method to write an {@link InputStream} to response.\n *\n *  @param attributes\n *  @param stream\n */\nprotected final void writeStream(Attributes attributes, InputStream stream) {\n    final Response response = attributes.getResponse();\n    OutputStream s = new OutputStream() {\n\n        @Override\n        public void write(int b) throws IOException {\n            response.write(new byte[] { (byte) b });\n        }\n\n        @Override\n        public void write(byte[] b) throws IOException {\n            response.write(b);\n        }\n\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            if (off == 0 || len == b.length) {\n                write(b);\n            } else {\n                byte[] copy = new byte[len];\n                System.arraycopy(b, off, copy, 0, len);\n                write(copy);\n            }\n        }\n    };\n    try {\n        Streams.copy(stream, s);\n    } catch (IOException e) {\n        throw new WicketRuntimeException(e);\n    }\n}", "code_comment": "/**\n *  Convenience method to write an {@link InputStream} to response.\n *\n *  @param attributes\n *  @param stream\n */\n", "code_no_comment": "protected final void writeStream(Attributes attributes, InputStream stream) {\n    final Response response = attributes.getResponse();\n    OutputStream s = new OutputStream() {\n\n        @Override\n        public void write(int b) throws IOException {\n            response.write(new byte[] { (byte) b });\n        }\n\n        @Override\n        public void write(byte[] b) throws IOException {\n            response.write(b);\n        }\n\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            if (off == 0 || len == b.length) {\n                write(b);\n            } else {\n                byte[] copy = new byte[len];\n                System.arraycopy(b, off, copy, 0, len);\n                write(copy);\n            }\n        }\n    };\n    try {\n        Streams.copy(stream, s);\n    } catch (IOException e) {\n        throw new WicketRuntimeException(e);\n    }\n}", "lc": 0.6363636363636364, "pi": 0.729591836734694, "ma": 0.0, "nbd": 0.0, "ml": 0.0, "d": 0.08601087493821061, "mi": -0.4037854889589906, "fo": 0.08333333333333333, "r": 0.028571428571428574, "e": 0.15162261597303422}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-276_1bf5c550", "label": 1, "code": "public void writeHead(Id id) {\n    head = id;\n}", "code_comment": NaN, "code_no_comment": "public void writeHead(Id id) {\n    head = id;\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.0785775738457126, "fo": -0.5, "r": 2.685714285714286, "e": -0.16422749602751402}
{"project_name": "Cli", "project_version": 26, "label": 3, "code": "/**\n * Create an Option using the current settings and with\n * the specified Option <code>char</code>.\n *\n * @param opt the <code>java.lang.String</code> representation\n * of the Option\n * @return the Option instance\n * @throws IllegalArgumentException if <code>opt</code> is not\n * a valid character.  See Option.\n */\npublic static Option create(String opt) throws IllegalArgumentException {\n    // create the option\n    Option option = new Option(opt, description);\n    // set the option properties\n    option.setLongOpt(longopt);\n    option.setRequired(required);\n    option.setOptionalArg(optionalArg);\n    option.setArgs(numberOfArgs);\n    option.setType(type);\n    option.setValueSeparator(valuesep);\n    option.setArgName(argName);\n    // reset the OptionBuilder properties\n    OptionBuilder.reset();\n    // return the Option instance\n    return option;\n}", "code_comment": "/**\n * Create an Option using the current settings and with\n * the specified Option <code>char</code>.\n *\n * @param opt the <code>java.lang.String</code> representation\n * of the Option\n * @return the Option instance\n * @throws IllegalArgumentException if <code>opt</code> is not\n * a valid character.  See Option.\n */\n", "code_no_comment": "public static Option create(String opt) throws IllegalArgumentException {\n        Option option = new Option(opt, description);\n        option.setLongOpt(longopt);\n    option.setRequired(required);\n    option.setOptionalArg(optionalArg);\n    option.setArgs(numberOfArgs);\n    option.setType(type);\n    option.setValueSeparator(valuesep);\n    option.setArgName(argName);\n        OptionBuilder.reset();\n        return option;\n}", "lc": -0.09090909090909091, "pi": -0.7806122448979592, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.1029538285058791, "fo": 0.16666666666666666, "r": 0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 149, "label": 2, "code": "/**\n * Generates JavaScript source code for an AST.\n */\nprivate String toSource(Node n, SourceMap sourceMap) {\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\n    builder.setPrettyPrint(options.prettyPrint);\n    builder.setLineBreak(options.lineBreak);\n    builder.setSourceMap(sourceMap);\n    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    Charset charset = options.outputCharset;\n    builder.setOutputCharset(charset);\n    return builder.build();\n}", "code_comment": "/**\n * Generates JavaScript source code for an AST.\n */\n", "code_no_comment": "private String toSource(Node n, SourceMap sourceMap) {\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\n    builder.setPrettyPrint(options.prettyPrint);\n    builder.setLineBreak(options.lineBreak);\n    builder.setSourceMap(sourceMap);\n    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    Charset charset = options.outputCharset;\n    builder.setOutputCharset(charset);\n    return builder.build();\n}", "lc": -0.18181818181818182, "pi": -0.7244897959183674, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.1775164898193289, "fo": 0.0, "r": 0.0, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 95, "label": 2, "code": "/**\n * Defines a typed variable. The defining node will be annotated with the\n * variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\n * inferred.\n *\n * Slots may be any variable or any qualified name in the global scope.\n *\n * @param n the defining NAME or GETPROP node.\n * @param parent the {@code n}'s parent.\n * @param type the variable's type. It may be {@code null} if\n *     {@code inferred} is {@code true}.\n */\nvoid defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type != null);\n    // Only allow declarations of NAMEs and qualfied names.\n    boolean shouldDeclareOnGlobalThis = false;\n    if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n    } else {\n        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n    }\n    String variableName = n.getQualifiedName();\n    Preconditions.checkArgument(!variableName.isEmpty());\n    // If n is a property, then we should really declare it in the\n    // scope where the root object appears. This helps out people\n    // who declare \"global\" names in an anonymous namespace.\n    Scope scopeToDeclareIn = scope;\n    // declared in closest scope?\n    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern = input.isExtern();\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n            }\n        }\n        // in the scope chain.\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n            FunctionType fnType = (FunctionType) type;\n            if (fnType.isConstructor() || fnType.isInterface()) {\n                FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n            }\n        }\n    }\n}", "code_comment": "/**\n * Defines a typed variable. The defining node will be annotated with the\n * variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\n * inferred.\n *\n * Slots may be any variable or any qualified name in the global scope.\n *\n * @param n the defining NAME or GETPROP node.\n * @param parent the {@code n}'s parent.\n * @param type the variable's type. It may be {@code null} if\n *     {@code inferred} is {@code true}.\n */\n", "code_no_comment": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type != null);\n        boolean shouldDeclareOnGlobalThis = false;\n    if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n    } else {\n        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n    }\n    String variableName = n.getQualifiedName();\n    Preconditions.checkArgument(!variableName.isEmpty());\n                Scope scopeToDeclareIn = scope;\n        if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern = input.isExtern();\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n            }\n        }\n                if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n            FunctionType fnType = (FunctionType) type;\n            if (fnType.isConstructor() || fnType.isInterface()) {\n                FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName),                 superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n            }\n        }\n    }\n}", "lc": 1.1818181818181819, "pi": 0.6836734693877553, "ma": 0.8333333333333334, "nbd": 0.5, "ml": 1.1666666666666667, "d": 1.1122095897182405, "mi": -0.810151993117293, "fo": 2.6666666666666665, "r": -0.028571428571428574, "e": 3.896539761265371}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5019_917dd2b5", "label": 3, "code": "/**\n *  Initializes the cache for the existence of the minified resource.\n *  @return the name of the minified resource or the special constant {@link #NO_MINIFIED_NAME}\n *  if there is no minified version\n */\nprivate String internalGetMinifiedName() {\n    String minifiedName = MINIFIED_NAMES_CACHE.get(this);\n    if (minifiedName != null && minifiedName != NO_MINIFIED_NAME) {\n        return minifiedName;\n    }\n    String name = getMinifiedName();\n    IResourceStreamLocator locator = Application.get().getResourceSettings().getResourceStreamLocator();\n    String absolutePath = Packages.absolutePath(getScope(), name);\n    IResourceStream stream = locator.locate(getScope(), absolutePath, getStyle(), getVariation(), getLocale(), null, true);\n    minifiedName = stream != null ? name : NO_MINIFIED_NAME;\n    MINIFIED_NAMES_CACHE.put(this, minifiedName);\n    if (minifiedName == NO_MINIFIED_NAME && log.isDebugEnabled()) {\n        log.debug(\"No minified version of '\" + super.getName() + \"' found, expected a file with the name '\" + name + \"', using full version\");\n    }\n    return minifiedName;\n}", "code_comment": "/**\n *  Initializes the cache for the existence of the minified resource.\n *  @return the name of the minified resource or the special constant {@link #NO_MINIFIED_NAME}\n *  if there is no minified version\n */\n", "code_no_comment": "private String internalGetMinifiedName() {\n    String minifiedName = MINIFIED_NAMES_CACHE.get(this);\n    if (minifiedName != null && minifiedName != NO_MINIFIED_NAME) {\n        return minifiedName;\n    }\n    String name = getMinifiedName();\n    IResourceStreamLocator locator = Application.get().getResourceSettings().getResourceStreamLocator();\n    String absolutePath = Packages.absolutePath(getScope(), name);\n    IResourceStream stream = locator.locate(getScope(), absolutePath, getStyle(), getVariation(), getLocale(), null, true);\n    minifiedName = stream != null ? name : NO_MINIFIED_NAME;\n    MINIFIED_NAMES_CACHE.put(this, minifiedName);\n    if (minifiedName == NO_MINIFIED_NAME && log.isDebugEnabled()) {\n        log.debug(\"No minified version of '\" + super.getName() + \"' found, expected a file with the name '\" + name + \"', using full version\");\n    }\n    return minifiedName;\n}", "lc": 0.09090909090909091, "pi": -0.5204081632653061, "ma": 0.0, "nbd": -0.5, "ml": 0.25, "d": 0.3153732081067722, "mi": -0.17006022368798418, "fo": 0.8333333333333334, "r": -0.028571428571428574, "e": 0.39674320394378987}
{"project_name": "Csv", "project_version": 7, "label": 1, "code": "/**\n * Initializes the name to index mapping if the format defines a header.\n *\n * @return null if the format has no header.\n */\nprivate Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] header = null;\n        if (formatHeader.length == 0) {\n            // read the header from the first line of the file\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord != null) {\n                header = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            header = formatHeader;\n        }\n        // build the name to index mappings\n        if (header != null) {\n            for (int i = 0; i < header.length; i++) {\n                hdrMap.put(header[i], Integer.valueOf(i));\n            }\n        }\n    }\n    return hdrMap;\n}", "code_comment": "/**\n * Initializes the name to index mapping if the format defines a header.\n *\n * @return null if the format has no header.\n */\n", "code_no_comment": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] header = null;\n        if (formatHeader.length == 0) {\n                        final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord != null) {\n                header = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            header = formatHeader;\n        }\n                if (header != null) {\n            for (int i = 0; i < header.length; i++) {\n                hdrMap.put(header[i], Integer.valueOf(i));\n            }\n        }\n    }\n    return hdrMap;\n}", "lc": 0.5, "pi": 0.7704081632653063, "ma": 0.5, "nbd": 0.5, "ml": 0.6666666666666666, "d": 0.6258032624814632, "mi": -0.38055635216518496, "fo": 0.08333333333333333, "r": -0.028571428571428574, "e": 0.5615146414483405}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8954_7b1253db", "label": 3, "code": "protected void doReleaseExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {\n    if (!markerFile) {\n        // if not using marker file then nothing to release\n        return;\n    }\n    // only release the file if camel get the lock before\n    if (exchange.getProperty(Exchange.FILE_LOCK_FILE_ACQUIRED, false, Boolean.class)) {\n        String lockFileName = exchange.getProperty(Exchange.FILE_LOCK_FILE_NAME, getLockFileName(file), String.class);\n        File lock = new File(lockFileName);\n        if (lock.exists()) {\n            LOG.trace(\"Unlocking file: {}\", lockFileName);\n            boolean deleted = FileUtil.deleteFile(lock);\n            LOG.trace(\"Lock file: {} was deleted: {}\", lockFileName, deleted);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "protected void doReleaseExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {\n    if (!markerFile) {\n                return;\n    }\n        if (exchange.getProperty(Exchange.FILE_LOCK_FILE_ACQUIRED, false, Boolean.class)) {\n        String lockFileName = exchange.getProperty(Exchange.FILE_LOCK_FILE_NAME, getLockFileName(file), String.class);\n        File lock = new File(lockFileName);\n        if (lock.exists()) {\n            LOG.trace(\"Unlocking file: {}\", lockFileName);\n            boolean deleted = FileUtil.deleteFile(lock);\n            LOG.trace(\"Lock file: {} was deleted: {}\", lockFileName, deleted);\n        }\n    }\n}", "lc": 0.0, "pi": 0.4438775510204082, "ma": 0.0, "nbd": 0.0, "ml": 0.08333333333333333, "d": -0.056351952545724164, "mi": -0.045884714654431, "fo": 0.08333333333333333, "r": -0.028571428571428574, "e": 0.008407536373409397}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-4170_2a489d05", "label": 3, "code": "@Override\npublic void restrict(FilterImpl f) {\n    if (propertyName != null) {\n        if (f.getSelector().equals(selector)) {\n            String p = propertyName;\n            if (relativePath != null) {\n                p = PathUtils.concat(relativePath, p);\n            }\n            p = normalizePropertyName(p);\n            restrictPropertyOnFilter(p, f);\n        }\n    }\n    f.restrictFulltextCondition(fullTextSearchExpression.currentValue().getValue(Type.STRING));\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void restrict(FilterImpl f) {\n    if (propertyName != null) {\n        if (f.getSelector().equals(selector)) {\n            String p = propertyName;\n            if (relativePath != null) {\n                p = PathUtils.concat(relativePath, p);\n            }\n            p = normalizePropertyName(p);\n            restrictPropertyOnFilter(p, f);\n        }\n    }\n    f.restrictFulltextCondition(fullTextSearchExpression.currentValue().getValue(Type.STRING));\n}", "lc": 0.0, "pi": 1.1173469387755102, "ma": 0.0, "nbd": 0.5, "ml": 0.16666666666666666, "d": -0.08798813643104299, "mi": -0.0005735589331802703, "fo": 0.16666666666666666, "r": 0.39999999999999997, "e": -0.04955863646292417}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3566_434e88fd", "label": 1, "code": "@SuppressWarnings(\"unchecked\")\nprivate static void validateInfo(ArrayList<Type> typeHierarchy, Type type, TypeInformation<?> typeInfo) {\n    if (type == null) {\n        throw new InvalidTypesException(\"Unknown Error. Type is null.\");\n    }\n    if (typeInfo == null) {\n        throw new InvalidTypesException(\"Unknown Error. TypeInformation is null.\");\n    }\n    if (!(type instanceof TypeVariable<?>)) {\n        // check for basic type\n        if (typeInfo.isBasicType()) {\n            TypeInformation<?> actual;\n            // check if basic type at all\n            if (!(type instanceof Class<?>) || (actual = BasicTypeInfo.getInfoFor((Class<?>) type)) == null) {\n                throw new InvalidTypesException(\"Basic type expected.\");\n            }\n            // check if correct basic type\n            if (!typeInfo.equals(actual)) {\n                throw new InvalidTypesException(\"Basic type '\" + typeInfo + \"' expected but was '\" + actual + \"'.\");\n            }\n        } else // check for tuple\n        if (typeInfo.isTupleType()) {\n            // check if tuple at all\n            if (!(isClassType(type) && Tuple.class.isAssignableFrom(typeToClass(type)))) {\n                throw new InvalidTypesException(\"Tuple type expected.\");\n            }\n            // do not allow usage of Tuple as type\n            if (isClassType(type) && typeToClass(type).equals(Tuple.class)) {\n                throw new InvalidTypesException(\"Concrete subclass of Tuple expected.\");\n            }\n            // go up the hierarchy until we reach immediate child of Tuple (with or without generics)\n            while (!(isClassType(type) && typeToClass(type).getSuperclass().equals(Tuple.class))) {\n                typeHierarchy.add(type);\n                type = typeToClass(type).getGenericSuperclass();\n            }\n            if (type == Tuple0.class) {\n                return;\n            }\n            // check if immediate child of Tuple has generics\n            if (type instanceof Class<?>) {\n                throw new InvalidTypesException(\"Parameterized Tuple type expected.\");\n            }\n            TupleTypeInfo<?> tti = (TupleTypeInfo<?>) typeInfo;\n            Type[] subTypes = ((ParameterizedType) type).getActualTypeArguments();\n            if (subTypes.length != tti.getArity()) {\n                throw new InvalidTypesException(\"Tuple arity '\" + tti.getArity() + \"' expected but was '\" + subTypes.length + \"'.\");\n            }\n            for (int i = 0; i < subTypes.length; i++) {\n                validateInfo(new ArrayList<Type>(typeHierarchy), subTypes[i], tti.getTypeAt(i));\n            }\n        } else // check for Either\n        if (typeInfo instanceof EitherTypeInfo) {\n            // check if Either at all\n            if (!(isClassType(type) && Either.class.isAssignableFrom(typeToClass(type)))) {\n                throw new InvalidTypesException(\"Either type expected.\");\n            }\n            // go up the hierarchy until we reach Either (with or without generics)\n            while (!(isClassType(type) && typeToClass(type).equals(Either.class))) {\n                typeHierarchy.add(type);\n                type = typeToClass(type).getGenericSuperclass();\n            }\n            // check if Either has generics\n            if (type instanceof Class<?>) {\n                throw new InvalidTypesException(\"Parameterized Either type expected.\");\n            }\n            EitherTypeInfo<?, ?> eti = (EitherTypeInfo<?, ?>) typeInfo;\n            Type[] subTypes = ((ParameterizedType) type).getActualTypeArguments();\n            validateInfo(new ArrayList<Type>(typeHierarchy), subTypes[0], eti.getLeftType());\n            validateInfo(new ArrayList<Type>(typeHierarchy), subTypes[1], eti.getRightType());\n        } else // check for Writable\n        if (typeInfo instanceof WritableTypeInfo<?>) {\n            // check if writable at all\n            if (!(type instanceof Class<?> && Writable.class.isAssignableFrom((Class<?>) type))) {\n                throw new InvalidTypesException(\"Writable type expected.\");\n            }\n            // check writable type contents\n            Class<?> clazz;\n            if (((WritableTypeInfo<?>) typeInfo).getTypeClass() != (clazz = (Class<?>) type)) {\n                throw new InvalidTypesException(\"Writable type '\" + ((WritableTypeInfo<?>) typeInfo).getTypeClass().getCanonicalName() + \"' expected but was '\" + clazz.getCanonicalName() + \"'.\");\n            }\n        } else // check for primitive array\n        if (typeInfo instanceof PrimitiveArrayTypeInfo) {\n            Type component;\n            // check if array at all\n            if (!(type instanceof Class<?> && ((Class<?>) type).isArray() && (component = ((Class<?>) type).getComponentType()) != null) && !(type instanceof GenericArrayType && (component = ((GenericArrayType) type).getGenericComponentType()) != null)) {\n                throw new InvalidTypesException(\"Array type expected.\");\n            }\n            if (component instanceof TypeVariable<?>) {\n                component = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) component);\n                if (component instanceof TypeVariable) {\n                    return;\n                }\n            }\n            if (!(component instanceof Class<?> && ((Class<?>) component).isPrimitive())) {\n                throw new InvalidTypesException(\"Primitive component expected.\");\n            }\n        } else // check for basic array\n        if (typeInfo instanceof BasicArrayTypeInfo<?, ?>) {\n            Type component;\n            // check if array at all\n            if (!(type instanceof Class<?> && ((Class<?>) type).isArray() && (component = ((Class<?>) type).getComponentType()) != null) && !(type instanceof GenericArrayType && (component = ((GenericArrayType) type).getGenericComponentType()) != null)) {\n                throw new InvalidTypesException(\"Array type expected.\");\n            }\n            if (component instanceof TypeVariable<?>) {\n                component = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) component);\n                if (component instanceof TypeVariable) {\n                    return;\n                }\n            }\n            validateInfo(typeHierarchy, component, ((BasicArrayTypeInfo<?, ?>) typeInfo).getComponentInfo());\n        } else // check for object array\n        if (typeInfo instanceof ObjectArrayTypeInfo<?, ?>) {\n            // check if array at all\n            if (!(type instanceof Class<?> && ((Class<?>) type).isArray()) && !(type instanceof GenericArrayType)) {\n                throw new InvalidTypesException(\"Object array type expected.\");\n            }\n            // check component\n            Type component;\n            if (type instanceof Class<?>) {\n                component = ((Class<?>) type).getComponentType();\n            } else {\n                component = ((GenericArrayType) type).getGenericComponentType();\n            }\n            if (component instanceof TypeVariable<?>) {\n                component = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) component);\n                if (component instanceof TypeVariable) {\n                    return;\n                }\n            }\n            validateInfo(typeHierarchy, component, ((ObjectArrayTypeInfo<?, ?>) typeInfo).getComponentInfo());\n        } else // check for value\n        if (typeInfo instanceof ValueTypeInfo<?>) {\n            // check if value at all\n            if (!(type instanceof Class<?> && Value.class.isAssignableFrom((Class<?>) type))) {\n                throw new InvalidTypesException(\"Value type expected.\");\n            }\n            TypeInformation<?> actual;\n            // check value type contents\n            if (!((ValueTypeInfo<?>) typeInfo).equals(actual = ValueTypeInfo.getValueTypeInfo((Class<? extends Value>) type))) {\n                throw new InvalidTypesException(\"Value type '\" + typeInfo + \"' expected but was '\" + actual + \"'.\");\n            }\n        } else // check for POJO\n        if (typeInfo instanceof PojoTypeInfo) {\n            Class<?> clazz = null;\n            if (!(isClassType(type) && ((PojoTypeInfo<?>) typeInfo).getTypeClass() == (clazz = typeToClass(type)))) {\n                throw new InvalidTypesException(\"POJO type '\" + ((PojoTypeInfo<?>) typeInfo).getTypeClass().getCanonicalName() + \"' expected but was '\" + clazz.getCanonicalName() + \"'.\");\n            }\n        } else // check for Enum\n        if (typeInfo instanceof EnumTypeInfo) {\n            if (!(type instanceof Class<?> && Enum.class.isAssignableFrom((Class<?>) type))) {\n                throw new InvalidTypesException(\"Enum type expected.\");\n            }\n            // check enum type contents\n            if (!(typeInfo.getTypeClass() == type)) {\n                throw new InvalidTypesException(\"Enum type '\" + typeInfo.getTypeClass().getCanonicalName() + \"' expected but was '\" + typeToClass(type).getCanonicalName() + \"'.\");\n            }\n        } else // check for generic object\n        if (typeInfo instanceof GenericTypeInfo<?>) {\n            Class<?> clazz = null;\n            if (!(isClassType(type) && ((GenericTypeInfo<?>) typeInfo).getTypeClass() == (clazz = typeToClass(type)))) {\n                throw new InvalidTypesException(\"Generic object type '\" + ((GenericTypeInfo<?>) typeInfo).getTypeClass().getCanonicalName() + \"' expected but was '\" + clazz.getCanonicalName() + \"'.\");\n            }\n        }\n    } else {\n        type = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) type);\n        if (!(type instanceof TypeVariable)) {\n            validateInfo(typeHierarchy, type, typeInfo);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings(\"unchecked\")\nprivate static void validateInfo(ArrayList<Type> typeHierarchy, Type type, TypeInformation<?> typeInfo) {\n    if (type == null) {\n        throw new InvalidTypesException(\"Unknown Error. Type is null.\");\n    }\n    if (typeInfo == null) {\n        throw new InvalidTypesException(\"Unknown Error. TypeInformation is null.\");\n    }\n    if (!(type instanceof TypeVariable<?>)) {\n                if (typeInfo.isBasicType()) {\n            TypeInformation<?> actual;\n                        if (!(type instanceof Class<?>) || (actual = BasicTypeInfo.getInfoFor((Class<?>) type)) == null) {\n                throw new InvalidTypesException(\"Basic type expected.\");\n            }\n                        if (!typeInfo.equals(actual)) {\n                throw new InvalidTypesException(\"Basic type '\" + typeInfo + \"' expected but was '\" + actual + \"'.\");\n            }\n        } else         if (typeInfo.isTupleType()) {\n                        if (!(isClassType(type) && Tuple.class.isAssignableFrom(typeToClass(type)))) {\n                throw new InvalidTypesException(\"Tuple type expected.\");\n            }\n                        if (isClassType(type) && typeToClass(type).equals(Tuple.class)) {\n                throw new InvalidTypesException(\"Concrete subclass of Tuple expected.\");\n            }\n                        while (!(isClassType(type) && typeToClass(type).getSuperclass().equals(Tuple.class))) {\n                typeHierarchy.add(type);\n                type = typeToClass(type).getGenericSuperclass();\n            }\n            if (type == Tuple0.class) {\n                return;\n            }\n                        if (type instanceof Class<?>) {\n                throw new InvalidTypesException(\"Parameterized Tuple type expected.\");\n            }\n            TupleTypeInfo<?> tti = (TupleTypeInfo<?>) typeInfo;\n            Type[] subTypes = ((ParameterizedType) type).getActualTypeArguments();\n            if (subTypes.length != tti.getArity()) {\n                throw new InvalidTypesException(\"Tuple arity '\" + tti.getArity() + \"' expected but was '\" + subTypes.length + \"'.\");\n            }\n            for (int i = 0; i < subTypes.length; i++) {\n                validateInfo(new ArrayList<Type>(typeHierarchy), subTypes[i], tti.getTypeAt(i));\n            }\n        } else         if (typeInfo instanceof EitherTypeInfo) {\n                        if (!(isClassType(type) && Either.class.isAssignableFrom(typeToClass(type)))) {\n                throw new InvalidTypesException(\"Either type expected.\");\n            }\n                        while (!(isClassType(type) && typeToClass(type).equals(Either.class))) {\n                typeHierarchy.add(type);\n                type = typeToClass(type).getGenericSuperclass();\n            }\n                        if (type instanceof Class<?>) {\n                throw new InvalidTypesException(\"Parameterized Either type expected.\");\n            }\n            EitherTypeInfo<?, ?> eti = (EitherTypeInfo<?, ?>) typeInfo;\n            Type[] subTypes = ((ParameterizedType) type).getActualTypeArguments();\n            validateInfo(new ArrayList<Type>(typeHierarchy), subTypes[0], eti.getLeftType());\n            validateInfo(new ArrayList<Type>(typeHierarchy), subTypes[1], eti.getRightType());\n        } else         if (typeInfo instanceof WritableTypeInfo<?>) {\n                        if (!(type instanceof Class<?> && Writable.class.isAssignableFrom((Class<?>) type))) {\n                throw new InvalidTypesException(\"Writable type expected.\");\n            }\n                        Class<?> clazz;\n            if (((WritableTypeInfo<?>) typeInfo).getTypeClass() != (clazz = (Class<?>) type)) {\n                throw new InvalidTypesException(\"Writable type '\" + ((WritableTypeInfo<?>) typeInfo).getTypeClass().getCanonicalName() + \"' expected but was '\" + clazz.getCanonicalName() + \"'.\");\n            }\n        } else         if (typeInfo instanceof PrimitiveArrayTypeInfo) {\n            Type component;\n                        if (!(type instanceof Class<?> && ((Class<?>) type).isArray() && (component = ((Class<?>) type).getComponentType()) != null) && !(type instanceof GenericArrayType && (component = ((GenericArrayType) type).getGenericComponentType()) != null)) {\n                throw new InvalidTypesException(\"Array type expected.\");\n            }\n            if (component instanceof TypeVariable<?>) {\n                component = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) component);\n                if (component instanceof TypeVariable) {\n                    return;\n                }\n            }\n            if (!(component instanceof Class<?> && ((Class<?>) component).isPrimitive())) {\n                throw new InvalidTypesException(\"Primitive component expected.\");\n            }\n        } else         if (typeInfo instanceof BasicArrayTypeInfo<?, ?>) {\n            Type component;\n                        if (!(type instanceof Class<?> && ((Class<?>) type).isArray() && (component = ((Class<?>) type).getComponentType()) != null) && !(type instanceof GenericArrayType && (component = ((GenericArrayType) type).getGenericComponentType()) != null)) {\n                throw new InvalidTypesException(\"Array type expected.\");\n            }\n            if (component instanceof TypeVariable<?>) {\n                component = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) component);\n                if (component instanceof TypeVariable) {\n                    return;\n                }\n            }\n            validateInfo(typeHierarchy, component, ((BasicArrayTypeInfo<?, ?>) typeInfo).getComponentInfo());\n        } else         if (typeInfo instanceof ObjectArrayTypeInfo<?, ?>) {\n                        if (!(type instanceof Class<?> && ((Class<?>) type).isArray()) && !(type instanceof GenericArrayType)) {\n                throw new InvalidTypesException(\"Object array type expected.\");\n            }\n                        Type component;\n            if (type instanceof Class<?>) {\n                component = ((Class<?>) type).getComponentType();\n            } else {\n                component = ((GenericArrayType) type).getGenericComponentType();\n            }\n            if (component instanceof TypeVariable<?>) {\n                component = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) component);\n                if (component instanceof TypeVariable) {\n                    return;\n                }\n            }\n            validateInfo(typeHierarchy, component, ((ObjectArrayTypeInfo<?, ?>) typeInfo).getComponentInfo());\n        } else         if (typeInfo instanceof ValueTypeInfo<?>) {\n                        if (!(type instanceof Class<?> && Value.class.isAssignableFrom((Class<?>) type))) {\n                throw new InvalidTypesException(\"Value type expected.\");\n            }\n            TypeInformation<?> actual;\n                        if (!((ValueTypeInfo<?>) typeInfo).equals(actual = ValueTypeInfo.getValueTypeInfo((Class<? extends Value>) type))) {\n                throw new InvalidTypesException(\"Value type '\" + typeInfo + \"' expected but was '\" + actual + \"'.\");\n            }\n        } else         if (typeInfo instanceof PojoTypeInfo) {\n            Class<?> clazz = null;\n            if (!(isClassType(type) && ((PojoTypeInfo<?>) typeInfo).getTypeClass() == (clazz = typeToClass(type)))) {\n                throw new InvalidTypesException(\"POJO type '\" + ((PojoTypeInfo<?>) typeInfo).getTypeClass().getCanonicalName() + \"' expected but was '\" + clazz.getCanonicalName() + \"'.\");\n            }\n        } else         if (typeInfo instanceof EnumTypeInfo) {\n            if (!(type instanceof Class<?> && Enum.class.isAssignableFrom((Class<?>) type))) {\n                throw new InvalidTypesException(\"Enum type expected.\");\n            }\n                        if (!(typeInfo.getTypeClass() == type)) {\n                throw new InvalidTypesException(\"Enum type '\" + typeInfo.getTypeClass().getCanonicalName() + \"' expected but was '\" + typeToClass(type).getCanonicalName() + \"'.\");\n            }\n        } else         if (typeInfo instanceof GenericTypeInfo<?>) {\n            Class<?> clazz = null;\n            if (!(isClassType(type) && ((GenericTypeInfo<?>) typeInfo).getTypeClass() == (clazz = typeToClass(type)))) {\n                throw new InvalidTypesException(\"Generic object type '\" + ((GenericTypeInfo<?>) typeInfo).getTypeClass().getCanonicalName() + \"' expected but was '\" + clazz.getCanonicalName() + \"'.\");\n            }\n        }\n    } else {\n        type = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) type);\n        if (!(type instanceof TypeVariable)) {\n            validateInfo(typeHierarchy, type, typeInfo);\n        }\n    }\n}", "lc": 6.2272727272727275, "pi": 0.35714285714285726, "ma": 10.833333333333334, "nbd": 5.5, "ml": 7.5, "d": 3.3109243697479, "mi": -1.9698881560080304, "fo": 6.25, "r": -0.028571428571428574, "e": 26.760438750904786}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3789_9319e139", "label": 1, "code": "public boolean storeFile(String fileName, Exchange exchange) throws GenericFileOperationFailedException {\n    ObjectHelper.notNull(endpoint, \"endpoint\");\n    File file = new File(fileName);\n    // if an existing file already exists what should we do?\n    if (file.exists()) {\n        if (endpoint.getFileExist() == GenericFileExist.Ignore) {\n            // ignore but indicate that the file was written\n            LOG.trace(\"An existing file already exists: {}. Ignore and do not override it.\", file);\n            return true;\n        } else if (endpoint.getFileExist() == GenericFileExist.Fail) {\n            throw new GenericFileOperationFailedException(\"File already exist: \" + file + \". Cannot write new file.\");\n        }\n    }\n    // 3. write stream to file\n    try {\n        // is the body file based\n        File source = null;\n        // get the File Object from in message\n        source = exchange.getIn().getBody(File.class);\n        if (source != null) {\n            // okay we know the body is a file type\n            // so try to see if we can optimize by renaming the local work path file instead of doing\n            // a full file to file copy, as the local work copy is to be deleted afterwards anyway\n            // local work path\n            File local = exchange.getIn().getHeader(Exchange.FILE_LOCAL_WORK_PATH, File.class);\n            if (local != null && local.exists()) {\n                boolean renamed = writeFileByLocalWorkPath(local, file);\n                if (renamed) {\n                    // try to keep last modified timestamp if configured to do so\n                    keepLastModified(exchange, file);\n                    // clear header as we have renamed the file\n                    exchange.getIn().setHeader(Exchange.FILE_LOCAL_WORK_PATH, null);\n                    // to the target.\n                    return true;\n                }\n            } else if (source.exists()) {\n                // no there is no local work file so use file to file copy if the source exists\n                writeFileByFile(source, file);\n                // try to keep last modified timestamp if configured to do so\n                keepLastModified(exchange, file);\n                return true;\n            }\n        }\n        // fallback and use stream based\n        InputStream in = ExchangeHelper.getMandatoryInBody(exchange, InputStream.class);\n        writeFileByStream(in, file);\n        // try to keep last modified timestamp if configured to do so\n        keepLastModified(exchange, file);\n        return true;\n    } catch (IOException e) {\n        throw new GenericFileOperationFailedException(\"Cannot store file: \" + file, e);\n    } catch (InvalidPayloadException e) {\n        throw new GenericFileOperationFailedException(\"Cannot store file: \" + file, e);\n    }\n}", "code_comment": NaN, "code_no_comment": "public boolean storeFile(String fileName, Exchange exchange) throws GenericFileOperationFailedException {\n    ObjectHelper.notNull(endpoint, \"endpoint\");\n    File file = new File(fileName);\n        if (file.exists()) {\n        if (endpoint.getFileExist() == GenericFileExist.Ignore) {\n                        LOG.trace(\"An existing file already exists: {}. Ignore and do not override it.\", file);\n            return true;\n        } else if (endpoint.getFileExist() == GenericFileExist.Fail) {\n            throw new GenericFileOperationFailedException(\"File already exist: \" + file + \". Cannot write new file.\");\n        }\n    }\n        try {\n                File source = null;\n                source = exchange.getIn().getBody(File.class);\n        if (source != null) {\n                                                            File local = exchange.getIn().getHeader(Exchange.FILE_LOCAL_WORK_PATH, File.class);\n            if (local != null && local.exists()) {\n                boolean renamed = writeFileByLocalWorkPath(local, file);\n                if (renamed) {\n                                        keepLastModified(exchange, file);\n                                        exchange.getIn().setHeader(Exchange.FILE_LOCAL_WORK_PATH, null);\n                                        return true;\n                }\n            } else if (source.exists()) {\n                                writeFileByFile(source, file);\n                                keepLastModified(exchange, file);\n                return true;\n            }\n        }\n                InputStream in = ExchangeHelper.getMandatoryInBody(exchange, InputStream.class);\n        writeFileByStream(in, file);\n                keepLastModified(exchange, file);\n        return true;\n    } catch (IOException e) {\n        throw new GenericFileOperationFailedException(\"Cannot store file: \" + file, e);\n    } catch (InvalidPayloadException e) {\n        throw new GenericFileOperationFailedException(\"Cannot store file: \" + file, e);\n    }\n}", "lc": 1.1363636363636365, "pi": 1.1428571428571428, "ma": 1.5, "nbd": 1.0, "ml": 1.0, "d": 0.5625308947108255, "mi": -0.7304273014052196, "fo": 1.1666666666666667, "r": -0.028571428571428574, "e": 1.2015795717852844}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4066_4d3d1f85", "label": 1, "code": "public IRequestHandler mapRequest(Request request) {\n    InterceptData data = InterceptData.get();\n    if (data != null) {\n        if (data.originalUrl.equals(request.getOriginalUrl())) {\n            if (data.postParameters.isEmpty() == false && request.getPostParameters() instanceof IWritableRequestParameters) {\n                IWritableRequestParameters parameters = (IWritableRequestParameters) request.getPostParameters();\n                parameters.reset();\n                for (String s : data.postParameters.keySet()) {\n                    parameters.setParameterValues(s, data.postParameters.get(s));\n                }\n            }\n            InterceptData.clear();\n        }\n    }\n    return null;\n}", "code_comment": NaN, "code_no_comment": "public IRequestHandler mapRequest(Request request) {\n    InterceptData data = InterceptData.get();\n    if (data != null) {\n        if (data.originalUrl.equals(request.getOriginalUrl())) {\n            if (data.postParameters.isEmpty() == false && request.getPostParameters() instanceof IWritableRequestParameters) {\n                IWritableRequestParameters parameters = (IWritableRequestParameters) request.getPostParameters();\n                parameters.reset();\n                for (String s : data.postParameters.keySet()) {\n                    parameters.setParameterValues(s, data.postParameters.get(s));\n                }\n            }\n            InterceptData.clear();\n        }\n    }\n    return null;\n}", "lc": 0.09090909090909091, "pi": 1.5918367346938773, "ma": 0.16666666666666666, "nbd": 1.0, "ml": 0.3333333333333333, "d": 0.36085022244191806, "mi": -0.11127043303699445, "fo": 0.4166666666666667, "r": -0.028571428571428574, "e": 0.2218338965483273}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2359_b3071839", "label": 0, "code": "/**\n * Get the latest property value that is larger or equal the min revision,\n * and smaller or equal the readRevision revision. A {@code null} return\n * value indicates that the property was not set or removed within the given\n * range. A non-null value means the the property was either set or removed\n * depending on {@link Value#value}.\n *\n * @param valueMap the sorted revision-value map\n * @param min the minimum revision (null meaning unlimited)\n * @param readRevision the maximum revision\n * @param validRevisions map of revision to commit value considered valid\n *                       against the given readRevision.\n * @param lastRevs to keep track of the most recent modification.\n * @return the value, or null if not found\n */\n@CheckForNull\nprivate Value getLatestValue(@Nonnull RevisionContext context, @Nonnull Map<Revision, String> valueMap, @Nullable Revision min, @Nonnull Revision readRevision, @Nonnull Map<Revision, String> validRevisions, @Nonnull LastRevs lastRevs) {\n    for (Map.Entry<Revision, String> entry : valueMap.entrySet()) {\n        Revision propRev = entry.getKey();\n        String commitValue = validRevisions.get(propRev);\n        if (commitValue == null) {\n            // resolve revision\n            NodeDocument commitRoot = getCommitRoot(propRev);\n            if (commitRoot == null) {\n                continue;\n            }\n            commitValue = commitRoot.getCommitValue(propRev);\n            if (commitValue == null) {\n                continue;\n            }\n        }\n        Revision commitRev = resolveCommitRevision(propRev, commitValue);\n        if (Utils.isCommitted(commitValue)) {\n            lastRevs.update(commitRev);\n        } else {\n            // branch commit\n            lastRevs.updateBranch(commitRev.asBranchRevision());\n        }\n        if (min != null && isRevisionNewer(context, min, commitRev)) {\n            continue;\n        }\n        if (isValidRevision(context, propRev, commitValue, readRevision, validRevisions)) {\n            // TODO: need to check older revisions as well?\n            return new Value(commitRev, entry.getValue());\n        }\n    }\n    return null;\n}", "code_comment": "/**\n * Get the latest property value that is larger or equal the min revision,\n * and smaller or equal the readRevision revision. A {@code null} return\n * value indicates that the property was not set or removed within the given\n * range. A non-null value means the the property was either set or removed\n * depending on {@link Value#value}.\n *\n * @param valueMap the sorted revision-value map\n * @param min the minimum revision (null meaning unlimited)\n * @param readRevision the maximum revision\n * @param validRevisions map of revision to commit value considered valid\n *                       against the given readRevision.\n * @param lastRevs to keep track of the most recent modification.\n * @return the value, or null if not found\n */\n", "code_no_comment": "@CheckForNull\nprivate Value getLatestValue(@Nonnull RevisionContext context, @Nonnull Map<Revision, String> valueMap, @Nullable Revision min, @Nonnull Revision readRevision, @Nonnull Map<Revision, String> validRevisions, @Nonnull LastRevs lastRevs) {\n    for (Map.Entry<Revision, String> entry : valueMap.entrySet()) {\n        Revision propRev = entry.getKey();\n        String commitValue = validRevisions.get(propRev);\n        if (commitValue == null) {\n                        NodeDocument commitRoot = getCommitRoot(propRev);\n            if (commitRoot == null) {\n                continue;\n            }\n            commitValue = commitRoot.getCommitValue(propRev);\n            if (commitValue == null) {\n                continue;\n            }\n        }\n        Revision commitRev = resolveCommitRevision(propRev, commitValue);\n        if (Utils.isCommitted(commitValue)) {\n            lastRevs.update(commitRev);\n        } else {\n                        lastRevs.updateBranch(commitRev.asBranchRevision());\n        }\n        if (min != null && isRevisionNewer(context, min, commitRev)) {\n            continue;\n        }\n        if (isValidRevision(context, propRev, commitValue, readRevision, validRevisions)) {\n                        return new Value(commitRev, entry.getValue());\n        }\n    }\n    return null;\n}", "lc": 0.7272727272727273, "pi": 0.5714285714285713, "ma": 1.1666666666666667, "nbd": 0.5, "ml": 1.0833333333333333, "d": 0.5111220958971825, "mi": -0.5615141955835963, "fo": 0.5833333333333334, "r": -0.028571428571428574, "e": 0.8636077453839928}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3789_9319e139", "label": 1, "code": "private void writeFileByStream(InputStream in, File target) throws IOException {\n    FileChannel out = null;\n    try {\n        out = prepareOutputFileChannel(target, out);\n        LOG.trace(\"Using InputStream to transfer from: {} to: {}\", in, out);\n        int size = endpoint.getBufferSize();\n        byte[] buffer = new byte[size];\n        ByteBuffer byteBuffer = ByteBuffer.wrap(buffer);\n        int bytesRead;\n        while ((bytesRead = in.read(buffer)) != -1) {\n            if (bytesRead < size) {\n                byteBuffer.limit(bytesRead);\n            }\n            out.write(byteBuffer);\n            byteBuffer.clear();\n        }\n    } finally {\n        IOHelper.close(in, target.getName(), LOG);\n        IOHelper.close(out, target.getName(), LOG);\n    }\n}", "code_comment": NaN, "code_no_comment": "private void writeFileByStream(InputStream in, File target) throws IOException {\n    FileChannel out = null;\n    try {\n        out = prepareOutputFileChannel(target, out);\n        LOG.trace(\"Using InputStream to transfer from: {} to: {}\", in, out);\n        int size = endpoint.getBufferSize();\n        byte[] buffer = new byte[size];\n        ByteBuffer byteBuffer = ByteBuffer.wrap(buffer);\n        int bytesRead;\n        while ((bytesRead = in.read(buffer)) != -1) {\n            if (bytesRead < size) {\n                byteBuffer.limit(bytesRead);\n            }\n            out.write(byteBuffer);\n            byteBuffer.clear();\n        }\n    } finally {\n        IOHelper.close(in, target.getName(), LOG);\n        IOHelper.close(out, target.getName(), LOG);\n    }\n}", "lc": 0.3181818181818182, "pi": 0.43877551020408156, "ma": -0.16666666666666666, "nbd": 0.5, "ml": -0.08333333333333333, "d": 0.37073652990608014, "mi": -0.27444794952681417, "fo": 0.5, "r": -0.028571428571428574, "e": 0.3822580852403408}
{"project_name": "Lang", "project_version": 63, "label": 1, "code": "/**\n * <p>Formats the time gap as a string, using the specified format.\n * Padding the left hand side of numbers with zeroes is optional and\n * the timezone may be specified.\n *\n * @param startMillis  the start of the duration\n * @param endMillis  the end of the duration\n * @param format  the way in which to format the duration\n * @param padWithZeros whether to pad the left hand side of numbers with 0's\n * @param timezone the millis are defined in\n * @return the time as a String\n */\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        days += 31;\n        // days += 31; // TODO: Need tests to show this is bad and the new code is good.\n        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n        // Also it's contextual - if asked for no M in the format then I should probably\n        // be doing no calculating here.\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += 365 * years;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}", "code_comment": "/**\n * <p>Formats the time gap as a string, using the specified format.\n * Padding the left hand side of numbers with zeroes is optional and\n * the timezone may be specified.\n *\n * @param startMillis  the start of the duration\n * @param endMillis  the end of the duration\n * @param format  the way in which to format the duration\n * @param padWithZeros whether to pad the left hand side of numbers with 0's\n * @param timezone the millis are defined in\n * @return the time as a String\n */\n", "code_no_comment": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n            Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n        while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        days += 31;\n                                                months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n        if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n                        days += 365 * years;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}", "lc": 2.9545454545454546, "pi": -0.2602040816326532, "ma": 1.8333333333333333, "nbd": 0.0, "ml": 2.25, "d": 2.5318833415719233, "mi": -1.23831373673645, "fo": 2.5833333333333335, "r": -0.028571428571428574, "e": 12.717912806609531}
{"project_name": "Compress", "project_version": 4, "label": 1, "code": "/**\n * Performs all changes collected in this ChangeSet on the input stream and\n * streams the result to the output stream. Perform may be called more than once.\n *\n * This method finishes the stream, no other entries should be added\n * after that.\n *\n * @param in\n *            the InputStream to perform the changes on\n * @param out\n *            the resulting OutputStream with all modifications\n * @throws IOException\n *             if an read/write error occurs\n * @return the results of this operation\n */\npublic ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out) throws IOException {\n    ChangeSetResults results = new ChangeSetResults();\n    Set workingSet = new LinkedHashSet(changes);\n    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {\n        Change change = (Change) it.next();\n        if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n            copyStream(change.getInput(), out, change.getEntry());\n            it.remove();\n            results.addedFromChangeSet(change.getEntry().getName());\n        }\n    }\n    ArchiveEntry entry = null;\n    while ((entry = in.getNextEntry()) != null) {\n        boolean copy = true;\n        for (Iterator it = workingSet.iterator(); it.hasNext(); ) {\n            Change change = (Change) it.next();\n            final int type = change.type();\n            final String name = entry.getName();\n            if (type == Change.TYPE_DELETE && name != null) {\n                if (name.equals(change.targetFile())) {\n                    copy = false;\n                    it.remove();\n                    results.deleted(name);\n                    break;\n                }\n            } else if (type == Change.TYPE_DELETE_DIR && name != null) {\n                if (name.startsWith(change.targetFile() + \"/\")) {\n                    copy = false;\n                    results.deleted(name);\n                    break;\n                }\n            }\n        }\n        if (copy) {\n            if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n                copyStream(in, out, entry);\n                results.addedFromStream(entry.getName());\n            }\n        }\n    }\n    // Adds files which hasn't been added from the original and do not have replace mode on\n    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {\n        Change change = (Change) it.next();\n        if (change.type() == Change.TYPE_ADD && !change.isReplaceMode() && !results.hasBeenAdded(change.getEntry().getName())) {\n            copyStream(change.getInput(), out, change.getEntry());\n            it.remove();\n            results.addedFromChangeSet(change.getEntry().getName());\n        }\n    }\n    return results;\n}", "code_comment": "/**\n * Performs all changes collected in this ChangeSet on the input stream and\n * streams the result to the output stream. Perform may be called more than once.\n *\n * This method finishes the stream, no other entries should be added\n * after that.\n *\n * @param in\n *            the InputStream to perform the changes on\n * @param out\n *            the resulting OutputStream with all modifications\n * @throws IOException\n *             if an read/write error occurs\n * @return the results of this operation\n */\n", "code_no_comment": "public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out) throws IOException {\n    ChangeSetResults results = new ChangeSetResults();\n    Set workingSet = new LinkedHashSet(changes);\n    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {\n        Change change = (Change) it.next();\n        if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n            copyStream(change.getInput(), out, change.getEntry());\n            it.remove();\n            results.addedFromChangeSet(change.getEntry().getName());\n        }\n    }\n    ArchiveEntry entry = null;\n    while ((entry = in.getNextEntry()) != null) {\n        boolean copy = true;\n        for (Iterator it = workingSet.iterator(); it.hasNext(); ) {\n            Change change = (Change) it.next();\n            final int type = change.type();\n            final String name = entry.getName();\n            if (type == Change.TYPE_DELETE && name != null) {\n                if (name.equals(change.targetFile())) {\n                    copy = false;\n                    it.remove();\n                    results.deleted(name);\n                    break;\n                }\n            } else if (type == Change.TYPE_DELETE_DIR && name != null) {\n                if (name.startsWith(change.targetFile() + \"/\")) {\n                    copy = false;\n                    results.deleted(name);\n                    break;\n                }\n            }\n        }\n        if (copy) {\n            if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n                copyStream(in, out, entry);\n                results.addedFromStream(entry.getName());\n            }\n        }\n    }\n        for (Iterator it = workingSet.iterator(); it.hasNext(); ) {\n        Change change = (Change) it.next();\n        if (change.type() == Change.TYPE_ADD && !change.isReplaceMode() && !results.hasBeenAdded(change.getEntry().getName())) {\n            copyStream(change.getInput(), out, change.getEntry());\n            it.remove();\n            results.addedFromChangeSet(change.getEntry().getName());\n        }\n    }\n    return results;\n}", "lc": 1.6363636363636365, "pi": 1.306122448979592, "ma": 1.8333333333333333, "nbd": 1.5, "ml": 2.4166666666666665, "d": 1.5353435491843799, "mi": -0.9308861485517642, "fo": 3.3333333333333335, "r": -0.028571428571428574, "e": 4.324827287873531}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2649_72d24f4b", "label": 3, "code": "@Override\npublic void run() {\n    String name = reference.name;\n    try {\n        if (!local.fileExists(name)) {\n            long start = System.currentTimeMillis();\n            remote.copy(local, name, name, IOContext.READ);\n            reference.markValid();\n            downloadTime.addAndGet(System.currentTimeMillis() - start);\n            downloadSize.addAndGet(remote.fileLength(name));\n        } else {\n            long localLength = local.fileLength(name);\n            long remoteLength = remote.fileLength(name);\n            // updated but still do a check if the copy is consistent\n            if (localLength != remoteLength) {\n                log.warn(\"Found local copy for {} in {} but size of local {} differs from remote {}. \" + \"Content would be read from remote file only\", name, local, localLength, remoteLength);\n                invalidFileCount.incrementAndGet();\n            } else {\n                reference.markValid();\n            }\n        }\n    } catch (IOException e) {\n        // TODO In case of exception there would not be any other attempt\n        // to download the file. Look into support for retry\n        log.warn(\"Error occurred while copying file [{}] \" + \"from {} to {}\", name, remote, local, e);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void run() {\n    String name = reference.name;\n    try {\n        if (!local.fileExists(name)) {\n            long start = System.currentTimeMillis();\n            remote.copy(local, name, name, IOContext.READ);\n            reference.markValid();\n            downloadTime.addAndGet(System.currentTimeMillis() - start);\n            downloadSize.addAndGet(remote.fileLength(name));\n        } else {\n            long localLength = local.fileLength(name);\n            long remoteLength = remote.fileLength(name);\n                        if (localLength != remoteLength) {\n                log.warn(\"Found local copy for {} in {} but size of local {} differs from remote {}. \" + \"Content would be read from remote file only\", name, local, localLength, remoteLength);\n                invalidFileCount.incrementAndGet();\n            } else {\n                reference.markValid();\n            }\n        }\n    } catch (IOException e) {\n                        log.warn(\"Error occurred while copying file [{}] \" + \"from {} to {}\", name, remote, local, e);\n    }\n}", "lc": 0.45454545454545453, "pi": 0.9744897959183673, "ma": 0.0, "nbd": 0.5, "ml": 0.08333333333333333, "d": 0.41028175976272874, "mi": -0.3616289073702324, "fo": 0.6666666666666666, "r": -0.028571428571428574, "e": 0.48728590334973726}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-1897_8ee095bf", "label": 1, "code": "/**\n *  @return The interface name\n */\npublic String getInterfaceName() {\n    return interfaceName;\n}", "code_comment": "/**\n *  @return The interface name\n */\n", "code_no_comment": "public String getInterfaceName() {\n    return interfaceName;\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.2001720676799543, "fo": -0.5, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2494_0dc92ca1", "label": 1, "code": "public long getSum() {\n    return sum;\n}", "code_comment": NaN, "code_no_comment": "public long getSum() {\n    return sum;\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.2776025236593067, "fo": -0.5, "r": 2.685714285714286, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5826_a04674f2", "label": 1, "code": "@Override\nString getNext(boolean first) {\n    String next = scanner.next();\n    if (next == null) {\n        return null;\n    }\n    // initialize inherited namespaces on first\n    if (first && inheritNamespaceToken != null) {\n        rootTokenNamespaces = getNamespacesFromNamespaceToken(next);\n    }\n    // make sure next is positioned at start token as we can have leading data\n    // or we reached EOL and there is no more start tags\n    Matcher matcher = startTokenPattern.matcher(next);\n    if (!matcher.find()) {\n        return null;\n    } else {\n        int index = matcher.start();\n        next = next.substring(index);\n    }\n    // build answer accordingly to whether namespaces should be inherited or not\n    StringBuilder sb = new StringBuilder();\n    if (inheritNamespaceToken != null && rootTokenNamespaces != null) {\n        // append root namespaces to local start token\n        String tag = ObjectHelper.before(next, \">\");\n        // grab the text\n        String text = ObjectHelper.after(next, \">\");\n        // build result with inherited namespaces\n        next = sb.append(tag).append(rootTokenNamespaces).append(\">\").append(text).append(endToken).toString();\n    } else {\n        next = sb.append(next).append(endToken).toString();\n    }\n    return next;\n}", "code_comment": NaN, "code_no_comment": "@Override\nString getNext(boolean first) {\n    String next = scanner.next();\n    if (next == null) {\n        return null;\n    }\n        if (first && inheritNamespaceToken != null) {\n        rootTokenNamespaces = getNamespacesFromNamespaceToken(next);\n    }\n            Matcher matcher = startTokenPattern.matcher(next);\n    if (!matcher.find()) {\n        return null;\n    } else {\n        int index = matcher.start();\n        next = next.substring(index);\n    }\n        StringBuilder sb = new StringBuilder();\n    if (inheritNamespaceToken != null && rootTokenNamespaces != null) {\n                String tag = ObjectHelper.before(next, \">\");\n                String text = ObjectHelper.after(next, \">\");\n                next = sb.append(tag).append(rootTokenNamespaces).append(\">\").append(text).append(endToken).toString();\n    } else {\n        next = sb.append(next).append(endToken).toString();\n    }\n    return next;\n}", "lc": 0.5454545454545454, "pi": -0.2346938775510204, "ma": 0.16666666666666666, "nbd": -0.5, "ml": 0.5, "d": 0.6139396935244688, "mi": -0.4330369945511905, "fo": 0.9166666666666666, "r": -0.028571428571428574, "e": 0.8230691148316137}
{"project_name": "Lang", "project_version": 37, "label": 1, "code": "/**\n * <p>Adds all the elements of the given arrays into a new array.</p>\n * <p>The new array contains all of the element of <code>array1</code> followed\n * by all of the elements <code>array2</code>. When an array is returned, it is always\n * a new array.</p>\n *\n * <pre>\n * ArrayUtils.addAll(null, null)     = null\n * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n * ArrayUtils.addAll([], [])         = []\n * ArrayUtils.addAll([null], [null]) = [null, null]\n * ArrayUtils.addAll([\"a\", \"b\", \"c\"], [\"1\", \"2\", \"3\"]) = [\"a\", \"b\", \"c\", \"1\", \"2\", \"3\"]\n * </pre>\n *\n * @param array1  the first array whose elements are added to the new array, may be <code>null</code>\n * @param array2  the second array whose elements are added to the new array, may be <code>null</code>\n * @return The new array, <code>null</code> if both arrays are <code>null</code>.\n *      The type of the new array is the type of the first array,\n *      unless the first array is null, in which case the type is the same as the second array.\n * @since 2.1\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T[] addAll(T[] array1, T... array2) {\n    if (array1 == null) {\n        return clone(array2);\n    } else if (array2 == null) {\n        return clone(array1);\n    }\n    final Class<?> type1 = array1.getClass().getComponentType();\n    T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n    System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n    // Check if problem is incompatible types\n    return joinedArray;\n}", "code_comment": "/**\n * <p>Adds all the elements of the given arrays into a new array.</p>\n * <p>The new array contains all of the element of <code>array1</code> followed\n * by all of the elements <code>array2</code>. When an array is returned, it is always\n * a new array.</p>\n *\n * <pre>\n * ArrayUtils.addAll(null, null)     = null\n * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n * ArrayUtils.addAll([], [])         = []\n * ArrayUtils.addAll([null], [null]) = [null, null]\n * ArrayUtils.addAll([\"a\", \"b\", \"c\"], [\"1\", \"2\", \"3\"]) = [\"a\", \"b\", \"c\", \"1\", \"2\", \"3\"]\n * </pre>\n *\n * @param array1  the first array whose elements are added to the new array, may be <code>null</code>\n * @param array2  the second array whose elements are added to the new array, may be <code>null</code>\n * @return The new array, <code>null</code> if both arrays are <code>null</code>.\n *      The type of the new array is the type of the first array,\n *      unless the first array is null, in which case the type is the same as the second array.\n * @since 2.1\n */\n", "code_no_comment": "@SuppressWarnings(\"unchecked\")\npublic static <T> T[] addAll(T[] array1, T... array2) {\n    if (array1 == null) {\n        return clone(array2);\n    } else if (array2 == null) {\n        return clone(array1);\n    }\n    final Class<?> type1 = array1.getClass().getComponentType();\n    T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n    System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n}", "lc": -0.045454545454545456, "pi": -0.28571428571428575, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.08333333333333333, "d": 0.12357884330202672, "mi": -0.009463722397476294, "fo": 0.08333333333333333, "r": -0.028571428571428574, "e": 0.11243741460761263}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3310_4416a9f8", "label": 1, "code": "private Property internalRemoveProperty(final String jcrName) throws RepositoryException {\n    final String oakName = getOakName(checkNotNull(jcrName));\n    return perform(new ItemWriteOperation<Property>(\"internalRemoveProperty\") {\n\n        @Nonnull\n        @Override\n        public Property perform() throws RepositoryException {\n            PropertyDelegate property = dlg.getPropertyOrNull(oakName);\n            if (property != null) {\n                property.remove();\n            } else {\n                // Return an instance which throws on access; see OAK-395\n                property = dlg.getProperty(oakName);\n            }\n            return new PropertyImpl(property, sessionContext);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"Removing property [%s]\", jcrName);\n        }\n    });\n}", "code_comment": NaN, "code_no_comment": "private Property internalRemoveProperty(final String jcrName) throws RepositoryException {\n    final String oakName = getOakName(checkNotNull(jcrName));\n    return perform(new ItemWriteOperation<Property>(\"internalRemoveProperty\") {\n\n        @Nonnull\n        @Override\n        public Property perform() throws RepositoryException {\n            PropertyDelegate property = dlg.getPropertyOrNull(oakName);\n            if (property != null) {\n                property.remove();\n            } else {\n                                property = dlg.getProperty(oakName);\n            }\n            return new PropertyImpl(property, sessionContext);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"Removing property [%s]\", jcrName);\n        }\n    });\n}", "lc": 0.2727272727272727, "pi": 0.7193877551020407, "ma": -0.3333333333333333, "nbd": 0.0, "ml": -0.25, "d": -0.040533860603064735, "mi": -0.1843991970174938, "fo": 0.08333333333333333, "r": 0.05714285714285714, "e": 0.0004068853568384531}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-5209_ed651a4d", "label": 3, "code": "public List<String> getRuntimeClasspathElements() throws DependencyResolutionRequiredException {\n    List<String> list = new ArrayList<String>(getArtifacts().size() + 1);\n    list.add(getBuild().getOutputDirectory());\n    for (Artifact a : getArtifacts()) {\n        if (a.getArtifactHandler().isAddedToClasspath()) {\n            // TODO: let the scope handler deal with this\n            if (Artifact.SCOPE_COMPILE.equals(a.getScope()) || Artifact.SCOPE_RUNTIME.equals(a.getScope())) {\n                addArtifactPath(a, list);\n            }\n        }\n    }\n    return list;\n}", "code_comment": NaN, "code_no_comment": "public List<String> getRuntimeClasspathElements() throws DependencyResolutionRequiredException {\n    List<String> list = new ArrayList<String>(getArtifacts().size() + 1);\n    list.add(getBuild().getOutputDirectory());\n    for (Artifact a : getArtifacts()) {\n        if (a.getArtifactHandler().isAddedToClasspath()) {\n                        if (Artifact.SCOPE_COMPILE.equals(a.getScope()) || Artifact.SCOPE_RUNTIME.equals(a.getScope())) {\n                addArtifactPath(a, list);\n            }\n        }\n    }\n    return list;\n}", "lc": -0.09090909090909091, "pi": 0.8826530612244898, "ma": 0.0, "nbd": 0.5, "ml": 0.16666666666666666, "d": -0.04844290657439445, "mi": 0.06739317464869501, "fo": 0.5833333333333334, "r": 0.0, "e": -0.030426458684004277}
{"project_name": "Csv", "project_version": 11, "label": 1, "code": "/**\n * Initializes the name to index mapping if the format defines a header.\n *\n * @return null if the format has no header.\n * @throws IOException if there is a problem reading the header or skipping the first record\n */\nprivate Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            // read the header from the first line of the file\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord != null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        // build the name to index mappings\n        if (headerRecord != null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                final boolean emptyHeader = header.trim().isEmpty();\n                if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header + \"\\\" in \" + Arrays.toString(headerRecord));\n                }\n                hdrMap.put(header, Integer.valueOf(i));\n            }\n        }\n    }\n    return hdrMap;\n}", "code_comment": "/**\n * Initializes the name to index mapping if the format defines a header.\n *\n * @return null if the format has no header.\n * @throws IOException if there is a problem reading the header or skipping the first record\n */\n", "code_no_comment": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n                        final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord != null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n                if (headerRecord != null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                final boolean emptyHeader = header.trim().isEmpty();\n                if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header + \"\\\" in \" + Arrays.toString(headerRecord));\n                }\n                hdrMap.put(header, Integer.valueOf(i));\n            }\n        }\n    }\n    return hdrMap;\n}", "lc": 0.7727272727272727, "pi": 1.0918367346938775, "ma": 0.8333333333333334, "nbd": 1.0, "ml": 1.25, "d": 1.4562530894710826, "mi": -0.5692572411815318, "fo": 0.5, "r": -0.028571428571428574, "e": 2.0389924661963934}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5418_e350f19e", "label": 1, "code": "/**\n *  Marks the form component required if necessary\n */\nprivate void setComponentRequiredFlag() {\n    BeanValidationContext config = BeanValidationConfiguration.get();\n    Validator validator = config.getValidator();\n    Property property = getProperty();\n    // if the property has a NotNull constraint mark the form component required\n    Iterator<ConstraintDescriptor<?>> it = new ConstraintIterator(validator, property);\n    while (it.hasNext()) {\n        ConstraintDescriptor<?> desc = it.next();\n        if (desc.getAnnotation().annotationType().equals(NotNull.class)) {\n            component.setRequired(true);\n            break;\n        }\n    }\n}", "code_comment": "/**\n *  Marks the form component required if necessary\n */\n", "code_no_comment": "private void setComponentRequiredFlag() {\n    BeanValidationContext config = BeanValidationConfiguration.get();\n    Validator validator = config.getValidator();\n    Property property = getProperty();\n        Iterator<ConstraintDescriptor<?>> it = new ConstraintIterator(validator, property);\n    while (it.hasNext()) {\n        ConstraintDescriptor<?> desc = it.next();\n        if (desc.getAnnotation().annotationType().equals(NotNull.class)) {\n            component.setRequired(true);\n            break;\n        }\n    }\n}", "lc": -0.045454545454545456, "pi": 0.34183673469387754, "ma": 0.0, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.3806228373702422, "mi": 0.03412675652423281, "fo": 0.25, "r": 0.4571428571428572, "e": -0.16422749602751402}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-492_61ccbb95", "label": 3, "code": "/**\n * Unregisters all MBeans associated with the specified logger context\n * (including MBeans for {@code LoggerConfig}s and {@code Appender}s from\n * the platform MBean server.\n *\n * @param loggerContextName name of the logger context to unregister\n * @param mbs the MBean Server to unregister the instrumented objects from\n */\npublic static void unregisterContext(String contextName, MBeanServer mbs) {\n    final String pattern = LoggerContextAdminMBean.PATTERN;\n    final String search = String.format(pattern, contextName, \"*\");\n    // unregister context mbean\n    unregisterAllMatching(search, mbs);\n    unregisterLoggerConfigs(contextName, mbs);\n    unregisterAppenders(contextName, mbs);\n    unregisterAsyncAppenders(contextName, mbs);\n    unregisterAsyncLoggerRingBufferAdmins(contextName, mbs);\n    unregisterAsyncLoggerConfigRingBufferAdmins(contextName, mbs);\n}", "code_comment": "/**\n * Unregisters all MBeans associated with the specified logger context\n * (including MBeans for {@code LoggerConfig}s and {@code Appender}s from\n * the platform MBean server.\n *\n * @param loggerContextName name of the logger context to unregister\n * @param mbs the MBean Server to unregister the instrumented objects from\n */\n", "code_no_comment": "public static void unregisterContext(String contextName, MBeanServer mbs) {\n    final String pattern = LoggerContextAdminMBean.PATTERN;\n    final String search = String.format(pattern, contextName, \"*\");\n        unregisterAllMatching(search, mbs);\n    unregisterLoggerConfigs(contextName, mbs);\n    unregisterAppenders(contextName, mbs);\n    unregisterAsyncAppenders(contextName, mbs);\n    unregisterAsyncLoggerRingBufferAdmins(contextName, mbs);\n    unregisterAsyncLoggerConfigRingBufferAdmins(contextName, mbs);\n}", "lc": -0.18181818181818182, "pi": -0.7244897959183674, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.19673071408087184, "fo": 0.08333333333333333, "r": 0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-3718_73ce9cfb", "label": 0, "code": "public boolean equals(Mutation m) {\n    serialize();\n    m.serialize();\n    if (Arrays.equals(row, m.row) && entries == m.entries && Arrays.equals(data, m.data)) {\n        if (values == null && m.values == null)\n            return true;\n        if (values != null && m.values != null && values.size() == m.values.size()) {\n            for (int i = 0; i < values.size(); i++) {\n                if (!Arrays.equals(values.get(i), m.values.get(i)))\n                    return false;\n            }\n            return true;\n        }\n    }\n    return false;\n}", "code_comment": NaN, "code_no_comment": "public boolean equals(Mutation m) {\n    serialize();\n    m.serialize();\n    if (Arrays.equals(row, m.row) && entries == m.entries && Arrays.equals(data, m.data)) {\n        if (values == null && m.values == null)\n            return true;\n        if (values != null && m.values != null && values.size() == m.values.size()) {\n            for (int i = 0; i < values.size(); i++) {\n                if (!Arrays.equals(values.get(i), m.values.get(i)))\n                    return false;\n            }\n            return true;\n        }\n    }\n    return false;\n}", "lc": 0.09090909090909091, "pi": 1.2551020408163267, "ma": 0.3333333333333333, "nbd": 0.5, "ml": 1.75, "d": 1.503707365299061, "mi": -0.15887582449096668, "fo": 0.3333333333333333, "r": -0.028571428571428574, "e": 1.126991061371161}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2219_f2740ce1", "label": 1, "code": "@Override\npublic Cursor query(IndexPlan plan, NodeState root) {\n    LOG.debug(\"query(IndexPlan, NodeState)\");\n    LOG.debug(\"query() - plan: {}\", plan);\n    LOG.debug(\"query() - rootState: {}\", root);\n    Filter filter = plan.getFilter();\n    List<OrderEntry> sortOrder = plan.getSortOrder();\n    String pathPrefix = plan.getPathPrefix();\n    Iterable<String> paths = null;\n    OrderedContentMirrorStoreStrategy strategy = OrderedPropertyIndexLookup.getStrategy(plan.getDefinition());\n    int depth = 1;\n    PropertyRestriction pr = plan.getPropertyRestriction();\n    if (pr != null) {\n        String propertyName = PathUtils.getName(pr.propertyName);\n        depth = PathUtils.getDepth(propertyName);\n        paths = strategy.query(plan.getFilter(), propertyName, plan.getDefinition(), pr, pathPrefix);\n    }\n    if (paths == null && sortOrder != null && !sortOrder.isEmpty()) {\n        // we could be here if we have a query where the ORDER BY makes us play it.\n        for (OrderEntry oe : sortOrder) {\n            String propertyName = PathUtils.getName(oe.getPropertyName());\n            depth = PathUtils.getDepth(oe.getPropertyName());\n            paths = strategy.query(plan.getFilter(), propertyName, plan.getDefinition(), new PropertyRestriction(), pathPrefix);\n        }\n    }\n    if (paths == null) {\n        // if still here then something went wrong.\n        throw new IllegalStateException(\"OrderedPropertyIndex index is used even when no index is available for filter \" + filter);\n    }\n    Cursor cursor = Cursors.newPathCursor(paths, filter.getQueryEngineSettings());\n    if (depth > 1) {\n        cursor = Cursors.newAncestorCursor(cursor, depth - 1, filter.getQueryEngineSettings());\n    }\n    return cursor;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Cursor query(IndexPlan plan, NodeState root) {\n    LOG.debug(\"query(IndexPlan, NodeState)\");\n    LOG.debug(\"query() - plan: {}\", plan);\n    LOG.debug(\"query() - rootState: {}\", root);\n    Filter filter = plan.getFilter();\n    List<OrderEntry> sortOrder = plan.getSortOrder();\n    String pathPrefix = plan.getPathPrefix();\n    Iterable<String> paths = null;\n    OrderedContentMirrorStoreStrategy strategy = OrderedPropertyIndexLookup.getStrategy(plan.getDefinition());\n    int depth = 1;\n    PropertyRestriction pr = plan.getPropertyRestriction();\n    if (pr != null) {\n        String propertyName = PathUtils.getName(pr.propertyName);\n        depth = PathUtils.getDepth(propertyName);\n        paths = strategy.query(plan.getFilter(), propertyName, plan.getDefinition(), pr, pathPrefix);\n    }\n    if (paths == null && sortOrder != null && !sortOrder.isEmpty()) {\n                for (OrderEntry oe : sortOrder) {\n            String propertyName = PathUtils.getName(oe.getPropertyName());\n            depth = PathUtils.getDepth(oe.getPropertyName());\n            paths = strategy.query(plan.getFilter(), propertyName, plan.getDefinition(), new PropertyRestriction(), pathPrefix);\n        }\n    }\n    if (paths == null) {\n                throw new IllegalStateException(\"OrderedPropertyIndex index is used even when no index is available for filter \" + filter);\n    }\n    Cursor cursor = Cursors.newPathCursor(paths, filter.getQueryEngineSettings());\n    if (depth > 1) {\n        cursor = Cursors.newAncestorCursor(cursor, depth - 1, filter.getQueryEngineSettings());\n    }\n    return cursor;\n}", "lc": 0.8636363636363636, "pi": 0.005102040816326422, "ma": 0.5, "nbd": 0.0, "ml": 0.5, "d": 1.5650024715768662, "mi": -0.6521365070260974, "fo": 1.6666666666666667, "r": -0.028571428571428574, "e": 3.4896415554156444}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1103_a6f96306", "label": 1, "code": "/**\n * {@inheritDoc}\n */\npublic Optimum optimize(final LeastSquaresProblem lsp) {\n    // create local evaluation and iteration counts\n    final Incrementor evaluationCounter = lsp.getEvaluationCounter();\n    final Incrementor iterationCounter = lsp.getIterationCounter();\n    final ConvergenceChecker<Evaluation> checker = lsp.getConvergenceChecker();\n    // Computation will be useless without a checker (see \"for-loop\").\n    if (checker == null) {\n        throw new NullArgumentException();\n    }\n    final int nC = lsp.getParameterSize();\n    final RealVector currentPoint = lsp.getStart();\n    // iterate until convergence is reached\n    Evaluation current = null;\n    while (true) {\n        iterationCounter.incrementCount();\n        // evaluate the objective function and its jacobian\n        Evaluation previous = current;\n        // Value of the objective function at \"currentPoint\".\n        evaluationCounter.incrementCount();\n        current = lsp.evaluate(currentPoint);\n        final RealVector currentResiduals = current.getResiduals();\n        final RealMatrix weightedJacobian = current.getJacobian();\n        // Check convergence.\n        if (previous != null) {\n            if (checker.converged(iterationCounter.getCount(), previous, current)) {\n                return new OptimumImpl(current, evaluationCounter.getCount(), iterationCounter.getCount());\n            }\n        }\n        // solve the linearized least squares problem\n        final RealVector dX = this.decomposition.solve(weightedJacobian, currentResiduals);\n        // update the estimated parameters\n        for (int i = 0; i < nC; ++i) {\n            currentPoint.setEntry(i, currentPoint.getEntry(i) + dX.getEntry(i));\n        }\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public Optimum optimize(final LeastSquaresProblem lsp) {\n        final Incrementor evaluationCounter = lsp.getEvaluationCounter();\n    final Incrementor iterationCounter = lsp.getIterationCounter();\n    final ConvergenceChecker<Evaluation> checker = lsp.getConvergenceChecker();\n        if (checker == null) {\n        throw new NullArgumentException();\n    }\n    final int nC = lsp.getParameterSize();\n    final RealVector currentPoint = lsp.getStart();\n        Evaluation current = null;\n    while (true) {\n        iterationCounter.incrementCount();\n                Evaluation previous = current;\n                evaluationCounter.incrementCount();\n        current = lsp.evaluate(currentPoint);\n        final RealVector currentResiduals = current.getResiduals();\n        final RealMatrix weightedJacobian = current.getJacobian();\n                if (previous != null) {\n            if (checker.converged(iterationCounter.getCount(), previous, current)) {\n                return new OptimumImpl(current, evaluationCounter.getCount(), iterationCounter.getCount());\n            }\n        }\n                final RealVector dX = this.decomposition.solve(weightedJacobian, currentResiduals);\n                for (int i = 0; i < nC; ++i) {\n            currentPoint.setEntry(i, currentPoint.getEntry(i) + dX.getEntry(i));\n        }\n    }\n}", "lc": 0.6363636363636364, "pi": 0.27040816326530603, "ma": 0.5, "nbd": 0.5, "ml": 0.5833333333333334, "d": 0.8492338111715275, "mi": -0.5124749067966736, "fo": 1.0, "r": -0.028571428571428574, "e": 1.345008801572719}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5261_55c2e2d8", "label": 1, "code": "public synchronized BlockingQueue<Exchange> getQueue() {\n    if (queue == null) {\n        if (size > 0) {\n            queue = new LinkedBlockingQueue<Exchange>(size);\n        } else {\n            queue = new LinkedBlockingQueue<Exchange>();\n        }\n    }\n    return queue;\n}", "code_comment": NaN, "code_no_comment": "public synchronized BlockingQueue<Exchange> getQueue() {\n    if (queue == null) {\n        if (size > 0) {\n            queue = new LinkedBlockingQueue<Exchange>(size);\n        } else {\n            queue = new LinkedBlockingQueue<Exchange>();\n        }\n    }\n    return queue;\n}", "lc": -0.18181818181818182, "pi": 0.5510204081632651, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.028670291646070156, "mi": 0.30054488098652155, "fo": -0.5, "r": 0.5142857142857143, "e": -0.10963204714730534}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5114_518c933b", "label": 1, "code": "/**\n *  Stringizes this url\n *\n *  @param mode\n *             {@link StringMode} that determins how to stringize the url\n *  @param charset\n *             charset\n *  @return sringized version of this url\n */\npublic String toString(StringMode mode, Charset charset) {\n    StringBuilder result = new StringBuilder();\n    final String path = getPath(charset);\n    if (StringMode.FULL == mode) {\n        if (Strings.isEmpty(host)) {\n            throw new IllegalStateException(\"Cannot render this url in \" + StringMode.FULL.name() + \" mode because it does not have a host set.\");\n        }\n        if (Strings.isEmpty(protocol) == false) {\n            result.append(protocol);\n            result.append(\"://\");\n        } else if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false) {\n            result.append(\"//\");\n        }\n        result.append(host);\n        if (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false) {\n            result.append(':');\n            result.append(port);\n        }\n        if (path.contains(\"..\")) {\n            throw new IllegalStateException(\"Cannot render this url in \" + StringMode.FULL.name() + \" mode because it has a `..` segment: \" + toString());\n        }\n        if (!path.startsWith(\"/\")) {\n            result.append('/');\n        }\n    }\n    result.append(path);\n    result.append(getQueryString(charset));\n    return result.toString();\n}", "code_comment": "/**\n *  Stringizes this url\n *\n *  @param mode\n *             {@link StringMode} that determins how to stringize the url\n *  @param charset\n *             charset\n *  @return sringized version of this url\n */\n", "code_no_comment": "public String toString(StringMode mode, Charset charset) {\n    StringBuilder result = new StringBuilder();\n    final String path = getPath(charset);\n    if (StringMode.FULL == mode) {\n        if (Strings.isEmpty(host)) {\n            throw new IllegalStateException(\"Cannot render this url in \" + StringMode.FULL.name() + \" mode because it does not have a host set.\");\n        }\n        if (Strings.isEmpty(protocol) == false) {\n            result.append(protocol);\n            result.append(\"://\");\n        } else if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false) {\n            result.append(\"//\");\n        }\n        result.append(host);\n        if (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false) {\n            result.append(':');\n            result.append(port);\n        }\n        if (path.contains(\"..\")) {\n            throw new IllegalStateException(\"Cannot render this url in \" + StringMode.FULL.name() + \" mode because it has a `..` segment: \" + toString());\n        }\n        if (!path.startsWith(\"/\")) {\n            result.append('/');\n        }\n    }\n    result.append(path);\n    result.append(getQueryString(charset));\n    return result.toString();\n}", "lc": 0.6818181818181818, "pi": 0.2653061224489796, "ma": 1.0, "nbd": 0.5, "ml": 1.1666666666666667, "d": 1.0944142362827487, "mi": -0.538571838256381, "fo": 1.4166666666666667, "r": -0.028571428571428574, "e": 1.5298075646412341}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2427_e6d4f9a6", "label": 1, "code": "@Override\npublic String toString() {\n    StringBuilder buff = new StringBuilder();\n    buff.append(s1).append(\" union \").append(s2);\n    // order by ...\n    if (orderList != null && !orderList.isEmpty()) {\n        buff.append(\" order by \");\n        for (int i = 0; i < orderList.size(); i++) {\n            if (i > 0) {\n                buff.append(\", \");\n            }\n            buff.append(orderList.get(i));\n        }\n    }\n    // leave original xpath string as a comment\n    if (xpathQuery != null) {\n        buff.append(\" /* xpath: \");\n        buff.append(xpathQuery);\n        buff.append(\" */\");\n    }\n    return buff.toString();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic String toString() {\n    StringBuilder buff = new StringBuilder();\n    buff.append(s1).append(\" union \").append(s2);\n        if (orderList != null && !orderList.isEmpty()) {\n        buff.append(\" order by \");\n        for (int i = 0; i < orderList.size(); i++) {\n            if (i > 0) {\n                buff.append(\", \");\n            }\n            buff.append(orderList.get(i));\n        }\n    }\n        if (xpathQuery != null) {\n        buff.append(\" /* xpath: \");\n        buff.append(xpathQuery);\n        buff.append(\" */\");\n    }\n    return buff.toString();\n}", "lc": 0.2727272727272727, "pi": 0.6377551020408161, "ma": 0.16666666666666666, "nbd": 0.5, "ml": 0.4166666666666667, "d": 0.9678695007414733, "mi": -0.24118153140235157, "fo": 0.5833333333333334, "r": 0.05714285714285714, "e": 0.6727699470192435}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3617_7ae109a6", "label": 1, "code": "/*\n\t * TODO: simplify the code below. See WICKET-3347\n\t */\n@Override\npublic void respond(RequestCycle requestCycle) {\n    Url currentUrl = requestCycle.getUrlRenderer().getBaseUrl();\n    Url targetUrl = requestCycle.mapUrlFor(getRenderPageRequestHandler());\n    // \n    // the code below is little hairy but we have to handle 3 redirect policies,\n    // 3 rendering strategies and two kind of requests (ajax and normal)\n    // \n    // try to get an already rendered buffered response for current URL\n    BufferedWebResponse bufferedResponse = getAndRemoveBufferedResponse(currentUrl);\n    boolean isAjax = isAjax(requestCycle);\n    boolean shouldPreserveClientUrl = ((WebRequest) requestCycle.getRequest()).shouldPreserveClientUrl();\n    if (bufferedResponse != null) {\n        logger.warn(\"The Buffered response should be handled by BufferedResponseRequestHandler\");\n        // if there is saved response for this URL render it\n        bufferedResponse.writeTo((WebResponse) requestCycle.getResponse());\n    } else if (// \n    getRedirectPolicy() == RedirectPolicy.NEVER_REDIRECT || isOnePassRender() || (// \n    !isAjax && // \n    (targetUrl.equals(currentUrl) && !getPageProvider().isNewPageInstance() && !getPage().isPageStateless()) || // \n    (targetUrl.equals(currentUrl) && isRedirectToRender())) || // \n    shouldPreserveClientUrl) {\n        // if the policy is never to redirect\n        // or one pass render mode is on\n        // or the targetUrl matches current url and the page is not stateless\n        // or the targetUrl matches current url, page is stateless but it's redirect-to-render\n        // or the request determines that the current url should be preserved\n        // just render the page\n        BufferedWebResponse response = renderPage(currentUrl, requestCycle);\n        if (response != null) {\n            response.writeTo((WebResponse) requestCycle.getResponse());\n        }\n    } else if (// \n    (!targetUrl.equals(currentUrl) && getRedirectPolicy() == RedirectPolicy.ALWAYS_REDIRECT) || // \n    isRedirectToRender() || (isAjax && targetUrl.equals(currentUrl))) {\n        // if target URL is different\n        // and render policy is always-redirect or it's redirect-to-render\n        redirectTo(targetUrl, requestCycle);\n    } else if (// \n    !targetUrl.equals(currentUrl) && (getPageProvider().isNewPageInstance() || (isSessionTemporary() && getPage().isPageStateless()))) {\n        // if target URL is different and session is temporary and page is stateless\n        // this is special case when page is stateless but there is no session so we can't\n        // render it to buffer\n        // alternatively if URLs are different and we have a page class and not an instance we\n        // can redirect to the url which will instantiate the instance of us\n        // note: if we had session here we would render the page to buffer and then redirect to\n        // URL generated *after* page has been rendered (the statelessness may change during\n        // render). this would save one redirect because now we have to render to URL generated\n        // *before* page is rendered, render the page, get URL after render and if the URL is\n        // different (meaning page is not stateless), save the buffer and redirect again (which\n        // is pretty much what the next step does)\n        redirectTo(targetUrl, requestCycle);\n    } else if (isRedirectToBuffer()) {\n        // redirect to buffer\n        BufferedWebResponse response = renderPage(targetUrl, requestCycle);\n        if (response == null) {\n            return;\n        }\n        // check if the url hasn't changed after page has been rendered\n        // (i.e. the stateless flag might have changed which could result in different page url)\n        Url targetUrl2 = requestCycle.mapUrlFor(getRenderPageRequestHandler());\n        if (targetUrl.getSegments().equals(targetUrl2.getSegments()) == false) {\n            // the amount of segments is different - generated relative URLs will not work, we\n            // need to rerender the page. This shouldn't happen, but in theory it can - with\n            // RequestHandlerEncoders that produce different URLs with different amount of\n            // segments for stateless and stateful pages\n            response = renderPage(targetUrl2, requestCycle);\n        }\n        if (currentUrl.equals(targetUrl2)) {\n            // no need to redirect when both urls are exactly the same\n            response.writeTo((WebResponse) requestCycle.getResponse());\n        } else // if page is still stateless after render\n        if (getPage().isPageStateless() && !enableRedirectForStatelessPage()) {\n            // we don't want the redirect to happen for stateless page\n            // example:\n            // when a normal mounted stateful page is hit at /mount/point\n            // wicket renders the page to buffer and redirects to /mount/point?12\n            // but for stateless page the redirect is not necessary\n            // also for listener interface on stateful page we want to redirect\n            // after the listener is invoked, but on stateless page the user\n            // must ask for redirect explicitly\n            response.writeTo((WebResponse) requestCycle.getResponse());\n        } else {\n            storeBufferedResponse(targetUrl2, response);\n            redirectTo(targetUrl2, requestCycle);\n        }\n    } else {\n        throw new IllegalStateException(\"Unknown RenderStrategy.\");\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void respond(RequestCycle requestCycle) {\n    Url currentUrl = requestCycle.getUrlRenderer().getBaseUrl();\n    Url targetUrl = requestCycle.mapUrlFor(getRenderPageRequestHandler());\n                        BufferedWebResponse bufferedResponse = getAndRemoveBufferedResponse(currentUrl);\n    boolean isAjax = isAjax(requestCycle);\n    boolean shouldPreserveClientUrl = ((WebRequest) requestCycle.getRequest()).shouldPreserveClientUrl();\n    if (bufferedResponse != null) {\n        logger.warn(\"The Buffered response should be handled by BufferedResponseRequestHandler\");\n                bufferedResponse.writeTo((WebResponse) requestCycle.getResponse());\n    } else if (    getRedirectPolicy() == RedirectPolicy.NEVER_REDIRECT || isOnePassRender() || (    !isAjax &&     (targetUrl.equals(currentUrl) && !getPageProvider().isNewPageInstance() && !getPage().isPageStateless()) ||     (targetUrl.equals(currentUrl) && isRedirectToRender())) ||     shouldPreserveClientUrl) {\n                                                        BufferedWebResponse response = renderPage(currentUrl, requestCycle);\n        if (response != null) {\n            response.writeTo((WebResponse) requestCycle.getResponse());\n        }\n    } else if (    (!targetUrl.equals(currentUrl) && getRedirectPolicy() == RedirectPolicy.ALWAYS_REDIRECT) ||     isRedirectToRender() || (isAjax && targetUrl.equals(currentUrl))) {\n                        redirectTo(targetUrl, requestCycle);\n    } else if (    !targetUrl.equals(currentUrl) && (getPageProvider().isNewPageInstance() || (isSessionTemporary() && getPage().isPageStateless()))) {\n                                                                                                redirectTo(targetUrl, requestCycle);\n    } else if (isRedirectToBuffer()) {\n                BufferedWebResponse response = renderPage(targetUrl, requestCycle);\n        if (response == null) {\n            return;\n        }\n                        Url targetUrl2 = requestCycle.mapUrlFor(getRenderPageRequestHandler());\n        if (targetUrl.getSegments().equals(targetUrl2.getSegments()) == false) {\n                                                            response = renderPage(targetUrl2, requestCycle);\n        }\n        if (currentUrl.equals(targetUrl2)) {\n                        response.writeTo((WebResponse) requestCycle.getResponse());\n        } else         if (getPage().isPageStateless() && !enableRedirectForStatelessPage()) {\n                                                                                                            response.writeTo((WebResponse) requestCycle.getResponse());\n        } else {\n            storeBufferedResponse(targetUrl2, response);\n            redirectTo(targetUrl2, requestCycle);\n        }\n    } else {\n        throw new IllegalStateException(\"Unknown RenderStrategy.\");\n    }\n}", "lc": 1.5909090909090908, "pi": 0.09693877551020405, "ma": 1.3333333333333333, "nbd": 2.5, "ml": 3.25, "d": 1.2901631240731588, "mi": -0.8901634642959568, "fo": 3.9166666666666665, "r": -0.028571428571428574, "e": 3.4551076961294496}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3324_5f863af6", "label": 1, "code": "@Override\npublic boolean isGranted(long repositoryPermissions) {\n    return hasPermissions(getEntryIterator(new EntryPredicate()), repositoryPermissions, null);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean isGranted(long repositoryPermissions) {\n    return hasPermissions(getEntryIterator(new EntryPredicate()), repositoryPermissions, null);\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8850014338973328, "fo": -0.3333333333333333, "r": 0.3428571428571429, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 171, "label": 2, "code": "/**\n * Determines whether a qualified name is inferred.\n * NOTE(nicksantos): Determining whether a property is declared or not\n * is really really obnoxious.\n *\n * The problem is that there are two (equally valid) coding styles:\n *\n * (function() {\n *   /* The authoritative definition of goog.bar. /\n *   goog.bar = function() {};\n * })();\n *\n * function f() {\n *   goog.bar();\n *   /* Reset goog.bar to a no-op. /\n *   goog.bar = function() {};\n * }\n *\n * In a dynamic language with first-class functions, it's very difficult\n * to know which one the user intended without looking at lots of\n * contextual information (the second example demonstrates a small case\n * of this, but there are some really pathological cases as well).\n *\n * The current algorithm checks if either the declaration has\n * JsDoc type information, or @const with a known type,\n * or a function literal with a name we haven't seen before.\n */\nprivate boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n    // Prototype sets are always declared.\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n            return false;\n        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n            // Functions assigned in conditional blocks are inferred.\n            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                    return true;\n                }\n            }\n            // Check if this is assigned in an inner scope.\n            // Functions assigned in inner scopes are inferred.\n            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false;\n            }\n        }\n    }\n    return inferred;\n}", "code_comment": "/**\n * Determines whether a qualified name is inferred.\n * NOTE(nicksantos): Determining whether a property is declared or not\n * is really really obnoxious.\n *\n * The problem is that there are two (equally valid) coding styles:\n *\n * (function() {\n *   /* The authoritative definition of goog.bar. /\n *   goog.bar = function() {};\n * })();\n *\n * function f() {\n *   goog.bar();\n *   /* Reset goog.bar to a no-op. /\n *   goog.bar = function() {};\n * }\n *\n * In a dynamic language with first-class functions, it's very difficult\n * to know which one the user intended without looking at lots of\n * contextual information (the second example demonstrates a small case\n * of this, but there are some really pathological cases as well).\n *\n * The current algorithm checks if either the declaration has\n * JsDoc type information, or @const with a known type,\n * or a function literal with a name we haven't seen before.\n */\n", "code_no_comment": "private boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n        boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n            return false;\n        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n                        for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                    return true;\n                }\n            }\n                                    AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false;\n            }\n        }\n    }\n    return inferred;\n}", "lc": 0.5, "pi": 1.1224489795918366, "ma": 0.8333333333333334, "nbd": 1.5, "ml": 1.8333333333333333, "d": 0.8709836875926843, "mi": -0.4654430742758821, "fo": 0.9166666666666666, "r": -0.028571428571428574, "e": 1.298473965761668}
{"project_name": "Csv", "project_version": 5, "label": 1, "code": "/**\n * Outputs the record separator.\n *\n * @throws IOException\n *             If an I/O error occurs\n */\npublic void println() throws IOException {\n    final String recordSeparator = format.getRecordSeparator();\n    out.append(recordSeparator);\n    newRecord = true;\n}", "code_comment": "/**\n * Outputs the record separator.\n *\n * @throws IOException\n *             If an I/O error occurs\n */\n", "code_no_comment": "public void println() throws IOException {\n    final String recordSeparator = format.getRecordSeparator();\n    out.append(recordSeparator);\n    newRecord = true;\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.6888442787496416, "fo": -0.3333333333333333, "r": 2.8000000000000003, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-4029_5ca779a0", "label": 1, "code": "@Override\npublic int hashCode() {\n    return toThrift(false).hashCode();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic int hashCode() {\n    return toThrift(false).hashCode();\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9836535704043596, "fo": -0.3333333333333333, "r": 1.7714285714285716, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1117_f4c926ea", "label": 1, "code": "/**\n * Create a list of hyperplanes representing the boundary of a box.\n * @param xMin low bound along the x direction\n * @param xMax high bound along the x direction\n * @param yMin low bound along the y direction\n * @param yMax high bound along the y direction\n * @param tolerance tolerance below which points are considered identical\n * @return boundary of the box\n */\nprivate static Line[] boxBoundary(final double xMin, final double xMax, final double yMin, final double yMax, final double tolerance) {\n    final Vector2D minMin = new Vector2D(xMin, yMin);\n    final Vector2D minMax = new Vector2D(xMin, yMax);\n    final Vector2D maxMin = new Vector2D(xMax, yMin);\n    final Vector2D maxMax = new Vector2D(xMax, yMax);\n    return new Line[] { new Line(minMin, maxMin, tolerance), new Line(maxMin, maxMax, tolerance), new Line(maxMax, minMax, tolerance), new Line(minMax, minMin, tolerance) };\n}", "code_comment": "/**\n * Create a list of hyperplanes representing the boundary of a box.\n * @param xMin low bound along the x direction\n * @param xMax high bound along the x direction\n * @param yMin low bound along the y direction\n * @param yMax high bound along the y direction\n * @param tolerance tolerance below which points are considered identical\n * @return boundary of the box\n */\n", "code_no_comment": "private static Line[] boxBoundary(final double xMin, final double xMax, final double yMin, final double yMax, final double tolerance) {\n    final Vector2D minMin = new Vector2D(xMin, yMin);\n    final Vector2D minMax = new Vector2D(xMin, yMax);\n    final Vector2D maxMin = new Vector2D(xMax, yMin);\n    final Vector2D maxMax = new Vector2D(xMax, yMax);\n    return new Line[] { new Line(minMin, maxMin, tolerance), new Line(maxMin, maxMax, tolerance), new Line(maxMax, minMax, tolerance), new Line(minMax, minMin, tolerance) };\n}", "lc": -0.3181818181818182, "pi": -0.6173469387755102, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.3369658732434759, "fo": -0.5, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1505_b082fc1e", "label": 1, "code": "synchronized void addMutation(Mutation m) {\n    long now = System.currentTimeMillis();\n    mutationCount++;\n    for (ColumnUpdate u : m.getUpdates()) {\n        Key key = new Key(m.getRow(), 0, m.getRow().length, u.getColumnFamily(), 0, u.getColumnFamily().length, u.getColumnQualifier(), 0, u.getColumnQualifier().length, u.getColumnVisibility(), 0, u.getColumnVisibility().length, u.getTimestamp());\n        if (u.isDeleted())\n            key.setDeleted(true);\n        if (!u.hasTimestamp())\n            if (timeType.equals(TimeType.LOGICAL))\n                key.setTimestamp(mutationCount);\n            else\n                key.setTimestamp(now);\n        table.put(new MockMemKey(key, mutationCount), new Value(u.getValue()));\n    }\n}", "code_comment": NaN, "code_no_comment": "synchronized void addMutation(Mutation m) {\n    long now = System.currentTimeMillis();\n    mutationCount++;\n    for (ColumnUpdate u : m.getUpdates()) {\n        Key key = new Key(m.getRow(), 0, m.getRow().length, u.getColumnFamily(), 0, u.getColumnFamily().length, u.getColumnQualifier(), 0, u.getColumnQualifier().length, u.getColumnVisibility(), 0, u.getColumnVisibility().length, u.getTimestamp());\n        if (u.isDeleted())\n            key.setDeleted(true);\n        if (!u.hasTimestamp())\n            if (timeType.equals(TimeType.LOGICAL))\n                key.setTimestamp(mutationCount);\n            else\n                key.setTimestamp(now);\n        table.put(new MockMemKey(key, mutationCount), new Value(u.getValue()));\n    }\n}", "lc": 0.045454545454545456, "pi": 0.9846938775510206, "ma": 0.16666666666666666, "nbd": -0.5, "ml": 0.08333333333333333, "d": 0.0029658922392486655, "mi": -0.14367651276168644, "fo": 1.0833333333333333, "r": -0.028571428571428574, "e": 0.13895349086221148}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-369_f4a4464b", "label": 3, "code": "/**\n * {@inheritDoc}\n */\npublic double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n    return solve(min, max);\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n    return solve(min, max);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9675939202753088, "fo": -0.4166666666666667, "r": 2.142857142857143, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5432_93935780", "label": 1, "code": "public Producer createProducer() throws Exception {\n    return new SedaProducer(this, getQueue(), getWaitForTaskToComplete(), getTimeout(), isBlockWhenFull());\n}", "code_comment": NaN, "code_no_comment": "public Producer createProducer() throws Exception {\n    return new SedaProducer(this, getQueue(), getWaitForTaskToComplete(), getTimeout(), isBlockWhenFull());\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.0106108402638376, "fo": -0.16666666666666666, "r": 0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7795_19b2aa31", "label": 1, "code": "public void done(boolean doneSync) {\n    try {\n        if (!doneSync) {\n            // when done asynchronously then restore information from previous thread\n            if (breadcrumbId != null) {\n                MDC.put(MDC_BREADCRUMB_ID, breadcrumbId);\n            }\n            if (exchangeId != null) {\n                MDC.put(MDC_EXCHANGE_ID, exchangeId);\n            }\n            if (messageId != null) {\n                MDC.put(MDC_MESSAGE_ID, messageId);\n            }\n            if (correlationId != null) {\n                MDC.put(MDC_CORRELATION_ID, correlationId);\n            }\n            if (routeId != null) {\n                MDC.put(MDC_ROUTE_ID, routeId);\n            }\n            if (camelContextId != null) {\n                MDC.put(MDC_CAMEL_CONTEXT_ID, camelContextId);\n            }\n        }\n    } finally {\n        // muse ensure delegate is invoked\n        delegate.done(doneSync);\n    }\n}", "code_comment": NaN, "code_no_comment": "public void done(boolean doneSync) {\n    try {\n        if (!doneSync) {\n                        if (breadcrumbId != null) {\n                MDC.put(MDC_BREADCRUMB_ID, breadcrumbId);\n            }\n            if (exchangeId != null) {\n                MDC.put(MDC_EXCHANGE_ID, exchangeId);\n            }\n            if (messageId != null) {\n                MDC.put(MDC_MESSAGE_ID, messageId);\n            }\n            if (correlationId != null) {\n                MDC.put(MDC_CORRELATION_ID, correlationId);\n            }\n            if (routeId != null) {\n                MDC.put(MDC_ROUTE_ID, routeId);\n            }\n            if (camelContextId != null) {\n                MDC.put(MDC_CAMEL_CONTEXT_ID, camelContextId);\n            }\n        }\n    } finally {\n                delegate.done(doneSync);\n    }\n}", "lc": 0.5454545454545454, "pi": 0.8571428571428572, "ma": 0.6666666666666666, "nbd": 0.5, "ml": 0.75, "d": 0.06623826000988631, "mi": -0.34327502150846007, "fo": 0.08333333333333333, "r": -0.028571428571428574, "e": 0.04865063966661098}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_add180fb", "label": 1, "code": "/**\n * @deprecated since 1.4 {@link #attachIterator(String, IteratorSetting)}\n */\n@Override\npublic void addAggregators(String tableName, List<? extends PerColumnIteratorConfig> aggregators) throws AccumuloSecurityException, TableNotFoundException, AccumuloException {\n    acu.addAggregators(tableName, aggregators);\n}", "code_comment": "/**\n * @deprecated since 1.4 {@link #attachIterator(String, IteratorSetting)}\n */\n", "code_no_comment": "@Override\npublic void addAggregators(String tableName, List<? extends PerColumnIteratorConfig> aggregators) throws AccumuloSecurityException, TableNotFoundException, AccumuloException {\n    acu.addAggregators(tableName, aggregators);\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7823343848580444, "fo": -0.4166666666666667, "r": 1.4285714285714286, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-4509_8e3450f4", "label": 1, "code": "public void process(Exchange exchange) throws Exception {\n    ObjectHelper.notNull(dataFormat, \"dataFormat\");\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    Message in = exchange.getIn();\n    Object body = in.getBody();\n    // lets setup the out message before we invoke the dataFormat\n    // so that it can mutate it if necessary\n    Message out = exchange.getOut();\n    out.copyFrom(in);\n    dataFormat.marshal(exchange, body, buffer);\n    byte[] data = buffer.toByteArray();\n    out.setBody(data);\n}", "code_comment": NaN, "code_no_comment": "public void process(Exchange exchange) throws Exception {\n    ObjectHelper.notNull(dataFormat, \"dataFormat\");\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    Message in = exchange.getIn();\n    Object body = in.getBody();\n            Message out = exchange.getOut();\n    out.copyFrom(in);\n    dataFormat.marshal(exchange, body, buffer);\n    byte[] data = buffer.toByteArray();\n    out.setBody(data);\n}", "lc": -0.13636363636363635, "pi": -0.7551020408163265, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.1187266991683396, "fo": 0.16666666666666666, "r": 0.20000000000000004, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 144, "label": 2, "code": "FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) {\n    return new FunctionType(registry, null, null, new ArrowType(registry, call.parameters, newReturnType, inferred), typeOfThis, null, false, false);\n}", "code_comment": NaN, "code_no_comment": "FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) {\n    return new FunctionType(registry, null, null, new ArrowType(registry, call.parameters, newReturnType, inferred), typeOfThis, null, false, false);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8683682248351021, "fo": -0.5, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1008_0c20bfd8", "label": 1, "code": "/**\n * Scans for classes starting at the package provided and descending into subpackages.\n * Each class is offered up to the Test as it is discovered, and if the Test returns\n * true the class is retained.  Accumulated classes can be fetched by calling\n * {@link #getClasses()}.\n *\n * @param test an instance of {@link Test} that will be used to filter classes\n * @param packageName the name of the package from which to start scanning for\n *        classes, e.g. {@code net.sourceforge.stripes}\n */\npublic void findInPackage(final Test test, String packageName) {\n    packageName = packageName.replace('.', '/');\n    final ClassLoader loader = getClassLoader();\n    Enumeration<URL> urls;\n    try {\n        urls = loader.getResources(packageName);\n    } catch (final IOException ioe) {\n        LOGGER.warn(\"Could not read package: \" + packageName, ioe);\n        return;\n    }\n    while (urls.hasMoreElements()) {\n        try {\n            final URL url = urls.nextElement();\n            final String urlPath = extractPath(url);\n            LOGGER.info(\"Scanning for classes in [\" + urlPath + \"] matching criteria: \" + test);\n            // Check for a jar in a war in JBoss\n            if (VFSZIP.equals(url.getProtocol())) {\n                final String path = urlPath.substring(0, urlPath.length() - packageName.length() - 2);\n                final URL newURL = new URL(url.getProtocol(), url.getHost(), path);\n                @SuppressWarnings(\"resource\")\n                final JarInputStream stream = new JarInputStream(newURL.openStream());\n                try {\n                    loadImplementationsInJar(test, packageName, path, stream);\n                } finally {\n                    close(stream, newURL);\n                }\n            } else if (BUNDLE_RESOURCE.equals(url.getProtocol())) {\n                loadImplementationsInBundle(test, packageName);\n            } else {\n                final File file = new File(urlPath);\n                if (file.isDirectory()) {\n                    loadImplementationsInDirectory(test, packageName, file);\n                } else {\n                    loadImplementationsInJar(test, packageName, file);\n                }\n            }\n        } catch (final IOException ioe) {\n            LOGGER.warn(\"could not read entries\", ioe);\n        }\n    }\n}", "code_comment": "/**\n * Scans for classes starting at the package provided and descending into subpackages.\n * Each class is offered up to the Test as it is discovered, and if the Test returns\n * true the class is retained.  Accumulated classes can be fetched by calling\n * {@link #getClasses()}.\n *\n * @param test an instance of {@link Test} that will be used to filter classes\n * @param packageName the name of the package from which to start scanning for\n *        classes, e.g. {@code net.sourceforge.stripes}\n */\n", "code_no_comment": "public void findInPackage(final Test test, String packageName) {\n    packageName = packageName.replace('.', '/');\n    final ClassLoader loader = getClassLoader();\n    Enumeration<URL> urls;\n    try {\n        urls = loader.getResources(packageName);\n    } catch (final IOException ioe) {\n        LOGGER.warn(\"Could not read package: \" + packageName, ioe);\n        return;\n    }\n    while (urls.hasMoreElements()) {\n        try {\n            final URL url = urls.nextElement();\n            final String urlPath = extractPath(url);\n            LOGGER.info(\"Scanning for classes in [\" + urlPath + \"] matching criteria: \" + test);\n                        if (VFSZIP.equals(url.getProtocol())) {\n                final String path = urlPath.substring(0, urlPath.length() - packageName.length() - 2);\n                final URL newURL = new URL(url.getProtocol(), url.getHost(), path);\n                @SuppressWarnings(\"resource\")\n                final JarInputStream stream = new JarInputStream(newURL.openStream());\n                try {\n                    loadImplementationsInJar(test, packageName, path, stream);\n                } finally {\n                    close(stream, newURL);\n                }\n            } else if (BUNDLE_RESOURCE.equals(url.getProtocol())) {\n                loadImplementationsInBundle(test, packageName);\n            } else {\n                final File file = new File(urlPath);\n                if (file.isDirectory()) {\n                    loadImplementationsInDirectory(test, packageName, file);\n                } else {\n                    loadImplementationsInJar(test, packageName, file);\n                }\n            }\n        } catch (final IOException ioe) {\n            LOGGER.warn(\"could not read entries\", ioe);\n        }\n    }\n}", "lc": 1.1818181818181819, "pi": 1.3877551020408165, "ma": 0.5, "nbd": 1.5, "ml": 0.3333333333333333, "d": 0.022738507167572957, "mi": -0.7089188414109552, "fo": 1.5833333333333333, "r": -0.028571428571428574, "e": 0.44398473537461286}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1429_c2f5ca6c", "label": 1, "code": "@Override\npublic DocumentNodeState apply(String input) {\n    return getNode(input, readRevision);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic DocumentNodeState apply(String input) {\n    return getNode(input, readRevision);\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8850014338973328, "fo": -0.4166666666666667, "r": 1.657142857142857, "e": -0.16422749602751402}
{"project_name": "Math", "project_version": 64, "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\nprotected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n    // arrays shared with the other private methods\n    solvedCols = Math.min(rows, cols);\n    diagR = new double[cols];\n    jacNorm = new double[cols];\n    beta = new double[cols];\n    permutation = new int[cols];\n    lmDir = new double[cols];\n    // local point\n    double delta = 0;\n    double xNorm = 0;\n    double[] diag = new double[cols];\n    double[] oldX = new double[cols];\n    double[] oldRes = new double[rows];\n    double[] work1 = new double[cols];\n    double[] work2 = new double[cols];\n    double[] work3 = new double[cols];\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n        // compute Qt.res\n        qTy(residuals);\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n        if (firstIteration) {\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n        }\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4; ) {\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes = tmpVec;\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                    tmp = 0.1;\n                }\n                delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n            // tests for convergence.\n            // we use the vectorial convergence checker\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec = residuals;\n                residuals = oldRes;\n                oldRes = tmpVec;\n            }\n            if (checker == null) {\n                if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) {\n                    return current;\n                }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\n            }\n        }\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\nprotected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n        solvedCols = Math.min(rows, cols);\n    diagR = new double[cols];\n    jacNorm = new double[cols];\n    beta = new double[cols];\n    permutation = new int[cols];\n    lmDir = new double[cols];\n        double delta = 0;\n    double xNorm = 0;\n    double[] diag = new double[cols];\n    double[] oldX = new double[cols];\n    double[] oldRes = new double[rows];\n    double[] work1 = new double[cols];\n    double[] work2 = new double[cols];\n    double[] work3 = new double[cols];\n        updateResidualsAndCost();\n        lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n                VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n                qTy(residuals);\n                for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n        if (firstIteration) {\n                                    xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n                        delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n        }\n                double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n                        return current;\n        }\n                for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n                for (double ratio = 0; ratio < 1.0e-4; ) {\n                        for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes = tmpVec;\n                        determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n                        double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n                        if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n                        updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n                        double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n                        for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n                        ratio = (preRed == 0) ? 0 : (actRed / preRed);\n                        if (ratio <= 0.25) {\n                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                    tmp = 0.1;\n                }\n                delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n                        if (ratio >= 1.0e-4) {\n                                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n                                    } else {\n                                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec = residuals;\n                residuals = oldRes;\n                oldRes = tmpVec;\n            }\n            if (checker == null) {\n                if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) {\n                    return current;\n                }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n                        if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\n            }\n        }\n    }\n}", "lc": 6.590909090909091, "pi": 0.9438775510204083, "ma": 5.666666666666667, "nbd": 1.5, "ml": 5.25, "d": 7.0301532377656955, "mi": -1.821623171780901, "fo": 1.1666666666666667, "r": -0.028571428571428574, "e": 66.8449809620483}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3433_e76d23b0", "label": 3, "code": "/**\n * Returns an expression which converts the given expression to the given type the type\n * expression is evaluated to\n */\npublic static Expression convertToExpression(final Expression expression, final Expression type) {\n    return new ExpressionAdapter() {\n\n        public Object evaluate(Exchange exchange) {\n            return expression.evaluate(exchange, type.evaluate(exchange, Object.class).getClass());\n        }\n\n        @Override\n        public String toString() {\n            return \"\" + expression + \".convertToEvaluatedType(\" + type + \")\";\n        }\n    };\n}", "code_comment": "/**\n * Returns an expression which converts the given expression to the given type the type\n * expression is evaluated to\n */\n", "code_no_comment": "public static Expression convertToExpression(final Expression expression, final Expression type) {\n    return new ExpressionAdapter() {\n\n        public Object evaluate(Exchange exchange) {\n            return expression.evaluate(exchange, type.evaluate(exchange, Object.class).getClass());\n        }\n\n        @Override\n        public String toString() {\n            return \"\" + expression + \".convertToEvaluatedType(\" + type + \")\";\n        }\n    };\n}", "lc": -0.13636363636363635, "pi": 0.4591836734693877, "ma": -0.5, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.1915686836822482, "fo": -0.25, "r": 0.7999999999999999, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3897_94c6c575", "label": 1, "code": "@Nonnull\npublic String reset(@Nonnull String branchRevisionId, @Nonnull String ancestorRevisionId) throws DocumentStoreException {\n    RevisionVector branch = RevisionVector.fromString(branchRevisionId);\n    if (!branch.isBranch()) {\n        throw new DocumentStoreException(\"Not a branch revision: \" + branchRevisionId);\n    }\n    RevisionVector ancestor = RevisionVector.fromString(ancestorRevisionId);\n    if (!ancestor.isBranch()) {\n        throw new DocumentStoreException(\"Not a branch revision: \" + ancestorRevisionId);\n    }\n    try {\n        return nodeStore.reset(branch, ancestor, null).toString();\n    } catch (DocumentStoreException e) {\n        throw new DocumentStoreException(e);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Nonnull\npublic String reset(@Nonnull String branchRevisionId, @Nonnull String ancestorRevisionId) throws DocumentStoreException {\n    RevisionVector branch = RevisionVector.fromString(branchRevisionId);\n    if (!branch.isBranch()) {\n        throw new DocumentStoreException(\"Not a branch revision: \" + branchRevisionId);\n    }\n    RevisionVector ancestor = RevisionVector.fromString(ancestorRevisionId);\n    if (!ancestor.isBranch()) {\n        throw new DocumentStoreException(\"Not a branch revision: \" + ancestorRevisionId);\n    }\n    try {\n        return nodeStore.reset(branch, ancestor, null).toString();\n    } catch (DocumentStoreException e) {\n        throw new DocumentStoreException(e);\n    }\n}", "lc": 0.09090909090909091, "pi": -0.19897959183673475, "ma": 0.5, "nbd": -0.5, "ml": -0.08333333333333333, "d": 0.09589718240237279, "mi": -0.09951247490679667, "fo": 0.0, "r": 0.028571428571428574, "e": 0.04559685798844445}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7586_1f92fa42", "label": 3, "code": "@ManagedAttribute(description = \"Message History\")\nBoolean getMessageHistory();", "code_comment": NaN, "code_no_comment": "@ManagedAttribute(description = \"Message History\")\nBoolean getMessageHistory();", "lc": -0.5454545454545454, "pi": -1.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.2899340407226842, "fo": -0.5, "r": 2.8000000000000003, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-621_00b4b8a0", "label": 1, "code": "private boolean isDisconnected() {\n    if (isRoot()) {\n        return false;\n    }\n    if (parent.nodeBuilder == null) {\n        return false;\n    }\n    if (!parent.nodeBuilder.isConnected()) {\n        return true;\n    }\n    return !getNodeBuilder().isConnected();\n}", "code_comment": NaN, "code_no_comment": "private boolean isDisconnected() {\n    if (isRoot()) {\n        return false;\n    }\n    if (parent.nodeBuilder == null) {\n        return false;\n    }\n    if (!parent.nodeBuilder.isConnected()) {\n        return true;\n    }\n    return !getNodeBuilder().isConnected();\n}", "lc": -0.09090909090909091, "pi": -0.2346938775510204, "ma": 0.0, "nbd": -0.5, "ml": 0.08333333333333333, "d": -0.10380622837370242, "mi": 0.23343848580441648, "fo": -0.16666666666666666, "r": 0.28571428571428575, "e": -0.1276849079796643}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6593_7f8a295a", "label": 3, "code": "/**\n * Returns some descriptive text to describe this node\n */\npublic String getLabel() {\n    String language = getExpression();\n    if (ObjectHelper.isEmpty(language)) {\n        Predicate predicate = getPredicate();\n        if (predicate != null) {\n            return predicate.toString();\n        }\n        Expression expressionValue = getExpressionValue();\n        if (expressionValue != null) {\n            return expressionValue.toString();\n        }\n    } else {\n        return language;\n    }\n    return \"\";\n}", "code_comment": "/**\n * Returns some descriptive text to describe this node\n */\n", "code_no_comment": "public String getLabel() {\n    String language = getExpression();\n    if (ObjectHelper.isEmpty(language)) {\n        Predicate predicate = getPredicate();\n        if (predicate != null) {\n            return predicate.toString();\n        }\n        Expression expressionValue = getExpressionValue();\n        if (expressionValue != null) {\n            return expressionValue.toString();\n        }\n    } else {\n        return language;\n    }\n    return \"\";\n}", "lc": 0.09090909090909091, "pi": 0.22448979591836732, "ma": 0.0, "nbd": 0.0, "ml": 0.16666666666666666, "d": -0.07217004448838356, "mi": -0.007456266131345144, "fo": 0.0, "r": 1.2, "e": -0.08050762160518415}
{"project_name": "Closure", "project_version": 155, "label": 2, "code": "/**\n * For each node, update the block stack and reference collection\n * as appropriate.\n */\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.NAME) {\n        Var v = t.getScope().getVar(n.getString());\n        if (v != null && varFilter.apply(v)) {\n            addReference(t, v, new Reference(n, parent, t, blockStack.peek()));\n        }\n    }\n    if (isBlockBoundary(n, parent)) {\n        blockStack.pop();\n    }\n}", "code_comment": "/**\n * For each node, update the block stack and reference collection\n * as appropriate.\n */\n", "code_no_comment": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.NAME) {\n        Var v = t.getScope().getVar(n.getString());\n        if (v != null && varFilter.apply(v)) {\n            addReference(t, v, new Reference(n, parent, t, blockStack.peek()));\n        }\n    }\n    if (isBlockBoundary(n, parent)) {\n        blockStack.pop();\n    }\n}", "lc": -0.13636363636363635, "pi": 0.26020408163265296, "ma": 0.0, "nbd": 0.0, "ml": 0.4166666666666667, "d": 0.24616905585763724, "mi": 0.09521078290794362, "fo": 0.25, "r": 0.17142857142857146, "e": 0.10961919813603677}
{"project_name": "Math", "project_version": 4, "label": 1, "code": "/**\n * Get the intersection of the instance and another sub-line.\n * <p>\n * This method is related to the {@link Line#intersection(Line)\n * intersection} method in the {@link Line Line} class, but in addition\n * to compute the point along infinite lines, it also checks the point\n * lies on both sub-line ranges.\n * </p>\n * @param subLine other sub-line which may intersect instance\n * @param includeEndPoints if true, endpoints are considered to belong to\n * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\n * are considered to not belong to instance (i.e. they are open sets) and intersection\n * occurring on endpoints lead to null being returned\n * @return the intersection point if there is one, null if the sub-lines don't intersect\n */\npublic Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {\n    // retrieve the underlying lines\n    Line line1 = (Line) getHyperplane();\n    Line line2 = (Line) subLine.getHyperplane();\n    // compute the intersection on infinite line\n    Vector2D v2D = line1.intersection(line2);\n    // check location of point with respect to first sub-line\n    Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n    // check location of point with respect to second sub-line\n    Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\n    if (includeEndPoints) {\n        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;\n    } else {\n        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;\n    }\n}", "code_comment": "/**\n * Get the intersection of the instance and another sub-line.\n * <p>\n * This method is related to the {@link Line#intersection(Line)\n * intersection} method in the {@link Line Line} class, but in addition\n * to compute the point along infinite lines, it also checks the point\n * lies on both sub-line ranges.\n * </p>\n * @param subLine other sub-line which may intersect instance\n * @param includeEndPoints if true, endpoints are considered to belong to\n * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\n * are considered to not belong to instance (i.e. they are open sets) and intersection\n * occurring on endpoints lead to null being returned\n * @return the intersection point if there is one, null if the sub-lines don't intersect\n */\n", "code_no_comment": "public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {\n        Line line1 = (Line) getHyperplane();\n    Line line2 = (Line) subLine.getHyperplane();\n        Vector2D v2D = line1.intersection(line2);\n        Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n        Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\n    if (includeEndPoints) {\n        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;\n    } else {\n        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;\n    }\n}", "lc": -0.09090909090909091, "pi": -0.3622448979591837, "ma": 0.0, "nbd": -0.5, "ml": 0.25, "d": 0.64755313890262, "mi": 0.0014338973329508797, "fo": 0.25, "r": -0.028571428571428574, "e": 0.47909251716413753}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2999_3bf07779", "label": 1, "code": "@Override\npublic void propertyChanged(PropertyState before, PropertyState after) {\n    markPropertyChanged(before.getName());\n    checkAggregates(before.getName());\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void propertyChanged(PropertyState before, PropertyState after) {\n    markPropertyChanged(before.getName());\n    checkAggregates(before.getName());\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7183825638084315, "fo": -0.16666666666666666, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "Cli", "project_version": 16, "label": 3, "code": "public void addOption(Option option) {\n    options.add(option);\n    nameToOption.put(option.getPreferredName(), option);\n    for (Iterator i = option.getTriggers().iterator(); i.hasNext(); ) {\n        nameToOption.put(i.next(), option);\n    }\n// ensure that all parent options are also added\n}", "code_comment": NaN, "code_no_comment": "public void addOption(Option option) {\n    options.add(option);\n    nameToOption.put(option.getPreferredName(), option);\n    for (Iterator i = option.getTriggers().iterator(); i.hasNext(); ) {\n        nameToOption.put(i.next(), option);\n    }\n}", "lc": -0.3181818181818182, "pi": -0.2346938775510204, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.3806228373702422, "mi": 0.4232864926871235, "fo": 0.16666666666666666, "r": 0.0, "e": -0.16422749602751402}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1640_8f321c72", "label": 1, "code": "/**\n *  Normalizes a path string.\n *\n *  @param path\n *         the path string to normalize\n *  @return the normalized path string\n */\nprivate String normalizePath(String path) {\n    // remove double slashes & backslashes\n    path = path.replace(\"//\", \"/\");\n    path = path.replace(\"\\\\\", \"/\");\n    return path;\n}", "code_comment": "/**\n *  Normalizes a path string.\n *\n *  @param path\n *         the path string to normalize\n *  @return the normalized path string\n */\n", "code_no_comment": "private String normalizePath(String path) {\n        path = path.replace(\"//\", \"/\");\n    path = path.replace(\"\\\\\", \"/\");\n    return path;\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.669916833954689, "fo": -0.3333333333333333, "r": 2.428571428571429, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-678_6c54045d", "label": 1, "code": "@Nonnull\nprivate MutableNodeState write(long newRevision, boolean reconnect) {\n    // make sure that all revision numbers up to the root gets updated\n    if (!isRoot()) {\n        checkState(reconnect || exists(), \"This node has been removed\");\n        parent.write(newRevision, reconnect);\n    }\n    if (writeState == null || revision != root.revision) {\n        // root never gets here since revision == root.revision\n        assert (!isRoot());\n        // The builder could have been reset, need to re-get base state\n        baseState = parent.getBaseState(name);\n        writeState = parent.getWriteState(name);\n        if (writeState == null) {\n            if (exists()) {\n                assert baseState != null;\n                writeState = new MutableNodeState(baseState);\n            } else {\n                writeState = new MutableNodeState(null);\n            }\n            // guaranteed by called parent.write()\n            assert parent.writeState != null;\n            parent.writeState.nodes.put(name, writeState);\n        }\n    }\n    revision = newRevision;\n    assert classInvariants();\n    assert writeState != null;\n    return writeState;\n}", "code_comment": NaN, "code_no_comment": "@Nonnull\nprivate MutableNodeState write(long newRevision, boolean reconnect) {\n        if (!isRoot()) {\n        checkState(reconnect || exists(), \"This node has been removed\");\n        parent.write(newRevision, reconnect);\n    }\n    if (writeState == null || revision != root.revision) {\n                assert (!isRoot());\n                baseState = parent.getBaseState(name);\n        writeState = parent.getWriteState(name);\n        if (writeState == null) {\n            if (exists()) {\n                assert baseState != null;\n                writeState = new MutableNodeState(baseState);\n            } else {\n                writeState = new MutableNodeState(null);\n            }\n                        assert parent.writeState != null;\n            parent.writeState.nodes.put(name, writeState);\n        }\n    }\n    revision = newRevision;\n    assert classInvariants();\n    assert writeState != null;\n    return writeState;\n}", "lc": 0.5454545454545454, "pi": 0.8826530612244898, "ma": 0.16666666666666666, "nbd": 0.5, "ml": 0.4166666666666667, "d": -0.3806228373702422, "mi": 0.07169486664754805, "fo": 0.3333333333333333, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4255_c250db9c", "label": 1, "code": "/**\n *  Returns <code>true</code> if the authority is properly formatted. An authority is the\n *  combination of host name and port. A <code>null</code> authority value is considered invalid.\n *\n *  @param authority\n *             an authority value to validate\n *  @return true if authority (host name and port) is valid.\n */\nprotected boolean isValidAuthority(String authority) {\n    if (authority == null) {\n        return false;\n    }\n    Matcher authorityMatcher = Pattern.compile(AUTHORITY_PATTERN).matcher(authority);\n    if (!authorityMatcher.matches()) {\n        return false;\n    }\n    boolean ipV4Address = false;\n    boolean hostname = false;\n    // check if authority is IP address or hostname\n    String hostIP = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP);\n    Matcher matchIPV4Pat = Pattern.compile(IP_V4_DOMAIN_PATTERN).matcher(hostIP);\n    ipV4Address = matchIPV4Pat.matches();\n    if (ipV4Address) {\n        // this is an IP address so check components\n        for (int i = 1; i <= 4; i++) {\n            String ipSegment = matchIPV4Pat.group(i);\n            if (ipSegment == null || ipSegment.length() <= 0) {\n                return false;\n            }\n            try {\n                if (Integer.parseInt(ipSegment) > 255) {\n                    return false;\n                }\n            } catch (NumberFormatException e) {\n                return false;\n            }\n        }\n    } else {\n        // Domain is hostname name\n        hostname = Pattern.compile(DOMAIN_PATTERN).matcher(hostIP).matches();\n    }\n    // rightmost hostname will never start with a digit.\n    if (hostname) {\n        // LOW-TECH FIX FOR VALIDATOR-202\n        // TODO: Rewrite to use ArrayList and .add semantics: see\n        // VALIDATOR-203\n        char[] chars = hostIP.toCharArray();\n        int size = 1;\n        for (char ch : chars) {\n            if (ch == '.') {\n                size++;\n            }\n        }\n        String[] domainSegment = new String[size];\n        boolean match = true;\n        int segmentCount = 0;\n        int segmentLength = 0;\n        while (match) {\n            Matcher atomMatcher = Pattern.compile(ATOM_PATTERN).matcher(hostIP);\n            match = atomMatcher.find();\n            if (match) {\n                domainSegment[segmentCount] = atomMatcher.group(1);\n                segmentLength = domainSegment[segmentCount].length() + 1;\n                hostIP = (segmentLength >= hostIP.length()) ? \"\" : hostIP.substring(segmentLength);\n                segmentCount++;\n            }\n        }\n        if (segmentCount > 1) {\n            String topLevel = domainSegment[segmentCount - 1];\n            if (topLevel.length() < 2 || topLevel.length() > 4) {\n                return false;\n            }\n            // First letter of top level must be a alpha\n            Matcher alphaMatcher = Pattern.compile(ALPHA_PATTERN).matcher(topLevel.substring(0, 1));\n            if (!alphaMatcher.matches()) {\n                return false;\n            }\n        }\n    }\n    if (!hostname && !ipV4Address) {\n        return false;\n    }\n    String port = authorityMatcher.group(PARSE_AUTHORITY_PORT);\n    if (port != null) {\n        Matcher portMatcher = Pattern.compile(PORT_PATTERN).matcher(port);\n        if (!portMatcher.matches()) {\n            return false;\n        }\n    }\n    String extra = authorityMatcher.group(PARSE_AUTHORITY_EXTRA);\n    if (!isBlankOrNull(extra)) {\n        return false;\n    }\n    return true;\n}", "code_comment": "/**\n *  Returns <code>true</code> if the authority is properly formatted. An authority is the\n *  combination of host name and port. A <code>null</code> authority value is considered invalid.\n *\n *  @param authority\n *             an authority value to validate\n *  @return true if authority (host name and port) is valid.\n */\n", "code_no_comment": "protected boolean isValidAuthority(String authority) {\n    if (authority == null) {\n        return false;\n    }\n    Matcher authorityMatcher = Pattern.compile(AUTHORITY_PATTERN).matcher(authority);\n    if (!authorityMatcher.matches()) {\n        return false;\n    }\n    boolean ipV4Address = false;\n    boolean hostname = false;\n        String hostIP = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP);\n    Matcher matchIPV4Pat = Pattern.compile(IP_V4_DOMAIN_PATTERN).matcher(hostIP);\n    ipV4Address = matchIPV4Pat.matches();\n    if (ipV4Address) {\n                for (int i = 1; i <= 4; i++) {\n            String ipSegment = matchIPV4Pat.group(i);\n            if (ipSegment == null || ipSegment.length() <= 0) {\n                return false;\n            }\n            try {\n                if (Integer.parseInt(ipSegment) > 255) {\n                    return false;\n                }\n            } catch (NumberFormatException e) {\n                return false;\n            }\n        }\n    } else {\n                hostname = Pattern.compile(DOMAIN_PATTERN).matcher(hostIP).matches();\n    }\n        if (hostname) {\n                                char[] chars = hostIP.toCharArray();\n        int size = 1;\n        for (char ch : chars) {\n            if (ch == '.') {\n                size++;\n            }\n        }\n        String[] domainSegment = new String[size];\n        boolean match = true;\n        int segmentCount = 0;\n        int segmentLength = 0;\n        while (match) {\n            Matcher atomMatcher = Pattern.compile(ATOM_PATTERN).matcher(hostIP);\n            match = atomMatcher.find();\n            if (match) {\n                domainSegment[segmentCount] = atomMatcher.group(1);\n                segmentLength = domainSegment[segmentCount].length() + 1;\n                hostIP = (segmentLength >= hostIP.length()) ? \"\" : hostIP.substring(segmentLength);\n                segmentCount++;\n            }\n        }\n        if (segmentCount > 1) {\n            String topLevel = domainSegment[segmentCount - 1];\n            if (topLevel.length() < 2 || topLevel.length() > 4) {\n                return false;\n            }\n                        Matcher alphaMatcher = Pattern.compile(ALPHA_PATTERN).matcher(topLevel.substring(0, 1));\n            if (!alphaMatcher.matches()) {\n                return false;\n            }\n        }\n    }\n    if (!hostname && !ipV4Address) {\n        return false;\n    }\n    String port = authorityMatcher.group(PARSE_AUTHORITY_PORT);\n    if (port != null) {\n        Matcher portMatcher = Pattern.compile(PORT_PATTERN).matcher(port);\n        if (!portMatcher.matches()) {\n            return false;\n        }\n    }\n    String extra = authorityMatcher.group(PARSE_AUTHORITY_EXTRA);\n    if (!isBlankOrNull(extra)) {\n        return false;\n    }\n    return true;\n}", "lc": 2.9545454545454546, "pi": 0.7653061224489793, "ma": 2.8333333333333335, "nbd": 1.0, "ml": 2.9166666666666665, "d": 3.219970341077608, "mi": -1.2205334098078582, "fo": 2.25, "r": -0.028571428571428574, "e": 10.673793584916975}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2082_0cfa43d7", "label": 3, "code": "@Override\npublic void registerInputOutput() {\n    this.userClassLoader = getUserCodeClassLoader();\n    this.configuration = new StreamConfig(getTaskConfiguration());\n    this.context = createRuntimeContext(getEnvironment().getTaskName());\n    this.stateHandleProvider = getStateHandleProvider();\n    outputHandler = new OutputHandler<OUT>(this);\n    streamOperator = configuration.getStreamOperator(userClassLoader);\n    if (streamOperator != null) {\n        // IterationHead and IterationTail don't have an Operator...\n        streamOperator.setup(outputHandler.getOutput(), this.context);\n    }\n    hasChainedOperators = !outputHandler.getChainedOperators().isEmpty();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void registerInputOutput() {\n    this.userClassLoader = getUserCodeClassLoader();\n    this.configuration = new StreamConfig(getTaskConfiguration());\n    this.context = createRuntimeContext(getEnvironment().getTaskName());\n    this.stateHandleProvider = getStateHandleProvider();\n    outputHandler = new OutputHandler<OUT>(this);\n    streamOperator = configuration.getStreamOperator(userClassLoader);\n    if (streamOperator != null) {\n                streamOperator.setup(outputHandler.getOutput(), this.context);\n    }\n    hasChainedOperators = !outputHandler.getChainedOperators().isEmpty();\n}", "lc": -0.045454545454545456, "pi": -0.4540816326530613, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.12753336628769152, "mi": 0.03441353599082315, "fo": 0.4166666666666667, "r": 0.0, "e": -0.056171594262488175}
{"project_name": "Lang", "project_version": 32, "label": 1, "code": "/**\n * <p>\n * Registers the given object. Used by the reflection methods to avoid infinite loops.\n * </p>\n *\n * @param value\n *            The object to register.\n */\nstatic void register(Object value) {\n    getRegistry().add(new IDKey(value));\n}", "code_comment": "/**\n * <p>\n * Registers the given object. Used by the reflection methods to avoid infinite loops.\n * </p>\n *\n * @param value\n *            The object to register.\n */\n", "code_no_comment": "static void register(Object value) {\n    getRegistry().add(new IDKey(value));\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.046171494121021, "fo": -0.3333333333333333, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-3718_73ce9cfb", "label": 0, "code": "public TMutation toThrift() {\n    serialize();\n    return new TMutation(java.nio.ByteBuffer.wrap(row), java.nio.ByteBuffer.wrap(data), ByteBufferUtil.toByteBuffers(values), entries);\n}", "code_comment": NaN, "code_no_comment": "public TMutation toThrift() {\n    serialize();\n    return new TMutation(java.nio.ByteBuffer.wrap(row), java.nio.ByteBuffer.wrap(data), ByteBufferUtil.toByteBuffers(values), entries);\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7381703470031546, "fo": -0.16666666666666666, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2899_31aea2ad", "label": 0, "code": "// given a wal path, transform it to a recovery path\npublic static Path getRecoveryPath(VolumeManager fs, Path walPath) throws IOException {\n    if (walPath.depth() >= 3 && walPath.toUri().getScheme() != null) {\n        // its a fully qualified path\n        String uuid = walPath.getName();\n        // drop uuid\n        walPath = walPath.getParent();\n        // drop server\n        walPath = walPath.getParent();\n        if (!walPath.getName().equals(FileType.WAL.getDirectory()))\n            throw new IllegalArgumentException(\"Bad path \" + walPath);\n        // drop wal\n        walPath = walPath.getParent();\n        walPath = new Path(walPath, FileType.RECOVERY.getDirectory());\n        walPath = new Path(walPath, uuid);\n        return walPath;\n    }\n    throw new IllegalArgumentException(\"Bad path \" + walPath);\n}", "code_comment": NaN, "code_no_comment": "public static Path getRecoveryPath(VolumeManager fs, Path walPath) throws IOException {\n    if (walPath.depth() >= 3 && walPath.toUri().getScheme() != null) {\n                String uuid = walPath.getName();\n                walPath = walPath.getParent();\n                walPath = walPath.getParent();\n        if (!walPath.getName().equals(FileType.WAL.getDirectory()))\n            throw new IllegalArgumentException(\"Bad path \" + walPath);\n                walPath = walPath.getParent();\n        walPath = new Path(walPath, FileType.RECOVERY.getDirectory());\n        walPath = new Path(walPath, uuid);\n        return walPath;\n    }\n    throw new IllegalArgumentException(\"Bad path \" + walPath);\n}", "lc": 0.0, "pi": 0.1326530612244897, "ma": 0.16666666666666666, "nbd": -0.5, "ml": 0.16666666666666666, "d": 0.934256055363322, "mi": -0.0854602810438774, "fo": 0.4166666666666667, "r": -0.028571428571428574, "e": 0.7077578047035947}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "@Override\npublic String toString() {\n    StringBuilder sb = new StringBuilder(\"setTableProperty_result(\");\n    boolean first = true;\n    sb.append(\"ouch1:\");\n    if (this.ouch1 == null) {\n        sb.append(\"null\");\n    } else {\n        sb.append(this.ouch1);\n    }\n    first = false;\n    if (!first)\n        sb.append(\", \");\n    sb.append(\"ouch2:\");\n    if (this.ouch2 == null) {\n        sb.append(\"null\");\n    } else {\n        sb.append(this.ouch2);\n    }\n    first = false;\n    sb.append(\")\");\n    return sb.toString();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic String toString() {\n    StringBuilder sb = new StringBuilder(\"setTableProperty_result(\");\n    boolean first = true;\n    sb.append(\"ouch1:\");\n    if (this.ouch1 == null) {\n        sb.append(\"null\");\n    } else {\n        sb.append(this.ouch1);\n    }\n    first = false;\n    if (!first)\n        sb.append(\", \");\n    sb.append(\"ouch2:\");\n    if (this.ouch2 == null) {\n        sb.append(\"null\");\n    } else {\n        sb.append(this.ouch2);\n    }\n    first = false;\n    sb.append(\")\");\n    return sb.toString();\n}", "lc": 0.4090909090909091, "pi": -0.3520408163265306, "ma": 0.0, "nbd": -0.5, "ml": 0.08333333333333333, "d": 0.11369253583786461, "mi": -0.26584456552910807, "fo": 0.25, "r": 0.0, "e": 0.08033201845118018}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5", "label": 3, "code": "@Override\npublic void read(org.apache.thrift.protocol.TProtocol prot, update_result struct) throws org.apache.thrift.TException {\n    TTupleProtocol iprot = (TTupleProtocol) prot;\n    BitSet incoming = iprot.readBitSet(2);\n    if (incoming.get(0)) {\n        struct.ouch1 = new UnknownWriter();\n        struct.ouch1.read(iprot);\n        struct.setOuch1IsSet(true);\n    }\n    if (incoming.get(1)) {\n        struct.ouch2 = new MutationsRejectedException();\n        struct.ouch2.read(iprot);\n        struct.setOuch2IsSet(true);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void read(org.apache.thrift.protocol.TProtocol prot, update_result struct) throws org.apache.thrift.TException {\n    TTupleProtocol iprot = (TTupleProtocol) prot;\n    BitSet incoming = iprot.readBitSet(2);\n    if (incoming.get(0)) {\n        struct.ouch1 = new UnknownWriter();\n        struct.ouch1.read(iprot);\n        struct.setOuch1IsSet(true);\n    }\n    if (incoming.get(1)) {\n        struct.ouch2 = new MutationsRejectedException();\n        struct.ouch2.read(iprot);\n        struct.setOuch2IsSet(true);\n    }\n}", "lc": 0.045454545454545456, "pi": -0.015306122448979493, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.3806228373702422, "mi": -0.08115858904502435, "fo": 0.08333333333333333, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 162, "label": 2, "code": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    // Validate the top level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        int type = n.getType();\n        if (type == Token.NAME && parent.getType() == Token.VAR) {\n            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n                String name = n.getString();\n                Var aliasVar = t.getScope().getVar(name);\n                aliases.put(name, aliasVar);\n                aliasDefinitionsInOrder.add(n);\n                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n                transformation.addAlias(name, qualifiedName);\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n            }\n        }\n        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {\n            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (n.getType() == Token.NAME) {\n            String name = n.getString();\n            Var aliasVar = aliases.get(name);\n            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {\n                // Note, to support the transitive case, it's important we don't\n                // clone aliasedNode here.  For example,\n                // var g = goog; var d = g.dom; d.createElement('DIV');\n                // The node in aliasedNode (which is \"g\") will be replaced in the\n                // changes pass above with \"goog\".  If we cloned here, we'd end up\n                // with <code>g.dom.createElement('DIV')</code>.\n                Node aliasedNode = aliasVar.getInitialValue();\n                aliasUsages.add(new AliasedNode(n, aliasedNode));\n            }\n        }\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n    // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n        if (t.getScopeDepth() == 2) {\n        int type = n.getType();\n        if (type == Token.NAME && parent.getType() == Token.VAR) {\n            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n                String name = n.getString();\n                Var aliasVar = t.getScope().getVar(name);\n                aliases.put(name, aliasVar);\n                aliasDefinitionsInOrder.add(n);\n                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n                transformation.addAlias(name, qualifiedName);\n                                return;\n            } else {\n                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n            }\n        }\n        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {\n            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n        if (t.getScopeDepth() >= 2) {\n                if (n.getType() == Token.NAME) {\n            String name = n.getString();\n            Var aliasVar = aliases.get(name);\n            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {\n                                                                                                                Node aliasedNode = aliasVar.getInitialValue();\n                aliasUsages.add(new AliasedNode(n, aliasedNode));\n            }\n        }\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        }\n}", "lc": 1.5454545454545454, "pi": 0.8163265306122449, "ma": 1.6666666666666667, "nbd": 1.0, "ml": 2.25, "d": 0.5981216015818094, "mi": -0.8984800688270722, "fo": 2.5833333333333335, "r": -0.028571428571428574, "e": 2.0233295214599902}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3433_e76d23b0", "label": 3, "code": "public Object evaluate(Exchange exchange) {\n    return expression.evaluate(exchange, type.evaluate(exchange, Object.class).getClass());\n}", "code_comment": NaN, "code_no_comment": "public Object evaluate(Exchange exchange) {\n    return expression.evaluate(exchange, type.evaluate(exchange, Object.class).getClass());\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9638657872096357, "fo": -0.25, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2235_29d3d8f1", "label": 3, "code": "@Override\npublic void enter(NodeState before, NodeState after) throws CommitFailedException {\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void enter(NodeState before, NodeState after) throws CommitFailedException {\n}", "lc": -0.5, "pi": -1.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.046171494121021, "fo": -0.5, "r": 0.31428571428571433, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7883_d57f402b", "label": 1, "code": "@Override\npublic Reader getCharacterStream() {\n    InputStream is = getByteStream();\n    return camelContext.getTypeConverter().convertTo(Reader.class, is);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Reader getCharacterStream() {\n    InputStream is = getByteStream();\n    return camelContext.getTypeConverter().convertTo(Reader.class, is);\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7054774878118727, "fo": -0.25, "r": 0.5428571428571429, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1348_ef0f6ddc", "label": 1, "code": "public int start() throws IOException {\n    if (configError)\n        return 1;\n    String input;\n    if (isVerbose())\n        printInfo();\n    String home = System.getProperty(\"HOME\");\n    if (home == null)\n        home = System.getenv(\"HOME\");\n    String configDir = home + \"/.accumulo\";\n    String historyPath = configDir + \"/shell_history.txt\";\n    File accumuloDir = new File(configDir);\n    if (!accumuloDir.exists() && !accumuloDir.mkdirs())\n        log.warn(\"Unable to make directory for history at \" + accumuloDir);\n    try {\n        History history = new History();\n        history.setHistoryFile(new File(historyPath));\n        reader.setHistory(history);\n    } catch (IOException e) {\n        log.warn(\"Unable to load history file at \" + historyPath);\n    }\n    ShellCompletor userCompletor = null;\n    if (execFile != null) {\n        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));\n        while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());\n    } else if (execCommand != null) {\n        for (String command : execCommand.split(\"\\n\")) {\n            execCommand(command, true, isVerbose());\n        }\n        return exitCode;\n    }\n    while (true) {\n        if (hasExited())\n            return exitCode;\n        // If tab completion is true we need to reset\n        if (tabCompletion) {\n            if (userCompletor != null)\n                reader.removeCompletor(userCompletor);\n            userCompletor = setupCompletion();\n            reader.addCompletor(userCompletor);\n        }\n        reader.setDefaultPrompt(getDefaultPrompt());\n        input = reader.readLine();\n        if (input == null) {\n            reader.printNewline();\n            return exitCode;\n        }\n        // user canceled\n        execCommand(input, disableAuthTimeout, false);\n    }\n}", "code_comment": NaN, "code_no_comment": "public int start() throws IOException {\n    if (configError)\n        return 1;\n    String input;\n    if (isVerbose())\n        printInfo();\n    String home = System.getProperty(\"HOME\");\n    if (home == null)\n        home = System.getenv(\"HOME\");\n    String configDir = home + \"/.accumulo\";\n    String historyPath = configDir + \"/shell_history.txt\";\n    File accumuloDir = new File(configDir);\n    if (!accumuloDir.exists() && !accumuloDir.mkdirs())\n        log.warn(\"Unable to make directory for history at \" + accumuloDir);\n    try {\n        History history = new History();\n        history.setHistoryFile(new File(historyPath));\n        reader.setHistory(history);\n    } catch (IOException e) {\n        log.warn(\"Unable to load history file at \" + historyPath);\n    }\n    ShellCompletor userCompletor = null;\n    if (execFile != null) {\n        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));\n        while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());\n    } else if (execCommand != null) {\n        for (String command : execCommand.split(\"\\n\")) {\n            execCommand(command, true, isVerbose());\n        }\n        return exitCode;\n    }\n    while (true) {\n        if (hasExited())\n            return exitCode;\n                if (tabCompletion) {\n            if (userCompletor != null)\n                reader.removeCompletor(userCompletor);\n            userCompletor = setupCompletion();\n            reader.addCompletor(userCompletor);\n        }\n        reader.setDefaultPrompt(getDefaultPrompt());\n        input = reader.readLine();\n        if (input == null) {\n            reader.printNewline();\n            return exitCode;\n        }\n                execCommand(input, disableAuthTimeout, false);\n    }\n}", "lc": 1.5909090909090908, "pi": 0.1479591836734694, "ma": 1.8333333333333333, "nbd": 0.5, "ml": 1.6666666666666667, "d": 0.8057340583292142, "mi": -0.8844278749641529, "fo": 1.6666666666666667, "r": -0.028571428571428574, "e": 2.0024541611522997}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-509_b896c926", "label": 3, "code": "@Override\n@CheckForNull\npublic String getJcrName(String oakName) {\n    checkNotNull(oakName);\n    // hidden name\n    checkArgument(!oakName.startsWith(\":\"));\n    // expanded name\n    checkArgument(isExpandedName(oakName));\n    if (hasSessionLocalMappings()) {\n        int colon = oakName.indexOf(':');\n        if (colon > 0) {\n            String oakPrefix = oakName.substring(0, colon);\n            String uri = getNamespaceMap().get(oakPrefix);\n            if (uri == null) {\n                throw new IllegalStateException(\"No namespace mapping found for \" + oakName);\n            }\n            Map<String, String> local = getSessionLocalMappings();\n            for (Map.Entry<String, String> entry : local.entrySet()) {\n                if (uri.equals(entry.getValue())) {\n                    String jcrPrefix = entry.getKey();\n                    if (jcrPrefix.equals(oakPrefix)) {\n                        return oakName;\n                    } else {\n                        return jcrPrefix + oakName.substring(colon);\n                    }\n                }\n            }\n            // is no conflicting local mapping for the prefix\n            if (local.containsKey(oakPrefix)) {\n                for (int i = 2; true; i++) {\n                    String jcrPrefix = oakPrefix + i;\n                    if (!local.containsKey(jcrPrefix)) {\n                        return jcrPrefix + oakName.substring(colon);\n                    }\n                }\n            }\n        }\n    }\n    return oakName;\n}", "code_comment": NaN, "code_no_comment": "@Override\n@CheckForNull\npublic String getJcrName(String oakName) {\n    checkNotNull(oakName);\n        checkArgument(!oakName.startsWith(\":\"));\n        checkArgument(isExpandedName(oakName));\n    if (hasSessionLocalMappings()) {\n        int colon = oakName.indexOf(':');\n        if (colon > 0) {\n            String oakPrefix = oakName.substring(0, colon);\n            String uri = getNamespaceMap().get(oakPrefix);\n            if (uri == null) {\n                throw new IllegalStateException(\"No namespace mapping found for \" + oakName);\n            }\n            Map<String, String> local = getSessionLocalMappings();\n            for (Map.Entry<String, String> entry : local.entrySet()) {\n                if (uri.equals(entry.getValue())) {\n                    String jcrPrefix = entry.getKey();\n                    if (jcrPrefix.equals(oakPrefix)) {\n                        return oakName;\n                    } else {\n                        return jcrPrefix + oakName.substring(colon);\n                    }\n                }\n            }\n                        if (local.containsKey(oakPrefix)) {\n                for (int i = 2; true; i++) {\n                    String jcrPrefix = oakPrefix + i;\n                    if (!local.containsKey(jcrPrefix)) {\n                        return jcrPrefix + oakName.substring(colon);\n                    }\n                }\n            }\n        }\n    }\n    return oakName;\n}", "lc": 1.0454545454545454, "pi": 2.1785714285714284, "ma": 1.1666666666666667, "nbd": 1.5, "ml": 1.0833333333333333, "d": 0.9975284231339596, "mi": -0.6647548035560658, "fo": 1.1666666666666667, "r": -0.028571428571428574, "e": 1.4887506906343557}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1822_3e83a4c1", "label": 1, "code": "public static void setModified(@Nonnull UpdateOp op, @Nonnull Revision revision) {\n    checkNotNull(op).set(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));\n}", "code_comment": NaN, "code_no_comment": "public static void setModified(@Nonnull UpdateOp op, @Nonnull Revision revision) {\n    checkNotNull(op).set(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9065098938915972, "fo": -0.08333333333333333, "r": 0.14285714285714285, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-326_ce185345", "label": 1, "code": "/**\n * {@inheritDoc}\n */\npublic double getNorm() {\n    double res = 0;\n    Iterator iter = entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        res += iter.value() * iter.value();\n    }\n    return Math.sqrt(res);\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public double getNorm() {\n    double res = 0;\n    Iterator iter = entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        res += iter.value() * iter.value();\n    }\n    return Math.sqrt(res);\n}", "lc": -0.22727272727272727, "pi": -0.17857142857142863, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.07612456747404842, "mi": 0.3125896185833093, "fo": 0.0, "r": 1.657142857142857, "e": -0.10097181355228049}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443", "label": 1, "code": "@Override\npublic void clearLocatorCache(String tableName) throws TableNotFoundException {\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void clearLocatorCache(String tableName) throws TableNotFoundException {\n}", "lc": -0.5, "pi": -1.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.1015199311729282, "fo": -0.5, "r": 2.4571428571428573, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd", "label": 1, "code": "/**\n * Search for a given set of values.\n *\n * @param filter the filter (used for logging)\n * @param indexName the name of the index (for logging)\n * @param indexMeta the index metadata node (may not be null)\n * @param values values to look for (null to check for property existence)\n * @return an iterator of paths\n */\nIterable<String> query(Filter filter, String indexName, NodeState indexMeta, Iterable<String> values);", "code_comment": "/**\n * Search for a given set of values.\n *\n * @param filter the filter (used for logging)\n * @param indexName the name of the index (for logging)\n * @param indexMeta the index metadata node (may not be null)\n * @param values values to look for (null to check for property existence)\n * @return an iterator of paths\n */\n", "code_no_comment": "Iterable<String> query(Filter filter, String indexName, NodeState indexMeta, Iterable<String> values);", "lc": -0.5909090909090909, "pi": -1.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.459133926010898, "fo": -0.5, "r": 1.9714285714285713, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2494_0dc92ca1", "label": 1, "code": "public double getStdDev() {\n    return Math.sqrt(partialStdDev / count - getAverage() * getAverage());\n}", "code_comment": NaN, "code_no_comment": "public double getStdDev() {\n    return Math.sqrt(partialStdDev / count - getAverage() * getAverage());\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.15521502718734553, "mi": 0.9736162890737022, "fo": -0.25, "r": 2.428571428571429, "e": -0.14634167234164666}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4072_7d5b8645", "label": 1, "code": "/**\n *  render full representation of url (including protocol, host and port)\n *  into string representation\n */\npublic String toAbsoluteString() {\n    return toAbsoluteString(getCharset());\n}", "code_comment": "/**\n *  render full representation of url (including protocol, host and port)\n *  into string representation\n */\n", "code_no_comment": "public String toAbsoluteString() {\n    return toAbsoluteString(getCharset());\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.1669056495554921, "fo": -0.3333333333333333, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3377_00b9bc52", "label": 1, "code": "FullTextExpression parseTerm() throws ParseException {\n    if (parseIndex >= text.length()) {\n        throw getSyntaxError(\"term\");\n    }\n    boolean not = false;\n    StringBuilder buff = new StringBuilder();\n    char c = text.charAt(parseIndex);\n    if (c == '-') {\n        if (++parseIndex >= text.length()) {\n            throw getSyntaxError(\"term\");\n        }\n        not = true;\n    }\n    boolean escaped = false;\n    String boost = null;\n    if (c == '\\\"') {\n        parseIndex++;\n        while (true) {\n            if (parseIndex >= text.length()) {\n                throw getSyntaxError(\"double quote\");\n            }\n            c = text.charAt(parseIndex++);\n            if (c == '\\\\') {\n                escaped = true;\n                if (parseIndex >= text.length()) {\n                    throw getSyntaxError(\"escaped char\");\n                }\n                c = text.charAt(parseIndex++);\n                buff.append(c);\n            } else if (c == '\\\"') {\n                if (parseIndex < text.length()) {\n                    if (text.charAt(parseIndex) == '^') {\n                        boost = \"\";\n                    } else if (text.charAt(parseIndex) != ' ') {\n                        throw getSyntaxError(\"space\");\n                    }\n                }\n                parseIndex++;\n                break;\n            } else {\n                buff.append(c);\n            }\n        }\n    } else if (c == '\\'' && FullTextSearchImpl.JACKRABBIT_2_SINGLE_QUOTED_PHRASE) {\n        // basically the same as double quote\n        parseIndex++;\n        while (true) {\n            if (parseIndex >= text.length()) {\n                throw getSyntaxError(\"single quote\");\n            }\n            c = text.charAt(parseIndex++);\n            if (c == '\\\\') {\n                escaped = true;\n                if (parseIndex >= text.length()) {\n                    throw getSyntaxError(\"escaped char\");\n                }\n                c = text.charAt(parseIndex++);\n                buff.append(c);\n            } else if (c == '\\'') {\n                if (parseIndex < text.length()) {\n                    if (text.charAt(parseIndex) == '^') {\n                        boost = \"\";\n                    } else if (text.charAt(parseIndex) != ' ') {\n                        throw getSyntaxError(\"space\");\n                    }\n                }\n                parseIndex++;\n                break;\n            } else {\n                buff.append(c);\n            }\n        }\n    } else {\n        do {\n            c = text.charAt(parseIndex++);\n            if (c == '\\\\') {\n                escaped = true;\n                if (parseIndex >= text.length()) {\n                    throw getSyntaxError(\"escaped char\");\n                }\n                c = text.charAt(parseIndex++);\n                buff.append(c);\n            } else if (c == '^') {\n                boost = \"\";\n                break;\n            } else if (c == ' ') {\n                break;\n            } else {\n                buff.append(c);\n            }\n        } while (parseIndex < text.length());\n    }\n    if (boost != null) {\n        StringBuilder b = new StringBuilder();\n        while (parseIndex < text.length()) {\n            c = text.charAt(parseIndex++);\n            if ((c < '0' || c > '9') && c != '.') {\n                break;\n            }\n            b.append(c);\n        }\n        boost = b.toString();\n    }\n    if (buff.length() == 0) {\n        throw getSyntaxError(\"term\");\n    }\n    String text = buff.toString();\n    FullTextTerm term = new FullTextTerm(propertyName, text, not, escaped, boost);\n    return term.simplify();\n}", "code_comment": NaN, "code_no_comment": "FullTextExpression parseTerm() throws ParseException {\n    if (parseIndex >= text.length()) {\n        throw getSyntaxError(\"term\");\n    }\n    boolean not = false;\n    StringBuilder buff = new StringBuilder();\n    char c = text.charAt(parseIndex);\n    if (c == '-') {\n        if (++parseIndex >= text.length()) {\n            throw getSyntaxError(\"term\");\n        }\n        not = true;\n    }\n    boolean escaped = false;\n    String boost = null;\n    if (c == '\\\"') {\n        parseIndex++;\n        while (true) {\n            if (parseIndex >= text.length()) {\n                throw getSyntaxError(\"double quote\");\n            }\n            c = text.charAt(parseIndex++);\n            if (c == '\\\\') {\n                escaped = true;\n                if (parseIndex >= text.length()) {\n                    throw getSyntaxError(\"escaped char\");\n                }\n                c = text.charAt(parseIndex++);\n                buff.append(c);\n            } else if (c == '\\\"') {\n                if (parseIndex < text.length()) {\n                    if (text.charAt(parseIndex) == '^') {\n                        boost = \"\";\n                    } else if (text.charAt(parseIndex) != ' ') {\n                        throw getSyntaxError(\"space\");\n                    }\n                }\n                parseIndex++;\n                break;\n            } else {\n                buff.append(c);\n            }\n        }\n    } else if (c == '\\'' && FullTextSearchImpl.JACKRABBIT_2_SINGLE_QUOTED_PHRASE) {\n                parseIndex++;\n        while (true) {\n            if (parseIndex >= text.length()) {\n                throw getSyntaxError(\"single quote\");\n            }\n            c = text.charAt(parseIndex++);\n            if (c == '\\\\') {\n                escaped = true;\n                if (parseIndex >= text.length()) {\n                    throw getSyntaxError(\"escaped char\");\n                }\n                c = text.charAt(parseIndex++);\n                buff.append(c);\n            } else if (c == '\\'') {\n                if (parseIndex < text.length()) {\n                    if (text.charAt(parseIndex) == '^') {\n                        boost = \"\";\n                    } else if (text.charAt(parseIndex) != ' ') {\n                        throw getSyntaxError(\"space\");\n                    }\n                }\n                parseIndex++;\n                break;\n            } else {\n                buff.append(c);\n            }\n        }\n    } else {\n        do {\n            c = text.charAt(parseIndex++);\n            if (c == '\\\\') {\n                escaped = true;\n                if (parseIndex >= text.length()) {\n                    throw getSyntaxError(\"escaped char\");\n                }\n                c = text.charAt(parseIndex++);\n                buff.append(c);\n            } else if (c == '^') {\n                boost = \"\";\n                break;\n            } else if (c == ' ') {\n                break;\n            } else {\n                buff.append(c);\n            }\n        } while (parseIndex < text.length());\n    }\n    if (boost != null) {\n        StringBuilder b = new StringBuilder();\n        while (parseIndex < text.length()) {\n            c = text.charAt(parseIndex++);\n            if ((c < '0' || c > '9') && c != '.') {\n                break;\n            }\n            b.append(c);\n        }\n        boost = b.toString();\n    }\n    if (buff.length() == 0) {\n        throw getSyntaxError(\"term\");\n    }\n    String text = buff.toString();\n    FullTextTerm term = new FullTextTerm(propertyName, text, not, escaped, boost);\n    return term.simplify();\n}", "lc": 4.318181818181818, "pi": 1.3520408163265305, "ma": 7.0, "nbd": 3.0, "ml": 2.8333333333333335, "d": 3.554127533366288, "mi": -1.5531975910524811, "fo": 3.1666666666666665, "r": -0.028571428571428574, "e": 13.231119448691757}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-193_c831e44d", "label": 3, "code": "public String toStringNoTime() {\n    String labelString = new ColumnVisibility(colVisibility).toString();\n    String s = new String(row, 0, row.length) + \" \" + new String(colFamily, 0, colFamily.length) + \":\" + new String(colQualifier, 0, colQualifier.length) + \" \" + labelString;\n    return s;\n}", "code_comment": NaN, "code_no_comment": "public String toStringNoTime() {\n    String labelString = new ColumnVisibility(colVisibility).toString();\n    String s = new String(row, 0, row.length) + \" \" + new String(colFamily, 0, colFamily.length) + \":\" + new String(colQualifier, 0, colQualifier.length) + \" \" + labelString;\n    return s;\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": 0.01482946119624324, "mi": 0.5414396329222828, "fo": -0.4166666666666667, "r": -0.028571428571428574, "e": -0.04868490369666055}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5712_145da021", "label": 3, "code": "@Override\nprotected UrlInfo parseRequest(Request request) {\n    if (matches(request)) {\n        Url url = request.getUrl();\n        // try to extract page and component information from URL\n        PageComponentInfo info = getPageComponentInfo(url);\n        List<String> segments = url.getSegments();\n        // load the page class\n        String className;\n        if (segments.size() >= 3) {\n            className = segments.get(2);\n        } else {\n            className = segments.get(1);\n        }\n        Class<? extends IRequestablePage> pageClass = getPageClass(className);\n        if (pageClass != null && IRequestablePage.class.isAssignableFrom(pageClass)) {\n            if (Application.exists()) {\n                Application application = Application.get();\n                if (application.getSecuritySettings().getEnforceMounts()) {\n                    // we make an exception if the homepage itself was mounted, see WICKET-1898\n                    if (!pageClass.equals(application.getHomePage())) {\n                        // WICKET-5094 only enforce mount if page is mounted\n                        if (isPageMounted(pageClass, application)) {\n                            return null;\n                        }\n                    }\n                }\n            }\n            // extract the PageParameters from URL if there are any\n            PageParameters pageParameters = extractPageParameters(request, 3, pageParametersEncoder);\n            return new UrlInfo(info, pageClass, pageParameters);\n        }\n    }\n    return null;\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected UrlInfo parseRequest(Request request) {\n    if (matches(request)) {\n        Url url = request.getUrl();\n                PageComponentInfo info = getPageComponentInfo(url);\n        List<String> segments = url.getSegments();\n                String className;\n        if (segments.size() >= 3) {\n            className = segments.get(2);\n        } else {\n            className = segments.get(1);\n        }\n        Class<? extends IRequestablePage> pageClass = getPageClass(className);\n        if (pageClass != null && IRequestablePage.class.isAssignableFrom(pageClass)) {\n            if (Application.exists()) {\n                Application application = Application.get();\n                if (application.getSecuritySettings().getEnforceMounts()) {\n                                        if (!pageClass.equals(application.getHomePage())) {\n                                                if (isPageMounted(pageClass, application)) {\n                            return null;\n                        }\n                    }\n                }\n            }\n                        PageParameters pageParameters = extractPageParameters(request, 3, pageParametersEncoder);\n            return new UrlInfo(info, pageClass, pageParameters);\n        }\n    }\n    return null;\n}", "lc": 0.7272727272727273, "pi": 2.0306122448979593, "ma": 0.6666666666666666, "nbd": 2.0, "ml": 1.1666666666666667, "d": 0.3133959466139397, "mi": -0.5213650702609697, "fo": 0.9166666666666666, "r": -0.028571428571428574, "e": 0.5337265130781519}
{"project_name": "Closure", "project_version": 20, "label": 2, "code": "private Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) {\n        // Fold String(a) to '' + (a) on immutable literals,\n        // which allows further optimizations\n        // \n        // We can't do this in the general case, because String(a) has\n        // slightly different semantics than '' + (a). See\n        // http://code.google.com/p/closure-compiler/issues/detail?id=759\n        Node value = callTarget.getNext();\n        if (value != null) {\n            Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n            n.getParent().replaceChild(n, addition);\n            reportCodeChange();\n            return addition;\n        }\n    }\n    return n;\n}", "code_comment": NaN, "code_no_comment": "private Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) {\n                                                        Node value = callTarget.getNext();\n        if (value != null) {\n            Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n            n.getParent().replaceChild(n, addition);\n            reportCodeChange();\n            return addition;\n        }\n    }\n    return n;\n}", "lc": 0.0, "pi": 0.586734693877551, "ma": -0.16666666666666666, "nbd": 0.0, "ml": 0.25, "d": -0.030647553138902585, "mi": -0.04645827358761127, "fo": 0.6666666666666666, "r": 0.17142857142857146, "e": 0.030876174078404657}
{"project_name": "Math", "project_version": 6, "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic PointVectorValuePair doOptimize() {\n    checkParameters();\n    final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n    // Computation will be useless without a checker (see \"for-loop\").\n    if (checker == null) {\n        throw new NullArgumentException();\n    }\n    final double[] targetValues = getTarget();\n    // Number of observed data.\n    final int nR = targetValues.length;\n    final RealMatrix weightMatrix = getWeight();\n    // Diagonal of the weight matrix.\n    final double[] residualsWeights = new double[nR];\n    for (int i = 0; i < nR; i++) {\n        residualsWeights[i] = weightMatrix.getEntry(i, i);\n    }\n    final double[] currentPoint = getStartPoint();\n    final int nC = currentPoint.length;\n    // iterate until convergence is reached\n    PointVectorValuePair current = null;\n    int iter = 0;\n    for (boolean converged = false; !converged; ) {\n        ++iter;\n        // evaluate the objective function and its jacobian\n        PointVectorValuePair previous = current;\n        // Value of the objective function at \"currentPoint\".\n        final double[] currentObjective = computeObjectiveValue(currentPoint);\n        final double[] currentResiduals = computeResiduals(currentObjective);\n        final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n        current = new PointVectorValuePair(currentPoint, currentObjective);\n        // build the linear problem\n        final double[] b = new double[nC];\n        final double[][] a = new double[nC][nC];\n        for (int i = 0; i < nR; ++i) {\n            final double[] grad = weightedJacobian.getRow(i);\n            final double weight = residualsWeights[i];\n            final double residual = currentResiduals[i];\n            // compute the normal equation\n            final double wr = weight * residual;\n            for (int j = 0; j < nC; ++j) {\n                b[j] += wr * grad[j];\n            }\n            // build the contribution matrix for measurement i\n            for (int k = 0; k < nC; ++k) {\n                double[] ak = a[k];\n                double wgk = weight * grad[k];\n                for (int l = 0; l < nC; ++l) {\n                    ak[l] += wgk * grad[l];\n                }\n            }\n        }\n        try {\n            // solve the linearized least squares problem\n            RealMatrix mA = new BlockRealMatrix(a);\n            DecompositionSolver solver = useLU ? new LUDecomposition(mA).getSolver() : new QRDecomposition(mA).getSolver();\n            final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n            // update the estimated parameters\n            for (int i = 0; i < nC; ++i) {\n                currentPoint[i] += dX[i];\n            }\n        } catch (SingularMatrixException e) {\n            throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n        }\n        // Check convergence.\n        if (previous != null) {\n            converged = checker.converged(iter, previous, current);\n            if (converged) {\n                setCost(computeCost(currentResiduals));\n                return current;\n            }\n        }\n    }\n    // Must never happen.\n    throw new MathInternalError();\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic PointVectorValuePair doOptimize() {\n    checkParameters();\n    final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n        if (checker == null) {\n        throw new NullArgumentException();\n    }\n    final double[] targetValues = getTarget();\n        final int nR = targetValues.length;\n    final RealMatrix weightMatrix = getWeight();\n        final double[] residualsWeights = new double[nR];\n    for (int i = 0; i < nR; i++) {\n        residualsWeights[i] = weightMatrix.getEntry(i, i);\n    }\n    final double[] currentPoint = getStartPoint();\n    final int nC = currentPoint.length;\n        PointVectorValuePair current = null;\n    int iter = 0;\n    for (boolean converged = false; !converged; ) {\n        ++iter;\n                PointVectorValuePair previous = current;\n                final double[] currentObjective = computeObjectiveValue(currentPoint);\n        final double[] currentResiduals = computeResiduals(currentObjective);\n        final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n        current = new PointVectorValuePair(currentPoint, currentObjective);\n                final double[] b = new double[nC];\n        final double[][] a = new double[nC][nC];\n        for (int i = 0; i < nR; ++i) {\n            final double[] grad = weightedJacobian.getRow(i);\n            final double weight = residualsWeights[i];\n            final double residual = currentResiduals[i];\n                        final double wr = weight * residual;\n            for (int j = 0; j < nC; ++j) {\n                b[j] += wr * grad[j];\n            }\n                        for (int k = 0; k < nC; ++k) {\n                double[] ak = a[k];\n                double wgk = weight * grad[k];\n                for (int l = 0; l < nC; ++l) {\n                    ak[l] += wgk * grad[l];\n                }\n            }\n        }\n        try {\n                        RealMatrix mA = new BlockRealMatrix(a);\n            DecompositionSolver solver = useLU ? new LUDecomposition(mA).getSolver() : new QRDecomposition(mA).getSolver();\n            final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                        for (int i = 0; i < nC; ++i) {\n                currentPoint[i] += dX[i];\n            }\n        } catch (SingularMatrixException e) {\n            throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n        }\n                if (previous != null) {\n            converged = checker.converged(iter, previous, current);\n            if (converged) {\n                setCost(computeCost(currentResiduals));\n                return current;\n            }\n        }\n    }\n        throw new MathInternalError();\n}", "lc": 2.227272727272727, "pi": 0.8214285714285714, "ma": 2.0, "nbd": 1.0, "ml": 1.3333333333333333, "d": 1.5907068709836882, "mi": -1.082879265844566, "fo": 0.9166666666666666, "r": -0.028571428571428574, "e": 5.793816199176806}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3107_937963e3", "label": 1, "code": "/**\n *  Resets the state of {@link Execution} instances back to the state of a savepoint.\n *\n *  <p>The execution vertices need to be in state {@link ExecutionState#CREATED} when calling\n *  this method. The operation might block. Make sure that calls don't block the job manager\n *  actor.\n *\n *  @param tasks         Tasks that will possibly be reset\n *  @param savepointPath The path of the savepoint to rollback to\n *  @return The application ID of the rolled back savepoint\n *  @throws IllegalStateException If coordinator is shut down\n *  @throws IllegalStateException If mismatch between program and savepoint state\n *  @throws Exception             If savepoint store failure\n */\npublic ApplicationID restoreSavepoint(Map<JobVertexID, ExecutionJobVertex> tasks, String savepointPath) throws Exception {\n    checkNotNull(savepointPath, \"Savepoint path\");\n    synchronized (lock) {\n        if (isShutdown()) {\n            throw new IllegalStateException(\"CheckpointCoordinator is shut down\");\n        }\n        long recoveryTimestamp = System.currentTimeMillis();\n        LOG.info(\"Rolling back to savepoint '{}'.\", savepointPath);\n        Savepoint savepoint = savepointStore.getState(savepointPath);\n        CompletedCheckpoint checkpoint = savepoint.getCompletedCheckpoint();\n        LOG.info(\"Savepoint: {}@{}\", checkpoint.getCheckpointID(), checkpoint.getTimestamp());\n        // Set the initial state of all tasks\n        LOG.debug(\"Rolling back individual operators.\");\n        for (StateForTask state : checkpoint.getStates()) {\n            LOG.debug(\"Rolling back subtask {} of operator {}.\", state.getSubtask(), state.getOperatorId());\n            ExecutionJobVertex vertex = tasks.get(state.getOperatorId());\n            if (vertex == null) {\n                String msg = String.format(\"Failed to rollback to savepoint %s. \" + \"Cannot map old state for task %s to the new program. \" + \"This indicates that the program has been changed in a \" + \"non-compatible way  after the savepoint.\", savepoint, state.getOperatorId());\n                throw new IllegalStateException(msg);\n            }\n            if (state.getSubtask() >= vertex.getParallelism()) {\n                String msg = String.format(\"Failed to rollback to savepoint %s. \" + \"Parallelism mismatch between savepoint state and new program. \" + \"Cannot map subtask %d of operator %s to new program with \" + \"parallelism %d. This indicates that the program has been changed \" + \"in a non-compatible way after the savepoint.\", savepoint, state.getSubtask(), state.getOperatorId(), vertex.getParallelism());\n                throw new IllegalStateException(msg);\n            }\n            Execution exec = vertex.getTaskVertices()[state.getSubtask()].getCurrentExecutionAttempt();\n            exec.setInitialState(state.getState(), recoveryTimestamp);\n        }\n        // Reset the checkpoint ID counter\n        long nextCheckpointId = checkpoint.getCheckpointID();\n        checkpointIdCounter.setCount(nextCheckpointId + 1);\n        LOG.info(\"Reset the checkpoint ID to {}\", nextCheckpointId);\n        this.appId = savepoint.getApplicationId();\n        LOG.info(\"Reset the application ID to {}\", appId);\n        return appId;\n    }\n}", "code_comment": "/**\n *  Resets the state of {@link Execution} instances back to the state of a savepoint.\n *\n *  <p>The execution vertices need to be in state {@link ExecutionState#CREATED} when calling\n *  this method. The operation might block. Make sure that calls don't block the job manager\n *  actor.\n *\n *  @param tasks         Tasks that will possibly be reset\n *  @param savepointPath The path of the savepoint to rollback to\n *  @return The application ID of the rolled back savepoint\n *  @throws IllegalStateException If coordinator is shut down\n *  @throws IllegalStateException If mismatch between program and savepoint state\n *  @throws Exception             If savepoint store failure\n */\n", "code_no_comment": "public ApplicationID restoreSavepoint(Map<JobVertexID, ExecutionJobVertex> tasks, String savepointPath) throws Exception {\n    checkNotNull(savepointPath, \"Savepoint path\");\n    synchronized (lock) {\n        if (isShutdown()) {\n            throw new IllegalStateException(\"CheckpointCoordinator is shut down\");\n        }\n        long recoveryTimestamp = System.currentTimeMillis();\n        LOG.info(\"Rolling back to savepoint '{}'.\", savepointPath);\n        Savepoint savepoint = savepointStore.getState(savepointPath);\n        CompletedCheckpoint checkpoint = savepoint.getCompletedCheckpoint();\n        LOG.info(\"Savepoint: {}@{}\", checkpoint.getCheckpointID(), checkpoint.getTimestamp());\n                LOG.debug(\"Rolling back individual operators.\");\n        for (StateForTask state : checkpoint.getStates()) {\n            LOG.debug(\"Rolling back subtask {} of operator {}.\", state.getSubtask(), state.getOperatorId());\n            ExecutionJobVertex vertex = tasks.get(state.getOperatorId());\n            if (vertex == null) {\n                String msg = String.format(\"Failed to rollback to savepoint %s. \" + \"Cannot map old state for task %s to the new program. \" + \"This indicates that the program has been changed in a \" + \"non-compatible way  after the savepoint.\", savepoint, state.getOperatorId());\n                throw new IllegalStateException(msg);\n            }\n            if (state.getSubtask() >= vertex.getParallelism()) {\n                String msg = String.format(\"Failed to rollback to savepoint %s. \" + \"Parallelism mismatch between savepoint state and new program. \" + \"Cannot map subtask %d of operator %s to new program with \" + \"parallelism %d. This indicates that the program has been changed \" + \"in a non-compatible way after the savepoint.\", savepoint, state.getSubtask(), state.getOperatorId(), vertex.getParallelism());\n                throw new IllegalStateException(msg);\n            }\n            Execution exec = vertex.getTaskVertices()[state.getSubtask()].getCurrentExecutionAttempt();\n            exec.setInitialState(state.getState(), recoveryTimestamp);\n        }\n                long nextCheckpointId = checkpoint.getCheckpointID();\n        checkpointIdCounter.setCount(nextCheckpointId + 1);\n        LOG.info(\"Reset the checkpoint ID to {}\", nextCheckpointId);\n        this.appId = savepoint.getApplicationId();\n        LOG.info(\"Reset the application ID to {}\", appId);\n        return appId;\n    }\n}", "lc": 0.9090909090909091, "pi": 0.4693877551020408, "ma": 0.6666666666666666, "nbd": 0.5, "ml": 0.16666666666666666, "d": 0.374691052891745, "mi": -0.6736449670203618, "fo": 2.3333333333333335, "r": -0.028571428571428574, "e": 1.2648609522830552}
{"project_name": "Closure", "project_version": 114, "label": 2, "code": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n    Node nameNode = n.getFirstChild();\n    Node parent = n.getParent();\n    NameInformation ns = createNameInformation(t, nameNode);\n    if (ns != null) {\n        if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n            // logic.\n            if (parent.getFirstChild().getNext() != n) {\n                recordDepScope(recordNode, ns);\n            } else {\n                recordDepScope(nameNode, ns);\n            }\n        } else {\n            // The rhs of the assignment is the caller, so it's used by the\n            // context. Don't associate it w/ the lhs.\n            // FYI: this fixes only the specific case where the assignment is the\n            // caller expression, but it could be nested deeper in the caller and\n            // we would still get a bug.\n            // See testAssignWithCall2 for an example of this.\n            recordDepScope(recordNode, ns);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n    Node nameNode = n.getFirstChild();\n    Node parent = n.getParent();\n    NameInformation ns = createNameInformation(t, nameNode);\n    if (ns != null) {\n        if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n                        if (parent.getFirstChild().getNext() != n) {\n                recordDepScope(recordNode, ns);\n            } else {\n                recordDepScope(nameNode, ns);\n            }\n        } else {\n                                                                                    recordDepScope(recordNode, ns);\n        }\n    }\n}", "lc": 0.09090909090909091, "pi": 1.0051020408163267, "ma": 0.0, "nbd": 0.5, "ml": 0.4166666666666667, "d": 0.4300543746910529, "mi": -0.09148264984227125, "fo": 0.3333333333333333, "r": -0.028571428571428574, "e": 0.2222364989014096}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1133_27e40205", "label": 1, "code": "private <IN1, IN2> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> returnTypeHierarchy, TypeInformation<IN1> in1TypeInfo, TypeInformation<IN2> in2TypeInfo) {\n    Type matReturnTypeVar = materializeTypeVariable(returnTypeHierarchy, returnTypeVar);\n    // variable could be resolved\n    if (!(matReturnTypeVar instanceof TypeVariable)) {\n        return createTypeInfoWithTypeHierarchy(returnTypeHierarchy, matReturnTypeVar, in1TypeInfo, in2TypeInfo);\n    } else {\n        returnTypeVar = (TypeVariable<?>) matReturnTypeVar;\n    }\n    TypeInformation<?> info = null;\n    if (in1TypeInfo != null) {\n        // find the deepest type variable that describes the type of input 1\n        ParameterizedType baseClass = (ParameterizedType) returnTypeHierarchy.get(returnTypeHierarchy.size() - 1);\n        Type in1Type = baseClass.getActualTypeArguments()[0];\n        if (in1Type instanceof TypeVariable) {\n            in1Type = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) in1Type);\n            info = findCorrespondingInfo(returnTypeVar, in1Type, in1TypeInfo);\n        }\n    }\n    if (info == null && in2TypeInfo != null) {\n        // find the deepest type variable that describes the type of input 2\n        ParameterizedType baseClass = (ParameterizedType) returnTypeHierarchy.get(returnTypeHierarchy.size() - 1);\n        Type in2Type = baseClass.getActualTypeArguments()[1];\n        if (in2Type instanceof TypeVariable) {\n            in2Type = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) in2Type);\n            info = findCorrespondingInfo(returnTypeVar, in2Type, in2TypeInfo);\n        }\n    }\n    if (info != null) {\n        return info;\n    }\n    return null;\n}", "code_comment": NaN, "code_no_comment": "private <IN1, IN2> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> returnTypeHierarchy, TypeInformation<IN1> in1TypeInfo, TypeInformation<IN2> in2TypeInfo) {\n    Type matReturnTypeVar = materializeTypeVariable(returnTypeHierarchy, returnTypeVar);\n        if (!(matReturnTypeVar instanceof TypeVariable)) {\n        return createTypeInfoWithTypeHierarchy(returnTypeHierarchy, matReturnTypeVar, in1TypeInfo, in2TypeInfo);\n    } else {\n        returnTypeVar = (TypeVariable<?>) matReturnTypeVar;\n    }\n    TypeInformation<?> info = null;\n    if (in1TypeInfo != null) {\n                ParameterizedType baseClass = (ParameterizedType) returnTypeHierarchy.get(returnTypeHierarchy.size() - 1);\n        Type in1Type = baseClass.getActualTypeArguments()[0];\n        if (in1Type instanceof TypeVariable) {\n            in1Type = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) in1Type);\n            info = findCorrespondingInfo(returnTypeVar, in1Type, in1TypeInfo);\n        }\n    }\n    if (info == null && in2TypeInfo != null) {\n                ParameterizedType baseClass = (ParameterizedType) returnTypeHierarchy.get(returnTypeHierarchy.size() - 1);\n        Type in2Type = baseClass.getActualTypeArguments()[1];\n        if (in2Type instanceof TypeVariable) {\n            in2Type = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) in2Type);\n            info = findCorrespondingInfo(returnTypeVar, in2Type, in2TypeInfo);\n        }\n    }\n    if (info != null) {\n        return info;\n    }\n    return null;\n}", "lc": 0.6818181818181818, "pi": 0.11224489795918377, "ma": 0.5, "nbd": 0.0, "ml": 0.6666666666666666, "d": 1.683638161146812, "mi": -0.529681674792085, "fo": 0.5, "r": -0.028571428571428574, "e": 2.3856630732265156}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-3897_699b8bf0", "label": 3, "code": "@Override\npublic long isReady(long tid, Master master) throws Exception {\n    // suppress assignment of tablets to the server\n    if (force) {\n        return 0;\n    }\n    // only send this request once\n    if (!requestedShutdown) {\n        master.shutdownTServer(server);\n    }\n    if (master.onlineTabletServers().contains(server)) {\n        TServerConnection connection = master.getConnection(server);\n        if (connection != null) {\n            try {\n                TabletServerStatus status = connection.getTableMap(false);\n                if (status.tableMap != null && status.tableMap.isEmpty()) {\n                    log.info(\"tablet server hosts no tablets \" + server);\n                    connection.halt(master.getMasterLock());\n                    log.info(\"tablet server asked to halt \" + server);\n                    return 0;\n                }\n            } catch (TTransportException ex) {\n            // expected\n            } catch (Exception ex) {\n                log.error(\"Error talking to tablet server \" + server + \": \" + ex);\n            }\n            // tserver to ack the request and stop itself.\n            return 1000;\n        }\n    }\n    return 0;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic long isReady(long tid, Master master) throws Exception {\n        if (force) {\n        return 0;\n    }\n        if (!requestedShutdown) {\n        master.shutdownTServer(server);\n    }\n    if (master.onlineTabletServers().contains(server)) {\n        TServerConnection connection = master.getConnection(server);\n        if (connection != null) {\n            try {\n                TabletServerStatus status = connection.getTableMap(false);\n                if (status.tableMap != null && status.tableMap.isEmpty()) {\n                    log.info(\"tablet server hosts no tablets \" + server);\n                    connection.halt(master.getMasterLock());\n                    log.info(\"tablet server asked to halt \" + server);\n                    return 0;\n                }\n            } catch (TTransportException ex) {\n                        } catch (Exception ex) {\n                log.error(\"Error talking to tablet server \" + server + \": \" + ex);\n            }\n                        return 1000;\n        }\n    }\n    return 0;\n}", "lc": 0.6363636363636364, "pi": 1.7040816326530615, "ma": 0.6666666666666666, "nbd": 1.0, "ml": 0.6666666666666666, "d": 0.2778052397429561, "mi": -0.4554057929452251, "fo": 0.4166666666666667, "r": -0.028571428571428574, "e": 0.36354135882577165}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1429_c2f5ca6c", "label": 1, "code": "// ------------------------------< internal >--------------------------------\nprivate boolean dispatch(@Nonnull String jsonDiff, @Nonnull DocumentNodeState base, @Nonnull NodeStateDiff diff) {\n    if (!AbstractNodeState.comparePropertiesAgainstBaseState(this, base, diff)) {\n        return false;\n    }\n    if (jsonDiff.trim().isEmpty()) {\n        return true;\n    }\n    JsopTokenizer t = new JsopTokenizer(jsonDiff);\n    boolean continueComparison = true;\n    while (continueComparison) {\n        int r = t.read();\n        if (r == JsopReader.END) {\n            break;\n        }\n        switch(r) {\n            case '+':\n                {\n                    String path = t.readString();\n                    t.read(':');\n                    t.read('{');\n                    while (t.read() != '}') {\n                    // skip properties\n                    }\n                    String name = PathUtils.getName(path);\n                    continueComparison = diff.childNodeAdded(name, getChildNode(name));\n                    break;\n                }\n            case '-':\n                {\n                    String path = t.readString();\n                    String name = PathUtils.getName(path);\n                    continueComparison = diff.childNodeDeleted(name, base.getChildNode(name));\n                    break;\n                }\n            case '^':\n                {\n                    String path = t.readString();\n                    t.read(':');\n                    if (t.matches('{')) {\n                        t.read('}');\n                        String name = PathUtils.getName(path);\n                        continueComparison = diff.childNodeChanged(name, base.getChildNode(name), getChildNode(name));\n                    } else if (t.matches('[')) {\n                        // ignore multi valued property\n                        while (t.read() != ']') {\n                        // skip values\n                        }\n                    } else {\n                        // ignore single valued property\n                        t.read();\n                    }\n                    break;\n                }\n            case '>':\n                {\n                    String from = t.readString();\n                    t.read(':');\n                    String to = t.readString();\n                    String fromName = PathUtils.getName(from);\n                    continueComparison = diff.childNodeDeleted(fromName, base.getChildNode(fromName));\n                    if (!continueComparison) {\n                        break;\n                    }\n                    String toName = PathUtils.getName(to);\n                    continueComparison = diff.childNodeAdded(toName, getChildNode(toName));\n                    break;\n                }\n            default:\n                throw new IllegalArgumentException(\"jsonDiff: illegal token '\" + t.getToken() + \"' at pos: \" + t.getLastPos() + ' ' + jsonDiff);\n        }\n    }\n    return continueComparison;\n}", "code_comment": NaN, "code_no_comment": "private boolean dispatch(@Nonnull String jsonDiff, @Nonnull DocumentNodeState base, @Nonnull NodeStateDiff diff) {\n    if (!AbstractNodeState.comparePropertiesAgainstBaseState(this, base, diff)) {\n        return false;\n    }\n    if (jsonDiff.trim().isEmpty()) {\n        return true;\n    }\n    JsopTokenizer t = new JsopTokenizer(jsonDiff);\n    boolean continueComparison = true;\n    while (continueComparison) {\n        int r = t.read();\n        if (r == JsopReader.END) {\n            break;\n        }\n        switch(r) {\n            case '+':\n                {\n                    String path = t.readString();\n                    t.read(':');\n                    t.read('{');\n                    while (t.read() != '}') {\n                                        }\n                    String name = PathUtils.getName(path);\n                    continueComparison = diff.childNodeAdded(name, getChildNode(name));\n                    break;\n                }\n            case '-':\n                {\n                    String path = t.readString();\n                    String name = PathUtils.getName(path);\n                    continueComparison = diff.childNodeDeleted(name, base.getChildNode(name));\n                    break;\n                }\n            case '^':\n                {\n                    String path = t.readString();\n                    t.read(':');\n                    if (t.matches('{')) {\n                        t.read('}');\n                        String name = PathUtils.getName(path);\n                        continueComparison = diff.childNodeChanged(name, base.getChildNode(name), getChildNode(name));\n                    } else if (t.matches('[')) {\n                                                while (t.read() != ']') {\n                                                }\n                    } else {\n                                                t.read();\n                    }\n                    break;\n                }\n            case '>':\n                {\n                    String from = t.readString();\n                    t.read(':');\n                    String to = t.readString();\n                    String fromName = PathUtils.getName(from);\n                    continueComparison = diff.childNodeDeleted(fromName, base.getChildNode(fromName));\n                    if (!continueComparison) {\n                        break;\n                    }\n                    String toName = PathUtils.getName(to);\n                    continueComparison = diff.childNodeAdded(toName, getChildNode(toName));\n                    break;\n                }\n            default:\n                throw new IllegalArgumentException(\"jsonDiff: illegal token '\" + t.getToken() + \"' at pos: \" + t.getLastPos() + ' ' + jsonDiff);\n        }\n    }\n    return continueComparison;\n}", "lc": 2.5, "pi": 1.9489795918367347, "ma": 3.0, "nbd": 2.0, "ml": 1.4166666666666667, "d": 0.8452792881858627, "mi": -1.123315170633783, "fo": 2.5833333333333335, "r": -0.028571428571428574, "e": 2.640655984855299}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5916_def03add", "label": 1, "code": "/**\n *  @see org.apache.wicket.model.IModel#getObject()\n */\n@Override\npublic final T getObject() {\n    if (!attached) {\n        transientModelObject = load();\n        if (log.isDebugEnabled()) {\n            log.debug(\"loaded transient object \" + transientModelObject + \" for \" + this + \", requestCycle \" + RequestCycle.get());\n        }\n        attached = true;\n        onAttach();\n    }\n    return transientModelObject;\n}", "code_comment": "/**\n *  @see org.apache.wicket.model.IModel#getObject()\n */\n", "code_no_comment": "@Override\npublic final T getObject() {\n    if (!attached) {\n        transientModelObject = load();\n        if (log.isDebugEnabled()) {\n            log.debug(\"loaded transient object \" + transientModelObject + \" for \" + this + \", requestCycle \" + RequestCycle.get());\n        }\n        attached = true;\n        onAttach();\n    }\n    return transientModelObject;\n}", "lc": -0.09090909090909091, "pi": 0.3826530612244898, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.13544241225902123, "mi": 0.15486091195870355, "fo": -0.08333333333333333, "r": 1.2857142857142858, "e": -0.10706224489358877}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-5727_ce6f0bfd", "label": 1, "code": "// DefaultProjectBuilder\npublic Artifact createDependencyArtifact(Dependency d) {\n    VersionRange versionRange;\n    try {\n        versionRange = VersionRange.createFromVersionSpec(d.getVersion());\n    } catch (InvalidVersionSpecificationException e) {\n        return null;\n    }\n    Artifact artifact = XcreateDependencyArtifact(d.getGroupId(), d.getArtifactId(), versionRange, d.getType(), d.getClassifier(), d.getScope(), d.isOptional());\n    if (Artifact.SCOPE_SYSTEM.equals(d.getScope()) && d.getSystemPath() != null) {\n        artifact.setFile(new File(d.getSystemPath()));\n    }\n    if (!d.getExclusions().isEmpty()) {\n        List<String> exclusions = new ArrayList<String>();\n        for (Exclusion exclusion : d.getExclusions()) {\n            exclusions.add(exclusion.getGroupId() + ':' + exclusion.getArtifactId());\n        }\n        artifact.setDependencyFilter(new ExcludesArtifactFilter(exclusions));\n    }\n    return artifact;\n}", "code_comment": NaN, "code_no_comment": "public Artifact createDependencyArtifact(Dependency d) {\n    VersionRange versionRange;\n    try {\n        versionRange = VersionRange.createFromVersionSpec(d.getVersion());\n    } catch (InvalidVersionSpecificationException e) {\n        return null;\n    }\n    Artifact artifact = XcreateDependencyArtifact(d.getGroupId(), d.getArtifactId(), versionRange, d.getType(), d.getClassifier(), d.getScope(), d.isOptional());\n    if (Artifact.SCOPE_SYSTEM.equals(d.getScope()) && d.getSystemPath() != null) {\n        artifact.setFile(new File(d.getSystemPath()));\n    }\n    if (!d.getExclusions().isEmpty()) {\n        List<String> exclusions = new ArrayList<String>();\n        for (Exclusion exclusion : d.getExclusions()) {\n            exclusions.add(exclusion.getGroupId() + ':' + exclusion.getArtifactId());\n        }\n        artifact.setDependencyFilter(new ExcludesArtifactFilter(exclusions));\n    }\n    return artifact;\n}", "lc": 0.2727272727272727, "pi": -0.056122448979591774, "ma": 0.16666666666666666, "nbd": 0.0, "ml": 0.16666666666666666, "d": 0.3470093919920911, "mi": -0.29251505592199617, "fo": 1.25, "r": -0.028571428571428574, "e": 0.4724538613420364}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-102_7f391872", "label": 0, "code": "/**\n * Returns the priority value based on the Facility and Log Level.\n * @param facility The Facility.\n * @param level The Level.\n * @return The integer value of the priority.\n */\npublic static int getPriority(Facility facility, Level level) {\n    return facility.getCode() << 3 + Severity.getSeverity(level).getCode();\n}", "code_comment": "/**\n * Returns the priority value based on the Facility and Log Level.\n * @param facility The Facility.\n * @param level The Level.\n * @return The integer value of the priority.\n */\n", "code_no_comment": "public static int getPriority(Facility facility, Level level) {\n    return facility.getCode() << 3 + Severity.getSeverity(level).getCode();\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.12357884330202666, "mi": 0.9159736162890739, "fo": -0.25, "r": 2.628571428571429, "e": -0.1342850167679597}
{"project_name": "Closure", "project_version": 96, "label": 2, "code": "/**\n * Visits the parameters of a CALL or a NEW node.\n */\nprivate void visitParameterList(NodeTraversal t, Node call, FunctionType functionType) {\n    Iterator<Node> arguments = call.children().iterator();\n    // skip the function name\n    arguments.next();\n    Iterator<Node> parameters = functionType.getParameters().iterator();\n    int ordinal = 0;\n    Node parameter = null;\n    Node argument = null;\n    while (arguments.hasNext() && parameters.hasNext()) {\n        // If there are no parameters left in the list, then the while loop\n        // above implies that this must be a var_args function.\n        parameter = parameters.next();\n        argument = arguments.next();\n        ordinal++;\n        validator.expectArgumentMatchesParameter(t, argument, getJSType(argument), getJSType(parameter), call, ordinal);\n    }\n    int numArgs = call.getChildCount() - 1;\n    int minArgs = functionType.getMinArguments();\n    int maxArgs = functionType.getMaxArguments();\n    if (minArgs > numArgs || maxArgs < numArgs) {\n        report(t, call, WRONG_ARGUMENT_COUNT, validator.getReadableJSTypeName(call.getFirstChild(), false), String.valueOf(numArgs), String.valueOf(minArgs), maxArgs != Integer.MAX_VALUE ? \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n    }\n}", "code_comment": "/**\n * Visits the parameters of a CALL or a NEW node.\n */\n", "code_no_comment": "private void visitParameterList(NodeTraversal t, Node call, FunctionType functionType) {\n    Iterator<Node> arguments = call.children().iterator();\n        arguments.next();\n    Iterator<Node> parameters = functionType.getParameters().iterator();\n    int ordinal = 0;\n    Node parameter = null;\n    Node argument = null;\n    while (arguments.hasNext() && parameters.hasNext()) {\n                        parameter = parameters.next();\n        argument = arguments.next();\n        ordinal++;\n        validator.expectArgumentMatchesParameter(t, argument, getJSType(argument), getJSType(parameter), call, ordinal);\n    }\n    int numArgs = call.getChildCount() - 1;\n    int minArgs = functionType.getMinArguments();\n    int maxArgs = functionType.getMaxArguments();\n    if (minArgs > numArgs || maxArgs < numArgs) {\n        report(t, call, WRONG_ARGUMENT_COUNT, validator.getReadableJSTypeName(call.getFirstChild(), false), String.valueOf(numArgs), String.valueOf(minArgs), maxArgs != Integer.MAX_VALUE ? \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n    }\n}", "lc": 0.2727272727272727, "pi": -0.37244897959183676, "ma": 0.0, "nbd": -0.5, "ml": 0.4166666666666667, "d": 1.2189817103311915, "mi": -0.344422139374821, "fo": 1.1666666666666667, "r": -0.028571428571428574, "e": 1.9104809384917834}
{"project_name": "Closure", "project_version": 132, "label": 2, "code": "/**\n * Try turning IF nodes into smaller HOOKs\n *\n * Returns the replacement for n or the original if no replacement was\n * necessary.\n */\nprivate Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n    /* If the condition is a literal, we'll let other\n     * optimizations try to remove useless code.\n     */\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                // until CollapseProperties has been run.\n                return n;\n            }\n            if (cond.isNot()) {\n                // if(!x)bar(); -> x||bar();\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                    // It's not okay to add two sets of parentheses.\n                    return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            // if(x)foo(); -> x&&foo();\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                // we can further optimize its parent.\n                return n;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n            // Try to combine two IF-ELSE\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n                        return n;\n                    }\n                }\n            }\n        }\n        return n;\n    }\n    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n     * peephole optimization. This should probably get moved to another pass.\n     */\n    tryRemoveRepeatedStatements(n);\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n    }\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n        // note - we ignore any cases with \"return;\", technically this\n        // can be converted to \"return undefined;\" or some variant, but\n        // that does not help code size.\n        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == elseOp.getType()) {\n            // if(x)a=1;else a=2; -> a=x?1:2;\n            if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // proceed even if there are side effects...\n                !mayEffectMutableState(lhs)) {\n                    n.removeChild(cond);\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild();\n                    elseOp.removeChild(elseExpr);\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n                    return expr;\n                }\n            }\n        }\n        // if(x)foo();else bar(); -> x?foo():bar()\n        n.removeChild(cond);\n        thenOp.detachFromParent();\n        elseOp.detachFromParent();\n        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n    return n;\n}", "code_comment": "/**\n * Try turning IF nodes into smaller HOOKs\n *\n * Returns the replacement for n or the original if no replacement was\n * necessary.\n */\n", "code_no_comment": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n        if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                                return n;\n            }\n            if (cond.isNot()) {\n                                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                                        return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n                        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                                return n;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n                        if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                                                return n;\n                    }\n                }\n            }\n        }\n        return n;\n    }\n        tryRemoveRepeatedStatements(n);\n        if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n    }\n        if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n                                Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == elseOp.getType()) {\n                        if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&                 !mayEffectMutableState(lhs)) {\n                    n.removeChild(cond);\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild();\n                    elseOp.removeChild(elseExpr);\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n                    return expr;\n                }\n            }\n        }\n                n.removeChild(cond);\n        thenOp.detachFromParent();\n        elseOp.detachFromParent();\n        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n        if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n        } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n    return n;\n}", "lc": 5.7272727272727275, "pi": 1.3214285714285716, "ma": 2.8333333333333335, "nbd": 1.5, "ml": 6.5, "d": 1.729115175481958, "mi": -1.6139948379696019, "fo": 11.75, "r": -0.028571428571428574, "e": 14.799923762533139}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3563_c62b66c1", "label": 1, "code": "/**\n *  Renders a placeholder tag for the component when it is invisible and\n *  {@link #setOutputMarkupPlaceholderTag(boolean)} has been called with <code>true</code>.\n *\n *  @param tag\n *             component tag\n *  @param response\n *             response\n */\nprotected void renderPlaceholderTag(final ComponentTag tag, final Response response) {\n    String ns = Strings.isEmpty(tag.getNamespace()) ? null : tag.getNamespace() + \":\";\n    response.write(\"<\");\n    if (ns != null) {\n        response.write(ns);\n    }\n    response.write(tag.getName());\n    response.write(\" id=\\\"\");\n    response.write(getMarkupId());\n    response.write(\"\\\" style=\\\"display:none\\\"></\");\n    if (ns != null) {\n        response.write(ns);\n    }\n    response.write(tag.getName());\n    response.write(\">\");\n}", "code_comment": "/**\n *  Renders a placeholder tag for the component when it is invisible and\n *  {@link #setOutputMarkupPlaceholderTag(boolean)} has been called with <code>true</code>.\n *\n *  @param tag\n *             component tag\n *  @param response\n *             response\n */\n", "code_no_comment": "protected void renderPlaceholderTag(final ComponentTag tag, final Response response) {\n    String ns = Strings.isEmpty(tag.getNamespace()) ? null : tag.getNamespace() + \":\";\n    response.write(\"<\");\n    if (ns != null) {\n        response.write(ns);\n    }\n    response.write(tag.getName());\n    response.write(\" id=\\\"\");\n    response.write(getMarkupId());\n    response.write(\"\\\" style=\\\"display:none\\\"></\");\n    if (ns != null) {\n        response.write(ns);\n    }\n    response.write(tag.getName());\n    response.write(\">\");\n}", "lc": 0.09090909090909091, "pi": -0.5204081632653061, "ma": 0.0, "nbd": -0.5, "ml": 0.08333333333333333, "d": 0.10380622837370251, "mi": -0.10438772583882998, "fo": 0.75, "r": -0.028571428571428574, "e": 0.08734757860382644}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1496_0a4c7694", "label": 1, "code": "// ------------------------------------------------------------------------\n// Task events\n// ------------------------------------------------------------------------\n@Override\npublic void sendTaskEvent(TaskEvent event) throws IOException, InterruptedException {\n    // remote input channels.\n    synchronized (requestLock) {\n        for (InputChannel inputChannel : inputChannels.values()) {\n            inputChannel.sendTaskEvent(event);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void sendTaskEvent(TaskEvent event) throws IOException, InterruptedException {\n        synchronized (requestLock) {\n        for (InputChannel inputChannel : inputChannels.values()) {\n            inputChannel.sendTaskEvent(event);\n        }\n    }\n}", "lc": -0.2727272727272727, "pi": 0.6071428571428571, "ma": -0.3333333333333333, "nbd": 0.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.4536851161456839, "fo": -0.3333333333333333, "r": 2.5142857142857147, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1183_742960f1", "label": 3, "code": "@Override\npublic String createBatchScanner(ByteBuffer login, String tableName, BatchScanOptions opts) throws TException {\n    try {\n        Connector connector = getConnector(login);\n        int threads = 10;\n        Authorizations auth;\n        if (opts != null && opts.isSetAuthorizations()) {\n            auth = getAuthorizations(opts.authorizations);\n        } else {\n            auth = connector.securityOperations().getUserAuthorizations(connector.whoami());\n        }\n        if (opts != null && opts.threads > 0)\n            threads = opts.threads;\n        BatchScanner scanner = connector.createBatchScanner(tableName, auth, threads);\n        if (opts != null) {\n            if (opts.iterators != null) {\n                for (org.apache.accumulo.proxy.thrift.IteratorSetting iter : opts.iterators) {\n                    IteratorSetting is = new IteratorSetting(iter.getPriority(), iter.getName(), iter.getIteratorClass(), iter.getProperties());\n                    scanner.addScanIterator(is);\n                }\n            }\n            ArrayList<Range> ranges = new ArrayList<Range>();\n            if (opts.ranges == null) {\n                ranges.add(new Range());\n            } else {\n                for (org.apache.accumulo.proxy.thrift.Range range : opts.ranges) {\n                    Range aRange = new Range(range.getStart() == null ? null : Util.fromThrift(range.getStart()), true, range.getStop() == null ? null : Util.fromThrift(range.getStop()), false);\n                    ranges.add(aRange);\n                }\n            }\n            scanner.setRanges(ranges);\n        }\n        UUID uuid = UUID.randomUUID();\n        ScannerPlusIterator spi = new ScannerPlusIterator();\n        spi.scanner = scanner;\n        spi.iterator = scanner.iterator();\n        scannerCache.put(uuid, spi);\n        return uuid.toString();\n    } catch (Exception e) {\n        throw translateException(e);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic String createBatchScanner(ByteBuffer login, String tableName, BatchScanOptions opts) throws TException {\n    try {\n        Connector connector = getConnector(login);\n        int threads = 10;\n        Authorizations auth;\n        if (opts != null && opts.isSetAuthorizations()) {\n            auth = getAuthorizations(opts.authorizations);\n        } else {\n            auth = connector.securityOperations().getUserAuthorizations(connector.whoami());\n        }\n        if (opts != null && opts.threads > 0)\n            threads = opts.threads;\n        BatchScanner scanner = connector.createBatchScanner(tableName, auth, threads);\n        if (opts != null) {\n            if (opts.iterators != null) {\n                for (org.apache.accumulo.proxy.thrift.IteratorSetting iter : opts.iterators) {\n                    IteratorSetting is = new IteratorSetting(iter.getPriority(), iter.getName(), iter.getIteratorClass(), iter.getProperties());\n                    scanner.addScanIterator(is);\n                }\n            }\n            ArrayList<Range> ranges = new ArrayList<Range>();\n            if (opts.ranges == null) {\n                ranges.add(new Range());\n            } else {\n                for (org.apache.accumulo.proxy.thrift.Range range : opts.ranges) {\n                    Range aRange = new Range(range.getStart() == null ? null : Util.fromThrift(range.getStart()), true, range.getStop() == null ? null : Util.fromThrift(range.getStop()), false);\n                    ranges.add(aRange);\n                }\n            }\n            scanner.setRanges(ranges);\n        }\n        UUID uuid = UUID.randomUUID();\n        ScannerPlusIterator spi = new ScannerPlusIterator();\n        spi.scanner = scanner;\n        spi.iterator = scanner.iterator();\n        scannerCache.put(uuid, spi);\n        return uuid.toString();\n    } catch (Exception e) {\n        throw translateException(e);\n    }\n}", "lc": 1.2727272727272727, "pi": 1.0612244897959182, "ma": 1.3333333333333333, "nbd": 1.0, "ml": 0.9166666666666666, "d": 0.49925852694018796, "mi": -0.8250645253799829, "fo": 1.6666666666666667, "r": -0.028571428571428574, "e": 1.8303844852471938}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4309_b4274415", "label": 1, "code": "/**\n *  Convert to object types, returning null if text is null.\n *\n *  @return converted\n *  @throws StringValueConversionException\n */\npublic final Long toOptionalLong() throws StringValueConversionException {\n    return (text == null) ? null : toLongObject();\n}", "code_comment": "/**\n *  Convert to object types, returning null if text is null.\n *\n *  @return converted\n *  @throws StringValueConversionException\n */\n", "code_no_comment": "public final Long toOptionalLong() throws StringValueConversionException {\n    return (text == null) ? null : toLongObject();\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.3333333333333333, "nbd": -1.0, "ml": -0.25, "d": -0.3806228373702422, "mi": 1.012044737596788, "fo": -0.4166666666666667, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4345_4f08e6f2", "label": 1, "code": "private Url decryptUrl(final Request request, final Url encryptedUrl) {\n    if (encryptedUrl.getSegments().isEmpty() && encryptedUrl.getQueryParameters().isEmpty()) {\n        return encryptedUrl;\n    }\n    List<String> encryptedSegments = encryptedUrl.getSegments();\n    if (encryptedSegments.size() < 1) {\n        return null;\n    }\n    Url url = new Url(request.getCharset());\n    try {\n        String encryptedUrlString = encryptedSegments.get(0);\n        if (Strings.isEmpty(encryptedUrlString)) {\n            return null;\n        }\n        String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);\n        if (decryptedUrl == null) {\n            return null;\n        }\n        Url originalUrl = Url.parse(decryptedUrl, request.getCharset());\n        int originalNumberOfSegments = originalUrl.getSegments().size();\n        int encryptedNumberOfSegments = encryptedUrl.getSegments().size();\n        HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);\n        int segNo = 1;\n        for (; segNo < encryptedNumberOfSegments; segNo++) {\n            if (segNo > originalNumberOfSegments || !generator.next().equals(encryptedSegments.get(segNo))) {\n                break;\n            }\n            // unmodified segment\n            url.getSegments().add(originalUrl.getSegments().get(segNo - 1));\n        }\n        for (; segNo < encryptedNumberOfSegments; segNo++) {\n            // modified or additional segment\n            url.getSegments().add(encryptedUrl.getSegments().get(segNo));\n        }\n        url.getQueryParameters().addAll(originalUrl.getQueryParameters());\n    } catch (Exception e) {\n        log.error(\"Error decrypting URL\", e);\n        url = null;\n    }\n    return url;\n}", "code_comment": NaN, "code_no_comment": "private Url decryptUrl(final Request request, final Url encryptedUrl) {\n    if (encryptedUrl.getSegments().isEmpty() && encryptedUrl.getQueryParameters().isEmpty()) {\n        return encryptedUrl;\n    }\n    List<String> encryptedSegments = encryptedUrl.getSegments();\n    if (encryptedSegments.size() < 1) {\n        return null;\n    }\n    Url url = new Url(request.getCharset());\n    try {\n        String encryptedUrlString = encryptedSegments.get(0);\n        if (Strings.isEmpty(encryptedUrlString)) {\n            return null;\n        }\n        String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);\n        if (decryptedUrl == null) {\n            return null;\n        }\n        Url originalUrl = Url.parse(decryptedUrl, request.getCharset());\n        int originalNumberOfSegments = originalUrl.getSegments().size();\n        int encryptedNumberOfSegments = encryptedUrl.getSegments().size();\n        HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);\n        int segNo = 1;\n        for (; segNo < encryptedNumberOfSegments; segNo++) {\n            if (segNo > originalNumberOfSegments || !generator.next().equals(encryptedSegments.get(segNo))) {\n                break;\n            }\n                        url.getSegments().add(originalUrl.getSegments().get(segNo - 1));\n        }\n        for (; segNo < encryptedNumberOfSegments; segNo++) {\n                        url.getSegments().add(encryptedUrl.getSegments().get(segNo));\n        }\n        url.getQueryParameters().addAll(originalUrl.getQueryParameters());\n    } catch (Exception e) {\n        log.error(\"Error decrypting URL\", e);\n        url = null;\n    }\n    return url;\n}", "lc": 1.1363636363636365, "pi": 0.15816326530612249, "ma": 1.0, "nbd": 0.5, "ml": 1.25, "d": 1.7745921898171038, "mi": -0.7238313736736455, "fo": 2.1666666666666665, "r": -0.028571428571428574, "e": 3.2433474244156915}
{"project_name": "Math", "project_version": 18, "label": 1, "code": "/**\n * @param x Original objective variables.\n * @return the normalized objective variables.\n */\npublic double[] encode(final double[] x) {\n    if (boundaries == null) {\n        return x;\n    }\n    double[] res = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        double diff = boundaries[1][i] - boundaries[0][i];\n        res[i] = (x[i] - boundaries[0][i]) / diff;\n    }\n    return res;\n}", "code_comment": "/**\n * @param x Original objective variables.\n * @return the normalized objective variables.\n */\n", "code_no_comment": "public double[] encode(final double[] x) {\n    if (boundaries == null) {\n        return x;\n    }\n    double[] res = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        double diff = boundaries[1][i] - boundaries[0][i];\n        res[i] = (x[i] - boundaries[0][i]) / diff;\n    }\n    return res;\n}", "lc": -0.13636363636363635, "pi": -0.17857142857142863, "ma": -0.16666666666666666, "nbd": -0.5, "ml": 0.0, "d": 1.2901631240731588, "mi": 0.12962431889876677, "fo": -0.5, "r": 2.0571428571428574, "e": 0.4426141741726307}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5707_3f70d612", "label": 3, "code": "/**\n * Sets a condition when tne <tt>n'th</tt> (by index) {@link Exchange} is done being processed.\n * <p/>\n * The difference between <i>done</i> and <i>completed</i> is that done can also include failed\n * messages, where as completed is only successful processed messages.\n *\n * @param index the message by index to be done\n * @return the builder\n */\npublic NotifyBuilder whenDoneByIndex(final int index) {\n    stack.add(new EventPredicateSupport() {\n\n        private AtomicInteger current = new AtomicInteger();\n\n        private String id;\n\n        private AtomicBoolean done = new AtomicBoolean();\n\n        @Override\n        public boolean onExchangeCreated(Exchange exchange) {\n            if (current.get() == index) {\n                id = exchange.getExchangeId();\n            }\n            current.incrementAndGet();\n            return true;\n        }\n\n        @Override\n        public boolean onExchangeCompleted(Exchange exchange) {\n            if (exchange.getExchangeId().equals(id)) {\n                done.set(false);\n            }\n            return true;\n        }\n\n        @Override\n        public boolean onExchangeFailed(Exchange exchange) {\n            if (exchange.getExchangeId().equals(id)) {\n                done.set(true);\n            }\n            return true;\n        }\n\n        public boolean matches() {\n            return done.get();\n        }\n\n        @Override\n        public void reset() {\n            current.set(0);\n            id = null;\n            done.set(false);\n        }\n\n        @Override\n        public String toString() {\n            return \"whenDoneByIndex(\" + index + \")\";\n        }\n    });\n    return this;\n}", "code_comment": "/**\n * Sets a condition when tne <tt>n'th</tt> (by index) {@link Exchange} is done being processed.\n * <p/>\n * The difference between <i>done</i> and <i>completed</i> is that done can also include failed\n * messages, where as completed is only successful processed messages.\n *\n * @param index the message by index to be done\n * @return the builder\n */\n", "code_no_comment": "public NotifyBuilder whenDoneByIndex(final int index) {\n    stack.add(new EventPredicateSupport() {\n\n        private AtomicInteger current = new AtomicInteger();\n\n        private String id;\n\n        private AtomicBoolean done = new AtomicBoolean();\n\n        @Override\n        public boolean onExchangeCreated(Exchange exchange) {\n            if (current.get() == index) {\n                id = exchange.getExchangeId();\n            }\n            current.incrementAndGet();\n            return true;\n        }\n\n        @Override\n        public boolean onExchangeCompleted(Exchange exchange) {\n            if (exchange.getExchangeId().equals(id)) {\n                done.set(false);\n            }\n            return true;\n        }\n\n        @Override\n        public boolean onExchangeFailed(Exchange exchange) {\n            if (exchange.getExchangeId().equals(id)) {\n                done.set(true);\n            }\n            return true;\n        }\n\n        public boolean matches() {\n            return done.get();\n        }\n\n        @Override\n        public void reset() {\n            current.set(0);\n            id = null;\n            done.set(false);\n        }\n\n        @Override\n        public String toString() {\n            return \"whenDoneByIndex(\" + index + \")\";\n        }\n    });\n    return this;\n}", "lc": 1.3181818181818181, "pi": 0.26020408163265296, "ma": 0.0, "nbd": 0.0, "ml": 0.16666666666666666, "d": 0.044488383588729634, "mi": -0.6392314310295386, "fo": 0.5833333333333334, "r": -0.028571428571428574, "e": 0.2026032096830149}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2812_e494c279", "label": 3, "code": "public static <X, K> KeySelector<X, K> getSelectorForOneKey(Keys<X> keys, Partitioner<K> partitioner, TypeInformation<X> typeInfo, ExecutionConfig executionConfig) {\n    if (partitioner != null) {\n        keys.validateCustomPartitioner(partitioner, null);\n    }\n    int[] logicalKeyPositions = keys.computeLogicalKeyPositions();\n    if (logicalKeyPositions.length != 1) {\n        throw new IllegalArgumentException(\"There must be exactly 1 key specified\");\n    }\n    TypeComparator<X> comparator = ((CompositeType<X>) typeInfo).createComparator(logicalKeyPositions, new boolean[1], 0, executionConfig);\n    return new OneKeySelector<X, K>(comparator);\n}", "code_comment": NaN, "code_no_comment": "public static <X, K> KeySelector<X, K> getSelectorForOneKey(Keys<X> keys, Partitioner<K> partitioner, TypeInformation<X> typeInfo, ExecutionConfig executionConfig) {\n    if (partitioner != null) {\n        keys.validateCustomPartitioner(partitioner, null);\n    }\n    int[] logicalKeyPositions = keys.computeLogicalKeyPositions();\n    if (logicalKeyPositions.length != 1) {\n        throw new IllegalArgumentException(\"There must be exactly 1 key specified\");\n    }\n    TypeComparator<X> comparator = ((CompositeType<X>) typeInfo).createComparator(logicalKeyPositions, new boolean[1], 0, executionConfig);\n    return new OneKeySelector<X, K>(comparator);\n}", "lc": -0.13636363636363635, "pi": -0.3112244897959183, "ma": 0.0, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.03657933761739987, "mi": 0.06481215944938318, "fo": -0.25, "r": -0.028571428571428574, "e": 0.020489889969633492}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6667_1fc7bd7a", "label": 1, "code": "public void done(boolean doneSync) {\n    // we only have to handle async completion of the routing slip\n    if (doneSync) {\n        return;\n    }\n    Exchange target = exchange;\n    // increment index as we have just processed once\n    index.getAndIncrement();\n    // continue looping asynchronously\n    while (index.get() < count.get()) {\n        // and prepare for next iteration\n        target = prepareExchange(exchange, index.get());\n        // process again\n        boolean sync = process(target, callback, index, count);\n        if (!sync) {\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", target.getExchangeId());\n            // so we break out now, then the callback will be invoked which then continue routing from where we left here\n            return;\n        }\n        // increment counter before next loop\n        index.getAndIncrement();\n    }\n    // we are done so prepare the result\n    ExchangeHelper.copyResults(exchange, target);\n    LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n    callback.done(false);\n}", "code_comment": NaN, "code_no_comment": "public void done(boolean doneSync) {\n        if (doneSync) {\n        return;\n    }\n    Exchange target = exchange;\n        index.getAndIncrement();\n        while (index.get() < count.get()) {\n                target = prepareExchange(exchange, index.get());\n                boolean sync = process(target, callback, index, count);\n        if (!sync) {\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", target.getExchangeId());\n                        return;\n        }\n                index.getAndIncrement();\n    }\n        ExchangeHelper.copyResults(exchange, target);\n    LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n    callback.done(false);\n}", "lc": 0.22727272727272727, "pi": 0.12244897959183662, "ma": 0.0, "nbd": 0.0, "ml": 0.16666666666666666, "d": 0.024715768660405344, "mi": -0.1795239460854605, "fo": 0.5833333333333334, "r": -0.028571428571428574, "e": 0.039189484369177796}
{"project_name": "JxPath", "project_version": 13, "label": 1, "code": "public NodePointer createAttribute(JXPathContext context, QName name) {\n    if (!(node instanceof Element)) {\n        return super.createAttribute(context, name);\n    }\n    Element element = (Element) node;\n    String prefix = name.getPrefix();\n    if (prefix != null) {\n        String ns = getNamespaceURI(prefix);\n        if (ns == null) {\n            throw new JXPathException(\"Unknown namespace prefix: \" + prefix);\n        }\n        element.setAttributeNS(ns, name.toString(), \"\");\n    } else {\n        if (!element.hasAttribute(name.getName())) {\n            element.setAttribute(name.getName(), \"\");\n        }\n    }\n    NodeIterator it = attributeIterator(name);\n    it.setPosition(1);\n    return it.getNodePointer();\n}", "code_comment": NaN, "code_no_comment": "public NodePointer createAttribute(JXPathContext context, QName name) {\n    if (!(node instanceof Element)) {\n        return super.createAttribute(context, name);\n    }\n    Element element = (Element) node;\n    String prefix = name.getPrefix();\n    if (prefix != null) {\n        String ns = getNamespaceURI(prefix);\n        if (ns == null) {\n            throw new JXPathException(\"Unknown namespace prefix: \" + prefix);\n        }\n        element.setAttributeNS(ns, name.toString(), \"\");\n    } else {\n        if (!element.hasAttribute(name.getName())) {\n            element.setAttribute(name.getName(), \"\");\n        }\n    }\n    NodeIterator it = attributeIterator(name);\n    it.setPosition(1);\n    return it.getNodePointer();\n}", "lc": 0.3181818181818182, "pi": 0.0714285714285715, "ma": 0.3333333333333333, "nbd": 0.0, "ml": 0.3333333333333333, "d": 0.3450321304992586, "mi": -0.2907943791224549, "fo": 0.5, "r": -0.028571428571428574, "e": 0.3513048170943246}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1008_0c20bfd8", "label": 1, "code": "/**\n * Will be called repeatedly with candidate classes. Must return True if a class\n * is to be included in the results, false otherwise.\n * @param type The Class to match against.\n * @return true if the Class matches.\n */\nboolean matches(Class<?> type);", "code_comment": "/**\n * Will be called repeatedly with candidate classes. Must return True if a class\n * is to be included in the results, false otherwise.\n * @param type The Class to match against.\n * @return true if the Class matches.\n */\n", "code_no_comment": "boolean matches(Class<?> type);", "lc": -0.5909090909090909, "pi": -1.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.7106395182104968, "fo": -0.5, "r": 2.8000000000000003, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6447_020c451a", "label": 1, "code": "protected boolean continueRouting(Iterator<Processor> it, Exchange exchange) {\n    boolean answer = it.hasNext();\n    if (answer) {\n        Object matched = exchange.getProperty(Exchange.FILTER_MATCHED);\n        if (matched != null) {\n            boolean hasMatched = exchange.getContext().getTypeConverter().convertTo(Boolean.class, matched);\n            if (hasMatched) {\n                LOG.debug(\"ExchangeId: {} has been matched: {}\", exchange.getExchangeId(), exchange);\n                answer = false;\n            }\n        }\n    }\n    LOG.trace(\"ExchangeId: {} should continue matching: {}\", exchange.getExchangeId(), answer);\n    return answer;\n}", "code_comment": NaN, "code_no_comment": "protected boolean continueRouting(Iterator<Processor> it, Exchange exchange) {\n    boolean answer = it.hasNext();\n    if (answer) {\n        Object matched = exchange.getProperty(Exchange.FILTER_MATCHED);\n        if (matched != null) {\n            boolean hasMatched = exchange.getContext().getTypeConverter().convertTo(Boolean.class, matched);\n            if (hasMatched) {\n                LOG.debug(\"ExchangeId: {} has been matched: {}\", exchange.getExchangeId(), exchange);\n                answer = false;\n            }\n        }\n    }\n    LOG.trace(\"ExchangeId: {} should continue matching: {}\", exchange.getExchangeId(), answer);\n    return answer;\n}", "lc": 0.045454545454545456, "pi": 1.0255102040816328, "ma": 0.0, "nbd": 0.5, "ml": 0.08333333333333333, "d": -0.06030647553138898, "mi": -0.0656724978491542, "fo": 0.25, "r": -0.028571428571428574, "e": -0.007902141930178469}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-554_3f51fb09", "label": 1, "code": "/**\n * Create a {@code PropertyState} based on a {@link Value}. The\n * {@link Type} of the property state is determined by the\n * type of the value.\n * @param name  The name of the property state\n * @param value  The value of the property state\n * @return  The new property state\n * @throws RepositoryException forwarded from {@code value}\n */\n@Nonnull\npublic static PropertyState createProperty(String name, Value value) throws RepositoryException {\n    int type = value.getType();\n    switch(type) {\n        case PropertyType.STRING:\n            return StringPropertyState.stringProperty(name, value.getString());\n        case PropertyType.BINARY:\n            return BinaryPropertyState.binaryProperty(name, value);\n        case PropertyType.LONG:\n            return LongPropertyState.createLongProperty(name, value.getLong());\n        case PropertyType.DOUBLE:\n            return DoublePropertyState.doubleProperty(name, value.getDouble());\n        case PropertyType.DATE:\n            return LongPropertyState.createDateProperty(name, value.getLong());\n        case PropertyType.BOOLEAN:\n            return BooleanPropertyState.booleanProperty(name, value.getBoolean());\n        case PropertyType.DECIMAL:\n            return DecimalPropertyState.decimalProperty(name, value.getDecimal());\n        default:\n            return new GenericPropertyState(name, value.getString(), Type.fromTag(type, false));\n    }\n}", "code_comment": "/**\n * Create a {@code PropertyState} based on a {@link Value}. The\n * {@link Type} of the property state is determined by the\n * type of the value.\n * @param name  The name of the property state\n * @param value  The value of the property state\n * @return  The new property state\n * @throws RepositoryException forwarded from {@code value}\n */\n", "code_no_comment": "@Nonnull\npublic static PropertyState createProperty(String name, Value value) throws RepositoryException {\n    int type = value.getType();\n    switch(type) {\n        case PropertyType.STRING:\n            return StringPropertyState.stringProperty(name, value.getString());\n        case PropertyType.BINARY:\n            return BinaryPropertyState.binaryProperty(name, value);\n        case PropertyType.LONG:\n            return LongPropertyState.createLongProperty(name, value.getLong());\n        case PropertyType.DOUBLE:\n            return DoublePropertyState.doubleProperty(name, value.getDouble());\n        case PropertyType.DATE:\n            return LongPropertyState.createDateProperty(name, value.getLong());\n        case PropertyType.BOOLEAN:\n            return BooleanPropertyState.booleanProperty(name, value.getBoolean());\n        case PropertyType.DECIMAL:\n            return DecimalPropertyState.decimalProperty(name, value.getDecimal());\n        default:\n            return new GenericPropertyState(name, value.getString(), Type.fromTag(type, false));\n    }\n}", "lc": 0.36363636363636365, "pi": 0.5459183673469387, "ma": 0.8333333333333334, "nbd": 0.0, "ml": 0.25, "d": -0.3806228373702422, "mi": -0.3530255233725267, "fo": 0.8333333333333334, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5484_ecdfc124", "label": 1, "code": "/**\n *  Should the page be rendered immediately.\n */\nprotected boolean shouldRenderPageAndWriteResponse(RequestCycle cycle, Url currentUrl, Url targetUrl) {\n    return neverRedirect(getRedirectPolicy()) || (!isAjax(cycle) && ((isOnePassRender() && notForcedRedirect(getRedirectPolicy())) || (targetUrl.equals(currentUrl) && notNewAndNotStatelessPage(isNewPageInstance(), isPageStateless())))) || (targetUrl.equals(currentUrl) && isRedirectToRender()) || shouldPreserveClientUrl(cycle);\n}", "code_comment": "/**\n *  Should the page be rendered immediately.\n */\n", "code_no_comment": "protected boolean shouldRenderPageAndWriteResponse(RequestCycle cycle, Url currentUrl, Url targetUrl) {\n    return neverRedirect(getRedirectPolicy()) || (!isAjax(cycle) && ((isOnePassRender() && notForcedRedirect(getRedirectPolicy())) || (targetUrl.equals(currentUrl) && notNewAndNotStatelessPage(isNewPageInstance(), isPageStateless())))) || (targetUrl.equals(currentUrl) && isRedirectToRender()) || shouldPreserveClientUrl(cycle);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.08403361344537813, "mi": 0.7636937195296818, "fo": 0.5833333333333334, "r": 2.7142857142857144, "e": -0.06828392888500563}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd", "label": 1, "code": "@Override\npublic IndexRow next() {\n    final IndexRow r = c.next();\n    return new IndexRow() {\n\n        @Override\n        public String getPath() {\n            String sub = r.getPath();\n            if (PathUtils.isAbsolute(sub)) {\n                return path + sub;\n            } else {\n                return PathUtils.concat(path, r.getPath());\n            }\n        }\n\n        @Override\n        public PropertyValue getValue(String columnName) {\n            return r.getValue(columnName);\n        }\n    };\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic IndexRow next() {\n    final IndexRow r = c.next();\n    return new IndexRow() {\n\n        @Override\n        public String getPath() {\n            String sub = r.getPath();\n            if (PathUtils.isAbsolute(sub)) {\n                return path + sub;\n            } else {\n                return PathUtils.concat(path, r.getPath());\n            }\n        }\n\n        @Override\n        public PropertyValue getValue(String columnName) {\n            return r.getValue(columnName);\n        }\n    };\n}", "lc": 0.22727272727272727, "pi": 0.9387755102040818, "ma": -0.3333333333333333, "nbd": 0.0, "ml": -0.16666666666666666, "d": 0.03855659911023239, "mi": -0.1052480642386006, "fo": 0.0, "r": 1.1428571428571428, "e": -0.02380493487692788}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4932_f20b2d70", "label": 1, "code": "/**\n *  Creates a {@code IRequestHandler} that processes a hybrid request. When the page identified\n *  by {@code pageInfo} was not available, the request should be treated as a bookmarkable\n *  request.\n *\n *  @param pageInfo\n *  @param pageClass\n *  @param pageParameters\n *  @param renderCount\n *  @return a {@code IRequestHandler} capable of processing the hybrid request.\n */\nprotected IRequestHandler processHybrid(PageInfo pageInfo, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters, Integer renderCount) {\n    PageProvider provider = new PageProvider(pageInfo.getPageId(), pageClass, pageParameters, renderCount);\n    provider.setPageSource(getContext());\n    return new RenderPageRequestHandler(provider);\n}", "code_comment": "/**\n *  Creates a {@code IRequestHandler} that processes a hybrid request. When the page identified\n *  by {@code pageInfo} was not available, the request should be treated as a bookmarkable\n *  request.\n *\n *  @param pageInfo\n *  @param pageClass\n *  @param pageParameters\n *  @param renderCount\n *  @return a {@code IRequestHandler} capable of processing the hybrid request.\n */\n", "code_no_comment": "protected IRequestHandler processHybrid(PageInfo pageInfo, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters, Integer renderCount) {\n    PageProvider provider = new PageProvider(pageInfo.getPageId(), pageClass, pageParameters, renderCount);\n    provider.setPageSource(getContext());\n    return new RenderPageRequestHandler(provider);\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.571264697447663, "fo": -0.25, "r": 1.2285714285714286, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5", "label": 3, "code": "public boolean equals(update_result that) {\n    if (that == null)\n        return false;\n    boolean this_present_ouch1 = true && this.isSetOuch1();\n    boolean that_present_ouch1 = true && that.isSetOuch1();\n    if (this_present_ouch1 || that_present_ouch1) {\n        if (!(this_present_ouch1 && that_present_ouch1))\n            return false;\n        if (!this.ouch1.equals(that.ouch1))\n            return false;\n    }\n    boolean this_present_ouch2 = true && this.isSetOuch2();\n    boolean that_present_ouch2 = true && that.isSetOuch2();\n    if (this_present_ouch2 || that_present_ouch2) {\n        if (!(this_present_ouch2 && that_present_ouch2))\n            return false;\n        if (!this.ouch2.equals(that.ouch2))\n            return false;\n    }\n    return true;\n}", "code_comment": NaN, "code_no_comment": "public boolean equals(update_result that) {\n    if (that == null)\n        return false;\n    boolean this_present_ouch1 = true && this.isSetOuch1();\n    boolean that_present_ouch1 = true && that.isSetOuch1();\n    if (this_present_ouch1 || that_present_ouch1) {\n        if (!(this_present_ouch1 && that_present_ouch1))\n            return false;\n        if (!this.ouch1.equals(that.ouch1))\n            return false;\n    }\n    boolean this_present_ouch2 = true && this.isSetOuch2();\n    boolean that_present_ouch2 = true && that.isSetOuch2();\n    if (this_present_ouch2 || that_present_ouch2) {\n        if (!(this_present_ouch2 && that_present_ouch2))\n            return false;\n        if (!this.ouch2.equals(that.ouch2))\n            return false;\n    }\n    return true;\n}", "lc": 0.3181818181818182, "pi": 0.3061224489795919, "ma": 0.6666666666666666, "nbd": -0.5, "ml": 1.25, "d": 0.726643598615917, "mi": -0.26641812446228874, "fo": 0.0, "r": -0.028571428571428574, "e": 0.4473725913457626}
{"project_name": "Closure", "project_version": 37, "label": 2, "code": "/**\n * Traverses a function.\n */\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        traverseBranch(fnName, n);\n    }\n    curNode = n;\n    pushScope(n);\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        traverseBranch(fnName, n);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    popScope();\n}", "code_comment": "/**\n * Traverses a function.\n */\n", "code_no_comment": "private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n                traverseBranch(fnName, n);\n    }\n    curNode = n;\n    pushScope(n);\n    if (isFunctionExpression) {\n                        traverseBranch(fnName, n);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n        traverseBranch(args, n);\n        Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    popScope();\n}", "lc": 0.2727272727272727, "pi": -0.6275510204081632, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.16666666666666666, "d": 0.633712308452793, "mi": -0.2520791511327791, "fo": 0.9166666666666666, "r": 0.2571428571428572, "e": 0.5752202534681623}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8954_7b1253db", "label": 3, "code": "@Override\npublic boolean acquireExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {\n    if (!markerFile) {\n        // if not using marker file then we assume acquired\n        return true;\n    }\n    String lockFileName = getLockFileName(file);\n    LOG.trace(\"Locking the file: {} using the lock file name: {}\", file, lockFileName);\n    // create a plain file as marker filer for locking (do not use FileLock)\n    boolean acquired = FileUtil.createNewFile(new File(lockFileName));\n    exchange.setProperty(Exchange.FILE_LOCK_FILE_ACQUIRED, acquired);\n    exchange.setProperty(Exchange.FILE_LOCK_FILE_NAME, lockFileName);\n    return acquired;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean acquireExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {\n    if (!markerFile) {\n                return true;\n    }\n    String lockFileName = getLockFileName(file);\n    LOG.trace(\"Locking the file: {} using the lock file name: {}\", file, lockFileName);\n        boolean acquired = FileUtil.createNewFile(new File(lockFileName));\n    exchange.setProperty(Exchange.FILE_LOCK_FILE_ACQUIRED, acquired);\n    exchange.setProperty(Exchange.FILE_LOCK_FILE_NAME, lockFileName);\n    return acquired;\n}", "lc": -0.09090909090909091, "pi": -0.413265306122449, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.07217004448838356, "mi": 0.0696874103814165, "fo": -0.08333333333333333, "r": -0.028571428571428574, "e": -0.030794797007036967}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-4387_ca05fd06", "label": 1, "code": "private Statement convertToStatement(String query) throws ParseException {\n    query = query.trim();\n    Statement statement = new Statement();\n    if (query.startsWith(\"explain \")) {\n        query = query.substring(\"explain\".length()).trim();\n        statement.setExplain(true);\n    }\n    if (query.startsWith(\"measure\")) {\n        query = query.substring(\"measure\".length()).trim();\n        statement.setMeasure(true);\n    }\n    if (query.isEmpty()) {\n        // special case, will always result in an empty result\n        query = \"//jcr:root\";\n    }\n    statement.setOriginalQuery(query);\n    initialize(query);\n    expected = new ArrayList<String>();\n    read();\n    if (currentTokenType == END) {\n        throw getSyntaxError(\"the query may not be empty\");\n    }\n    currentSelector.name = \"a\";\n    String pathPattern = \"\";\n    boolean startOfQuery = true;\n    while (true) {\n        // if true, path or nodeType conditions are not allowed\n        boolean shortcut = false;\n        boolean slash = readIf(\"/\");\n        if (!slash) {\n            if (startOfQuery) {\n                // the query doesn't start with \"/\"\n                currentSelector.path = \"/\";\n                pathPattern = \"/\";\n                currentSelector.isChild = true;\n            } else {\n                break;\n            }\n        } else if (readIf(\"jcr:root\")) {\n            // \"/jcr:root\" may only appear at the beginning\n            if (!pathPattern.isEmpty()) {\n                throw getSyntaxError(\"jcr:root needs to be at the beginning\");\n            }\n            if (readIf(\"/\")) {\n                // \"/jcr:root/\"\n                currentSelector.path = \"/\";\n                pathPattern = \"/\";\n                if (readIf(\"/\")) {\n                    // \"/jcr:root//\"\n                    pathPattern = \"//\";\n                    currentSelector.isDescendant = true;\n                } else {\n                    currentSelector.isChild = true;\n                }\n            } else {\n                // for example \"/jcr:root[condition]\"\n                pathPattern = \"/%\";\n                currentSelector.path = \"/\";\n                shortcut = true;\n            }\n        } else if (readIf(\"/\")) {\n            // \"//\" was read\n            pathPattern += \"%\";\n            if (currentSelector.isDescendant) {\n                // the query started with \"//\", and now \"//\" was read\n                nextSelector(true);\n            }\n            currentSelector.isDescendant = true;\n        } else {\n            // the token \"/\" was read\n            pathPattern += \"/\";\n            if (startOfQuery) {\n                currentSelector.path = \"/\";\n            } else {\n                if (currentSelector.isDescendant) {\n                    // the query started with \"//\", and now \"/\" was read\n                    nextSelector(true);\n                }\n                currentSelector.isChild = true;\n            }\n        }\n        int startParseIndex = parseIndex;\n        if (shortcut) {\n        // \"*\" and so on are not allowed now\n        } else if (readIf(\"*\")) {\n            // \"...*\"\n            pathPattern += \"%\";\n            if (!currentSelector.isDescendant) {\n                if (selectors.size() == 0 && currentSelector.path.equals(\"\")) {\n                    // the query /* is special\n                    currentSelector.path = \"/\";\n                }\n            }\n        } else if (readIf(\"text\")) {\n            // \"...text()\"\n            currentSelector.isChild = false;\n            pathPattern += \"jcr:xmltext\";\n            read(\"(\");\n            read(\")\");\n            if (currentSelector.isDescendant) {\n                currentSelector.nodeName = \"jcr:xmltext\";\n            } else {\n                currentSelector.path = PathUtils.concat(currentSelector.path, \"jcr:xmltext\");\n            }\n        } else if (readIf(\"element\")) {\n            // \"...element(...\"\n            read(\"(\");\n            if (readIf(\")\")) {\n                // any\n                pathPattern += \"%\";\n            } else {\n                if (readIf(\"*\")) {\n                    // any\n                    pathPattern += \"%\";\n                } else {\n                    String name = readPathSegment();\n                    pathPattern += name;\n                    appendNodeName(name);\n                }\n                if (readIf(\",\")) {\n                    currentSelector.nodeType = readIdentifier();\n                }\n                read(\")\");\n            }\n        } else if (readIf(\"@\")) {\n            rewindSelector();\n            Expression.Property p = readProperty();\n            statement.addSelectColumn(p);\n        } else if (readIf(\"rep:excerpt\")) {\n            rewindSelector();\n            readExcerpt();\n            Expression.Property p = new Expression.Property(currentSelector, \"rep:excerpt\", false);\n            statement.addSelectColumn(p);\n        } else if (readIf(\"(\")) {\n            rewindSelector();\n            do {\n                if (readIf(\"@\")) {\n                    Expression.Property p = readProperty();\n                    statement.addSelectColumn(p);\n                } else if (readIf(\"rep:excerpt\")) {\n                    readExcerpt();\n                    Expression.Property p = new Expression.Property(currentSelector, \"rep:excerpt\", false);\n                    statement.addSelectColumn(p);\n                } else if (readIf(\"rep:spellcheck\")) {\n                    // only rep:spellcheck() is currently supported\n                    read(\"(\");\n                    read(\")\");\n                    Expression.Property p = new Expression.Property(currentSelector, \"rep:spellcheck()\", false);\n                    statement.addSelectColumn(p);\n                } else if (readIf(\"rep:suggest\")) {\n                    readExcerpt();\n                    Expression.Property p = new Expression.Property(currentSelector, \"rep:suggest()\", false);\n                    statement.addSelectColumn(p);\n                }\n            } while (readIf(\"|\"));\n            if (!readIf(\")\")) {\n                return convertToUnion(query, statement, startParseIndex - 1);\n            }\n        } else if (currentTokenType == IDENTIFIER) {\n            // path restriction\n            String name = readPathSegment();\n            pathPattern += name;\n            appendNodeName(name);\n        } else if (readIf(\".\")) {\n            // \"a/./b\" is the same as \"a/b\"\n            if (readIf(\".\")) {\n                // \"..\" means \"the parent of the node\"\n                // handle like a regular path restriction\n                String name = \"..\";\n                pathPattern += name;\n                if (!currentSelector.isChild) {\n                    currentSelector.nodeName = name;\n                } else {\n                    if (currentSelector.isChild) {\n                        currentSelector.isChild = false;\n                        currentSelector.isParent = true;\n                    }\n                }\n            } else {\n                if (selectors.size() > 0) {\n                    currentSelector = selectors.remove(selectors.size() - 1);\n                    currentSelector.condition = null;\n                    currentSelector.joinCondition = null;\n                }\n            }\n        } else {\n            throw getSyntaxError();\n        }\n        if (readIf(\"[\")) {\n            Expression c = parseConstraint();\n            currentSelector.condition = Expression.and(currentSelector.condition, c);\n            read(\"]\");\n        }\n        startOfQuery = false;\n        nextSelector(false);\n    }\n    if (selectors.size() == 0) {\n        nextSelector(true);\n    }\n    // the current selector wasn't used so far\n    // go back to the last one\n    currentSelector = selectors.get(selectors.size() - 1);\n    if (selectors.size() == 1) {\n        currentSelector.onlySelector = true;\n    }\n    if (readIf(\"order\")) {\n        read(\"by\");\n        do {\n            Order order = new Order();\n            order.expr = parseExpression();\n            if (readIf(\"descending\")) {\n                order.descending = true;\n            } else {\n                readIf(\"ascending\");\n            }\n            statement.addOrderBy(order);\n        } while (readIf(\",\"));\n    }\n    if (!currentToken.isEmpty()) {\n        throw getSyntaxError(\"<end>\");\n    }\n    statement.setColumnSelector(currentSelector);\n    statement.setSelectors(selectors);\n    Expression where = null;\n    for (Selector s : selectors) {\n        where = Expression.and(where, s.condition);\n    }\n    statement.setWhere(where);\n    return statement;\n}", "code_comment": NaN, "code_no_comment": "private Statement convertToStatement(String query) throws ParseException {\n    query = query.trim();\n    Statement statement = new Statement();\n    if (query.startsWith(\"explain \")) {\n        query = query.substring(\"explain\".length()).trim();\n        statement.setExplain(true);\n    }\n    if (query.startsWith(\"measure\")) {\n        query = query.substring(\"measure\".length()).trim();\n        statement.setMeasure(true);\n    }\n    if (query.isEmpty()) {\n                query = \"//jcr:root\";\n    }\n    statement.setOriginalQuery(query);\n    initialize(query);\n    expected = new ArrayList<String>();\n    read();\n    if (currentTokenType == END) {\n        throw getSyntaxError(\"the query may not be empty\");\n    }\n    currentSelector.name = \"a\";\n    String pathPattern = \"\";\n    boolean startOfQuery = true;\n    while (true) {\n                boolean shortcut = false;\n        boolean slash = readIf(\"/\");\n        if (!slash) {\n            if (startOfQuery) {\n                                currentSelector.path = \"/\";\n                pathPattern = \"/\";\n                currentSelector.isChild = true;\n            } else {\n                break;\n            }\n        } else if (readIf(\"jcr:root\")) {\n                        if (!pathPattern.isEmpty()) {\n                throw getSyntaxError(\"jcr:root needs to be at the beginning\");\n            }\n            if (readIf(\"/\")) {\n                                currentSelector.path = \"/\";\n                pathPattern = \"/\";\n                if (readIf(\"/\")) {\n                                        pathPattern = \"//\";\n                    currentSelector.isDescendant = true;\n                } else {\n                    currentSelector.isChild = true;\n                }\n            } else {\n                                pathPattern = \"/%\";\n                currentSelector.path = \"/\";\n                shortcut = true;\n            }\n        } else if (readIf(\"/\")) {\n                        pathPattern += \"%\";\n            if (currentSelector.isDescendant) {\n                                nextSelector(true);\n            }\n            currentSelector.isDescendant = true;\n        } else {\n                        pathPattern += \"/\";\n            if (startOfQuery) {\n                currentSelector.path = \"/\";\n            } else {\n                if (currentSelector.isDescendant) {\n                                        nextSelector(true);\n                }\n                currentSelector.isChild = true;\n            }\n        }\n        int startParseIndex = parseIndex;\n        if (shortcut) {\n                } else if (readIf(\"*\")) {\n                        pathPattern += \"%\";\n            if (!currentSelector.isDescendant) {\n                if (selectors.size() == 0 && currentSelector.path.equals(\"\")) {\n                                        currentSelector.path = \"/\";\n                }\n            }\n        } else if (readIf(\"text\")) {\n                        currentSelector.isChild = false;\n            pathPattern += \"jcr:xmltext\";\n            read(\"(\");\n            read(\")\");\n            if (currentSelector.isDescendant) {\n                currentSelector.nodeName = \"jcr:xmltext\";\n            } else {\n                currentSelector.path = PathUtils.concat(currentSelector.path, \"jcr:xmltext\");\n            }\n        } else if (readIf(\"element\")) {\n                        read(\"(\");\n            if (readIf(\")\")) {\n                                pathPattern += \"%\";\n            } else {\n                if (readIf(\"*\")) {\n                                        pathPattern += \"%\";\n                } else {\n                    String name = readPathSegment();\n                    pathPattern += name;\n                    appendNodeName(name);\n                }\n                if (readIf(\",\")) {\n                    currentSelector.nodeType = readIdentifier();\n                }\n                read(\")\");\n            }\n        } else if (readIf(\"@\")) {\n            rewindSelector();\n            Expression.Property p = readProperty();\n            statement.addSelectColumn(p);\n        } else if (readIf(\"rep:excerpt\")) {\n            rewindSelector();\n            readExcerpt();\n            Expression.Property p = new Expression.Property(currentSelector, \"rep:excerpt\", false);\n            statement.addSelectColumn(p);\n        } else if (readIf(\"(\")) {\n            rewindSelector();\n            do {\n                if (readIf(\"@\")) {\n                    Expression.Property p = readProperty();\n                    statement.addSelectColumn(p);\n                } else if (readIf(\"rep:excerpt\")) {\n                    readExcerpt();\n                    Expression.Property p = new Expression.Property(currentSelector, \"rep:excerpt\", false);\n                    statement.addSelectColumn(p);\n                } else if (readIf(\"rep:spellcheck\")) {\n                                        read(\"(\");\n                    read(\")\");\n                    Expression.Property p = new Expression.Property(currentSelector, \"rep:spellcheck()\", false);\n                    statement.addSelectColumn(p);\n                } else if (readIf(\"rep:suggest\")) {\n                    readExcerpt();\n                    Expression.Property p = new Expression.Property(currentSelector, \"rep:suggest()\", false);\n                    statement.addSelectColumn(p);\n                }\n            } while (readIf(\"|\"));\n            if (!readIf(\")\")) {\n                return convertToUnion(query, statement, startParseIndex - 1);\n            }\n        } else if (currentTokenType == IDENTIFIER) {\n                        String name = readPathSegment();\n            pathPattern += name;\n            appendNodeName(name);\n        } else if (readIf(\".\")) {\n                        if (readIf(\".\")) {\n                                                String name = \"..\";\n                pathPattern += name;\n                if (!currentSelector.isChild) {\n                    currentSelector.nodeName = name;\n                } else {\n                    if (currentSelector.isChild) {\n                        currentSelector.isChild = false;\n                        currentSelector.isParent = true;\n                    }\n                }\n            } else {\n                if (selectors.size() > 0) {\n                    currentSelector = selectors.remove(selectors.size() - 1);\n                    currentSelector.condition = null;\n                    currentSelector.joinCondition = null;\n                }\n            }\n        } else {\n            throw getSyntaxError();\n        }\n        if (readIf(\"[\")) {\n            Expression c = parseConstraint();\n            currentSelector.condition = Expression.and(currentSelector.condition, c);\n            read(\"]\");\n        }\n        startOfQuery = false;\n        nextSelector(false);\n    }\n    if (selectors.size() == 0) {\n        nextSelector(true);\n    }\n            currentSelector = selectors.get(selectors.size() - 1);\n    if (selectors.size() == 1) {\n        currentSelector.onlySelector = true;\n    }\n    if (readIf(\"order\")) {\n        read(\"by\");\n        do {\n            Order order = new Order();\n            order.expr = parseExpression();\n            if (readIf(\"descending\")) {\n                order.descending = true;\n            } else {\n                readIf(\"ascending\");\n            }\n            statement.addOrderBy(order);\n        } while (readIf(\",\"));\n    }\n    if (!currentToken.isEmpty()) {\n        throw getSyntaxError(\"<end>\");\n    }\n    statement.setColumnSelector(currentSelector);\n    statement.setSelectors(selectors);\n    Expression where = null;\n    for (Selector s : selectors) {\n        where = Expression.and(where, s.condition);\n    }\n    statement.setWhere(where);\n    return statement;\n}", "lc": 8.681818181818182, "pi": 1.1938775510204083, "ma": 8.333333333333334, "nbd": 5.5, "ml": 6.083333333333333, "d": 1.7864557587740981, "mi": -2.0177803269285923, "fo": 7.666666666666667, "r": -0.028571428571428574, "e": 16.130169050158255}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3965_6051019b", "label": 1, "code": "/**\n *  Gets a URL for the listener interface (e.g. ILinkListener).\n *\n *  @see RequestCycle#urlFor(IRequestHandler)\n *\n *  @param listener\n *             The listener interface that the URL should call\n *  @return The URL\n */\npublic final CharSequence urlFor(final RequestListenerInterface listener) {\n    PageAndComponentProvider provider = new PageAndComponentProvider(getPage(), this);\n    IRequestHandler handler;\n    if (getPage().isPageStateless()) {\n        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener);\n    } else {\n        handler = new ListenerInterfaceRequestHandler(provider, listener);\n    }\n    return getRequestCycle().urlFor(handler);\n}", "code_comment": "/**\n *  Gets a URL for the listener interface (e.g. ILinkListener).\n *\n *  @see RequestCycle#urlFor(IRequestHandler)\n *\n *  @param listener\n *             The listener interface that the URL should call\n *  @return The URL\n */\n", "code_no_comment": "public final CharSequence urlFor(final RequestListenerInterface listener) {\n    PageAndComponentProvider provider = new PageAndComponentProvider(getPage(), this);\n    IRequestHandler handler;\n    if (getPage().isPageStateless()) {\n        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener);\n    } else {\n        handler = new ListenerInterfaceRequestHandler(provider, listener);\n    }\n    return getRequestCycle().urlFor(handler);\n}", "lc": -0.18181818181818182, "pi": -0.2500000000000001, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.3806228373702422, "mi": 0.2494981359334673, "fo": -0.08333333333333333, "r": 0.5714285714285714, "e": -0.16422749602751402}
{"project_name": "Codec", "project_version": 17, "label": 1, "code": "/**\n * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n *\n * @param bytes\n *            The bytes to be decoded into characters, may be <code>null</code>\n * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\n *         <code>null</code> if the input byte array was <code>null</code>.\n * @throws NullPointerException\n *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n *             required by the Java platform specification.\n * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n */\npublic static String newStringIso8859_1(final byte[] bytes) {\n    return new String(bytes, Charsets.ISO_8859_1);\n}", "code_comment": "/**\n * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n *\n * @param bytes\n *            The bytes to be decoded into characters, may be <code>null</code>\n * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\n *         <code>null</code> if the input byte array was <code>null</code>.\n * @throws NullPointerException\n *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n *             required by the Java platform specification.\n * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n */\n", "code_no_comment": "public static String newStringIso8859_1(final byte[] bytes) {\n    return new String(bytes, Charsets.ISO_8859_1);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.0585030111843994, "fo": -0.5, "r": 0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5681_78c73502", "label": 1, "code": "public Exchange call() throws Exception {\n    // the aggregation task to early and pile up too many threads\n    if (aggregationTaskSubmitted.compareAndSet(false, true)) {\n        // but only submit the task once\n        aggregateExecutorService.submit(aggregateOnTheFlyTask);\n    }\n    if (!running.get()) {\n        // do not start processing the task if we are not running\n        return subExchange;\n    }\n    try {\n        doProcessParallel(pair);\n    } catch (Throwable e) {\n        subExchange.setException(e);\n    }\n    // Decide whether to continue with the multicast or not; similar logic to the Pipeline\n    Integer number = getExchangeIndex(subExchange);\n    boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Parallel processing failed for number \" + number, LOG);\n    if (stopOnException && !continueProcessing) {\n        // signal to stop running\n        running.set(false);\n        // throw caused exception\n        if (subExchange.getException() != null) {\n            // wrap in exception to explain where it failed\n            throw new CamelExchangeException(\"Parallel processing failed for number \" + number, subExchange, subExchange.getException());\n        }\n    }\n    LOG.trace(\"Parallel processing complete for exchange: {}\", subExchange);\n    return subExchange;\n}", "code_comment": NaN, "code_no_comment": "public Exchange call() throws Exception {\n        if (aggregationTaskSubmitted.compareAndSet(false, true)) {\n                aggregateExecutorService.submit(aggregateOnTheFlyTask);\n    }\n    if (!running.get()) {\n                return subExchange;\n    }\n    try {\n        doProcessParallel(pair);\n    } catch (Throwable e) {\n        subExchange.setException(e);\n    }\n        Integer number = getExchangeIndex(subExchange);\n    boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Parallel processing failed for number \" + number, LOG);\n    if (stopOnException && !continueProcessing) {\n                running.set(false);\n                if (subExchange.getException() != null) {\n                        throw new CamelExchangeException(\"Parallel processing failed for number \" + number, subExchange, subExchange.getException());\n        }\n    }\n    LOG.trace(\"Parallel processing complete for exchange: {}\", subExchange);\n    return subExchange;\n}", "lc": 0.4090909090909091, "pi": -0.13775510204081634, "ma": 0.5, "nbd": 0.0, "ml": 0.4166666666666667, "d": 0.2303509639149778, "mi": -0.330943504445082, "fo": 0.4166666666666667, "r": -0.028571428571428574, "e": 0.24566881245154848}
{"project_name": "Closure", "project_version": 148, "label": 2, "code": "private void closeLine() throws IOException {\n    out.append(\"]\\n\");\n}", "code_comment": NaN, "code_no_comment": "private void closeLine() throws IOException {\n    out.append(\"]\\n\");\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.1015199311729282, "fo": -0.4166666666666667, "r": 2.4571428571428573, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5965_31c88569", "label": 1, "code": "/**\n *  Handle tag &lt;head&gt;\n *  @param tag\n */\nprivate void handleHeadTag(ComponentTag tag) {\n    // we found <head>\n    if (tag.isOpen()) {\n        if (foundHead) {\n            throw new MarkupException(new MarkupStream(markup), \"Tag <head> is not allowed at this position (do you have multiple <head> tags in your markup?).\");\n        }\n        foundHead = true;\n        if (tag.getId() == null) {\n            tag.setId(HEADER_ID);\n            tag.setAutoComponentTag(true);\n            tag.setModified(true);\n        }\n    } else if (tag.isClose()) {\n        if (foundHeaderItemsTag) {\n            // revert the settings from above\n            ComponentTag headOpenTag = tag.getOpenTag();\n            // change the id because it is special. See HtmlHeaderResolver\n            headOpenTag.setId(HEADER_ID + \"-Ignored\");\n            headOpenTag.setAutoComponentTag(false);\n            headOpenTag.setModified(false);\n            headOpenTag.setFlag(ComponentTag.RENDER_RAW, true);\n        }\n        foundClosingHead = true;\n    }\n}", "code_comment": "/**\n *  Handle tag &lt;head&gt;\n *  @param tag\n */\n", "code_no_comment": "private void handleHeadTag(ComponentTag tag) {\n        if (tag.isOpen()) {\n        if (foundHead) {\n            throw new MarkupException(new MarkupStream(markup), \"Tag <head> is not allowed at this position (do you have multiple <head> tags in your markup?).\");\n        }\n        foundHead = true;\n        if (tag.getId() == null) {\n            tag.setId(HEADER_ID);\n            tag.setAutoComponentTag(true);\n            tag.setModified(true);\n        }\n    } else if (tag.isClose()) {\n        if (foundHeaderItemsTag) {\n                        ComponentTag headOpenTag = tag.getOpenTag();\n                        headOpenTag.setId(HEADER_ID + \"-Ignored\");\n            headOpenTag.setAutoComponentTag(false);\n            headOpenTag.setModified(false);\n            headOpenTag.setFlag(ComponentTag.RENDER_RAW, true);\n        }\n        foundClosingHead = true;\n    }\n}", "lc": 0.36363636363636365, "pi": 0.3979591836734693, "ma": 0.5, "nbd": 0.5, "ml": 0.4166666666666667, "d": -0.00889767671774591, "mi": -0.2856323487238317, "fo": 0.4166666666666667, "r": -0.028571428571428574, "e": 0.04751992667497569}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1822_3e83a4c1", "label": 1, "code": "/**\n * Apply the changes to the in-memory document.\n *\n * @param doc\n *            the target document.\n * @param update\n *            the changes to apply.\n * @param comparator\n *            the revision comparator.\n */\npublic static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update, @Nonnull Comparator<Revision> comparator) {\n    for (Entry<Key, Operation> e : checkNotNull(update).getChanges().entrySet()) {\n        Key k = e.getKey();\n        Operation op = e.getValue();\n        switch(op.type) {\n            case SET:\n                {\n                    doc.put(k.toString(), op.value);\n                    break;\n                }\n            case INCREMENT:\n                {\n                    Object old = doc.get(k.toString());\n                    Long x = (Long) op.value;\n                    if (old == null) {\n                        old = 0L;\n                    }\n                    doc.put(k.toString(), ((Long) old) + x);\n                    break;\n                }\n            case SET_MAP_ENTRY:\n                {\n                    Object old = doc.get(k.getName());\n                    @SuppressWarnings(\"unchecked\")\n                    Map<Revision, Object> m = (Map<Revision, Object>) old;\n                    if (m == null) {\n                        m = new TreeMap<Revision, Object>(comparator);\n                        doc.put(k.getName(), m);\n                    }\n                    if (k.getRevision() == null) {\n                        throw new IllegalArgumentException(\"Cannot set map entry \" + k.getName() + \" with null revision\");\n                    }\n                    m.put(k.getRevision(), op.value);\n                    break;\n                }\n            case REMOVE_MAP_ENTRY:\n                {\n                    Object old = doc.get(k.getName());\n                    @SuppressWarnings(\"unchecked\")\n                    Map<Revision, Object> m = (Map<Revision, Object>) old;\n                    if (m != null) {\n                        m.remove(k.getRevision());\n                    }\n                    break;\n                }\n            case CONTAINS_MAP_ENTRY:\n                // no effect\n                break;\n        }\n    }\n}", "code_comment": "/**\n * Apply the changes to the in-memory document.\n *\n * @param doc\n *            the target document.\n * @param update\n *            the changes to apply.\n * @param comparator\n *            the revision comparator.\n */\n", "code_no_comment": "public static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update, @Nonnull Comparator<Revision> comparator) {\n    for (Entry<Key, Operation> e : checkNotNull(update).getChanges().entrySet()) {\n        Key k = e.getKey();\n        Operation op = e.getValue();\n        switch(op.type) {\n            case SET:\n                {\n                    doc.put(k.toString(), op.value);\n                    break;\n                }\n            case INCREMENT:\n                {\n                    Object old = doc.get(k.toString());\n                    Long x = (Long) op.value;\n                    if (old == null) {\n                        old = 0L;\n                    }\n                    doc.put(k.toString(), ((Long) old) + x);\n                    break;\n                }\n            case SET_MAP_ENTRY:\n                {\n                    Object old = doc.get(k.getName());\n                    @SuppressWarnings(\"unchecked\")\n                    Map<Revision, Object> m = (Map<Revision, Object>) old;\n                    if (m == null) {\n                        m = new TreeMap<Revision, Object>(comparator);\n                        doc.put(k.getName(), m);\n                    }\n                    if (k.getRevision() == null) {\n                        throw new IllegalArgumentException(\"Cannot set map entry \" + k.getName() + \" with null revision\");\n                    }\n                    m.put(k.getRevision(), op.value);\n                    break;\n                }\n            case REMOVE_MAP_ENTRY:\n                {\n                    Object old = doc.get(k.getName());\n                    @SuppressWarnings(\"unchecked\")\n                    Map<Revision, Object> m = (Map<Revision, Object>) old;\n                    if (m != null) {\n                        m.remove(k.getRevision());\n                    }\n                    break;\n                }\n            case CONTAINS_MAP_ENTRY:\n                                break;\n        }\n    }\n}", "lc": 1.6363636363636365, "pi": 1.5306122448979589, "ma": 2.1666666666666665, "nbd": 1.0, "ml": 0.6666666666666666, "d": 0.6653484923381119, "mi": -0.9019214224261546, "fo": 1.4166666666666667, "r": -0.028571428571428574, "e": 1.683276155233188}
{"project_name": "Closure", "project_version": 136, "label": 2, "code": "/**\n * Adds a node that may represent a function signature (if it's a function\n * itself or the name of a function).\n */\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getSourceName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (compiler.isIdeMode()) {\n                return;\n            } else {\n                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n            }\n        }\n        Node function = v.getInitialValue();\n        if (function != null && function.getType() == Token.FUNCTION) {\n            addSignature(name, function, v.getInputName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}", "code_comment": "/**\n * Adds a node that may represent a function signature (if it's a function\n * itself or the name of a function).\n */\n", "code_no_comment": "private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n                addSignature(name, node, t.getSourceName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (compiler.isIdeMode()) {\n                return;\n            } else {\n                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n            }\n        }\n        Node function = v.getInitialValue();\n        if (function != null && function.getType() == Token.FUNCTION) {\n            addSignature(name, function, v.getInputName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}", "lc": 0.5, "pi": 0.5765306122448981, "ma": 0.6666666666666666, "nbd": 1.0, "ml": 0.6666666666666666, "d": 0.3529411764705883, "mi": -0.4149698881560081, "fo": 0.5833333333333334, "r": -0.028571428571428574, "e": 0.47334900912708094}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-178_2f0643a9", "label": 3, "code": "protected Key buildDocKey() {\n    if (log.isTraceEnabled())\n        log.trace(\"building doc key for \" + currentPartition + \" \" + currentDocID);\n    int zeroIndex = currentDocID.find(\"\\0\");\n    if (zeroIndex < 0)\n        throw new IllegalArgumentException(\"bad current docID\");\n    Text colf = new Text(docColf);\n    colf.append(nullByte, 0, 1);\n    colf.append(currentDocID.getBytes(), 0, zeroIndex);\n    docColfSet = Collections.singleton((ByteSequence) new ArrayByteSequence(colf.getBytes(), 0, colf.getLength()));\n    if (log.isTraceEnabled())\n        log.trace(zeroIndex + \" \" + currentDocID.getLength());\n    Text colq = new Text();\n    colq.set(currentDocID.getBytes(), zeroIndex + 1, currentDocID.getLength() - zeroIndex - 2);\n    Key k = new Key(currentPartition, colf, colq);\n    if (log.isTraceEnabled())\n        log.trace(\"built doc key for seek: \" + k.toString());\n    return k;\n}", "code_comment": NaN, "code_no_comment": "protected Key buildDocKey() {\n    if (log.isTraceEnabled())\n        log.trace(\"building doc key for \" + currentPartition + \" \" + currentDocID);\n    int zeroIndex = currentDocID.find(\"\\0\");\n    if (zeroIndex < 0)\n        throw new IllegalArgumentException(\"bad current docID\");\n    Text colf = new Text(docColf);\n    colf.append(nullByte, 0, 1);\n    colf.append(currentDocID.getBytes(), 0, zeroIndex);\n    docColfSet = Collections.singleton((ByteSequence) new ArrayByteSequence(colf.getBytes(), 0, colf.getLength()));\n    if (log.isTraceEnabled())\n        log.trace(zeroIndex + \" \" + currentDocID.getLength());\n    Text colq = new Text();\n    colq.set(currentDocID.getBytes(), zeroIndex + 1, currentDocID.getLength() - zeroIndex - 2);\n    Key k = new Key(currentPartition, colf, colq);\n    if (log.isTraceEnabled())\n        log.trace(\"built doc key for seek: \" + k.toString());\n    return k;\n}", "lc": 0.22727272727272727, "pi": -0.413265306122449, "ma": 0.3333333333333333, "nbd": -1.0, "ml": 0.08333333333333333, "d": 0.5111220958971825, "mi": -0.299684542586751, "fo": 1.0, "r": -0.028571428571428574, "e": 0.7554961645701364}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5165_0d4d1df7", "label": 1, "code": "/**\n *  @param url\n *  @param requestCycle\n */\nprotected void redirectTo(Url url, RequestCycle requestCycle) {\n    WebResponse response = (WebResponse) requestCycle.getResponse();\n    String relativeUrl = requestCycle.getUrlRenderer().renderUrl(url);\n    response.sendRedirect(relativeUrl);\n}", "code_comment": "/**\n *  @param url\n *  @param requestCycle\n */\n", "code_no_comment": "protected void redirectTo(Url url, RequestCycle requestCycle) {\n    WebResponse response = (WebResponse) requestCycle.getResponse();\n    String relativeUrl = requestCycle.getUrlRenderer().renderUrl(url);\n    response.sendRedirect(relativeUrl);\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.6088328075709782, "fo": -0.16666666666666666, "r": 2.342857142857143, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 175, "label": 2, "code": "/**\n * Determines whether a function can be inlined at a particular call site.\n * There are several criteria that the function and reference must hold in\n * order for the functions to be inlined:\n * 1) If a call's arguments have side effects,\n * the corresponding argument in the function must only be referenced once.\n * For instance, this will not be inlined:\n * <pre>\n *     function foo(a) { return a + a }\n *     x = foo(i++);\n * </pre>\n */\nprivate CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n        return CanInlineResult.NO;\n    }\n    Node block = fnNode.getLastChild();\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n        if (NodeUtil.isFunctionObjectCall(callNode)) {\n            // TODO(johnlenz): Support replace this with a value.\n            if (cArg == null || !cArg.isThis()) {\n                return CanInlineResult.NO;\n            }\n            cArg = cArg.getNext();\n        } else {\n            // \".apply\" call should be filtered before this.\n            Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n        }\n    }\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n        if (fnParam != null) {\n            if (cArg != null) {\n                if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {\n                    return CanInlineResult.NO;\n                }\n            }\n            fnParam = fnParam.getNext();\n        }\n        // Limit the inlining\n        if (cArg != null) {\n            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n                return CanInlineResult.NO;\n            }\n            cArg = cArg.getNext();\n        }\n    }\n    return CanInlineResult.YES;\n}", "code_comment": "/**\n * Determines whether a function can be inlined at a particular call site.\n * There are several criteria that the function and reference must hold in\n * order for the functions to be inlined:\n * 1) If a call's arguments have side effects,\n * the corresponding argument in the function must only be referenced once.\n * For instance, this will not be inlined:\n * <pre>\n *     function foo(a) { return a + a }\n *     x = foo(i++);\n * </pre>\n */\n", "code_no_comment": "private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n        return CanInlineResult.NO;\n    }\n    Node block = fnNode.getLastChild();\n        Node cArg = callNode.getFirstChild().getNext();\n        if (!callNode.getFirstChild().isName()) {\n        if (NodeUtil.isFunctionObjectCall(callNode)) {\n                        if (cArg == null || !cArg.isThis()) {\n                return CanInlineResult.NO;\n            }\n            cArg = cArg.getNext();\n        } else {\n                        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n        }\n    }\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n        if (fnParam != null) {\n            if (cArg != null) {\n                if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {\n                    return CanInlineResult.NO;\n                }\n            }\n            fnParam = fnParam.getNext();\n        }\n                if (cArg != null) {\n            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n                return CanInlineResult.NO;\n            }\n            cArg = cArg.getNext();\n        }\n    }\n    return CanInlineResult.YES;\n}", "lc": 0.9545454545454546, "pi": 0.9387755102040818, "ma": 1.1666666666666667, "nbd": 1.0, "ml": 1.8333333333333333, "d": 1.240731586752348, "mi": -0.6329222827645544, "fo": 1.0833333333333333, "r": -0.028571428571428574, "e": 1.7019586176177075}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6447_020c451a", "label": 1, "code": "private boolean process(final Exchange exchange, final AsyncCallback callback, final Iterator<Processor> processors, final AsyncProcessor asyncProcessor) {\n    // this does the actual processing so log at trace level\n    LOG.trace(\"Processing exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n    // implement asynchronous routing logic in callback so we can have the callback being\n    // triggered and then continue routing where we left\n    boolean sync = asyncProcessor.process(exchange, new AsyncCallback() {\n\n        public void done(boolean doneSync) {\n            // we only have to handle async completion of the pipeline\n            if (doneSync) {\n                return;\n            }\n            // continue processing the pipeline asynchronously\n            while (continueRouting(processors, exchange)) {\n                AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());\n                // check for error if so we should break out\n                if (!continueProcessing(exchange, \"so breaking out of pipeline\", LOG)) {\n                    break;\n                }\n                doneSync = process(exchange, callback, processors, processor);\n                if (!doneSync) {\n                    LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n                    return;\n                }\n            }\n            LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n            callback.done(false);\n        }\n    });\n    return sync;\n}", "code_comment": NaN, "code_no_comment": "private boolean process(final Exchange exchange, final AsyncCallback callback, final Iterator<Processor> processors, final AsyncProcessor asyncProcessor) {\n        LOG.trace(\"Processing exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n            boolean sync = asyncProcessor.process(exchange, new AsyncCallback() {\n\n        public void done(boolean doneSync) {\n                        if (doneSync) {\n                return;\n            }\n                        while (continueRouting(processors, exchange)) {\n                AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());\n                                if (!continueProcessing(exchange, \"so breaking out of pipeline\", LOG)) {\n                    break;\n                }\n                doneSync = process(exchange, callback, processors, processor);\n                if (!doneSync) {\n                    LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n                    return;\n                }\n            }\n            LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n            callback.done(false);\n        }\n    });\n    return sync;\n}", "lc": 0.45454545454545453, "pi": 1.5357142857142858, "ma": 0.3333333333333333, "nbd": 0.5, "ml": 0.3333333333333333, "d": 0.04251112209589725, "mi": -0.34843705190708374, "fo": 0.5833333333333334, "r": -0.028571428571428574, "e": 0.12849867869334122}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-93_0be7e8f0", "label": 1, "code": "@Override\npublic void removeProperty(String name) {\n    builder.removeProperty(name);\n    if (listener != null) {\n        listener.removeProperty(this, name);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void removeProperty(String name) {\n    builder.removeProperty(name);\n    if (listener != null) {\n        listener.removeProperty(this, name);\n    }\n}", "lc": -0.3181818181818182, "pi": -0.11224489795918377, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.3806228373702422, "mi": 0.544307427588185, "fo": -0.3333333333333333, "r": 0.6571428571428571, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1779_9d36bede", "label": 0, "code": "private void collectDeletedDocuments(VersionGCStats stats, Revision headRevision, long oldestRevTimeStamp) {\n    List<String> docIdsToDelete = new ArrayList<String>();\n    Iterable<NodeDocument> itr = versionStore.getPossiblyDeletedDocs(oldestRevTimeStamp);\n    try {\n        for (NodeDocument doc : itr) {\n            // So deleting it is safe\n            if (doc.getNodeAtRevision(nodeStore, headRevision, null) == null) {\n                docIdsToDelete.add(doc.getId());\n                // Collect id of all previous docs also\n                for (NodeDocument prevDoc : ImmutableList.copyOf(doc.getAllPreviousDocs())) {\n                    docIdsToDelete.add(prevDoc.getId());\n                }\n            }\n        }\n    } finally {\n        Utils.closeIfCloseable(itr);\n    }\n    if (log.isDebugEnabled()) {\n        StringBuilder sb = new StringBuilder(\"Deleted document with following ids were deleted as part of GC \\n\");\n        Joiner.on(StandardSystemProperty.LINE_SEPARATOR.value()).appendTo(sb, docIdsToDelete);\n        log.debug(sb.toString());\n    }\n    nodeStore.getDocumentStore().remove(Collection.NODES, docIdsToDelete);\n    stats.deletedDocGCCount += docIdsToDelete.size();\n}", "code_comment": NaN, "code_no_comment": "private void collectDeletedDocuments(VersionGCStats stats, Revision headRevision, long oldestRevTimeStamp) {\n    List<String> docIdsToDelete = new ArrayList<String>();\n    Iterable<NodeDocument> itr = versionStore.getPossiblyDeletedDocs(oldestRevTimeStamp);\n    try {\n        for (NodeDocument doc : itr) {\n                        if (doc.getNodeAtRevision(nodeStore, headRevision, null) == null) {\n                docIdsToDelete.add(doc.getId());\n                                for (NodeDocument prevDoc : ImmutableList.copyOf(doc.getAllPreviousDocs())) {\n                    docIdsToDelete.add(prevDoc.getId());\n                }\n            }\n        }\n    } finally {\n        Utils.closeIfCloseable(itr);\n    }\n    if (log.isDebugEnabled()) {\n        StringBuilder sb = new StringBuilder(\"Deleted document with following ids were deleted as part of GC \\n\");\n        Joiner.on(StandardSystemProperty.LINE_SEPARATOR.value()).appendTo(sb, docIdsToDelete);\n        log.debug(sb.toString());\n    }\n    nodeStore.getDocumentStore().remove(Collection.NODES, docIdsToDelete);\n    stats.deletedDocGCCount += docIdsToDelete.size();\n}", "lc": 0.4090909090909091, "pi": 1.1428571428571428, "ma": 0.16666666666666666, "nbd": 1.0, "ml": 0.08333333333333333, "d": -0.07810182896688084, "mi": -0.3682248351018069, "fo": 1.0, "r": -0.028571428571428574, "e": 0.12090491303360874}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3028_89317b28", "label": 0, "code": "/**\n * Apply the changes to the document store.\n *\n * @param baseBranchRevision the base revision of this commit. Currently only\n *                     used for branch commits.\n */\nprivate void applyToDocumentStore(Revision baseBranchRevision) {\n    // the value in _revisions.<revision> property of the commit root node\n    // regular commits use \"c\", which makes the commit visible to\n    // other readers. branch commits use the base revision to indicate\n    // the visibility of the commit\n    String commitValue = baseBranchRevision != null ? baseBranchRevision.toString() : \"c\";\n    DocumentStore store = nodeStore.getDocumentStore();\n    String commitRootPath = null;\n    if (baseBranchRevision != null) {\n        // branch commits always use root node as commit root\n        commitRootPath = \"/\";\n    }\n    ArrayList<UpdateOp> newNodes = new ArrayList<UpdateOp>();\n    ArrayList<UpdateOp> changedNodes = new ArrayList<UpdateOp>();\n    // operations are added to this list before they are executed,\n    // so that all operations can be rolled back if there is a conflict\n    ArrayList<UpdateOp> opLog = new ArrayList<UpdateOp>();\n    // Compute the commit root\n    for (String p : operations.keySet()) {\n        markChanged(p);\n        if (commitRootPath == null) {\n            commitRootPath = p;\n        } else {\n            while (!PathUtils.isAncestor(commitRootPath, p)) {\n                commitRootPath = PathUtils.getParentPath(commitRootPath);\n                if (denotesRoot(commitRootPath)) {\n                    break;\n                }\n            }\n        }\n    }\n    // push branch changes to journal\n    if (baseBranchRevision != null) {\n        // store as external change\n        JournalEntry doc = JOURNAL.newDocument(store);\n        doc.modified(modifiedNodes);\n        Revision r = revision.asBranchRevision();\n        store.create(JOURNAL, singletonList(doc.asUpdateOp(r)));\n    }\n    int commitRootDepth = PathUtils.getDepth(commitRootPath);\n    // check if there are real changes on the commit root\n    boolean commitRootHasChanges = operations.containsKey(commitRootPath);\n    // create a \"root of the commit\" if there is none\n    UpdateOp commitRoot = getUpdateOperationForNode(commitRootPath);\n    for (String p : operations.keySet()) {\n        UpdateOp op = operations.get(p);\n        if (op.isNew()) {\n            NodeDocument.setDeleted(op, revision, false);\n        }\n        if (op == commitRoot) {\n            if (!op.isNew() && commitRootHasChanges) {\n                // commit root already exists and this is an update\n                changedNodes.add(op);\n            }\n        } else {\n            NodeDocument.setCommitRoot(op, revision, commitRootDepth);\n            if (op.isNew()) {\n                newNodes.add(op);\n            } else {\n                changedNodes.add(op);\n            }\n        }\n    }\n    if (changedNodes.size() == 0 && commitRoot.isNew()) {\n        // no updates and root of commit is also new. that is,\n        // it is the root of a subtree added in a commit.\n        // so we try to add the root like all other nodes\n        NodeDocument.setRevision(commitRoot, revision, commitValue);\n        newNodes.add(commitRoot);\n    }\n    try {\n        if (newNodes.size() > 0) {\n            // set commit root on new nodes\n            if (!store.create(NODES, newNodes)) {\n                // try to apply all changes one by one\n                for (UpdateOp op : newNodes) {\n                    if (op == commitRoot) {\n                        // don't write the commit root just yet\n                        // (because there might be a conflict)\n                        NodeDocument.unsetRevision(commitRoot, revision);\n                    }\n                    changedNodes.add(op);\n                }\n                newNodes.clear();\n            }\n        }\n        for (UpdateOp op : changedNodes) {\n            // set commit root on changed nodes. this may even apply\n            // to the commit root. the _commitRoot entry is removed\n            // again when the _revisions entry is set at the end\n            NodeDocument.setCommitRoot(op, revision, commitRootDepth);\n            opLog.add(op);\n            createOrUpdateNode(store, op);\n        }\n        // the revision, with the revision property set)\n        if (changedNodes.size() > 0 || !commitRoot.isNew()) {\n            // set revision to committed\n            NodeDocument.setRevision(commitRoot, revision, commitValue);\n            if (commitRootHasChanges) {\n                // remove previously added commit root\n                NodeDocument.removeCommitRoot(commitRoot, revision);\n            }\n            opLog.add(commitRoot);\n            if (baseBranchRevision == null) {\n                // create a clone of the commitRoot in order\n                // to set isNew to false. If we get here the\n                // commitRoot document already exists and\n                // only needs an update\n                UpdateOp commit = commitRoot.shallowCopy(commitRoot.getId());\n                commit.setNew(false);\n                // only set revision on commit root when there is\n                // no collision for this commit revision\n                commit.containsMapEntry(COLLISIONS, revision, false);\n                NodeDocument before = nodeStore.updateCommitRoot(commit);\n                if (before == null) {\n                    String msg = \"Conflicting concurrent change. \" + \"Update operation failed: \" + commitRoot;\n                    throw new DocumentStoreException(msg);\n                } else {\n                    // if we get here the commit was successful and\n                    // the commit revision is set on the commitRoot\n                    // document for this commit.\n                    // now check for conflicts/collisions by other commits.\n                    // use original commitRoot operation with\n                    // correct isNew flag.\n                    checkConflicts(commitRoot, before);\n                    checkSplitCandidate(before);\n                }\n            } else {\n                // this is a branch commit, do not fail on collisions now\n                // trying to merge the branch will fail later\n                createOrUpdateNode(store, commitRoot);\n            }\n            operations.put(commitRootPath, commitRoot);\n        }\n    } catch (DocumentStoreException e) {\n        rollback(newNodes, opLog, commitRoot);\n        throw e;\n    }\n}", "code_comment": "/**\n * Apply the changes to the document store.\n *\n * @param baseBranchRevision the base revision of this commit. Currently only\n *                     used for branch commits.\n */\n", "code_no_comment": "private void applyToDocumentStore(Revision baseBranchRevision) {\n                    String commitValue = baseBranchRevision != null ? baseBranchRevision.toString() : \"c\";\n    DocumentStore store = nodeStore.getDocumentStore();\n    String commitRootPath = null;\n    if (baseBranchRevision != null) {\n                commitRootPath = \"/\";\n    }\n    ArrayList<UpdateOp> newNodes = new ArrayList<UpdateOp>();\n    ArrayList<UpdateOp> changedNodes = new ArrayList<UpdateOp>();\n            ArrayList<UpdateOp> opLog = new ArrayList<UpdateOp>();\n        for (String p : operations.keySet()) {\n        markChanged(p);\n        if (commitRootPath == null) {\n            commitRootPath = p;\n        } else {\n            while (!PathUtils.isAncestor(commitRootPath, p)) {\n                commitRootPath = PathUtils.getParentPath(commitRootPath);\n                if (denotesRoot(commitRootPath)) {\n                    break;\n                }\n            }\n        }\n    }\n        if (baseBranchRevision != null) {\n                JournalEntry doc = JOURNAL.newDocument(store);\n        doc.modified(modifiedNodes);\n        Revision r = revision.asBranchRevision();\n        store.create(JOURNAL, singletonList(doc.asUpdateOp(r)));\n    }\n    int commitRootDepth = PathUtils.getDepth(commitRootPath);\n        boolean commitRootHasChanges = operations.containsKey(commitRootPath);\n        UpdateOp commitRoot = getUpdateOperationForNode(commitRootPath);\n    for (String p : operations.keySet()) {\n        UpdateOp op = operations.get(p);\n        if (op.isNew()) {\n            NodeDocument.setDeleted(op, revision, false);\n        }\n        if (op == commitRoot) {\n            if (!op.isNew() && commitRootHasChanges) {\n                                changedNodes.add(op);\n            }\n        } else {\n            NodeDocument.setCommitRoot(op, revision, commitRootDepth);\n            if (op.isNew()) {\n                newNodes.add(op);\n            } else {\n                changedNodes.add(op);\n            }\n        }\n    }\n    if (changedNodes.size() == 0 && commitRoot.isNew()) {\n                                NodeDocument.setRevision(commitRoot, revision, commitValue);\n        newNodes.add(commitRoot);\n    }\n    try {\n        if (newNodes.size() > 0) {\n                        if (!store.create(NODES, newNodes)) {\n                                for (UpdateOp op : newNodes) {\n                    if (op == commitRoot) {\n                                                                        NodeDocument.unsetRevision(commitRoot, revision);\n                    }\n                    changedNodes.add(op);\n                }\n                newNodes.clear();\n            }\n        }\n        for (UpdateOp op : changedNodes) {\n                                                NodeDocument.setCommitRoot(op, revision, commitRootDepth);\n            opLog.add(op);\n            createOrUpdateNode(store, op);\n        }\n                if (changedNodes.size() > 0 || !commitRoot.isNew()) {\n                        NodeDocument.setRevision(commitRoot, revision, commitValue);\n            if (commitRootHasChanges) {\n                                NodeDocument.removeCommitRoot(commitRoot, revision);\n            }\n            opLog.add(commitRoot);\n            if (baseBranchRevision == null) {\n                                                                                UpdateOp commit = commitRoot.shallowCopy(commitRoot.getId());\n                commit.setNew(false);\n                                                commit.containsMapEntry(COLLISIONS, revision, false);\n                NodeDocument before = nodeStore.updateCommitRoot(commit);\n                if (before == null) {\n                    String msg = \"Conflicting concurrent change. \" + \"Update operation failed: \" + commitRoot;\n                    throw new DocumentStoreException(msg);\n                } else {\n                                                                                                                                            checkConflicts(commitRoot, before);\n                    checkSplitCandidate(before);\n                }\n            } else {\n                                                createOrUpdateNode(store, commitRoot);\n            }\n            operations.put(commitRootPath, commitRoot);\n        }\n    } catch (DocumentStoreException e) {\n        rollback(newNodes, opLog, commitRoot);\n        throw e;\n    }\n}", "lc": 3.8636363636363638, "pi": 1.1734693877551021, "ma": 3.8333333333333335, "nbd": 1.5, "ml": 2.5833333333333335, "d": 2.041522491349481, "mi": -1.4032119300258106, "fo": 3.9166666666666665, "r": -0.028571428571428574, "e": 9.269542275388577}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2621_c849f986", "label": 1, "code": "private boolean isMultiPart() {\n    if (multiPart) {\n        return true;\n    } else {\n        final boolean[] anyEmbeddedMultipart = new boolean[] { false };\n        visitChildren(Form.class, new IVisitor<Form<?>>() {\n\n            public Object component(Form<?> form) {\n                if (form.multiPart) {\n                    anyEmbeddedMultipart[0] = true;\n                    return STOP_TRAVERSAL;\n                } else {\n                    return CONTINUE_TRAVERSAL;\n                }\n            }\n        });\n        return anyEmbeddedMultipart[0];\n    }\n}", "code_comment": NaN, "code_no_comment": "private boolean isMultiPart() {\n    if (multiPart) {\n        return true;\n    } else {\n        final boolean[] anyEmbeddedMultipart = new boolean[] { false };\n        visitChildren(Form.class, new IVisitor<Form<?>>() {\n\n            public Object component(Form<?> form) {\n                if (form.multiPart) {\n                    anyEmbeddedMultipart[0] = true;\n                    return STOP_TRAVERSAL;\n                } else {\n                    return CONTINUE_TRAVERSAL;\n                }\n            }\n        });\n        return anyEmbeddedMultipart[0];\n    }\n}", "lc": 0.18181818181818182, "pi": 1.7397959183673468, "ma": -0.16666666666666666, "nbd": 0.5, "ml": -0.08333333333333333, "d": -0.3806228373702422, "mi": -0.022082018927444685, "fo": -0.4166666666666667, "r": 0.37142857142857144, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-278_db19e70f", "label": 1, "code": "@Override\npublic boolean remove() {\n    if (isRemoved()) {\n        throw new IllegalStateException(\"Cannot remove removed tree\");\n    }\n    if (!isRoot() && parent.hasChild(name)) {\n        NodeBuilder builder = parent.getNodeBuilder();\n        builder.removeNode(name);\n        parent.children.remove(name);\n        parent = this;\n        root.purge();\n        return true;\n    } else {\n        return false;\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean remove() {\n    if (isRemoved()) {\n        throw new IllegalStateException(\"Cannot remove removed tree\");\n    }\n    if (!isRoot() && parent.hasChild(name)) {\n        NodeBuilder builder = parent.getNodeBuilder();\n        builder.removeNode(name);\n        parent.children.remove(name);\n        parent = this;\n        root.purge();\n        return true;\n    } else {\n        return false;\n    }\n}", "lc": 0.09090909090909091, "pi": 0.025510204081632563, "ma": 0.0, "nbd": -0.5, "ml": 0.16666666666666666, "d": -0.10973801285219967, "mi": -0.01749354746200171, "fo": 0.08333333333333333, "r": 0.2571428571428572, "e": -0.08581854626286507}
{"project_name": "Math", "project_version": 67, "label": 3, "code": "/**\n * {@inheritDoc}\n */\npublic double getResult() {\n    return optimizer.getResult();\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public double getResult() {\n    return optimizer.getResult();\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.2348723831373678, "fo": -0.4166666666666667, "r": 2.8000000000000003, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8964_ea8ee025", "label": 1, "code": "/**\n * Suspends each element of the given {@code services} if {@code services} itself is\n * not {@code null}, otherwise this method would return immediately.\n * <p/>\n * If there's any exception being thrown while suspending the elements one after the\n * other this method would rethrow the <b>first</b> such exception being thrown.\n *\n * @see #suspendService(Service)\n */\npublic static void suspendServices(Collection<?> services) throws Exception {\n    if (services == null) {\n        return;\n    }\n    Exception firstException = null;\n    for (Object value : services) {\n        if (value instanceof Service) {\n            Service service = (Service) value;\n            try {\n                suspendService(service);\n            } catch (Exception e) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Caught exception suspending service: \" + service, e);\n                }\n                if (firstException == null) {\n                    firstException = e;\n                }\n            }\n        }\n    }\n    if (firstException != null) {\n        throw firstException;\n    }\n}", "code_comment": "/**\n * Suspends each element of the given {@code services} if {@code services} itself is\n * not {@code null}, otherwise this method would return immediately.\n * <p/>\n * If there's any exception being thrown while suspending the elements one after the\n * other this method would rethrow the <b>first</b> such exception being thrown.\n *\n * @see #suspendService(Service)\n */\n", "code_no_comment": "public static void suspendServices(Collection<?> services) throws Exception {\n    if (services == null) {\n        return;\n    }\n    Exception firstException = null;\n    for (Object value : services) {\n        if (value instanceof Service) {\n            Service service = (Service) value;\n            try {\n                suspendService(service);\n            } catch (Exception e) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Caught exception suspending service: \" + service, e);\n                }\n                if (firstException == null) {\n                    firstException = e;\n                }\n            }\n        }\n    }\n    if (firstException != null) {\n        throw firstException;\n    }\n}", "lc": 0.45454545454545453, "pi": 1.5102040816326534, "ma": 0.8333333333333334, "nbd": 1.0, "ml": 0.3333333333333333, "d": 0.47948591201186364, "mi": -0.2936621737883571, "fo": -0.25, "r": 0.028571428571428574, "e": 0.1960844779660872}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-1856_faa5cf27", "label": 3, "code": "private void assembleModelInheritance(Model child, Model parent, String childPathAdjustment, boolean appendPaths) {\n    // cannot inherit from null parent.\n    if (parent == null) {\n        return;\n    }\n    // Group id\n    if (child.getGroupId() == null) {\n        child.setGroupId(parent.getGroupId());\n    }\n    // version\n    if (child.getVersion() == null) {\n        if (child.getParent() != null) {\n            child.setVersion(child.getParent().getVersion());\n        }\n    }\n    // inceptionYear\n    if (child.getInceptionYear() == null) {\n        child.setInceptionYear(parent.getInceptionYear());\n    }\n    // url\n    if (child.getUrl() == null) {\n        if (parent.getUrl() != null) {\n            child.setUrl(appendPath(parent.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths));\n        } else {\n            child.setUrl(parent.getUrl());\n        }\n    }\n    // ----------------------------------------------------------------------\n    // Distribution\n    // ----------------------------------------------------------------------\n    assembleDistributionInheritence(child, parent, childPathAdjustment, appendPaths);\n    // issueManagement\n    if (child.getIssueManagement() == null) {\n        child.setIssueManagement(parent.getIssueManagement());\n    }\n    // description\n    if (child.getDescription() == null) {\n        child.setDescription(parent.getDescription());\n    }\n    // Organization\n    if (child.getOrganization() == null) {\n        child.setOrganization(parent.getOrganization());\n    }\n    // Scm\n    assembleScmInheritance(child, parent, childPathAdjustment, appendPaths);\n    // ciManagement\n    if (child.getCiManagement() == null) {\n        child.setCiManagement(parent.getCiManagement());\n    }\n    // developers\n    if (child.getDevelopers().size() == 0) {\n        child.setDevelopers(parent.getDevelopers());\n    }\n    // licenses\n    if (child.getLicenses().size() == 0) {\n        child.setLicenses(parent.getLicenses());\n    }\n    // developers\n    if (child.getContributors().size() == 0) {\n        child.setContributors(parent.getContributors());\n    }\n    // mailingLists\n    if (child.getMailingLists().size() == 0) {\n        child.setMailingLists(parent.getMailingLists());\n    }\n    // Build\n    assembleBuildInheritance(child, parent);\n    assembleDependencyInheritance(child, parent);\n    child.setRepositories(ModelUtils.mergeRepositoryLists(child.getRepositories(), parent.getRepositories()));\n    child.setPluginRepositories(ModelUtils.mergeRepositoryLists(child.getPluginRepositories(), parent.getPluginRepositories()));\n    assembleReportingInheritance(child, parent);\n    assembleDependencyManagementInheritance(child, parent);\n    assembleDistributionManagementInheritance(child, parent);\n    Properties props = new Properties();\n    props.putAll(parent.getProperties());\n    props.putAll(child.getProperties());\n    child.setProperties(props);\n}", "code_comment": NaN, "code_no_comment": "private void assembleModelInheritance(Model child, Model parent, String childPathAdjustment, boolean appendPaths) {\n        if (parent == null) {\n        return;\n    }\n        if (child.getGroupId() == null) {\n        child.setGroupId(parent.getGroupId());\n    }\n        if (child.getVersion() == null) {\n        if (child.getParent() != null) {\n            child.setVersion(child.getParent().getVersion());\n        }\n    }\n        if (child.getInceptionYear() == null) {\n        child.setInceptionYear(parent.getInceptionYear());\n    }\n        if (child.getUrl() == null) {\n        if (parent.getUrl() != null) {\n            child.setUrl(appendPath(parent.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths));\n        } else {\n            child.setUrl(parent.getUrl());\n        }\n    }\n                assembleDistributionInheritence(child, parent, childPathAdjustment, appendPaths);\n        if (child.getIssueManagement() == null) {\n        child.setIssueManagement(parent.getIssueManagement());\n    }\n        if (child.getDescription() == null) {\n        child.setDescription(parent.getDescription());\n    }\n        if (child.getOrganization() == null) {\n        child.setOrganization(parent.getOrganization());\n    }\n        assembleScmInheritance(child, parent, childPathAdjustment, appendPaths);\n        if (child.getCiManagement() == null) {\n        child.setCiManagement(parent.getCiManagement());\n    }\n        if (child.getDevelopers().size() == 0) {\n        child.setDevelopers(parent.getDevelopers());\n    }\n        if (child.getLicenses().size() == 0) {\n        child.setLicenses(parent.getLicenses());\n    }\n        if (child.getContributors().size() == 0) {\n        child.setContributors(parent.getContributors());\n    }\n        if (child.getMailingLists().size() == 0) {\n        child.setMailingLists(parent.getMailingLists());\n    }\n        assembleBuildInheritance(child, parent);\n    assembleDependencyInheritance(child, parent);\n    child.setRepositories(ModelUtils.mergeRepositoryLists(child.getRepositories(), parent.getRepositories()));\n    child.setPluginRepositories(ModelUtils.mergeRepositoryLists(child.getPluginRepositories(), parent.getPluginRepositories()));\n    assembleReportingInheritance(child, parent);\n    assembleDependencyManagementInheritance(child, parent);\n    assembleDistributionManagementInheritance(child, parent);\n    Properties props = new Properties();\n    props.putAll(parent.getProperties());\n    props.putAll(child.getProperties());\n    child.setProperties(props);\n}", "lc": 2.090909090909091, "pi": -0.27040816326530603, "ma": 2.0, "nbd": 0.0, "ml": 2.0833333333333335, "d": 0.2204646564508157, "mi": -1.0240894751935767, "fo": 5.083333333333333, "r": -0.028571428571428574, "e": 1.2584107486262266}
{"project_name": "Time", "project_version": 16, "label": 2, "code": "// -----------------------------------------------------------------------\n/**\n * Parses a datetime from the given text, at the given position, saving the\n * result into the fields of the given ReadWritableInstant. If the parse\n * succeeds, the return value is the new text position. Note that the parse\n * may succeed without fully reading the text and in this case those fields\n * that were read will be set.\n * <p>\n * Only those fields present in the string will be changed in the specified\n * instant. All other fields will remain unaltered. Thus if the string only\n * contains a year and a month, then the day and time will be retained from\n * the input instant. If this is not the behaviour you want, then reset the\n * fields before calling this method, or use {@link #parseDateTime(String)}\n * or {@link #parseMutableDateTime(String)}.\n * <p>\n * If it fails, the return value is negative, but the instant may still be\n * modified. To determine the position where the parse failed, apply the\n * one's complement operator (~) on the return value.\n * <p>\n * This parse method ignores the {@link #getDefaultYear() default year} and\n * parses using the year from the supplied instant as the default.\n * <p>\n * The parse will use the chronology of the instant.\n *\n * @param instant  an instant that will be modified, not null\n * @param text  the text to parse\n * @param position  position to start parsing from\n * @return new position, negative value means parse failed -\n *  apply complement operator (~) to get position of failure\n * @throws UnsupportedOperationException if parsing is not supported\n * @throws IllegalArgumentException if the instant is null\n * @throws IllegalArgumentException if any field is out of range\n */\npublic int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    } else if (bucket.getZone() != null) {\n        chrono = chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone != null) {\n        instant.setZone(iZone);\n    }\n    return newPos;\n}", "code_comment": "/**\n * Parses a datetime from the given text, at the given position, saving the\n * result into the fields of the given ReadWritableInstant. If the parse\n * succeeds, the return value is the new text position. Note that the parse\n * may succeed without fully reading the text and in this case those fields\n * that were read will be set.\n * <p>\n * Only those fields present in the string will be changed in the specified\n * instant. All other fields will remain unaltered. Thus if the string only\n * contains a year and a month, then the day and time will be retained from\n * the input instant. If this is not the behaviour you want, then reset the\n * fields before calling this method, or use {@link #parseDateTime(String)}\n * or {@link #parseMutableDateTime(String)}.\n * <p>\n * If it fails, the return value is negative, but the instant may still be\n * modified. To determine the position where the parse failed, apply the\n * one's complement operator (~) on the return value.\n * <p>\n * This parse method ignores the {@link #getDefaultYear() default year} and\n * parses using the year from the supplied instant as the default.\n * <p>\n * The parse will use the chronology of the instant.\n *\n * @param instant  an instant that will be modified, not null\n * @param text  the text to parse\n * @param position  position to start parsing from\n * @return new position, negative value means parse failed -\n *  apply complement operator (~) to get position of failure\n * @throws UnsupportedOperationException if parsing is not supported\n * @throws IllegalArgumentException if the instant is null\n * @throws IllegalArgumentException if any field is out of range\n */\n", "code_no_comment": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    } else if (bucket.getZone() != null) {\n        chrono = chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone != null) {\n        instant.setZone(iZone);\n    }\n    return newPos;\n}", "lc": 0.5, "pi": -0.43367346938775514, "ma": 0.3333333333333333, "nbd": 0.0, "ml": 0.4166666666666667, "d": 0.4201680672268908, "mi": -0.44938342414683125, "fo": 1.0, "r": -0.028571428571428574, "e": 0.7936106149965093}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-366_db4a291f", "label": 1, "code": "void initiateClose(boolean saveState, boolean queueMinC, boolean disableWrites) {\n    if (!saveState && queueMinC) {\n        throw new IllegalArgumentException(\"Not saving state on close and requesting minor compactions queue does not make sense\");\n    }\n    log.debug(\"initiateClose(saveState=\" + saveState + \" queueMinC=\" + queueMinC + \" disableWrites=\" + disableWrites + \") \" + getExtent());\n    MinorCompactionTask mct = null;\n    synchronized (this) {\n        if (closed || closing || closeComplete) {\n            String msg = \"Tablet \" + getExtent() + \" already\";\n            if (closed)\n                msg += \" closed\";\n            if (closing)\n                msg += \" closing\";\n            if (closeComplete)\n                msg += \" closeComplete\";\n            throw new IllegalStateException(msg);\n        }\n        // enter the closing state, no splits, minor, or major compactions can start\n        // should cause running major compactions to stop\n        closing = true;\n        this.notifyAll();\n        // determines if inserts and queries can still continue while minor compacting\n        closed = disableWrites;\n        // true should cause any running major compactions to abort\n        while (majorCompactionInProgress) {\n            try {\n                this.wait(50);\n            } catch (InterruptedException e) {\n                log.error(e.toString());\n            }\n        }\n        if (!saveState || tabletMemory.getMemTable().getNumEntries() == 0) {\n            return;\n        }\n        tabletMemory.waitForMinC();\n        mct = prepareForMinC(getFlushID());\n        if (queueMinC) {\n            tabletResources.executeMinorCompaction(mct);\n            return;\n        }\n    }\n    // do minor compaction outside of synch block so that tablet can be read and written to while\n    // compaction runs\n    mct.run();\n}", "code_comment": NaN, "code_no_comment": "void initiateClose(boolean saveState, boolean queueMinC, boolean disableWrites) {\n    if (!saveState && queueMinC) {\n        throw new IllegalArgumentException(\"Not saving state on close and requesting minor compactions queue does not make sense\");\n    }\n    log.debug(\"initiateClose(saveState=\" + saveState + \" queueMinC=\" + queueMinC + \" disableWrites=\" + disableWrites + \") \" + getExtent());\n    MinorCompactionTask mct = null;\n    synchronized (this) {\n        if (closed || closing || closeComplete) {\n            String msg = \"Tablet \" + getExtent() + \" already\";\n            if (closed)\n                msg += \" closed\";\n            if (closing)\n                msg += \" closing\";\n            if (closeComplete)\n                msg += \" closeComplete\";\n            throw new IllegalStateException(msg);\n        }\n                        closing = true;\n        this.notifyAll();\n                closed = disableWrites;\n                while (majorCompactionInProgress) {\n            try {\n                this.wait(50);\n            } catch (InterruptedException e) {\n                log.error(e.toString());\n            }\n        }\n        if (!saveState || tabletMemory.getMemTable().getNumEntries() == 0) {\n            return;\n        }\n        tabletMemory.waitForMinC();\n        mct = prepareForMinC(getFlushID());\n        if (queueMinC) {\n            tabletResources.executeMinorCompaction(mct);\n            return;\n        }\n    }\n            mct.run();\n}", "lc": 1.1363636363636365, "pi": 0.6122448979591836, "ma": 1.3333333333333333, "nbd": 0.5, "ml": 1.1666666666666667, "d": 0.5150766188828474, "mi": -0.6808144536851166, "fo": 0.6666666666666666, "r": -0.028571428571428574, "e": 0.8075946222604837}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-3383_97f16db4", "label": 3, "code": "private static File computeTopCacheDir() {\n    String procName = ManagementFactory.getRuntimeMXBean().getName();\n    return new File(System.getProperty(\"java.io.tmpdir\"), \"accumulo-vfs-cache-\" + procName + \"-\" + System.getProperty(\"user.name\", \"nouser\"));\n}", "code_comment": NaN, "code_no_comment": "private static File computeTopCacheDir() {\n    String procName = ManagementFactory.getRuntimeMXBean().getName();\n    return new File(System.getProperty(\"java.io.tmpdir\"), \"accumulo-vfs-cache-\" + procName + \"-\" + System.getProperty(\"user.name\", \"nouser\"));\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.12951062778052397, "mi": 0.7126469744766275, "fo": -0.16666666666666666, "r": 0.028571428571428574, "e": -0.11765839618641345}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-366_db4a291f", "label": 1, "code": "long getCompactionID() {\n    try {\n        String zTablePath = Constants.ZROOT + \"/\" + HdfsZooInstance.getInstance().getInstanceID() + Constants.ZTABLES + \"/\" + extent.getTableId() + Constants.ZTABLE_COMPACT_ID;\n        return Long.parseLong(new String(ZooReaderWriter.getRetryingInstance().getData(zTablePath, null)));\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}", "code_comment": NaN, "code_no_comment": "long getCompactionID() {\n    try {\n        String zTablePath = Constants.ZROOT + \"/\" + HdfsZooInstance.getInstance().getInstanceID() + Constants.ZTABLES + \"/\" + extent.getTableId() + Constants.ZTABLE_COMPACT_ID;\n        return Long.parseLong(new String(ZooReaderWriter.getRetryingInstance().getData(zTablePath, null)));\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}", "lc": -0.2727272727272727, "pi": 0.051020408163265356, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.1314878892733564, "mi": 0.3002581015199312, "fo": 0.0, "r": 0.17142857142857146, "e": -0.08648669484883138}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1075_79467350", "label": 1, "code": "public void restrictProperty(String propertyName, Operator op, PropertyValue v) {\n    PropertyRestriction x = addRestricition(propertyName);\n    PropertyValue oldFirst = x.first;\n    PropertyValue oldLast = x.last;\n    switch(op) {\n        case EQUAL:\n            if (x.first != null && x.last == x.first && x.firstIncluding && x.lastIncluding) {\n                // if x is a multi-valued property with value \"{1, 2}\")\n                return;\n            }\n            x.first = maxValue(oldFirst, v);\n            x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;\n            x.last = minValue(oldLast, v);\n            x.lastIncluding = x.last == oldLast ? x.lastIncluding : true;\n            break;\n        case NOT_EQUAL:\n            if (v != null) {\n                throw new IllegalArgumentException(\"NOT_EQUAL only supported for NOT_EQUAL NULL\");\n            }\n            break;\n        case GREATER_THAN:\n            x.first = maxValue(oldFirst, v);\n            x.firstIncluding = false;\n            break;\n        case GREATER_OR_EQUAL:\n            x.first = maxValue(oldFirst, v);\n            x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;\n            break;\n        case LESS_THAN:\n            x.last = minValue(oldLast, v);\n            x.lastIncluding = false;\n            break;\n        case LESS_OR_EQUAL:\n            x.last = minValue(oldLast, v);\n            x.lastIncluding = x.last == oldLast ? x.lastIncluding : true;\n            break;\n        case LIKE:\n            // LIKE is handled in the fulltext index\n            x.isLike = true;\n            x.first = v;\n            break;\n        case IN:\n    }\n    if (x.first != null && x.last != null) {\n        if (x.first.compareTo(x.last) > 0) {\n            setAlwaysFalse();\n        } else if (x.first.compareTo(x.last) == 0 && (!x.firstIncluding || !x.lastIncluding)) {\n            setAlwaysFalse();\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "public void restrictProperty(String propertyName, Operator op, PropertyValue v) {\n    PropertyRestriction x = addRestricition(propertyName);\n    PropertyValue oldFirst = x.first;\n    PropertyValue oldLast = x.last;\n    switch(op) {\n        case EQUAL:\n            if (x.first != null && x.last == x.first && x.firstIncluding && x.lastIncluding) {\n                                return;\n            }\n            x.first = maxValue(oldFirst, v);\n            x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;\n            x.last = minValue(oldLast, v);\n            x.lastIncluding = x.last == oldLast ? x.lastIncluding : true;\n            break;\n        case NOT_EQUAL:\n            if (v != null) {\n                throw new IllegalArgumentException(\"NOT_EQUAL only supported for NOT_EQUAL NULL\");\n            }\n            break;\n        case GREATER_THAN:\n            x.first = maxValue(oldFirst, v);\n            x.firstIncluding = false;\n            break;\n        case GREATER_OR_EQUAL:\n            x.first = maxValue(oldFirst, v);\n            x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;\n            break;\n        case LESS_THAN:\n            x.last = minValue(oldLast, v);\n            x.lastIncluding = false;\n            break;\n        case LESS_OR_EQUAL:\n            x.last = minValue(oldLast, v);\n            x.lastIncluding = x.last == oldLast ? x.lastIncluding : true;\n            break;\n        case LIKE:\n                        x.isLike = true;\n            x.first = v;\n            break;\n        case IN:\n    }\n    if (x.first != null && x.last != null) {\n        if (x.first.compareTo(x.last) > 0) {\n            setAlwaysFalse();\n        } else if (x.first.compareTo(x.last) == 0 && (!x.firstIncluding || !x.lastIncluding)) {\n            setAlwaysFalse();\n        }\n    }\n}", "lc": 1.5909090909090908, "pi": 0.3469387755102042, "ma": 3.6666666666666665, "nbd": 0.5, "ml": 2.25, "d": 1.9584775086505195, "mi": -0.977344422139375, "fo": 0.4166666666666667, "r": -0.028571428571428574, "e": 4.731040213122267}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-581_bb02fa15", "label": 1, "code": "private boolean rollover(final RolloverStrategy strategy) {\n    try {\n        // Block until the asynchronous operation is completed.\n        semaphore.acquire();\n    } catch (final InterruptedException ie) {\n        LOGGER.error(\"Thread interrupted while attempting to check rollover\", ie);\n        return false;\n    }\n    boolean success = false;\n    Thread thread = null;\n    try {\n        final RolloverDescription descriptor = strategy.rollover(this);\n        if (descriptor != null) {\n            close();\n            if (descriptor.getSynchronous() != null) {\n                LOGGER.debug(\"RollingFileManager executing synchronous {}\", descriptor.getSynchronous());\n                try {\n                    success = descriptor.getSynchronous().execute();\n                } catch (final Exception ex) {\n                    LOGGER.error(\"Error in synchronous task\", ex);\n                }\n            }\n            if (success && descriptor.getAsynchronous() != null) {\n                LOGGER.debug(\"RollingFileManager executing async {}\", descriptor.getAsynchronous());\n                thread = new Thread(new AsyncAction(descriptor.getAsynchronous(), this));\n                thread.start();\n            }\n            return true;\n        }\n        return false;\n    } finally {\n        if (thread == null) {\n            semaphore.release();\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private boolean rollover(final RolloverStrategy strategy) {\n    try {\n                semaphore.acquire();\n    } catch (final InterruptedException ie) {\n        LOGGER.error(\"Thread interrupted while attempting to check rollover\", ie);\n        return false;\n    }\n    boolean success = false;\n    Thread thread = null;\n    try {\n        final RolloverDescription descriptor = strategy.rollover(this);\n        if (descriptor != null) {\n            close();\n            if (descriptor.getSynchronous() != null) {\n                LOGGER.debug(\"RollingFileManager executing synchronous {}\", descriptor.getSynchronous());\n                try {\n                    success = descriptor.getSynchronous().execute();\n                } catch (final Exception ex) {\n                    LOGGER.error(\"Error in synchronous task\", ex);\n                }\n            }\n            if (success && descriptor.getAsynchronous() != null) {\n                LOGGER.debug(\"RollingFileManager executing async {}\", descriptor.getAsynchronous());\n                thread = new Thread(new AsyncAction(descriptor.getAsynchronous(), this));\n                thread.start();\n            }\n            return true;\n        }\n        return false;\n    } finally {\n        if (thread == null) {\n            semaphore.release();\n        }\n    }\n}", "lc": 0.9545454545454546, "pi": 1.1887755102040816, "ma": 0.5, "nbd": 1.0, "ml": 0.4166666666666667, "d": 0.4221453287197232, "mi": -0.5595067393174652, "fo": 0.8333333333333334, "r": -0.028571428571428574, "e": 0.5104355386519674}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-428_d906576c", "label": 3, "code": "public Object next() {\n    index++;\n    return new Map.Entry() {\n\n        public Object getKey() {\n            return key;\n        }\n\n        public Object getValue() {\n            return value;\n        }\n\n        public Object setValue(final Object value) {\n            final Object oldValue = MicroMap.this.value;\n            MicroMap.this.value = value;\n            return oldValue;\n        }\n    };\n}", "code_comment": NaN, "code_no_comment": "public Object next() {\n    index++;\n    return new Map.Entry() {\n\n        public Object getKey() {\n            return key;\n        }\n\n        public Object getValue() {\n            return value;\n        }\n\n        public Object setValue(final Object value) {\n            final Object oldValue = MicroMap.this.value;\n            MicroMap.this.value = value;\n            return oldValue;\n        }\n    };\n}", "lc": 0.09090909090909091, "pi": 0.4846938775510205, "ma": -0.5, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.014829461196243152, "mi": 0.037854889589905176, "fo": -0.5, "r": 1.1714285714285715, "e": -0.08082028087938632}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4309_b4274415", "label": 1, "code": "/**\n *  Convert to object types, returning null if text is null.\n *\n *  @return converted\n *  @throws StringValueConversionException\n */\npublic final Integer toOptionalInteger() throws StringValueConversionException {\n    return (text == null) ? null : toInteger();\n}", "code_comment": "/**\n *  Convert to object types, returning null if text is null.\n *\n *  @return converted\n *  @throws StringValueConversionException\n */\n", "code_no_comment": "public final Integer toOptionalInteger() throws StringValueConversionException {\n    return (text == null) ? null : toInteger();\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.3333333333333333, "nbd": -1.0, "ml": -0.25, "d": -0.3806228373702422, "mi": 1.012044737596788, "fo": -0.4166666666666667, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-147_17296089", "label": 1, "code": "private Result filter() {\n    boolean match = false;\n    if (useMap) {\n        for (final Map.Entry<String, List<String>> entry : getMap().entrySet()) {\n            final String toMatch = ThreadContext.get(entry.getKey());\n            if (toMatch != null) {\n                match = entry.getValue().contains(toMatch);\n            } else {\n                match = false;\n            }\n            if ((!isAnd() && match) || (isAnd() && !match)) {\n                break;\n            }\n        }\n    } else {\n        match = key.equals(ThreadContext.get(key));\n    }\n    return match ? onMatch : onMismatch;\n}", "code_comment": NaN, "code_no_comment": "private Result filter() {\n    boolean match = false;\n    if (useMap) {\n        for (final Map.Entry<String, List<String>> entry : getMap().entrySet()) {\n            final String toMatch = ThreadContext.get(entry.getKey());\n            if (toMatch != null) {\n                match = entry.getValue().contains(toMatch);\n            } else {\n                match = false;\n            }\n            if ((!isAnd() && match) || (isAnd() && !match)) {\n                break;\n            }\n        }\n    } else {\n        match = key.equals(ThreadContext.get(key));\n    }\n    return match ? onMatch : onMismatch;\n}", "lc": 0.22727272727272727, "pi": 1.045918367346939, "ma": 0.5, "nbd": 0.5, "ml": 0.5, "d": 0.28373702422145336, "mi": -0.2162317178090051, "fo": 0.3333333333333333, "r": 0.028571428571428574, "e": 0.21002993819625582}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3314_8fc7e7af", "label": 0, "code": "// ------------------------------------------------------------------------\n// Core work methods of the Stream Task\n// ------------------------------------------------------------------------\n@Override\npublic final void invoke() throws Exception {\n    boolean disposed = false;\n    try {\n        // -------- Initialize ---------\n        LOG.debug(\"Initializing {}\", getName());\n        userClassLoader = getUserCodeClassLoader();\n        configuration = new StreamConfig(getTaskConfiguration());\n        accumulatorMap = getEnvironment().getAccumulatorRegistry().getUserMap();\n        headOperator = configuration.getStreamOperator(userClassLoader);\n        operatorChain = new OperatorChain<>(this, headOperator, getEnvironment().getAccumulatorRegistry().getReadWriteReporter());\n        if (headOperator != null) {\n            headOperator.setup(this, configuration, operatorChain.getChainEntryPoint());\n        }\n        timerService = Executors.newSingleThreadScheduledExecutor(new DispatcherThreadFactory(TRIGGER_THREAD_GROUP, \"Time Trigger for \" + getName()));\n        // task specific initialization\n        init();\n        // -------- Invoke --------\n        LOG.debug(\"Invoking {}\", getName());\n        // first order of business is to give operators back their state\n        stateBackend = createStateBackend();\n        stateBackend.initializeForJob(getEnvironment());\n        restoreState();\n        // executed before all operators are opened\n        synchronized (lock) {\n            openAllOperators();\n        }\n        // let the task do its work\n        isRunning = true;\n        run();\n        isRunning = false;\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Finished task {}\", getName());\n        }\n        // we also need to make sure that no triggers fire concurrently with the close logic\n        synchronized (lock) {\n            // this is part of the main logic, so if this fails, the task is considered failed\n            closeAllOperators();\n        }\n        // make sure all buffered data is flushed\n        operatorChain.flushOutputs();\n        // make an attempt to dispose the operators such that failures in the dispose call\n        // still let the computation fail\n        tryDisposeAllOperators();\n        disposed = true;\n    } finally {\n        // clean up everything we initialized\n        isRunning = false;\n        // stop all timers and threads\n        if (timerService != null) {\n            try {\n                timerService.shutdownNow();\n            } catch (Throwable t) {\n                // catch and log the exception to not replace the original exception\n                LOG.error(\"Could not shut down timer service\", t);\n            }\n        }\n        // stop all asynchronous checkpoint threads\n        try {\n            for (Thread checkpointThread : asyncCheckpointThreads) {\n                checkpointThread.interrupt();\n            }\n            asyncCheckpointThreads.clear();\n        } catch (Throwable t) {\n            // catch and log the exception to not replace the original exception\n            LOG.error(\"Could not shut down async checkpoint threads\", t);\n        }\n        // release the output resources. this method should never fail.\n        if (operatorChain != null) {\n            operatorChain.releaseOutputs();\n        }\n        // we must! perform this cleanup\n        try {\n            cleanup();\n        } catch (Throwable t) {\n            // catch and log the exception to not replace the original exception\n            LOG.error(\"Error during cleanup of stream task\", t);\n        }\n        // if the operators were not disposed before, do a hard dispose\n        if (!disposed) {\n            disposeAllOperators();\n        }\n        try {\n            if (stateBackend != null) {\n                stateBackend.close();\n            }\n        } catch (Throwable t) {\n            LOG.error(\"Error while closing the state backend\", t);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic final void invoke() throws Exception {\n    boolean disposed = false;\n    try {\n                LOG.debug(\"Initializing {}\", getName());\n        userClassLoader = getUserCodeClassLoader();\n        configuration = new StreamConfig(getTaskConfiguration());\n        accumulatorMap = getEnvironment().getAccumulatorRegistry().getUserMap();\n        headOperator = configuration.getStreamOperator(userClassLoader);\n        operatorChain = new OperatorChain<>(this, headOperator, getEnvironment().getAccumulatorRegistry().getReadWriteReporter());\n        if (headOperator != null) {\n            headOperator.setup(this, configuration, operatorChain.getChainEntryPoint());\n        }\n        timerService = Executors.newSingleThreadScheduledExecutor(new DispatcherThreadFactory(TRIGGER_THREAD_GROUP, \"Time Trigger for \" + getName()));\n                init();\n                LOG.debug(\"Invoking {}\", getName());\n                stateBackend = createStateBackend();\n        stateBackend.initializeForJob(getEnvironment());\n        restoreState();\n                synchronized (lock) {\n            openAllOperators();\n        }\n                isRunning = true;\n        run();\n        isRunning = false;\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Finished task {}\", getName());\n        }\n                synchronized (lock) {\n                        closeAllOperators();\n        }\n                operatorChain.flushOutputs();\n                        tryDisposeAllOperators();\n        disposed = true;\n    } finally {\n                isRunning = false;\n                if (timerService != null) {\n            try {\n                timerService.shutdownNow();\n            } catch (Throwable t) {\n                                LOG.error(\"Could not shut down timer service\", t);\n            }\n        }\n                try {\n            for (Thread checkpointThread : asyncCheckpointThreads) {\n                checkpointThread.interrupt();\n            }\n            asyncCheckpointThreads.clear();\n        } catch (Throwable t) {\n                        LOG.error(\"Could not shut down async checkpoint threads\", t);\n        }\n                if (operatorChain != null) {\n            operatorChain.releaseOutputs();\n        }\n                try {\n            cleanup();\n        } catch (Throwable t) {\n                        LOG.error(\"Error during cleanup of stream task\", t);\n        }\n                if (!disposed) {\n            disposeAllOperators();\n        }\n        try {\n            if (stateBackend != null) {\n                stateBackend.close();\n            }\n        } catch (Throwable t) {\n            LOG.error(\"Error while closing the state backend\", t);\n        }\n    }\n}", "lc": 2.590909090909091, "pi": 0.10714285714285712, "ma": 1.3333333333333333, "nbd": 0.5, "ml": 0.5833333333333334, "d": 0.3509639149777559, "mi": -1.0395755663894468, "fo": 2.9166666666666665, "r": -0.028571428571428574, "e": 1.1944997665762953}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-606_f0fbacab", "label": 1, "code": "/**\n * Determine whether this item is stale\n * @return  {@code true} iff stale\n */\npublic boolean isStale() {\n    Status status = getLocationOrNull().getStatus();\n    return status == Status.DISCONNECTED || status == null;\n}", "code_comment": "/**\n * Determine whether this item is stale\n * @return  {@code true} iff stale\n */\n", "code_no_comment": "public boolean isStale() {\n    Status status = getLocationOrNull().getStatus();\n    return status == Status.DISCONNECTED || status == null;\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.10776075135936727, "mi": 0.787783194723258, "fo": -0.3333333333333333, "r": 2.8285714285714287, "e": -0.13366826422706773}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5441_8ccb1f6d", "label": 1, "code": "/**\n *  set resource caching to maximum and set cache-visibility to 'public'\n *\n *  @param response\n */\n@Override\npublic void decorateResponse(AbstractResource.ResourceResponse response, IStaticCacheableResource resource) {\n    response.setCacheDurationToMaximum();\n    response.setCacheScope(WebResponse.CacheScope.PUBLIC);\n}", "code_comment": "/**\n *  set resource caching to maximum and set cache-visibility to 'public'\n *\n *  @param response\n */\n", "code_no_comment": "@Override\npublic void decorateResponse(AbstractResource.ResourceResponse response, IStaticCacheableResource resource) {\n    response.setCacheDurationToMaximum();\n    response.setCacheScope(WebResponse.CacheScope.PUBLIC);\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.6739317464869518, "fo": -0.3333333333333333, "r": 2.4571428571428573, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-447_00df38d2", "label": 1, "code": "@Override\npublic NodeBuilder child(String name) {\n    // shortcut when dealing with a read-only child node\n    read();\n    if (baseState != null && baseState.hasChildNode(name) && (writeState == null || !writeState.nodes.containsKey(name))) {\n        return createChildBuilder(name);\n    }\n    // no read-only child node found, switch to write mode\n    write();\n    // guaranteed by write()\n    assert writeState != null;\n    NodeState childBase = null;\n    if (baseState != null) {\n        childBase = baseState.getChildNode(name);\n    }\n    if (writeState.nodes.get(name) == null) {\n        if (writeState.nodes.containsKey(name)) {\n            // The child node was removed earlier and we're creating\n            // a new child with the same name. Use the null state to\n            // prevent the previous child state from re-surfacing.\n            childBase = null;\n        }\n        writeState.nodes.put(name, new MutableNodeState(childBase));\n    }\n    MemoryNodeBuilder builder = createChildBuilder(name);\n    builder.write();\n    return builder;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic NodeBuilder child(String name) {\n        read();\n    if (baseState != null && baseState.hasChildNode(name) && (writeState == null || !writeState.nodes.containsKey(name))) {\n        return createChildBuilder(name);\n    }\n        write();\n        assert writeState != null;\n    NodeState childBase = null;\n    if (baseState != null) {\n        childBase = baseState.getChildNode(name);\n    }\n    if (writeState.nodes.get(name) == null) {\n        if (writeState.nodes.containsKey(name)) {\n                                                childBase = null;\n        }\n        writeState.nodes.put(name, new MutableNodeState(childBase));\n    }\n    MemoryNodeBuilder builder = createChildBuilder(name);\n    builder.write();\n    return builder;\n}", "lc": 0.36363636363636365, "pi": -0.08163265306122457, "ma": 0.16666666666666666, "nbd": 0.0, "ml": 0.6666666666666666, "d": -0.3806228373702422, "mi": 0.14941210209348996, "fo": 0.4166666666666667, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-373_bfe4623c", "label": 1, "code": "/**\n * Returns the sum of the squares of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the sum of the squares of the values or Double.NaN if length = 0\n * @throws IllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\n@Override\npublic double evaluate(final double[] values, final int begin, final int length) {\n    double sumSq = Double.NaN;\n    if (test(values, begin, length)) {\n        sumSq = 0.0;\n        for (int i = begin; i < begin + length; i++) {\n            sumSq += values[i] * values[i];\n        }\n    }\n    return sumSq;\n}", "code_comment": "/**\n * Returns the sum of the squares of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the sum of the squares of the values or Double.NaN if length = 0\n * @throws IllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\n", "code_no_comment": "@Override\npublic double evaluate(final double[] values, final int begin, final int length) {\n    double sumSq = Double.NaN;\n    if (test(values, begin, length)) {\n        sumSq = 0.0;\n        for (int i = begin; i < begin + length; i++) {\n            sumSq += values[i] * values[i];\n        }\n    }\n    return sumSq;\n}", "lc": -0.13636363636363635, "pi": 0.36734693877551033, "ma": -0.16666666666666666, "nbd": 0.0, "ml": 0.16666666666666666, "d": 0.9540286702916463, "mi": 0.15027244049326058, "fo": -0.4166666666666667, "r": -0.028571428571428574, "e": 0.2577083360102107}
{"project_name": "Lang", "project_version": 30, "label": 3, "code": "/**\n * <p>Search a String to find the first index of any\n * character not in the given set of characters.</p>\n *\n * <p>A <code>null</code> String will return <code>-1</code>.\n * A <code>null</code> search string will return <code>-1</code>.</p>\n *\n * <pre>\n * StringUtils.indexOfAnyBut(null, *)            = -1\n * StringUtils.indexOfAnyBut(\"\", *)              = -1\n * StringUtils.indexOfAnyBut(*, null)            = -1\n * StringUtils.indexOfAnyBut(*, \"\")              = -1\n * StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"za\") = 3\n * StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"\")   = 0\n * StringUtils.indexOfAnyBut(\"aba\",\"ab\")         = -1\n * </pre>\n *\n * @param str  the String to check, may be null\n * @param searchChars  the chars to search for, may be null\n * @return the index of any of the chars, -1 if no match or null input\n * @since 2.0\n */\npublic static int indexOfAnyBut(String str, String searchChars) {\n    if (isEmpty(str) || isEmpty(searchChars)) {\n        return INDEX_NOT_FOUND;\n    }\n    int strLen = str.length();\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n        if (searchChars.indexOf(ch) < 0) {\n            return i;\n        }\n    }\n    return INDEX_NOT_FOUND;\n}", "code_comment": "/**\n * <p>Search a String to find the first index of any\n * character not in the given set of characters.</p>\n *\n * <p>A <code>null</code> String will return <code>-1</code>.\n * A <code>null</code> search string will return <code>-1</code>.</p>\n *\n * <pre>\n * StringUtils.indexOfAnyBut(null, *)            = -1\n * StringUtils.indexOfAnyBut(\"\", *)              = -1\n * StringUtils.indexOfAnyBut(*, null)            = -1\n * StringUtils.indexOfAnyBut(*, \"\")              = -1\n * StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"za\") = 3\n * StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"\")   = 0\n * StringUtils.indexOfAnyBut(\"aba\",\"ab\")         = -1\n * </pre>\n *\n * @param str  the String to check, may be null\n * @param searchChars  the chars to search for, may be null\n * @return the index of any of the chars, -1 if no match or null input\n * @since 2.0\n */\n", "code_no_comment": "public static int indexOfAnyBut(String str, String searchChars) {\n    if (isEmpty(str) || isEmpty(searchChars)) {\n        return INDEX_NOT_FOUND;\n    }\n    int strLen = str.length();\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n        if (searchChars.indexOf(ch) < 0) {\n            return i;\n        }\n    }\n    return INDEX_NOT_FOUND;\n}", "lc": -0.045454545454545456, "pi": 0.13775510204081634, "ma": 0.0, "nbd": 0.0, "ml": 0.5833333333333334, "d": 0.43796342066238264, "mi": 0.06194436478348142, "fo": -0.08333333333333333, "r": 0.08571428571428572, "e": 0.10213679057396532}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5571_0e87b84f", "label": 1, "code": "public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\n    BeanInvocation invocation = new BeanInvocation(method, args);\n    MethodInfo methodInfo = methodInfoCache.getMethodInfo(method);\n    final ExchangePattern pattern = methodInfo != null ? methodInfo.getPattern() : ExchangePattern.InOut;\n    return invokeWithbody(method, invocation, pattern);\n}", "code_comment": NaN, "code_no_comment": "public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\n    BeanInvocation invocation = new BeanInvocation(method, args);\n    MethodInfo methodInfo = methodInfoCache.getMethodInfo(method);\n    final ExchangePattern pattern = methodInfo != null ? methodInfo.getPattern() : ExchangePattern.InOut;\n    return invokeWithbody(method, invocation, pattern);\n}", "lc": -0.36363636363636365, "pi": -0.576530612244898, "ma": -0.3333333333333333, "nbd": -1.0, "ml": -0.25, "d": -0.06426099851705384, "mi": 0.4244336105534844, "fo": -0.25, "r": 0.05714285714285714, "e": -0.05421426154590737}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4", "label": 1, "code": "/**\n *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT USE IT.\n *\n *  Adds a child component to this container.\n *\n *  @param child\n *             The child\n *  @throws IllegalArgumentException\n *              Thrown if a child with the same id is replaced by the add\n *              operation.\n */\npublic void internalAdd(final Component child) {\n    if (log.isDebugEnabled()) {\n        log.debug(\"internalAdd \" + child.getId() + \" to \" + this);\n    }\n    // Add to map\n    addedComponent(child);\n    put(child);\n}", "code_comment": "/**\n *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT USE IT.\n *\n *  Adds a child component to this container.\n *\n *  @param child\n *             The child\n *  @throws IllegalArgumentException\n *              Thrown if a child with the same id is replaced by the add\n *              operation.\n */\n", "code_no_comment": "public void internalAdd(final Component child) {\n    if (log.isDebugEnabled()) {\n        log.debug(\"internalAdd \" + child.getId() + \" to \" + this);\n    }\n        addedComponent(child);\n    put(child);\n}", "lc": -0.3181818181818182, "pi": -0.2346938775510204, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.3806228373702422, "mi": 0.4924003441353601, "fo": -0.08333333333333333, "r": 2.685714285714286, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-9672_84922699", "label": 3, "code": "@SuppressWarnings({ \"deprecation\", \"unchecked\" })\npublic Object getManagedObjectForProcessor(CamelContext context, Processor processor, ProcessorDefinition<?> definition, Route route) {\n    ManagedProcessor answer = null;\n    if (definition instanceof RecipientListDefinition) {\n        // special for RecipientListDefinition, as the processor is wrapped in a pipeline as last\n        Pipeline pipeline = (Pipeline) processor;\n        Iterator<Processor> it = pipeline.getProcessors().iterator();\n        while (it.hasNext()) {\n            processor = it.next();\n        }\n    } else if (definition instanceof ThreadsDefinition) {\n        // special for ThreadsDefinition, as the processor is wrapped in a pipeline as first\n        Pipeline pipeline = (Pipeline) processor;\n        Iterator<Processor> it = pipeline.getProcessors().iterator();\n        processor = it.next();\n    }\n    // unwrap delegates as we want the real target processor\n    Processor target = processor;\n    while (target != null) {\n        // skip error handlers\n        if (target instanceof ErrorHandler) {\n            return false;\n        }\n        if (target instanceof ConvertBodyProcessor) {\n            answer = new ManagedConvertBody(context, (ConvertBodyProcessor) target, definition);\n        } else if (target instanceof ChoiceProcessor) {\n            answer = new ManagedChoice(context, (ChoiceProcessor) target, definition);\n        } else if (target instanceof Delayer) {\n            answer = new ManagedDelayer(context, (Delayer) target, definition);\n        } else if (target instanceof Throttler) {\n            answer = new ManagedThrottler(context, (Throttler) target, definition);\n        } else if (target instanceof DynamicRouter) {\n            answer = new ManagedDynamicRouter(context, (DynamicRouter) target, (org.apache.camel.model.DynamicRouterDefinition) definition);\n        } else if (target instanceof RoutingSlip) {\n            answer = new ManagedRoutingSlip(context, (RoutingSlip) target, (org.apache.camel.model.RoutingSlipDefinition) definition);\n        } else if (target instanceof FilterProcessor) {\n            answer = new ManagedFilter(context, (FilterProcessor) target, (org.apache.camel.model.FilterDefinition) definition);\n        } else if (target instanceof LogProcessor) {\n            answer = new ManagedLog(context, (LogProcessor) target, definition);\n        } else if (target instanceof LoopProcessor) {\n            answer = new ManagedLoop(context, (LoopProcessor) target, (org.apache.camel.model.LoopDefinition) definition);\n        } else if (target instanceof MarshalProcessor) {\n            answer = new ManagedMarshal(context, (MarshalProcessor) target, (org.apache.camel.model.MarshalDefinition) definition);\n        } else if (target instanceof UnmarshalProcessor) {\n            answer = new ManagedUnmarshal(context, (UnmarshalProcessor) target, (org.apache.camel.model.UnmarshalDefinition) definition);\n        } else if (target instanceof CircuitBreakerLoadBalancer) {\n            answer = new ManagedCircuitBreakerLoadBalancer(context, (CircuitBreakerLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\n        } else if (target instanceof FailOverLoadBalancer) {\n            answer = new ManagedFailoverLoadBalancer(context, (FailOverLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\n        } else if (target instanceof RandomLoadBalancer) {\n            answer = new ManagedRandomLoadBalancer(context, (RandomLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\n        } else if (target instanceof RoundRobinLoadBalancer) {\n            answer = new ManagedRoundRobinLoadBalancer(context, (RoundRobinLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\n        } else if (target instanceof StickyLoadBalancer) {\n            answer = new ManagedStickyLoadBalancer(context, (StickyLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\n        } else if (target instanceof TopicLoadBalancer) {\n            answer = new ManagedTopicLoadBalancer(context, (TopicLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\n        } else if (target instanceof WeightedLoadBalancer) {\n            answer = new ManagedWeightedLoadBalancer(context, (WeightedLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\n        } else if (target instanceof RecipientList) {\n            answer = new ManagedRecipientList(context, (RecipientList) target, (RecipientListDefinition) definition);\n        } else if (target instanceof Splitter) {\n            answer = new ManagedSplitter(context, (Splitter) target, (org.apache.camel.model.SplitDefinition) definition);\n        } else if (target instanceof MulticastProcessor) {\n            answer = new ManagedMulticast(context, (MulticastProcessor) target, definition);\n        } else if (target instanceof SamplingThrottler) {\n            answer = new ManagedSamplingThrottler(context, (SamplingThrottler) target, definition);\n        } else if (target instanceof Resequencer) {\n            answer = new ManagedResequencer(context, (Resequencer) target, definition);\n        } else if (target instanceof RollbackProcessor) {\n            answer = new ManagedRollback(context, (RollbackProcessor) target, definition);\n        } else if (target instanceof StreamResequencer) {\n            answer = new ManagedResequencer(context, (StreamResequencer) target, definition);\n        } else if (target instanceof SetBodyProcessor) {\n            answer = new ManagedSetBody(context, (SetBodyProcessor) target, (org.apache.camel.model.SetBodyDefinition) definition);\n        } else if (target instanceof RemoveHeaderProcessor) {\n            answer = new ManagedRemoveHeader(context, (RemoveHeaderProcessor) target, definition);\n        } else if (target instanceof RemoveHeadersProcessor) {\n            answer = new ManagedRemoveHeaders(context, (RemoveHeadersProcessor) target, definition);\n        } else if (target instanceof SetHeaderProcessor) {\n            answer = new ManagedSetHeader(context, (SetHeaderProcessor) target, (org.apache.camel.model.SetHeaderDefinition) definition);\n        } else if (target instanceof RemovePropertyProcessor) {\n            answer = new ManagedRemoveProperty(context, (RemovePropertyProcessor) target, definition);\n        } else if (target instanceof RemovePropertiesProcessor) {\n            answer = new ManagedRemoveProperties(context, (RemovePropertiesProcessor) target, definition);\n        } else if (target instanceof SetPropertyProcessor) {\n            answer = new ManagedSetProperty(context, (SetPropertyProcessor) target, (org.apache.camel.model.SetPropertyDefinition) definition);\n        } else if (target instanceof ExchangePatternProcessor) {\n            answer = new ManagedSetExchangePattern(context, (ExchangePatternProcessor) target, definition);\n        } else if (target instanceof ScriptProcessor) {\n            answer = new ManagedScript(context, (ScriptProcessor) target, (org.apache.camel.model.ScriptDefinition) definition);\n        } else if (target instanceof StopProcessor) {\n            answer = new ManagedStop(context, (StopProcessor) target, definition);\n        } else if (target instanceof ThreadsProcessor) {\n            answer = new ManagedThreads(context, (ThreadsProcessor) target, definition);\n        } else if (target instanceof ThrowExceptionProcessor) {\n            answer = new ManagedThrowException(context, (ThrowExceptionProcessor) target, definition);\n        } else if (target instanceof TransformProcessor) {\n            answer = new ManagedTransformer(context, (TransformProcessor) target, (org.apache.camel.model.TransformDefinition) definition);\n        } else if (target instanceof PredicateValidatingProcessor) {\n            answer = new ManagedValidate(context, (PredicateValidatingProcessor) target, (org.apache.camel.model.ValidateDefinition) definition);\n        } else if (target instanceof WireTapProcessor) {\n            answer = new ManagedWireTapProcessor(context, (WireTapProcessor) target, definition);\n        } else if (target instanceof SendDynamicProcessor) {\n            answer = new ManagedSendDynamicProcessor(context, (SendDynamicProcessor) target, definition);\n        } else if (target instanceof SendProcessor) {\n            SendProcessor sp = (SendProcessor) target;\n            // special for sending to throughput logger\n            if (sp.getDestination() instanceof LogEndpoint) {\n                LogEndpoint le = (LogEndpoint) sp.getDestination();\n                if (le.getLogger() instanceof ThroughputLogger) {\n                    ThroughputLogger tl = (ThroughputLogger) le.getLogger();\n                    answer = new ManagedThroughputLogger(context, tl, definition);\n                }\n            }\n            // regular send processor\n            if (answer == null) {\n                answer = new ManagedSendProcessor(context, (SendProcessor) target, definition);\n            }\n        } else if (target instanceof BeanProcessor) {\n            answer = new ManagedBeanProcessor(context, (BeanProcessor) target, definition);\n        } else if (target instanceof IdempotentConsumer) {\n            answer = new ManagedIdempotentConsumer(context, (IdempotentConsumer) target, (org.apache.camel.model.IdempotentConsumerDefinition) definition);\n        } else if (target instanceof AggregateProcessor) {\n            answer = new ManagedAggregateProcessor(context, (AggregateProcessor) target, (org.apache.camel.model.AggregateDefinition) definition);\n        } else if (target instanceof Enricher) {\n            answer = new ManagedEnricher(context, (Enricher) target, (org.apache.camel.model.EnrichDefinition) definition);\n        } else if (target instanceof PollEnricher) {\n            answer = new ManagedPollEnricher(context, (PollEnricher) target, (org.apache.camel.model.PollEnrichDefinition) definition);\n        } else if (target instanceof org.apache.camel.spi.ManagementAware) {\n            return ((org.apache.camel.spi.ManagementAware<Processor>) target).getManagedObject(processor);\n        }\n        // special for custom load balancer\n        if (definition instanceof LoadBalanceDefinition) {\n            LoadBalanceDefinition lb = (LoadBalanceDefinition) definition;\n            if (lb.getLoadBalancerType() instanceof CustomLoadBalancerDefinition) {\n                answer = new ManagedCustomLoadBalancer(context, (LoadBalancer) target, (LoadBalanceDefinition) definition);\n            }\n        }\n        if (answer != null) {\n            // break out as we found an answer\n            break;\n        }\n        // no answer yet, so unwrap any delegates and try again\n        if (target instanceof DelegateProcessor) {\n            target = ((DelegateProcessor) target).getProcessor();\n        } else {\n            // no delegate so we dont have any target to try next\n            break;\n        }\n    }\n    if (answer == null && definition instanceof ProcessDefinition) {\n        answer = new ManagedProcess(context, target, (ProcessDefinition) definition);\n    } else if (answer == null) {\n        // fallback to a generic processor\n        answer = new ManagedProcessor(context, target, definition);\n    }\n    answer.setRoute(route);\n    answer.init(context.getManagementStrategy());\n    return answer;\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings({ \"deprecation\", \"unchecked\" })\npublic Object getManagedObjectForProcessor(CamelContext context, Processor processor, ProcessorDefinition<?> definition, Route route) {\n    ManagedProcessor answer = null;\n    if (definition instanceof RecipientListDefinition) {\n                Pipeline pipeline = (Pipeline) processor;\n        Iterator<Processor> it = pipeline.getProcessors().iterator();\n        while (it.hasNext()) {\n            processor = it.next();\n        }\n    } else if (definition instanceof ThreadsDefinition) {\n                Pipeline pipeline = (Pipeline) processor;\n        Iterator<Processor> it = pipeline.getProcessors().iterator();\n        processor = it.next();\n    }\n        Processor target = processor;\n    while (target != null) {\n                if (target instanceof ErrorHandler) {\n            return false;\n        }\n        if (target instanceof ConvertBodyProcessor) {\n            answer = new ManagedConvertBody(context, (ConvertBodyProcessor) target, definition);\n        } else if (target instanceof ChoiceProcessor) {\n            answer = new ManagedChoice(context, (ChoiceProcessor) target, definition);\n        } else if (target instanceof Delayer) {\n            answer = new ManagedDelayer(context, (Delayer) target, definition);\n        } else if (target instanceof Throttler) {\n            answer = new ManagedThrottler(context, (Throttler) target, definition);\n        } else if (target instanceof DynamicRouter) {\n            answer = new ManagedDynamicRouter(context, (DynamicRouter) target, (org.apache.camel.model.DynamicRouterDefinition) definition);\n        } else if (target instanceof RoutingSlip) {\n            answer = new ManagedRoutingSlip(context, (RoutingSlip) target, (org.apache.camel.model.RoutingSlipDefinition) definition);\n        } else if (target instanceof FilterProcessor) {\n            answer = new ManagedFilter(context, (FilterProcessor) target, (org.apache.camel.model.FilterDefinition) definition);\n        } else if (target instanceof LogProcessor) {\n            answer = new ManagedLog(context, (LogProcessor) target, definition);\n        } else if (target instanceof LoopProcessor) {\n            answer = new ManagedLoop(context, (LoopProcessor) target, (org.apache.camel.model.LoopDefinition) definition);\n        } else if (target instanceof MarshalProcessor) {\n            answer = new ManagedMarshal(context, (MarshalProcessor) target, (org.apache.camel.model.MarshalDefinition) definition);\n        } else if (target instanceof UnmarshalProcessor) {\n            answer = new ManagedUnmarshal(context, (UnmarshalProcessor) target, (org.apache.camel.model.UnmarshalDefinition) definition);\n        } else if (target instanceof CircuitBreakerLoadBalancer) {\n            answer = new ManagedCircuitBreakerLoadBalancer(context, (CircuitBreakerLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\n        } else if (target instanceof FailOverLoadBalancer) {\n            answer = new ManagedFailoverLoadBalancer(context, (FailOverLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\n        } else if (target instanceof RandomLoadBalancer) {\n            answer = new ManagedRandomLoadBalancer(context, (RandomLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\n        } else if (target instanceof RoundRobinLoadBalancer) {\n            answer = new ManagedRoundRobinLoadBalancer(context, (RoundRobinLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\n        } else if (target instanceof StickyLoadBalancer) {\n            answer = new ManagedStickyLoadBalancer(context, (StickyLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\n        } else if (target instanceof TopicLoadBalancer) {\n            answer = new ManagedTopicLoadBalancer(context, (TopicLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\n        } else if (target instanceof WeightedLoadBalancer) {\n            answer = new ManagedWeightedLoadBalancer(context, (WeightedLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\n        } else if (target instanceof RecipientList) {\n            answer = new ManagedRecipientList(context, (RecipientList) target, (RecipientListDefinition) definition);\n        } else if (target instanceof Splitter) {\n            answer = new ManagedSplitter(context, (Splitter) target, (org.apache.camel.model.SplitDefinition) definition);\n        } else if (target instanceof MulticastProcessor) {\n            answer = new ManagedMulticast(context, (MulticastProcessor) target, definition);\n        } else if (target instanceof SamplingThrottler) {\n            answer = new ManagedSamplingThrottler(context, (SamplingThrottler) target, definition);\n        } else if (target instanceof Resequencer) {\n            answer = new ManagedResequencer(context, (Resequencer) target, definition);\n        } else if (target instanceof RollbackProcessor) {\n            answer = new ManagedRollback(context, (RollbackProcessor) target, definition);\n        } else if (target instanceof StreamResequencer) {\n            answer = new ManagedResequencer(context, (StreamResequencer) target, definition);\n        } else if (target instanceof SetBodyProcessor) {\n            answer = new ManagedSetBody(context, (SetBodyProcessor) target, (org.apache.camel.model.SetBodyDefinition) definition);\n        } else if (target instanceof RemoveHeaderProcessor) {\n            answer = new ManagedRemoveHeader(context, (RemoveHeaderProcessor) target, definition);\n        } else if (target instanceof RemoveHeadersProcessor) {\n            answer = new ManagedRemoveHeaders(context, (RemoveHeadersProcessor) target, definition);\n        } else if (target instanceof SetHeaderProcessor) {\n            answer = new ManagedSetHeader(context, (SetHeaderProcessor) target, (org.apache.camel.model.SetHeaderDefinition) definition);\n        } else if (target instanceof RemovePropertyProcessor) {\n            answer = new ManagedRemoveProperty(context, (RemovePropertyProcessor) target, definition);\n        } else if (target instanceof RemovePropertiesProcessor) {\n            answer = new ManagedRemoveProperties(context, (RemovePropertiesProcessor) target, definition);\n        } else if (target instanceof SetPropertyProcessor) {\n            answer = new ManagedSetProperty(context, (SetPropertyProcessor) target, (org.apache.camel.model.SetPropertyDefinition) definition);\n        } else if (target instanceof ExchangePatternProcessor) {\n            answer = new ManagedSetExchangePattern(context, (ExchangePatternProcessor) target, definition);\n        } else if (target instanceof ScriptProcessor) {\n            answer = new ManagedScript(context, (ScriptProcessor) target, (org.apache.camel.model.ScriptDefinition) definition);\n        } else if (target instanceof StopProcessor) {\n            answer = new ManagedStop(context, (StopProcessor) target, definition);\n        } else if (target instanceof ThreadsProcessor) {\n            answer = new ManagedThreads(context, (ThreadsProcessor) target, definition);\n        } else if (target instanceof ThrowExceptionProcessor) {\n            answer = new ManagedThrowException(context, (ThrowExceptionProcessor) target, definition);\n        } else if (target instanceof TransformProcessor) {\n            answer = new ManagedTransformer(context, (TransformProcessor) target, (org.apache.camel.model.TransformDefinition) definition);\n        } else if (target instanceof PredicateValidatingProcessor) {\n            answer = new ManagedValidate(context, (PredicateValidatingProcessor) target, (org.apache.camel.model.ValidateDefinition) definition);\n        } else if (target instanceof WireTapProcessor) {\n            answer = new ManagedWireTapProcessor(context, (WireTapProcessor) target, definition);\n        } else if (target instanceof SendDynamicProcessor) {\n            answer = new ManagedSendDynamicProcessor(context, (SendDynamicProcessor) target, definition);\n        } else if (target instanceof SendProcessor) {\n            SendProcessor sp = (SendProcessor) target;\n                        if (sp.getDestination() instanceof LogEndpoint) {\n                LogEndpoint le = (LogEndpoint) sp.getDestination();\n                if (le.getLogger() instanceof ThroughputLogger) {\n                    ThroughputLogger tl = (ThroughputLogger) le.getLogger();\n                    answer = new ManagedThroughputLogger(context, tl, definition);\n                }\n            }\n                        if (answer == null) {\n                answer = new ManagedSendProcessor(context, (SendProcessor) target, definition);\n            }\n        } else if (target instanceof BeanProcessor) {\n            answer = new ManagedBeanProcessor(context, (BeanProcessor) target, definition);\n        } else if (target instanceof IdempotentConsumer) {\n            answer = new ManagedIdempotentConsumer(context, (IdempotentConsumer) target, (org.apache.camel.model.IdempotentConsumerDefinition) definition);\n        } else if (target instanceof AggregateProcessor) {\n            answer = new ManagedAggregateProcessor(context, (AggregateProcessor) target, (org.apache.camel.model.AggregateDefinition) definition);\n        } else if (target instanceof Enricher) {\n            answer = new ManagedEnricher(context, (Enricher) target, (org.apache.camel.model.EnrichDefinition) definition);\n        } else if (target instanceof PollEnricher) {\n            answer = new ManagedPollEnricher(context, (PollEnricher) target, (org.apache.camel.model.PollEnrichDefinition) definition);\n        } else if (target instanceof org.apache.camel.spi.ManagementAware) {\n            return ((org.apache.camel.spi.ManagementAware<Processor>) target).getManagedObject(processor);\n        }\n                if (definition instanceof LoadBalanceDefinition) {\n            LoadBalanceDefinition lb = (LoadBalanceDefinition) definition;\n            if (lb.getLoadBalancerType() instanceof CustomLoadBalancerDefinition) {\n                answer = new ManagedCustomLoadBalancer(context, (LoadBalancer) target, (LoadBalanceDefinition) definition);\n            }\n        }\n        if (answer != null) {\n                        break;\n        }\n                if (target instanceof DelegateProcessor) {\n            target = ((DelegateProcessor) target).getProcessor();\n        } else {\n                        break;\n        }\n    }\n    if (answer == null && definition instanceof ProcessDefinition) {\n        answer = new ManagedProcess(context, target, (ProcessDefinition) definition);\n    } else if (answer == null) {\n                answer = new ManagedProcessor(context, target, definition);\n    }\n    answer.setRoute(route);\n    answer.init(context.getManagementStrategy());\n    return answer;\n}", "lc": 6.181818181818182, "pi": 0.13775510204081634, "ma": 10.166666666666666, "nbd": 23.5, "ml": 5.416666666666667, "d": 1.137913989125062, "mi": -2.008316604531116, "fo": 0.9166666666666666, "r": -0.028571428571428574, "e": 17.298229834547563}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-843_65390f8c", "label": 3, "code": "@Override\npublic void setLocalityGroups(String tableName, Map<String, Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n    throw new NotImplementedException();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void setLocalityGroups(String tableName, Map<String, Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n    throw new NotImplementedException();\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.3333333333333333, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7811872669916835, "fo": -0.5, "r": 0.0, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-757_76b7413d", "label": 1, "code": "/**\n * Provides <em>direct</em> access to the internal storage array.\n * Please note that this method returns a reference to this object's\n * storage array, not a copy.\n * <br/>\n * To correctly address elements of the array, the \"start index\" is\n * required (available via the {@link #getStartIndex() getStartIndex}\n * method.\n * <br/>\n * This method should only be used to avoid copying the internal array.\n * The returned value <em>must</em> be used for reading only; other\n * uses could lead to this object becoming inconsistent.\n * <br/>\n * The {@link #getElements} method has no such limitation since it\n * returns a copy of this array's addressable elements.\n *\n * @return the internal storage array used by this object.\n * @since 3.1\n */\nprotected double[] getArrayRef() {\n    return internalArray;\n}", "code_comment": "/**\n * Provides <em>direct</em> access to the internal storage array.\n * Please note that this method returns a reference to this object's\n * storage array, not a copy.\n * <br/>\n * To correctly address elements of the array, the \"start index\" is\n * required (available via the {@link #getStartIndex() getStartIndex}\n * method.\n * <br/>\n * This method should only be used to avoid copying the internal array.\n * The returned value <em>must</em> be used for reading only; other\n * uses could lead to this object becoming inconsistent.\n * <br/>\n * The {@link #getElements} method has no such limitation since it\n * returns a copy of this array's addressable elements.\n *\n * @return the internal storage array used by this object.\n * @since 3.1\n */\n", "code_no_comment": "protected double[] getArrayRef() {\n    return internalArray;\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.2776025236593067, "fo": -0.5, "r": 1.6857142857142857, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1369_ce0b0955", "label": 1, "code": "@Override\npublic String toString() {\n    StringBuilder buff = new StringBuilder(\"contains\").append('(').append(left).append(\", \").append(right).append(')');\n    return buff.toString();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic String toString() {\n    StringBuilder buff = new StringBuilder(\"contains\").append('(').append(left).append(\", \").append(right).append(')');\n    return buff.toString();\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.619443647834815, "fo": 0.0, "r": 0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 19, "label": 2, "code": "/**\n * Declares a refined type in {@code scope} for the name represented by\n * {@code node}. It must be possible to refine the type of the given node in\n * the given scope, as determined by {@link #getTypeIfRefinable}.\n */\nprotected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n    switch(node.getType()) {\n        case Token.NAME:\n            scope.inferSlotType(node.getString(), type);\n            break;\n        case Token.GETPROP:\n            String qualifiedName = node.getQualifiedName();\n            Preconditions.checkNotNull(qualifiedName);\n            JSType origType = node.getJSType();\n            origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n            scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n            break;\n        default:\n            throw new IllegalArgumentException(\"Node cannot be refined. \\n\" + node.toStringTree());\n    }\n}", "code_comment": "/**\n * Declares a refined type in {@code scope} for the name represented by\n * {@code node}. It must be possible to refine the type of the given node in\n * the given scope, as determined by {@link #getTypeIfRefinable}.\n */\n", "code_no_comment": "protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n    switch(node.getType()) {\n        case Token.NAME:\n            scope.inferSlotType(node.getString(), type);\n            break;\n        case Token.GETPROP:\n            String qualifiedName = node.getQualifiedName();\n            Preconditions.checkNotNull(qualifiedName);\n            JSType origType = node.getJSType();\n            origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n            scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n            break;\n        default:\n            throw new IllegalArgumentException(\"Node cannot be refined. \\n\" + node.toStringTree());\n    }\n}", "lc": 0.09090909090909091, "pi": 0.6479591836734694, "ma": 0.6666666666666666, "nbd": 0.0, "ml": 0.0, "d": -0.056351952545724164, "mi": -0.1385144823630628, "fo": 0.25, "r": -0.028571428571428574, "e": 0.013555706888354932}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1270_70564c7c", "label": 1, "code": "/**\n * Get the Lucene query for the given filter.\n *\n * @param filter the filter, including full-text constraint\n * @param reader the Lucene reader\n * @param nonFullTextConstraints whether non-full-text constraints (such a\n *            path, node type, and so on) should be added to the Lucene\n *            query\n * @param analyzer the Lucene analyzer used for building the fulltext query\n * @return the Lucene query\n */\nprivate static Query getQuery(Filter filter, IndexReader reader, boolean nonFullTextConstraints, Analyzer analyzer) {\n    List<Query> qs = new ArrayList<Query>();\n    FullTextExpression ft = filter.getFullTextConstraint();\n    if (ft == null) {\n    // there might be no full-text constraint\n    // when using the LowCostLuceneIndexProvider\n    // which is used for testing\n    } else {\n        qs.add(getFullTextQuery(ft, analyzer));\n    }\n    if (nonFullTextConstraints) {\n        addNonFullTextConstraints(qs, filter, reader);\n    }\n    if (qs.size() == 0) {\n        return new MatchAllDocsQuery();\n    }\n    if (qs.size() == 1) {\n        return qs.get(0);\n    }\n    BooleanQuery bq = new BooleanQuery();\n    for (Query q : qs) {\n        bq.add(q, MUST);\n    }\n    return bq;\n}", "code_comment": "/**\n * Get the Lucene query for the given filter.\n *\n * @param filter the filter, including full-text constraint\n * @param reader the Lucene reader\n * @param nonFullTextConstraints whether non-full-text constraints (such a\n *            path, node type, and so on) should be added to the Lucene\n *            query\n * @param analyzer the Lucene analyzer used for building the fulltext query\n * @return the Lucene query\n */\n", "code_no_comment": "private static Query getQuery(Filter filter, IndexReader reader, boolean nonFullTextConstraints, Analyzer analyzer) {\n    List<Query> qs = new ArrayList<Query>();\n    FullTextExpression ft = filter.getFullTextConstraint();\n    if (ft == null) {\n                } else {\n        qs.add(getFullTextQuery(ft, analyzer));\n    }\n    if (nonFullTextConstraints) {\n        addNonFullTextConstraints(qs, filter, reader);\n    }\n    if (qs.size() == 0) {\n        return new MatchAllDocsQuery();\n    }\n    if (qs.size() == 1) {\n        return qs.get(0);\n    }\n    BooleanQuery bq = new BooleanQuery();\n    for (Query q : qs) {\n        bq.add(q, MUST);\n    }\n    return bq;\n}", "lc": 0.36363636363636365, "pi": -0.42346938775510207, "ma": 0.3333333333333333, "nbd": -0.5, "ml": 0.16666666666666666, "d": -0.026693030153237728, "mi": -0.29251505592199617, "fo": 0.16666666666666666, "r": -0.028571428571428574, "e": 0.056449989506640805}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4594_5e1bf8d8", "label": 1, "code": "/**\n *  Creates a {@code IRequestHandler} that processes a listener request.\n *\n *  @param pageComponentInfo\n *  @param pageClass\n *  @param pageParameters\n *  @return a {@code IRequestHandler} that invokes the listener interface\n */\nprotected IRequestHandler processListener(PageComponentInfo pageComponentInfo, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters) {\n    PageInfo pageInfo = pageComponentInfo.getPageInfo();\n    ComponentInfo componentInfo = pageComponentInfo.getComponentInfo();\n    Integer renderCount = null;\n    RequestListenerInterface listenerInterface = null;\n    if (componentInfo != null) {\n        renderCount = componentInfo.getRenderCount();\n        listenerInterface = requestListenerInterfaceFromString(componentInfo.getListenerInterface());\n    }\n    if (listenerInterface != null) {\n        // WICKET-4594 - ignore the parsed parameters as they have nothing to do with the page\n        PageAndComponentProvider provider = new PageAndComponentProvider(pageInfo.getPageId(), pageClass, null, renderCount, componentInfo.getComponentPath());\n        provider.setPageSource(getContext());\n        return new ListenerInterfaceRequestHandler(provider, listenerInterface, componentInfo.getBehaviorId());\n    } else {\n        if (logger.isWarnEnabled()) {\n            if (componentInfo != null) {\n                logger.warn(\"Unknown listener interface '{}'\", componentInfo.getListenerInterface());\n            } else {\n                logger.warn(\"Cannot extract the listener interface for PageComponentInfo: '{}'\" + pageComponentInfo);\n            }\n        }\n        return null;\n    }\n}", "code_comment": "/**\n *  Creates a {@code IRequestHandler} that processes a listener request.\n *\n *  @param pageComponentInfo\n *  @param pageClass\n *  @param pageParameters\n *  @return a {@code IRequestHandler} that invokes the listener interface\n */\n", "code_no_comment": "protected IRequestHandler processListener(PageComponentInfo pageComponentInfo, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters) {\n    PageInfo pageInfo = pageComponentInfo.getPageInfo();\n    ComponentInfo componentInfo = pageComponentInfo.getComponentInfo();\n    Integer renderCount = null;\n    RequestListenerInterface listenerInterface = null;\n    if (componentInfo != null) {\n        renderCount = componentInfo.getRenderCount();\n        listenerInterface = requestListenerInterfaceFromString(componentInfo.getListenerInterface());\n    }\n    if (listenerInterface != null) {\n                PageAndComponentProvider provider = new PageAndComponentProvider(pageInfo.getPageId(), pageClass, null, renderCount, componentInfo.getComponentPath());\n        provider.setPageSource(getContext());\n        return new ListenerInterfaceRequestHandler(provider, listenerInterface, componentInfo.getBehaviorId());\n    } else {\n        if (logger.isWarnEnabled()) {\n            if (componentInfo != null) {\n                logger.warn(\"Unknown listener interface '{}'\", componentInfo.getListenerInterface());\n            } else {\n                logger.warn(\"Cannot extract the listener interface for PageComponentInfo: '{}'\" + pageComponentInfo);\n            }\n        }\n        return null;\n    }\n}", "lc": 0.45454545454545453, "pi": 0.6020408163265307, "ma": 0.16666666666666666, "nbd": 0.5, "ml": 0.16666666666666666, "d": -0.02273850716757287, "mi": -0.38112991109836564, "fo": 0.6666666666666666, "r": -0.028571428571428574, "e": 0.15772161332185491}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4520_ccb8fc9e", "label": 1, "code": "@Override\npublic Component resolve(final MarkupContainer container, final MarkupStream markupStream, final ComponentTag tag) {\n    String inlineEnclosureChildId = getInlineEnclosureAttribute(tag);\n    if (Strings.isEmpty(inlineEnclosureChildId) == false) {\n        String id = tag.getId();\n        if (id.equals(INLINE_ENCLOSURE_ID_PREFIX)) {\n            id = id + container.getPage().getAutoIndex();\n        }\n        // Yes, we handled the tag\n        return new InlineEnclosure(id, inlineEnclosureChildId);\n    }\n    // We were not able to handle the tag\n    return null;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Component resolve(final MarkupContainer container, final MarkupStream markupStream, final ComponentTag tag) {\n    String inlineEnclosureChildId = getInlineEnclosureAttribute(tag);\n    if (Strings.isEmpty(inlineEnclosureChildId) == false) {\n        String id = tag.getId();\n        if (id.equals(INLINE_ENCLOSURE_ID_PREFIX)) {\n            id = id + container.getPage().getAutoIndex();\n        }\n                return new InlineEnclosure(id, inlineEnclosureChildId);\n    }\n        return null;\n}", "lc": -0.09090909090909091, "pi": 0.3469387755102042, "ma": -0.16666666666666666, "nbd": 0.0, "ml": 0.0, "d": -0.09985170538803756, "mi": 0.07427588184685989, "fo": 0.0, "r": 0.39999999999999997, "e": -0.051708704348533724}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1668_63070cf9", "label": 1, "code": "@Override\npublic Cursor query(Filter filter, NodeState root) {\n    if (!isLive(root)) {\n        throw new IllegalStateException(\"Lucene index is not live\");\n    }\n    FullTextExpression ft = filter.getFullTextConstraint();\n    Set<String> relPaths = getRelativePaths(ft);\n    if (relPaths.size() > 1) {\n        return new MultiLuceneIndex(filter, root, relPaths).query();\n    }\n    String parent = relPaths.size() == 0 ? \"\" : relPaths.iterator().next();\n    // we only restrict non-full-text conditions if there is\n    // no relative property in the full-text constraint\n    boolean nonFullTextConstraints = parent.isEmpty();\n    Directory directory = newDirectory(root);\n    QueryEngineSettings settings = filter.getQueryEngineSettings();\n    if (directory == null) {\n        return newPathCursor(Collections.<String>emptySet(), settings);\n    }\n    long s = System.currentTimeMillis();\n    try {\n        try {\n            IndexReader reader = DirectoryReader.open(directory);\n            try {\n                IndexSearcher searcher = new IndexSearcher(reader);\n                List<LuceneResultRow> rows = new ArrayList<LuceneResultRow>();\n                Query query = getQuery(filter, reader, nonFullTextConstraints, analyzer);\n                // TODO OAK-828\n                HashSet<String> seenPaths = new HashSet<String>();\n                int parentDepth = getDepth(parent);\n                if (query != null) {\n                    // OAK-925\n                    // TODO how to best avoid loading all entries in memory?\n                    // (memory problem and performance problem)\n                    TopDocs docs = searcher.search(query, Integer.MAX_VALUE);\n                    for (ScoreDoc doc : docs.scoreDocs) {\n                        String path = reader.document(doc.doc, PATH_SELECTOR).get(PATH);\n                        if (path != null) {\n                            if (\"\".equals(path)) {\n                                path = \"/\";\n                            }\n                            if (!parent.isEmpty()) {\n                                // TODO OAK-828 this breaks node aggregation\n                                // get the base path\n                                // ensure the path ends with the given\n                                // relative path\n                                // if (!path.endsWith(\"/\" + parent)) {\n                                // continue;\n                                // }\n                                path = getAncestorPath(path, parentDepth);\n                                // avoid duplicate entries\n                                if (seenPaths.contains(path)) {\n                                    continue;\n                                }\n                                seenPaths.add(path);\n                            }\n                            LuceneResultRow r = new LuceneResultRow();\n                            r.path = path;\n                            r.score = doc.score;\n                            rows.add(r);\n                        }\n                    }\n                }\n                LOG.debug(\"query via {} took {} ms.\", this, System.currentTimeMillis() - s);\n                return new LucenePathCursor(rows, settings);\n            } finally {\n                reader.close();\n            }\n        } finally {\n            directory.close();\n        }\n    } catch (IOException e) {\n        LOG.warn(\"query via {} failed.\", this, e);\n        return newPathCursor(Collections.<String>emptySet(), settings);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Cursor query(Filter filter, NodeState root) {\n    if (!isLive(root)) {\n        throw new IllegalStateException(\"Lucene index is not live\");\n    }\n    FullTextExpression ft = filter.getFullTextConstraint();\n    Set<String> relPaths = getRelativePaths(ft);\n    if (relPaths.size() > 1) {\n        return new MultiLuceneIndex(filter, root, relPaths).query();\n    }\n    String parent = relPaths.size() == 0 ? \"\" : relPaths.iterator().next();\n            boolean nonFullTextConstraints = parent.isEmpty();\n    Directory directory = newDirectory(root);\n    QueryEngineSettings settings = filter.getQueryEngineSettings();\n    if (directory == null) {\n        return newPathCursor(Collections.<String>emptySet(), settings);\n    }\n    long s = System.currentTimeMillis();\n    try {\n        try {\n            IndexReader reader = DirectoryReader.open(directory);\n            try {\n                IndexSearcher searcher = new IndexSearcher(reader);\n                List<LuceneResultRow> rows = new ArrayList<LuceneResultRow>();\n                Query query = getQuery(filter, reader, nonFullTextConstraints, analyzer);\n                                HashSet<String> seenPaths = new HashSet<String>();\n                int parentDepth = getDepth(parent);\n                if (query != null) {\n                                                                                TopDocs docs = searcher.search(query, Integer.MAX_VALUE);\n                    for (ScoreDoc doc : docs.scoreDocs) {\n                        String path = reader.document(doc.doc, PATH_SELECTOR).get(PATH);\n                        if (path != null) {\n                            if (\"\".equals(path)) {\n                                path = \"/\";\n                            }\n                            if (!parent.isEmpty()) {\n                                                                                                                                                                                                                                                                path = getAncestorPath(path, parentDepth);\n                                                                if (seenPaths.contains(path)) {\n                                    continue;\n                                }\n                                seenPaths.add(path);\n                            }\n                            LuceneResultRow r = new LuceneResultRow();\n                            r.path = path;\n                            r.score = doc.score;\n                            rows.add(r);\n                        }\n                    }\n                }\n                LOG.debug(\"query via {} took {} ms.\", this, System.currentTimeMillis() - s);\n                return new LucenePathCursor(rows, settings);\n            } finally {\n                reader.close();\n            }\n        } finally {\n            directory.close();\n        }\n    } catch (IOException e) {\n        LOG.warn(\"query via {} failed.\", this, e);\n        return newPathCursor(Collections.<String>emptySet(), settings);\n    }\n}", "lc": 2.1818181818181817, "pi": 3.724489795918368, "ma": 1.6666666666666667, "nbd": 3.0, "ml": 1.0833333333333333, "d": 0.7503707365299062, "mi": -1.0481789503871526, "fo": 2.25, "r": -0.028571428571428574, "e": 2.9459270775780473}
{"project_name": "Time", "project_version": 26, "label": 2, "code": "public long addWrapField(long instant, int value) {\n    if (iTimeField) {\n        int offset = getOffsetToAdd(instant);\n        long localInstant = iField.addWrapField(instant + offset, value);\n        return localInstant - offset;\n    } else {\n        long localInstant = iZone.convertUTCToLocal(instant);\n        localInstant = iField.addWrapField(localInstant, value);\n        return iZone.convertLocalToUTC(localInstant, false);\n    }\n}", "code_comment": NaN, "code_no_comment": "public long addWrapField(long instant, int value) {\n    if (iTimeField) {\n        int offset = getOffsetToAdd(instant);\n        long localInstant = iField.addWrapField(instant + offset, value);\n        return localInstant - offset;\n    } else {\n        long localInstant = iZone.convertUTCToLocal(instant);\n        localInstant = iField.addWrapField(localInstant, value);\n        return iZone.convertLocalToUTC(localInstant, false);\n    }\n}", "lc": -0.13636363636363635, "pi": 0.035714285714285636, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": 0.06030647553138907, "mi": 0.16317751648981932, "fo": -0.08333333333333333, "r": 0.028571428571428574, "e": -0.030465005717810013}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-699_b2e24119", "label": 3, "code": "public double value(double x) {\n    return cumulativeProbability(x) - p;\n}", "code_comment": NaN, "code_no_comment": "public double value(double x) {\n    return cumulativeProbability(x) - p;\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.0785775738457126, "fo": -0.4166666666666667, "r": 2.657142857142857, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-757_76b7413d", "label": 1, "code": "/**\n * Adds several element to the end of this expandable array.\n *\n * @param values Values to be added to end of array.\n * @since 2.2\n */\n@Override\npublic synchronized void addElements(double[] values) {\n    final double[] tempArray = new double[numElements + values.length + 1];\n    System.arraycopy(internalArray, startIndex, tempArray, 0, numElements);\n    System.arraycopy(values, 0, tempArray, numElements, values.length);\n    internalArray = tempArray;\n    startIndex = 0;\n    numElements += values.length;\n}", "code_comment": "/**\n * Adds several element to the end of this expandable array.\n *\n * @param values Values to be added to end of array.\n * @since 2.2\n */\n", "code_no_comment": "@Override\npublic synchronized void addElements(double[] values) {\n    final double[] tempArray = new double[numElements + values.length + 1];\n    System.arraycopy(internalArray, startIndex, tempArray, 0, numElements);\n    System.arraycopy(values, 0, tempArray, numElements, values.length);\n    internalArray = tempArray;\n    startIndex = 0;\n    numElements += values.length;\n}", "lc": -0.22727272727272727, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": 0.08996539792387546, "mi": 0.25867507886435326, "fo": -0.3333333333333333, "r": 0.05714285714285714, "e": -0.017157713047314345}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5898_b00920f3", "label": 1, "code": "/**\n *  Get the markup for the child component, which is assumed to be a child of 'container'.\n */\n@Override\npublic IMarkupFragment getMarkup(final MarkupContainer container, final Component child) {\n    // If the sourcing strategy did not provide one, than ask the component.\n    // Get the markup for the container\n    IMarkupFragment markup = container.getMarkup();\n    if (markup == null) {\n        return null;\n    }\n    if (child == null) {\n        return markup;\n    }\n    // Find the child's markup\n    markup = markup.find(child.getId());\n    if (markup != null) {\n        return markup;\n    }\n    markup = searchMarkupInTransparentResolvers(container, child);\n    return markup;\n}", "code_comment": "/**\n *  Get the markup for the child component, which is assumed to be a child of 'container'.\n */\n", "code_no_comment": "@Override\npublic IMarkupFragment getMarkup(final MarkupContainer container, final Component child) {\n            IMarkupFragment markup = container.getMarkup();\n    if (markup == null) {\n        return null;\n    }\n    if (child == null) {\n        return markup;\n    }\n        markup = markup.find(child.getId());\n    if (markup != null) {\n        return markup;\n    }\n    markup = searchMarkupInTransparentResolvers(container, child);\n    return markup;\n}", "lc": 0.09090909090909091, "pi": -0.2908163265306122, "ma": 0.0, "nbd": -0.5, "ml": 0.0, "d": 0.08996539792387546, "mi": -0.03240607972469159, "fo": -0.16666666666666666, "r": 0.0, "e": -0.013071727463904979}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4", "label": 1, "code": "/**\n *  Adds a child component to this container.\n *  <p>\n *  Be careful when overriding this method, if not implemented properly it\n *  may lead to a java component hierarchy which no longer matches the\n *  template hierarchy, which in turn will lead to an error.\n *\n *  @param child\n *             The child\n *\n *  @throws IllegalArgumentException\n *              Thrown if a child with the same id is replaced by the add\n *              operation.\n *  @return This\n */\nfinal MarkupContainer add(final Component<?> child) {\n    if (child == null) {\n        throw new IllegalArgumentException(\"argument child may not be null\");\n    }\n    if (log.isDebugEnabled()) {\n        log.debug(\"Add \" + child.getId() + \" to component \" + this.getClass().getName() + \" with path \" + getPath());\n    }\n    // Add to map\n    addedComponent(child);\n    Component replaced = put(child);\n    child.setFlag(FLAG_REMOVED_FROM_PARENT, false);\n    if (replaced != null) {\n        replaced.setFlag(FLAG_REMOVED_FROM_PARENT, true);\n        removedComponent(replaced);\n        // The position of the associated markup remains the same\n        child.markupIndex = replaced.markupIndex;\n        // The generated markup id remains the same\n        String replacedId = (replaced.hasMarkupIdMetaData()) ? replaced.getMarkupId() : null;\n        child.setMarkupIdMetaData(replacedId);\n    }\n    return this;\n}", "code_comment": "/**\n *  Adds a child component to this container.\n *  <p>\n *  Be careful when overriding this method, if not implemented properly it\n *  may lead to a java component hierarchy which no longer matches the\n *  template hierarchy, which in turn will lead to an error.\n *\n *  @param child\n *             The child\n *\n *  @throws IllegalArgumentException\n *              Thrown if a child with the same id is replaced by the add\n *              operation.\n *  @return This\n */\n", "code_no_comment": "final MarkupContainer add(final Component<?> child) {\n    if (child == null) {\n        throw new IllegalArgumentException(\"argument child may not be null\");\n    }\n    if (log.isDebugEnabled()) {\n        log.debug(\"Add \" + child.getId() + \" to component \" + this.getClass().getName() + \" with path \" + getPath());\n    }\n        addedComponent(child);\n    Component replaced = put(child);\n    child.setFlag(FLAG_REMOVED_FROM_PARENT, false);\n    if (replaced != null) {\n        replaced.setFlag(FLAG_REMOVED_FROM_PARENT, true);\n        removedComponent(replaced);\n                child.markupIndex = replaced.markupIndex;\n                String replacedId = (replaced.hasMarkupIdMetaData()) ? replaced.getMarkupId() : null;\n        child.setMarkupIdMetaData(replacedId);\n    }\n    return this;\n}", "lc": 0.22727272727272727, "pi": -0.24489795918367346, "ma": 0.3333333333333333, "nbd": -0.5, "ml": 0.25, "d": 0.2738507167572912, "mi": -0.23343848580441648, "fo": 0.6666666666666666, "r": -0.028571428571428574, "e": 0.2685272034983575}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-843_65390f8c", "label": 3, "code": "@Override\npublic void online(String tableName) throws AccumuloSecurityException, AccumuloException {\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void online(String tableName) throws AccumuloSecurityException, AccumuloException {\n}", "lc": -0.5, "pi": -1.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.0662460567823349, "fo": -0.5, "r": 1.8, "e": -0.16422749602751402}
{"project_name": "Lang", "project_version": 51, "label": 1, "code": "// String to boolean methods\n// -----------------------------------------------------------------------\n/**\n * <p>Converts a String to a boolean (optimised for performance).</p>\n *\n * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n * (case insensitive) will return <code>true</code>. Otherwise,\n * <code>false</code> is returned.</p>\n *\n * <p>This method performs 4 times faster (JDK1.4) than\n * <code>Boolean.valueOf(String)</code>. However, this method accepts\n * 'on' and 'yes' as true values.\n *\n * <pre>\n *   BooleanUtils.toBoolean(null)    = false\n *   BooleanUtils.toBoolean(\"true\")  = true\n *   BooleanUtils.toBoolean(\"TRUE\")  = true\n *   BooleanUtils.toBoolean(\"tRUe\")  = true\n *   BooleanUtils.toBoolean(\"on\")    = true\n *   BooleanUtils.toBoolean(\"yes\")   = true\n *   BooleanUtils.toBoolean(\"false\") = false\n *   BooleanUtils.toBoolean(\"x gti\") = false\n * </pre>\n *\n * @param str  the String to check\n * @return the boolean value of the string, <code>false</code> if no match\n */\npublic static boolean toBoolean(String str) {\n    // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch(str.length()) {\n        case 2:\n            {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N');\n            }\n        case 3:\n            {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n            }\n        case 4:\n            {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n    }\n    return false;\n}", "code_comment": "/**\n * <p>Converts a String to a boolean (optimised for performance).</p>\n *\n * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n * (case insensitive) will return <code>true</code>. Otherwise,\n * <code>false</code> is returned.</p>\n *\n * <p>This method performs 4 times faster (JDK1.4) than\n * <code>Boolean.valueOf(String)</code>. However, this method accepts\n * 'on' and 'yes' as true values.\n *\n * <pre>\n *   BooleanUtils.toBoolean(null)    = false\n *   BooleanUtils.toBoolean(\"true\")  = true\n *   BooleanUtils.toBoolean(\"TRUE\")  = true\n *   BooleanUtils.toBoolean(\"tRUe\")  = true\n *   BooleanUtils.toBoolean(\"on\")    = true\n *   BooleanUtils.toBoolean(\"yes\")   = true\n *   BooleanUtils.toBoolean(\"false\") = false\n *   BooleanUtils.toBoolean(\"x gti\") = false\n * </pre>\n *\n * @param str  the String to check\n * @return the boolean value of the string, <code>false</code> if no match\n */\n", "code_no_comment": "public static boolean toBoolean(String str) {\n        if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch(str.length()) {\n        case 2:\n            {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N');\n            }\n        case 3:\n            {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n            }\n        case 4:\n            {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n    }\n    return false;\n}", "lc": 1.0454545454545454, "pi": 1.4540816326530612, "ma": 1.0, "nbd": 0.5, "ml": 0.5833333333333334, "d": 1.1537320810677214, "mi": -0.7358761112704332, "fo": 1.5833333333333333, "r": -0.028571428571428574, "e": 2.934046025158364}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3757_c1b2f2f8", "label": 3, "code": "public Endpoint registerEndpoint(String uri, Endpoint endpoint) {\n    if (endpoint instanceof InterceptSendToEndpoint) {\n        // endpoint already decorated\n        return endpoint;\n    } else if (endpoint instanceof MockEndpoint) {\n        // we should not intercept mock endpoints\n        return endpoint;\n    } else if (uri == null || pattern == null || EndpointHelper.matchEndpoint(uri, pattern)) {\n        // if pattern is null then it mean to match all\n        // only proxy if the uri is matched decorate endpoint with our proxy\n        // should be false by default\n        InterceptSendToEndpoint proxy = new InterceptSendToEndpoint(endpoint, false);\n        // create mock endpoint which we will use as interceptor\n        // replace :// from scheme to make it easy to lookup the mock endpoint without having double :// in uri\n        String key = \"mock:\" + endpoint.getEndpointKey().replaceFirst(\"://\", \":\");\n        LOG.info(\"Adviced endpoint [\" + uri + \"] with mock endpoint [\" + key + \"]\");\n        MockEndpoint mock = endpoint.getCamelContext().getEndpoint(key, MockEndpoint.class);\n        Processor producer;\n        try {\n            producer = mock.createProducer();\n        } catch (Exception e) {\n            throw wrapRuntimeCamelException(e);\n        }\n        proxy.setDetour(producer);\n        return proxy;\n    } else {\n        // no proxy so return regular endpoint\n        return endpoint;\n    }\n}", "code_comment": NaN, "code_no_comment": "public Endpoint registerEndpoint(String uri, Endpoint endpoint) {\n    if (endpoint instanceof InterceptSendToEndpoint) {\n                return endpoint;\n    } else if (endpoint instanceof MockEndpoint) {\n                return endpoint;\n    } else if (uri == null || pattern == null || EndpointHelper.matchEndpoint(uri, pattern)) {\n                                InterceptSendToEndpoint proxy = new InterceptSendToEndpoint(endpoint, false);\n                        String key = \"mock:\" + endpoint.getEndpointKey().replaceFirst(\"://\", \":\");\n        LOG.info(\"Adviced endpoint [\" + uri + \"] with mock endpoint [\" + key + \"]\");\n        MockEndpoint mock = endpoint.getCamelContext().getEndpoint(key, MockEndpoint.class);\n        Processor producer;\n        try {\n            producer = mock.createProducer();\n        } catch (Exception e) {\n            throw wrapRuntimeCamelException(e);\n        }\n        proxy.setDetour(producer);\n        return proxy;\n    } else {\n                return endpoint;\n    }\n}", "lc": 0.36363636363636365, "pi": 0.015306122448979493, "ma": 0.3333333333333333, "nbd": 1.0, "ml": 0.3333333333333333, "d": 0.31932773109243706, "mi": -0.334384858044164, "fo": 0.25, "r": -0.028571428571428574, "e": 0.4132199193938693}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1044_9396979b", "label": 0, "code": "public String getViolationDescription(short violationCode) {\n    switch(violationCode) {\n        case 1:\n            return \"data file size must be a non-negative integer\";\n        case 2:\n            return \"Invalid column name given.\";\n        case 3:\n            return \"Prev end row is greater than or equal to end row.\";\n        case 4:\n            return \"Invalid metadata row format\";\n        case 5:\n            return \"Row can not be less than \" + Constants.METADATA_TABLE_ID;\n        case 6:\n            return \"Empty values are not allowed for any \" + Constants.METADATA_TABLE_NAME + \" column\";\n        case 7:\n            return \"Lock not held in zookeeper by writer\";\n    }\n    return null;\n}", "code_comment": NaN, "code_no_comment": "public String getViolationDescription(short violationCode) {\n    switch(violationCode) {\n        case 1:\n            return \"data file size must be a non-negative integer\";\n        case 2:\n            return \"Invalid column name given.\";\n        case 3:\n            return \"Prev end row is greater than or equal to end row.\";\n        case 4:\n            return \"Invalid metadata row format\";\n        case 5:\n            return \"Row can not be less than \" + Constants.METADATA_TABLE_ID;\n        case 6:\n            return \"Empty values are not allowed for any \" + Constants.METADATA_TABLE_NAME + \" column\";\n        case 7:\n            return \"Lock not held in zookeeper by writer\";\n    }\n    return null;\n}", "lc": 0.22727272727272727, "pi": 0.4438775510204082, "ma": 0.6666666666666666, "nbd": 0.0, "ml": 0.25, "d": -0.3806228373702422, "mi": -0.11213077143676506, "fo": -0.5, "r": 0.0, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3053_7552a10b", "label": 1, "code": "protected Directory createLocalDirForIndexWriter(IndexDefinition definition) throws IOException {\n    String indexPath = definition.getIndexPathFromConfig();\n    File indexWriterDir;\n    if (indexPath == null) {\n        // If indexPath is not known create a unique directory for work\n        indexWriterDir = new File(indexWorkDir, String.valueOf(UNIQUE_COUNTER.incrementAndGet()));\n    } else {\n        File indexDir = getIndexDir(indexPath);\n        String newVersion = String.valueOf(definition.getReindexCount());\n        indexWriterDir = getVersionedDir(indexPath, indexDir, newVersion);\n    }\n    Directory dir = FSDirectory.open(indexWriterDir);\n    log.debug(\"IndexWriter would use {}\", indexWriterDir);\n    if (indexPath == null) {\n        dir = new DeleteOldDirOnClose(dir, indexWriterDir);\n        log.debug(\"IndexPath [{}] not configured in index definition {}. Writer would create index \" + \"files in temporary dir {} which would be deleted upon close. For better performance do \" + \"configure the 'indexPath' as part of your index definition\", LuceneIndexConstants.INDEX_PATH, definition, indexWriterDir);\n    }\n    return dir;\n}", "code_comment": NaN, "code_no_comment": "protected Directory createLocalDirForIndexWriter(IndexDefinition definition) throws IOException {\n    String indexPath = definition.getIndexPathFromConfig();\n    File indexWriterDir;\n    if (indexPath == null) {\n                indexWriterDir = new File(indexWorkDir, String.valueOf(UNIQUE_COUNTER.incrementAndGet()));\n    } else {\n        File indexDir = getIndexDir(indexPath);\n        String newVersion = String.valueOf(definition.getReindexCount());\n        indexWriterDir = getVersionedDir(indexPath, indexDir, newVersion);\n    }\n    Directory dir = FSDirectory.open(indexWriterDir);\n    log.debug(\"IndexWriter would use {}\", indexWriterDir);\n    if (indexPath == null) {\n        dir = new DeleteOldDirOnClose(dir, indexWriterDir);\n        log.debug(\"IndexPath [{}] not configured in index definition {}. Writer would create index \" + \"files in temporary dir {} which would be deleted upon close. For better performance do \" + \"configure the 'indexPath' as part of your index definition\", LuceneIndexConstants.INDEX_PATH, definition, indexWriterDir);\n    }\n    return dir;\n}", "lc": 0.18181818181818182, "pi": -0.2602040816326532, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.16666666666666666, "d": -0.014829461196243152, "mi": -0.21594493834241477, "fo": 0.3333333333333333, "r": -0.028571428571428574, "e": 0.12637859183402503}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-724_9c8bb934", "label": 1, "code": "/**\n * Generate a random int value uniformly distributed between\n * <code>lower</code> and <code>upper</code>, inclusive. This algorithm uses\n * a secure random number generator.\n *\n * @param lower\n *            the lower bound.\n * @param upper\n *            the upper bound.\n * @return the random integer.\n * @throws NumberIsTooLargeException if {@code lower >= upper}.\n */\npublic int nextSecureInt(int lower, int upper) {\n    if (lower >= upper) {\n        throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND, lower, upper, false);\n    }\n    SecureRandom sec = getSecRan();\n    return lower + (int) (sec.nextDouble() * (upper - lower + 1));\n}", "code_comment": "/**\n * Generate a random int value uniformly distributed between\n * <code>lower</code> and <code>upper</code>, inclusive. This algorithm uses\n * a secure random number generator.\n *\n * @param lower\n *            the lower bound.\n * @param upper\n *            the upper bound.\n * @return the random integer.\n * @throws NumberIsTooLargeException if {@code lower >= upper}.\n */\n", "code_no_comment": "public int nextSecureInt(int lower, int upper) {\n    if (lower >= upper) {\n        throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND, lower, upper, false);\n    }\n    SecureRandom sec = getSecRan();\n    return lower + (int) (sec.nextDouble() * (upper - lower + 1));\n}", "lc": -0.3181818181818182, "pi": -0.2346938775510204, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.16666666666666666, "d": 0.2580326248146318, "mi": 0.3989102380269573, "fo": -0.3333333333333333, "r": 0.2571428571428572, "e": -0.008433234395946565}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5460_a3a5a40f", "label": 1, "code": "/**\n *  @param setRenderingFlag\n *             rendering flag\n */\nvoid internalMarkRendering(boolean setRenderingFlag) {\n    if (setRenderingFlag) {\n        setFlag(FLAG_PREPARED_FOR_RENDER, false);\n        setFlag(FLAG_RENDERING, true);\n    } else {\n        setFlag(FLAG_RENDERING, false);\n    }\n}", "code_comment": "/**\n *  @param setRenderingFlag\n *             rendering flag\n */\n", "code_no_comment": "void internalMarkRendering(boolean setRenderingFlag) {\n    if (setRenderingFlag) {\n        setFlag(FLAG_PREPARED_FOR_RENDER, false);\n        setFlag(FLAG_RENDERING, true);\n    } else {\n        setFlag(FLAG_RENDERING, false);\n    }\n}", "lc": -0.2727272727272727, "pi": 0.051020408163265356, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.3806228373702422, "mi": 0.501577287066246, "fo": -0.25, "r": 2.542857142857143, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-428_d906576c", "label": 3, "code": "public Object next() {\n    index++;\n    return key;\n}", "code_comment": NaN, "code_no_comment": "public Object next() {\n    index++;\n    return key;\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9678806997418987, "fo": -0.5, "r": 2.7142857142857144, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-1619_b154d12f", "label": 1, "code": "/**\n *  Create a new PagingNavigation. May be subclassed to make us of specialized PagingNavigation.\n *\n *  @param pageable\n *             the pageable component\n *  @param labelProvider\n *             The label provider for the link text.\n *  @return the navigation object\n */\nprotected PagingNavigation newNavigation(final IPageable pageable, final IPagingLabelProvider labelProvider) {\n    return new PagingNavigation(\"navigation\", pageable, labelProvider) {\n\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public boolean isEnabled() {\n            return PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();\n        }\n    };\n}", "code_comment": "/**\n *  Create a new PagingNavigation. May be subclassed to make us of specialized PagingNavigation.\n *\n *  @param pageable\n *             the pageable component\n *  @param labelProvider\n *             The label provider for the link text.\n *  @return the navigation object\n */\n", "code_no_comment": "protected PagingNavigation newNavigation(final IPageable pageable, final IPagingLabelProvider labelProvider) {\n    return new PagingNavigation(\"navigation\", pageable, labelProvider) {\n\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public boolean isEnabled() {\n            return PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();\n        }\n    };\n}", "lc": -0.22727272727272727, "pi": 0.40816326530612235, "ma": -0.5, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.11171527434503209, "mi": 0.338973329509607, "fo": -0.3333333333333333, "r": 2.314285714285714, "e": -0.11540125320689906}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8146_17475d80", "label": 3, "code": "@Override\nprotected void doStop() throws Exception {\n    if (future != null) {\n        LOG.debug(\"This consumer is stopping, so cancelling scheduled task: \" + future);\n        future.cancel(false);\n        future = null;\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected void doStop() throws Exception {\n    if (future != null) {\n        LOG.debug(\"This consumer is stopping, so cancelling scheduled task: \" + future);\n        future.cancel(false);\n        future = null;\n    }\n}", "lc": -0.2727272727272727, "pi": 0.22448979591836732, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.11171527434503209, "mi": 0.4175509033553199, "fo": -0.3333333333333333, "r": 1.1142857142857143, "e": -0.12420282592587835}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5426_fb45a781", "label": 3, "code": "/**\n *  @see org.apache.wicket.Component#onBeforeRender()\n */\n@Override\nprotected void onBeforeRender() {\n    // Make sure it is really empty\n    renderedComponents = null;\n    // if the page is stateless, reset the flag so that it is tested again\n    if (Boolean.TRUE.equals(stateless)) {\n        stateless = null;\n    }\n    super.onBeforeRender();\n    // for links rendered before first stateful component\n    if (getSession().isTemporary() && !peekPageStateless()) {\n        getSession().bind();\n    }\n}", "code_comment": "/**\n *  @see org.apache.wicket.Component#onBeforeRender()\n */\n", "code_no_comment": "@Override\nprotected void onBeforeRender() {\n        renderedComponents = null;\n        if (Boolean.TRUE.equals(stateless)) {\n        stateless = null;\n    }\n    super.onBeforeRender();\n        if (getSession().isTemporary() && !peekPageStateless()) {\n        getSession().bind();\n    }\n}", "lc": -0.13636363636363635, "pi": -0.17857142857142863, "ma": -0.16666666666666666, "nbd": -0.5, "ml": 0.16666666666666666, "d": -0.12160158180919424, "mi": 0.23257814740464589, "fo": 0.08333333333333333, "r": 0.4571428571428572, "e": -0.11717869976571971}
{"project_name": "Codec", "project_version": 13, "label": 1, "code": "/**\n * Check if the Double Metaphone values of two <code>String</code> values\n * are equal, optionally using the alternate value.\n *\n * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\n * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\n * @param alternate use the alternate value if {@code true}.\n * @return {@code true} if the encoded <code>String</code>s are equal;\n *          {@code false} otherwise.\n */\npublic boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {\n    return doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate));\n}", "code_comment": "/**\n * Check if the Double Metaphone values of two <code>String</code> values\n * are equal, optionally using the alternate value.\n *\n * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\n * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\n * @param alternate use the alternate value if {@code true}.\n * @return {@code true} if the encoded <code>String</code>s are equal;\n *          {@code false} otherwise.\n */\n", "code_no_comment": "public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {\n    return doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate));\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9529681674792084, "fo": -0.25, "r": 0.5142857142857143, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1096_faf99727", "label": 0, "code": "/**\n * {@inheritDoc}\n */\npublic EnclosingBall<S, P> enclose(final List<P> points) {\n    if (points == null || points.isEmpty()) {\n        // return an empty ball\n        return generator.ballOnSupport(new ArrayList<P>());\n    }\n    // Emo Welzl algorithm with Bernd G\u00e4rtner and Linus K\u00e4llberg improvements\n    return pivotingBall(points);\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public EnclosingBall<S, P> enclose(final List<P> points) {\n    if (points == null || points.isEmpty()) {\n                return generator.ballOnSupport(new ArrayList<P>());\n    }\n        return pivotingBall(points);\n}", "lc": -0.36363636363636365, "pi": -0.13775510204081634, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.10776075135936727, "mi": 0.5316891310582161, "fo": -0.25, "r": 2.657142857142857, "e": -0.11788967838924795}
{"project_name": "Compress", "project_version": 20, "label": 1, "code": "private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException {\n    CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY);\n    ret.setDevice(readBinaryLong(2, swapHalfWord));\n    ret.setInode(readBinaryLong(2, swapHalfWord));\n    final long mode = readBinaryLong(2, swapHalfWord);\n    if (mode != 0) {\n        ret.setMode(mode);\n    }\n    ret.setUID(readBinaryLong(2, swapHalfWord));\n    ret.setGID(readBinaryLong(2, swapHalfWord));\n    ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord));\n    ret.setRemoteDevice(readBinaryLong(2, swapHalfWord));\n    ret.setTime(readBinaryLong(4, swapHalfWord));\n    long namesize = readBinaryLong(2, swapHalfWord);\n    ret.setSize(readBinaryLong(4, swapHalfWord));\n    final String name = readCString((int) namesize);\n    ret.setName(name);\n    if (mode == 0 && !name.equals(CPIO_TRAILER)) {\n        throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \" + name + \"Occured at byte: \" + getBytesRead());\n    }\n    skip(ret.getHeaderPadCount());\n    return ret;\n}", "code_comment": NaN, "code_no_comment": "private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException {\n    CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY);\n    ret.setDevice(readBinaryLong(2, swapHalfWord));\n    ret.setInode(readBinaryLong(2, swapHalfWord));\n    final long mode = readBinaryLong(2, swapHalfWord);\n    if (mode != 0) {\n        ret.setMode(mode);\n    }\n    ret.setUID(readBinaryLong(2, swapHalfWord));\n    ret.setGID(readBinaryLong(2, swapHalfWord));\n    ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord));\n    ret.setRemoteDevice(readBinaryLong(2, swapHalfWord));\n    ret.setTime(readBinaryLong(4, swapHalfWord));\n    long namesize = readBinaryLong(2, swapHalfWord);\n    ret.setSize(readBinaryLong(4, swapHalfWord));\n    final String name = readCString((int) namesize);\n    ret.setName(name);\n    if (mode == 0 && !name.equals(CPIO_TRAILER)) {\n        throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \" + name + \"Occured at byte: \" + getBytesRead());\n    }\n    skip(ret.getHeaderPadCount());\n    return ret;\n}", "lc": 0.4090909090909091, "pi": -0.6887755102040817, "ma": 0.0, "nbd": -0.5, "ml": 0.0, "d": 1.1122095897182405, "mi": -0.3785488958990538, "fo": 1.5833333333333333, "r": -0.028571428571428574, "e": 1.4072194311314412}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8227_54d7fc59", "label": 3, "code": "@Override\nprotected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) throws Exception {\n    // here we iterate the recipient lists and create the exchange pair for each of those\n    List<ProcessorExchangePair> result = new ArrayList<ProcessorExchangePair>();\n    // at first we must lookup the endpoint and acquire the producer which can send to the endpoint\n    int index = 0;\n    while (iter.hasNext()) {\n        Object recipient = iter.next();\n        Endpoint endpoint;\n        Producer producer;\n        ExchangePattern pattern;\n        try {\n            endpoint = resolveEndpoint(exchange, recipient);\n            pattern = resolveExchangePattern(exchange, recipient);\n            producer = producerCache.acquireProducer(endpoint);\n        } catch (Exception e) {\n            if (isIgnoreInvalidEndpoints()) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Endpoint uri is invalid: \" + recipient + \". This exception will be ignored.\", e);\n                }\n                continue;\n            } else {\n                // failure so break out\n                throw e;\n            }\n        }\n        // then create the exchange pair\n        result.add(createProcessorExchangePair(index++, endpoint, producer, exchange, pattern));\n    }\n    return result;\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) throws Exception {\n        List<ProcessorExchangePair> result = new ArrayList<ProcessorExchangePair>();\n        int index = 0;\n    while (iter.hasNext()) {\n        Object recipient = iter.next();\n        Endpoint endpoint;\n        Producer producer;\n        ExchangePattern pattern;\n        try {\n            endpoint = resolveEndpoint(exchange, recipient);\n            pattern = resolveExchangePattern(exchange, recipient);\n            producer = producerCache.acquireProducer(endpoint);\n        } catch (Exception e) {\n            if (isIgnoreInvalidEndpoints()) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Endpoint uri is invalid: \" + recipient + \". This exception will be ignored.\", e);\n                }\n                continue;\n            } else {\n                                throw e;\n            }\n        }\n                result.add(createProcessorExchangePair(index++, endpoint, producer, exchange, pattern));\n    }\n    return result;\n}", "lc": 0.5909090909090909, "pi": 1.1428571428571428, "ma": 0.5, "nbd": 1.0, "ml": 0.08333333333333333, "d": -0.06030647553138898, "mi": -0.42873530255233744, "fo": 0.3333333333333333, "r": -0.028571428571428574, "e": 0.08712057940474816}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8964_ea8ee025", "label": 1, "code": "/**\n * Resumes the given {@code service}.\n * <p/>\n * If {@code service} is a {@link org.apache.camel.SuspendableService} then\n * it's {@link org.apache.camel.SuspendableService#resume()} is called but\n * <b>only</b> if {@code service} is already {@link #isSuspended(Object)\n * suspended}.\n * <p/>\n * If {@code service} is <b>not</b> a\n * {@link org.apache.camel.SuspendableService} then it's\n * {@link org.apache.camel.Service#start()} is called.\n * <p/>\n * Calling this method has no effect if {@code service} is {@code null}.\n *\n * @param service the service\n * @return <tt>true</tt> if either <tt>resume</tt> method or\n *         {@link #startService(Service)} was called, <tt>false</tt>\n *         otherwise.\n * @throws Exception is thrown if error occurred\n * @see #startService(Service)\n */\npublic static boolean resumeService(Service service) throws Exception {\n    if (service instanceof SuspendableService) {\n        SuspendableService ss = (SuspendableService) service;\n        if (ss.isSuspended()) {\n            LOG.debug(\"Resuming service {}\", service);\n            ss.resume();\n            return true;\n        } else {\n            return false;\n        }\n    } else {\n        startService(service);\n        return true;\n    }\n}", "code_comment": "/**\n * Resumes the given {@code service}.\n * <p/>\n * If {@code service} is a {@link org.apache.camel.SuspendableService} then\n * it's {@link org.apache.camel.SuspendableService#resume()} is called but\n * <b>only</b> if {@code service} is already {@link #isSuspended(Object)\n * suspended}.\n * <p/>\n * If {@code service} is <b>not</b> a\n * {@link org.apache.camel.SuspendableService} then it's\n * {@link org.apache.camel.Service#start()} is called.\n * <p/>\n * Calling this method has no effect if {@code service} is {@code null}.\n *\n * @param service the service\n * @return <tt>true</tt> if either <tt>resume</tt> method or\n *         {@link #startService(Service)} was called, <tt>false</tt>\n *         otherwise.\n * @throws Exception is thrown if error occurred\n * @see #startService(Service)\n */\n", "code_no_comment": "public static boolean resumeService(Service service) throws Exception {\n    if (service instanceof SuspendableService) {\n        SuspendableService ss = (SuspendableService) service;\n        if (ss.isSuspended()) {\n            LOG.debug(\"Resuming service {}\", service);\n            ss.resume();\n            return true;\n        } else {\n            return false;\n        }\n    } else {\n        startService(service);\n        return true;\n    }\n}", "lc": 0.045454545454545456, "pi": 0.4591836734693877, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.3806228373702422, "mi": 0.06251792371666169, "fo": -0.16666666666666666, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-640_98556fed", "label": 1, "code": "/**\n * Returns the next pseudorandom, uniformly distributed {@code int}\n * value from this random number generator's sequence.\n * All 2<font size=\"-1\"><sup>32</sup></font> possible {@code int} values\n * should be produced with  (approximately) equal probability.\n * <p>\n * The default implementation provided here returns\n * <pre>\n * <code>(int) (nextDouble() * Integer.MAX_VALUE)</code>\n * </pre></p>\n *\n * @return the next pseudorandom, uniformly distributed {@code int}\n *  value from this random number generator's sequence\n */\npublic int nextInt() {\n    return (int) (nextDouble() * Integer.MAX_VALUE);\n}", "code_comment": "/**\n * Returns the next pseudorandom, uniformly distributed {@code int}\n * value from this random number generator's sequence.\n * All 2<font size=\"-1\"><sup>32</sup></font> possible {@code int} values\n * should be produced with  (approximately) equal probability.\n * <p>\n * The default implementation provided here returns\n * <pre>\n * <code>(int) (nextDouble() * Integer.MAX_VALUE)</code>\n * </pre></p>\n *\n * @return the next pseudorandom, uniformly distributed {@code int}\n *  value from this random number generator's sequence\n */\n", "code_no_comment": "public int nextInt() {\n    return (int) (nextDouble() * Integer.MAX_VALUE);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.1015199311729282, "fo": -0.4166666666666667, "r": 2.0, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4927_8c827e33", "label": 1, "code": "@Override\npublic void addCookie(Cookie cookie) {\n    checkHeader();\n    bufferedResponse.addCookie(cookie);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void addCookie(Cookie cookie) {\n    checkHeader();\n    bufferedResponse.addCookie(cookie);\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7912245483223405, "fo": -0.3333333333333333, "r": 1.7142857142857144, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 54, "label": 2, "code": "/**\n * Declare the symbol for a qualified name in the global scope.\n *\n * @param info The doc info for this property.\n * @param n A top-level GETPROP node (it should not be contained inside\n *     another GETPROP).\n * @param parent The parent of {@code n}.\n * @param rhsValue The node that {@code n} is being initialized to,\n *     or {@code null} if this is a stub declaration.\n */\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    // \n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    // \n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n            // the @extends tag.\n            if (!qVar.isTypeInferred()) {\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == scope) {\n                scope.undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}", "code_comment": "/**\n * Declare the symbol for a qualified name in the global scope.\n *\n * @param info The doc info for this property.\n * @param n A top-level GETPROP node (it should not be contained inside\n *     another GETPROP).\n * @param parent The parent of {@code n}.\n * @param rhsValue The node that {@code n} is being initialized to,\n *     or {@code null} if this is a stub declaration.\n */\n", "code_no_comment": "void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n                                                        JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n                valueType = rhsValue.getJSType();\n    }\n        if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n                        if (!qVar.isTypeInferred()) {\n                                return;\n            }\n            if (qVar.getScope() == scope) {\n                scope.undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n                inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n                inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n                                    boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n                        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n                FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}", "lc": 1.8636363636363635, "pi": 0.5357142857142858, "ma": 2.1666666666666665, "nbd": 1.0, "ml": 3.25, "d": 1.106277805239743, "mi": -1.0493260682535135, "fo": 3.25, "r": -0.028571428571428574, "e": 5.0712863145180975}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-4113_27300d81", "label": 0, "code": "public static ByteBuffer toByteBuffers(ByteSequence bs) {\n    if (bs == null)\n        return null;\n    if (bs.isBackedByArray()) {\n        return ByteBuffer.wrap(bs.getBackingArray(), bs.offset(), bs.length());\n    } else {\n        // TODO create more efficient impl\n        return ByteBuffer.wrap(bs.toArray());\n    }\n}", "code_comment": NaN, "code_no_comment": "public static ByteBuffer toByteBuffers(ByteSequence bs) {\n    if (bs == null)\n        return null;\n    if (bs.isBackedByArray()) {\n        return ByteBuffer.wrap(bs.getBackingArray(), bs.offset(), bs.length());\n    } else {\n                return ByteBuffer.wrap(bs.toArray());\n    }\n}", "lc": -0.22727272727272727, "pi": -0.035714285714285636, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.3806228373702422, "mi": 0.3240607972469171, "fo": 0.08333333333333333, "r": 0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 5, "label": 1, "code": "/**\n * Counts the number of direct (full) references to an object.\n * Specifically, we check for references of the following type:\n * <pre>\n *   x;\n *   x.fn();\n * </pre>\n */\nprivate boolean isInlinableObject(List<Reference> refs) {\n    boolean ret = false;\n    Set<String> validProperties = Sets.newHashSet();\n    for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n        // \n        if (parent.isGetProp()) {\n            Preconditions.checkState(parent.getFirstChild() == name);\n            // A call target may be using the object as a 'this' value.\n            if (gramps.isCall() && gramps.getFirstChild() == parent) {\n                return false;\n            }\n            // Deleting a property has different semantics from deleting\n            // a variable, so deleted properties should not be inlined.\n            // NOTE(nicksantos): This pass's object-splitting algorithm has\n            // a blind spot. It assumes that if a property isn't defined on an\n            // object, then the value is undefined. This is not true, because\n            // Object.prototype can have arbitrary properties on it.\n            // \n            // We short-circuit this problem by bailing out if we see a reference\n            // to a property that isn't defined on the object literal. This\n            // isn't a perfect algorithm, but it should catch most cases.\n            String propName = parent.getLastChild().getString();\n            if (!validProperties.contains(propName)) {\n                if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n                    validProperties.add(propName);\n                } else {\n                    return false;\n                }\n            }\n            continue;\n        }\n        // Only rewrite VAR declarations or simple assignment statements\n        if (!isVarOrAssignExprLhs(name)) {\n            return false;\n        }\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n            // A var with no assignment.\n            continue;\n        }\n        // We're looking for object literal assignments only.\n        if (!val.isObjectLit()) {\n            return false;\n        }\n        // Also, ES5 getters/setters aren't handled by this pass.\n        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n            if (child.isGetterDef() || child.isSetterDef()) {\n                // ES5 get/set not supported.\n                return false;\n            }\n            validProperties.add(child.getString());\n            Node childVal = child.getFirstChild();\n            // will happen.\n            for (Reference t : refs) {\n                Node refNode = t.getParent();\n                while (!NodeUtil.isStatementBlock(refNode)) {\n                    if (refNode == childVal) {\n                        // There's a self-referential assignment\n                        return false;\n                    }\n                    refNode = refNode.getParent();\n                }\n            }\n        }\n        // We have found an acceptable object literal assignment. As\n        // long as there are no other assignments that mess things up,\n        // we can inline.\n        ret = true;\n    }\n    return ret;\n}", "code_comment": "/**\n * Counts the number of direct (full) references to an object.\n * Specifically, we check for references of the following type:\n * <pre>\n *   x;\n *   x.fn();\n * </pre>\n */\n", "code_no_comment": "private boolean isInlinableObject(List<Reference> refs) {\n    boolean ret = false;\n    Set<String> validProperties = Sets.newHashSet();\n    for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n                if (parent.isGetProp()) {\n            Preconditions.checkState(parent.getFirstChild() == name);\n                        if (gramps.isCall() && gramps.getFirstChild() == parent) {\n                return false;\n            }\n                                                                                                                                    String propName = parent.getLastChild().getString();\n            if (!validProperties.contains(propName)) {\n                if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n                    validProperties.add(propName);\n                } else {\n                    return false;\n                }\n            }\n            continue;\n        }\n                if (!isVarOrAssignExprLhs(name)) {\n            return false;\n        }\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n                        continue;\n        }\n                if (!val.isObjectLit()) {\n            return false;\n        }\n                for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n            if (child.isGetterDef() || child.isSetterDef()) {\n                                return false;\n            }\n            validProperties.add(child.getString());\n            Node childVal = child.getFirstChild();\n                        for (Reference t : refs) {\n                Node refNode = t.getParent();\n                while (!NodeUtil.isStatementBlock(refNode)) {\n                    if (refNode == childVal) {\n                                                return false;\n                    }\n                    refNode = refNode.getParent();\n                }\n            }\n        }\n                                ret = true;\n    }\n    return ret;\n}", "lc": 1.7272727272727273, "pi": 1.1173469387755102, "ma": 2.0, "nbd": 1.5, "ml": 2.1666666666666665, "d": 1.0252100840336138, "mi": -0.9027817608259252, "fo": 1.75, "r": -0.028571428571428574, "e": 2.1441059443809136}
{"project_name": "Closure", "project_version": 30, "label": 2, "code": "boolean dependsOnOuterScopeVars(String name, Node useNode) {\n    Preconditions.checkArgument(getCfg().hasNode(useNode));\n    GraphNode<Node, Branch> n = getCfg().getNode(useNode);\n    FlowState<MustDef> state = n.getAnnotation();\n    Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));\n    for (Var s : def.depends) {\n        if (s.scope != jsScope) {\n            return true;\n        }\n    }\n    return false;\n}", "code_comment": NaN, "code_no_comment": "boolean dependsOnOuterScopeVars(String name, Node useNode) {\n    Preconditions.checkArgument(getCfg().hasNode(useNode));\n    GraphNode<Node, Branch> n = getCfg().getNode(useNode);\n    FlowState<MustDef> state = n.getAnnotation();\n    Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));\n    for (Var s : def.depends) {\n        if (s.scope != jsScope) {\n            return true;\n        }\n    }\n    return false;\n}", "lc": -0.09090909090909091, "pi": 0.09183673469387764, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.16666666666666666, "d": -0.1196243203163618, "mi": 0.043877258388299444, "fo": 0.25, "r": 0.0, "e": -0.0356431572590489}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5131_4b7367ef", "label": 1, "code": "/**\n * {@inheritDoc}\n */\npublic void respond(final IRequestCycle requestCycle) {\n    final String location;\n    if (redirectUrl.startsWith(\"/\")) {\n        // context-absolute url\n        location = requestCycle.getUrlRenderer().renderContextRelativeUrl(redirectUrl);\n    } else {\n        // if relative url, servlet container will translate to absolute as\n        // per the servlet spec\n        // if absolute url still do the same\n        location = redirectUrl;\n    }\n    WebResponse response = (WebResponse) requestCycle.getResponse();\n    if (status == HttpServletResponse.SC_MOVED_TEMPORARILY) {\n        response.sendRedirect(location);\n    } else {\n        response.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);\n        response.setHeader(\"Location\", location);\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public void respond(final IRequestCycle requestCycle) {\n    final String location;\n    if (redirectUrl.startsWith(\"/\")) {\n                location = requestCycle.getUrlRenderer().renderContextRelativeUrl(redirectUrl);\n    } else {\n                                location = redirectUrl;\n    }\n    WebResponse response = (WebResponse) requestCycle.getResponse();\n    if (status == HttpServletResponse.SC_MOVED_TEMPORARILY) {\n        response.sendRedirect(location);\n    } else {\n        response.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);\n        response.setHeader(\"Location\", location);\n    }\n}", "lc": 0.045454545454545456, "pi": -0.20918367346938782, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.06623826000988627, "mi": -0.024089475193576244, "fo": 0.08333333333333333, "r": 0.31428571428571433, "e": -0.042384605171298724}
{"project_name": "Math", "project_version": 81, "label": 1, "code": "/**\n * Compute the shift increment as an estimate of the smallest eigenvalue.\n * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n * @param start start index\n * @param end end index\n * @param deflated number of realEigenvalues just deflated\n */\nprivate void computeShiftIncrement(final int start, final int end, final int deflated) {\n    final double cnst1 = 0.563;\n    final double cnst2 = 1.010;\n    final double cnst3 = 1.05;\n    // tType records the type of shift.\n    if (dMin <= 0.0) {\n        tau = -dMin;\n        tType = -1;\n        return;\n    }\n    int nn = 4 * end + pingPong - 1;\n    switch(deflated) {\n        case // no realEigenvalues deflated.\n        0:\n            if (dMin == dN || dMin == dN1) {\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5] > work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4] > work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9] > work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n                }\n            } else if (dMin == dN2) {\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n                // approximate contribution to norm squared from i < nn-2.\n                if (end - start > 2) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n            } else {\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau = g * dMin;\n                tType = -6;\n            }\n            break;\n        case // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n        1:\n            if (dMin1 == dN1 && dMin2 == dN2) {\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n        case // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n        2:\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n        default:\n            // case 12, more than two realEigenvalues deflated. no information.\n            tau = 0.0;\n            tType = -12;\n    }\n}", "code_comment": "/**\n * Compute the shift increment as an estimate of the smallest eigenvalue.\n * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n * @param start start index\n * @param end end index\n * @param deflated number of realEigenvalues just deflated\n */\n", "code_no_comment": "private void computeShiftIncrement(final int start, final int end, final int deflated) {\n    final double cnst1 = 0.563;\n    final double cnst2 = 1.010;\n    final double cnst3 = 1.05;\n        if (dMin <= 0.0) {\n        tau = -dMin;\n        tType = -1;\n        return;\n    }\n    int nn = 4 * end + pingPong - 1;\n    switch(deflated) {\n        case         0:\n            if (dMin == dN || dMin == dN1) {\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n                if (dMin == dN && dMin1 == dN1) {\n                                        final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                                        tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5] > work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4] > work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9] > work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n                                        a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                                        if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n                }\n            } else if (dMin == dN2) {\n                                tType = -5;\n                double s = 0.25 * dMin;\n                                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n                                if (end - start > 2) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n            } else {\n                                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau = g * dMin;\n                tType = -6;\n            }\n            break;\n        case         1:\n            if (dMin1 == dN1 && dMin2 == dN2) {\n                                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n                                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n        case         2:\n                        if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n        default:\n                        tau = 0.0;\n            tType = -12;\n    }\n}", "lc": 8.863636363636363, "pi": 1.5459183673469388, "ma": 8.5, "nbd": 2.5, "ml": 5.916666666666667, "d": 15.571922886801785, "mi": -2.1115572125035853, "fo": 1.1666666666666667, "r": -0.028571428571428574, "e": 202.80059619412287}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1215_a9efe3c4", "label": 0, "code": "@Override\npublic PropertyValue currentProperty() {\n    boolean asterisk = PathUtils.getName(propertyName).equals(\"*\");\n    if (!asterisk) {\n        PropertyValue p = selector.currentProperty(propertyName);\n        return matchesPropertyType(p) ? p : null;\n    }\n    Tree tree = selector.currentTree();\n    if (tree == null || !tree.exists()) {\n        return null;\n    }\n    if (!asterisk) {\n        String name = PathUtils.getName(propertyName);\n        name = normalizePropertyName(name);\n        PropertyState p = tree.getProperty(name);\n        if (p == null) {\n            return null;\n        }\n        return matchesPropertyType(p) ? PropertyValues.create(p) : null;\n    }\n    // asterisk - create a multi-value property\n    // warning: the returned property state may have a mixed type\n    // (not all values may have the same type)\n    // TODO currently all property values are converted to strings -\n    // this doesn't play well with the idea that the types may be different\n    List<String> values = new ArrayList<String>();\n    for (PropertyState p : tree.getProperties()) {\n        if (matchesPropertyType(p)) {\n            Iterables.addAll(values, p.getValue(Type.STRINGS));\n        }\n    }\n    // \"*\"\n    return PropertyValues.newString(values);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic PropertyValue currentProperty() {\n    boolean asterisk = PathUtils.getName(propertyName).equals(\"*\");\n    if (!asterisk) {\n        PropertyValue p = selector.currentProperty(propertyName);\n        return matchesPropertyType(p) ? p : null;\n    }\n    Tree tree = selector.currentTree();\n    if (tree == null || !tree.exists()) {\n        return null;\n    }\n    if (!asterisk) {\n        String name = PathUtils.getName(propertyName);\n        name = normalizePropertyName(name);\n        PropertyState p = tree.getProperty(name);\n        if (p == null) {\n            return null;\n        }\n        return matchesPropertyType(p) ? PropertyValues.create(p) : null;\n    }\n                        List<String> values = new ArrayList<String>();\n    for (PropertyState p : tree.getProperties()) {\n        if (matchesPropertyType(p)) {\n            Iterables.addAll(values, p.getValue(Type.STRINGS));\n        }\n    }\n        return PropertyValues.newString(values);\n}", "lc": 0.6363636363636364, "pi": 0.04081632653061228, "ma": 0.8333333333333334, "nbd": 0.0, "ml": 0.6666666666666666, "d": 0.44389520514088, "mi": -0.49268712360195044, "fo": 0.8333333333333334, "r": -0.028571428571428574, "e": 0.647872846184486}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "public void recv_removeConstraint() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\n    removeConstraint_result result = new removeConstraint_result();\n    receiveBase(result, \"removeConstraint\");\n    if (result.ouch1 != null) {\n        throw result.ouch1;\n    }\n    if (result.ouch2 != null) {\n        throw result.ouch2;\n    }\n    return;\n}", "code_comment": NaN, "code_no_comment": "public void recv_removeConstraint() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\n    removeConstraint_result result = new removeConstraint_result();\n    receiveBase(result, \"removeConstraint\");\n    if (result.ouch1 != null) {\n        throw result.ouch1;\n    }\n    if (result.ouch2 != null) {\n        throw result.ouch2;\n    }\n    return;\n}", "lc": -0.13636363636363635, "pi": -0.3112244897959183, "ma": 0.16666666666666666, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.06426099851705384, "mi": 0.17866360768568987, "fo": -0.4166666666666667, "r": -0.028571428571428574, "e": -0.08859821570063517}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1311_94c8e3fa", "label": 1, "code": "@Override\npublic void postVisit(Operator<?> c) {\n    OptimizerNode n = this.con2node.get(c);\n    // first connect to the predecessors\n    n.setInput(this.con2node);\n    n.setBroadcastInputs(this.con2node);\n    // if the node represents a bulk iteration, we recursively translate the data flow now\n    if (n instanceof BulkIterationNode) {\n        final BulkIterationNode iterNode = (BulkIterationNode) n;\n        final BulkIterationBase<?> iter = iterNode.getIterationContract();\n        // pass a copy of the no iterative part into the iteration translation,\n        // in case the iteration references its closure\n        HashMap<Operator<?>, OptimizerNode> closure = new HashMap<Operator<?>, OptimizerNode>(con2node);\n        // first, recursively build the data flow for the step function\n        final GraphCreatingVisitor recursiveCreator = new GraphCreatingVisitor(this, true, iterNode.getDegreeOfParallelism(), closure);\n        BulkPartialSolutionNode partialSolution = null;\n        iter.getNextPartialSolution().accept(recursiveCreator);\n        partialSolution = (BulkPartialSolutionNode) recursiveCreator.con2node.get(iter.getPartialSolution());\n        OptimizerNode rootOfStepFunction = recursiveCreator.con2node.get(iter.getNextPartialSolution());\n        if (partialSolution == null) {\n            throw new CompilerException(\"Error: The step functions result does not depend on the partial solution.\");\n        }\n        OptimizerNode terminationCriterion = null;\n        if (iter.getTerminationCriterion() != null) {\n            terminationCriterion = recursiveCreator.con2node.get(iter.getTerminationCriterion());\n            // no intermediate node yet, traverse from the termination criterion to build the missing parts\n            if (terminationCriterion == null) {\n                iter.getTerminationCriterion().accept(recursiveCreator);\n                terminationCriterion = recursiveCreator.con2node.get(iter.getTerminationCriterion());\n            }\n        }\n        iterNode.setPartialSolution(partialSolution);\n        iterNode.setNextPartialSolution(rootOfStepFunction, terminationCriterion);\n        // go over the contained data flow and mark the dynamic path nodes\n        StaticDynamicPathIdentifier identifier = new StaticDynamicPathIdentifier(iterNode.getCostWeight());\n        rootOfStepFunction.accept(identifier);\n        if (terminationCriterion != null) {\n            terminationCriterion.accept(identifier);\n        }\n    } else if (n instanceof WorksetIterationNode) {\n        final WorksetIterationNode iterNode = (WorksetIterationNode) n;\n        final DeltaIterationBase<?, ?> iter = iterNode.getIterationContract();\n        // we need to ensure that both the next-workset and the solution-set-delta depend on the workset. One check is for free\n        // during the translation, we do the other check here as a pre-condition\n        {\n            StepFunctionValidator wsf = new StepFunctionValidator();\n            iter.getNextWorkset().accept(wsf);\n            if (!wsf.foundWorkset) {\n                throw new CompilerException(\"In the given program, the next workset does not depend on the workset. This is a prerequisite in delta iterations.\");\n            }\n        }\n        // calculate the closure of the anonymous function\n        HashMap<Operator<?>, OptimizerNode> closure = new HashMap<Operator<?>, OptimizerNode>(con2node);\n        // first, recursively build the data flow for the step function\n        final GraphCreatingVisitor recursiveCreator = new GraphCreatingVisitor(this, true, iterNode.getDegreeOfParallelism(), closure);\n        // descend from the solution set delta. check that it depends on both the workset\n        // and the solution set. If it does depend on both, this descend should create both nodes\n        iter.getSolutionSetDelta().accept(recursiveCreator);\n        final WorksetNode worksetNode = (WorksetNode) recursiveCreator.con2node.get(iter.getWorkset());\n        if (worksetNode == null) {\n            throw new CompilerException(\"In the given program, the solution set delta does not depend on the workset. This is a prerequisite in delta iterations.\");\n        }\n        iter.getNextWorkset().accept(recursiveCreator);\n        SolutionSetNode solutionSetNode = (SolutionSetNode) recursiveCreator.con2node.get(iter.getSolutionSet());\n        if (solutionSetNode == null || solutionSetNode.getOutgoingConnections() == null || solutionSetNode.getOutgoingConnections().isEmpty()) {\n            solutionSetNode = new SolutionSetNode((SolutionSetPlaceHolder<?>) iter.getSolutionSet(), iterNode);\n        } else {\n            for (PactConnection conn : solutionSetNode.getOutgoingConnections()) {\n                OptimizerNode successor = conn.getTarget();\n                if (successor.getClass() == JoinNode.class) {\n                    // find out which input to the match the solution set is\n                    JoinNode mn = (JoinNode) successor;\n                    if (mn.getFirstPredecessorNode() == solutionSetNode) {\n                        mn.makeJoinWithSolutionSet(0);\n                    } else if (mn.getSecondPredecessorNode() == solutionSetNode) {\n                        mn.makeJoinWithSolutionSet(1);\n                    } else {\n                        throw new CompilerException();\n                    }\n                } else if (successor.getClass() == CoGroupNode.class) {\n                    CoGroupNode cg = (CoGroupNode) successor;\n                    if (cg.getFirstPredecessorNode() == solutionSetNode) {\n                        cg.makeCoGroupWithSolutionSet(0);\n                    } else if (cg.getSecondPredecessorNode() == solutionSetNode) {\n                        cg.makeCoGroupWithSolutionSet(1);\n                    } else {\n                        throw new CompilerException();\n                    }\n                } else {\n                    throw new InvalidProgramException(\"Error: The only operations allowed on the solution set are Join and CoGroup.\");\n                }\n            }\n        }\n        final OptimizerNode nextWorksetNode = recursiveCreator.con2node.get(iter.getNextWorkset());\n        final OptimizerNode solutionSetDeltaNode = recursiveCreator.con2node.get(iter.getSolutionSetDelta());\n        // set the step function nodes to the iteration node\n        iterNode.setPartialSolution(solutionSetNode, worksetNode);\n        iterNode.setNextPartialSolution(solutionSetDeltaNode, nextWorksetNode);\n        // go over the contained data flow and mark the dynamic path nodes\n        StaticDynamicPathIdentifier pathIdentifier = new StaticDynamicPathIdentifier(iterNode.getCostWeight());\n        nextWorksetNode.accept(pathIdentifier);\n        iterNode.getSolutionSetDelta().accept(pathIdentifier);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void postVisit(Operator<?> c) {\n    OptimizerNode n = this.con2node.get(c);\n        n.setInput(this.con2node);\n    n.setBroadcastInputs(this.con2node);\n        if (n instanceof BulkIterationNode) {\n        final BulkIterationNode iterNode = (BulkIterationNode) n;\n        final BulkIterationBase<?> iter = iterNode.getIterationContract();\n                        HashMap<Operator<?>, OptimizerNode> closure = new HashMap<Operator<?>, OptimizerNode>(con2node);\n                final GraphCreatingVisitor recursiveCreator = new GraphCreatingVisitor(this, true, iterNode.getDegreeOfParallelism(), closure);\n        BulkPartialSolutionNode partialSolution = null;\n        iter.getNextPartialSolution().accept(recursiveCreator);\n        partialSolution = (BulkPartialSolutionNode) recursiveCreator.con2node.get(iter.getPartialSolution());\n        OptimizerNode rootOfStepFunction = recursiveCreator.con2node.get(iter.getNextPartialSolution());\n        if (partialSolution == null) {\n            throw new CompilerException(\"Error: The step functions result does not depend on the partial solution.\");\n        }\n        OptimizerNode terminationCriterion = null;\n        if (iter.getTerminationCriterion() != null) {\n            terminationCriterion = recursiveCreator.con2node.get(iter.getTerminationCriterion());\n                        if (terminationCriterion == null) {\n                iter.getTerminationCriterion().accept(recursiveCreator);\n                terminationCriterion = recursiveCreator.con2node.get(iter.getTerminationCriterion());\n            }\n        }\n        iterNode.setPartialSolution(partialSolution);\n        iterNode.setNextPartialSolution(rootOfStepFunction, terminationCriterion);\n                StaticDynamicPathIdentifier identifier = new StaticDynamicPathIdentifier(iterNode.getCostWeight());\n        rootOfStepFunction.accept(identifier);\n        if (terminationCriterion != null) {\n            terminationCriterion.accept(identifier);\n        }\n    } else if (n instanceof WorksetIterationNode) {\n        final WorksetIterationNode iterNode = (WorksetIterationNode) n;\n        final DeltaIterationBase<?, ?> iter = iterNode.getIterationContract();\n                        {\n            StepFunctionValidator wsf = new StepFunctionValidator();\n            iter.getNextWorkset().accept(wsf);\n            if (!wsf.foundWorkset) {\n                throw new CompilerException(\"In the given program, the next workset does not depend on the workset. This is a prerequisite in delta iterations.\");\n            }\n        }\n                HashMap<Operator<?>, OptimizerNode> closure = new HashMap<Operator<?>, OptimizerNode>(con2node);\n                final GraphCreatingVisitor recursiveCreator = new GraphCreatingVisitor(this, true, iterNode.getDegreeOfParallelism(), closure);\n                        iter.getSolutionSetDelta().accept(recursiveCreator);\n        final WorksetNode worksetNode = (WorksetNode) recursiveCreator.con2node.get(iter.getWorkset());\n        if (worksetNode == null) {\n            throw new CompilerException(\"In the given program, the solution set delta does not depend on the workset. This is a prerequisite in delta iterations.\");\n        }\n        iter.getNextWorkset().accept(recursiveCreator);\n        SolutionSetNode solutionSetNode = (SolutionSetNode) recursiveCreator.con2node.get(iter.getSolutionSet());\n        if (solutionSetNode == null || solutionSetNode.getOutgoingConnections() == null || solutionSetNode.getOutgoingConnections().isEmpty()) {\n            solutionSetNode = new SolutionSetNode((SolutionSetPlaceHolder<?>) iter.getSolutionSet(), iterNode);\n        } else {\n            for (PactConnection conn : solutionSetNode.getOutgoingConnections()) {\n                OptimizerNode successor = conn.getTarget();\n                if (successor.getClass() == JoinNode.class) {\n                                        JoinNode mn = (JoinNode) successor;\n                    if (mn.getFirstPredecessorNode() == solutionSetNode) {\n                        mn.makeJoinWithSolutionSet(0);\n                    } else if (mn.getSecondPredecessorNode() == solutionSetNode) {\n                        mn.makeJoinWithSolutionSet(1);\n                    } else {\n                        throw new CompilerException();\n                    }\n                } else if (successor.getClass() == CoGroupNode.class) {\n                    CoGroupNode cg = (CoGroupNode) successor;\n                    if (cg.getFirstPredecessorNode() == solutionSetNode) {\n                        cg.makeCoGroupWithSolutionSet(0);\n                    } else if (cg.getSecondPredecessorNode() == solutionSetNode) {\n                        cg.makeCoGroupWithSolutionSet(1);\n                    } else {\n                        throw new CompilerException();\n                    }\n                } else {\n                    throw new InvalidProgramException(\"Error: The only operations allowed on the solution set are Join and CoGroup.\");\n                }\n            }\n        }\n        final OptimizerNode nextWorksetNode = recursiveCreator.con2node.get(iter.getNextWorkset());\n        final OptimizerNode solutionSetDeltaNode = recursiveCreator.con2node.get(iter.getSolutionSetDelta());\n                iterNode.setPartialSolution(solutionSetNode, worksetNode);\n        iterNode.setNextPartialSolution(solutionSetDeltaNode, nextWorksetNode);\n                StaticDynamicPathIdentifier pathIdentifier = new StaticDynamicPathIdentifier(iterNode.getCostWeight());\n        nextWorksetNode.accept(pathIdentifier);\n        iterNode.getSolutionSetDelta().accept(pathIdentifier);\n    }\n}", "lc": 3.3636363636363638, "pi": 1.5051020408163265, "ma": 3.1666666666666665, "nbd": 3.0, "ml": 2.1666666666666665, "d": 1.0350963914977758, "mi": -1.3372526527100663, "fo": 4.583333333333333, "r": -0.028571428571428574, "e": 5.938757329290177}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1437_fb7ce0e3", "label": 1, "code": "@Override\npublic T copy(T from) {\n    T target;\n    try {\n        target = clazz.newInstance();\n    } catch (Throwable t) {\n        throw new RuntimeException(\"Cannot instantiate class.\", t);\n    }\n    try {\n        for (int i = 0; i < numFields; i++) {\n            Object copy = fieldSerializers[i].copy(fields[i].get(from));\n            fields[i].set(target, copy);\n        }\n    } catch (IllegalAccessException e) {\n        throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields before.\");\n    }\n    return target;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic T copy(T from) {\n    T target;\n    try {\n        target = clazz.newInstance();\n    } catch (Throwable t) {\n        throw new RuntimeException(\"Cannot instantiate class.\", t);\n    }\n    try {\n        for (int i = 0; i < numFields; i++) {\n            Object copy = fieldSerializers[i].copy(fields[i].get(from));\n            fields[i].set(target, copy);\n        }\n    } catch (IllegalAccessException e) {\n        throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields before.\");\n    }\n    return target;\n}", "lc": 0.18181818181818182, "pi": 0.26020408163265296, "ma": 0.3333333333333333, "nbd": 0.0, "ml": -0.16666666666666666, "d": -0.03657933761739987, "mi": -0.153713794092343, "fo": -0.16666666666666666, "r": 0.05714285714285714, "e": -0.0066729198521507035}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1008_0c20bfd8", "label": 1, "code": "/**\n * Provides access to the classes discovered so far. If no calls have been made to\n * any of the {@code find()} methods, this set will be empty.\n *\n * @return the set of classes that have been discovered.\n */\npublic Set<Class<?>> getClasses() {\n    return classMatches;\n}", "code_comment": "/**\n * Provides access to the classes discovered so far. If no calls have been made to\n * any of the {@code find()} methods, this set will be empty.\n *\n * @return the set of classes that have been discovered.\n */\n", "code_no_comment": "public Set<Class<?>> getClasses() {\n    return classMatches;\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.144536851161457, "fo": -0.5, "r": 2.7714285714285714, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5", "label": 3, "code": "@Override\npublic String createWriter(ByteBuffer login, String tableName, WriterOptions opts) throws TException {\n    try {\n        BatchWriter writer = getWriter(login, tableName, opts);\n        UUID uuid = UUID.randomUUID();\n        writerCache.put(uuid, writer);\n        return uuid.toString();\n    } catch (Exception e) {\n        throw translateException(e);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic String createWriter(ByteBuffer login, String tableName, WriterOptions opts) throws TException {\n    try {\n        BatchWriter writer = getWriter(login, tableName, opts);\n        UUID uuid = UUID.randomUUID();\n        writerCache.put(uuid, writer);\n        return uuid.toString();\n    } catch (Exception e) {\n        throw translateException(e);\n    }\n}", "lc": -0.13636363636363635, "pi": 0.15816326530612249, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.14683108689417854, "fo": -0.08333333333333333, "r": 0.17142857142857146, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3281_f7dd2fff", "label": 1, "code": "/**\n * Adds a route for an interceptor that intercepts incoming messages on the given endpoint.\n *\n * @param uri  endpoint uri\n * @return the builder\n */\npublic InterceptFromDefinition interceptFrom(String uri) {\n    routeCollection.setCamelContext(getContext());\n    return routeCollection.interceptFrom(uri);\n}", "code_comment": "/**\n * Adds a route for an interceptor that intercepts incoming messages on the given endpoint.\n *\n * @param uri  endpoint uri\n * @return the builder\n */\n", "code_no_comment": "public InterceptFromDefinition interceptFrom(String uri) {\n    routeCollection.setCamelContext(getContext());\n    return routeCollection.interceptFrom(uri);\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.855176369371953, "fo": -0.25, "r": 2.7714285714285714, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2047_a0a495f0", "label": 0, "code": "private PrivilegeBits resolvePrivilegeBits(NodeBuilder privileges, String name) {\n    NodeBuilder def = privileges.getChildNode(name);\n    PropertyState b = def.getProperty(REP_BITS);\n    if (b != null) {\n        return PrivilegeBits.getInstance(b);\n    }\n    PrivilegeBits bits = PrivilegeBits.getInstance();\n    for (String n : def.getNames(REP_AGGREGATES)) {\n        bits.add(resolvePrivilegeBits(privileges, n));\n    }\n    def.setProperty(bits.asPropertyState(REP_BITS));\n    return bits;\n}", "code_comment": NaN, "code_no_comment": "private PrivilegeBits resolvePrivilegeBits(NodeBuilder privileges, String name) {\n    NodeBuilder def = privileges.getChildNode(name);\n    PropertyState b = def.getProperty(REP_BITS);\n    if (b != null) {\n        return PrivilegeBits.getInstance(b);\n    }\n    PrivilegeBits bits = PrivilegeBits.getInstance();\n    for (String n : def.getNames(REP_AGGREGATES)) {\n        bits.add(resolvePrivilegeBits(privileges, n));\n    }\n    def.setProperty(bits.asPropertyState(REP_BITS));\n    return bits;\n}", "lc": -0.045454545454545456, "pi": -0.40816326530612235, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.25, "d": -0.0029658922392486217, "mi": 0.01778032692859205, "fo": 0.25, "r": 0.028571428571428574, "e": 0.00822336721189304}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-554_3f51fb09", "label": 1, "code": "/**\n * Create a multi valued {@code PropertyState} based on a list of\n * {@link Value} instances. The {@link Type} of the property is determined\n * by the type of the first value in the list or {@link Type#STRING} if the\n * list is empty.\n *\n * @param name  The name of the property state\n * @param values  The values of the property state\n * @return  The new property state\n * @throws RepositoryException forwarded from {@code value}\n */\n@Nonnull\npublic static PropertyState createProperty(String name, Iterable<Value> values) throws RepositoryException {\n    Value first = Iterables.getFirst(values, null);\n    if (first == null) {\n        return EmptyPropertyState.emptyProperty(name, STRINGS);\n    }\n    int type = first.getType();\n    switch(type) {\n        case PropertyType.STRING:\n            List<String> strings = Lists.newArrayList();\n            for (Value value : values) {\n                strings.add(value.getString());\n            }\n            return MultiStringPropertyState.stringProperty(name, strings);\n        case PropertyType.BINARY:\n            List<Blob> blobs = Lists.newArrayList();\n            for (Value value : values) {\n                blobs.add(new ValueBasedBlob(value));\n            }\n            return MultiBinaryPropertyState.binaryPropertyFromBlob(name, blobs);\n        case PropertyType.LONG:\n            List<Long> longs = Lists.newArrayList();\n            for (Value value : values) {\n                longs.add(value.getLong());\n            }\n            return MultiLongPropertyState.createLongProperty(name, longs);\n        case PropertyType.DOUBLE:\n            List<Double> doubles = Lists.newArrayList();\n            for (Value value : values) {\n                doubles.add(value.getDouble());\n            }\n            return MultiDoublePropertyState.doubleProperty(name, doubles);\n        case PropertyType.DATE:\n            List<Long> dates = Lists.newArrayList();\n            for (Value value : values) {\n                dates.add(value.getLong());\n            }\n            return MultiLongPropertyState.createDatePropertyFromLong(name, dates);\n        case PropertyType.BOOLEAN:\n            List<Boolean> booleans = Lists.newArrayList();\n            for (Value value : values) {\n                booleans.add(value.getBoolean());\n            }\n            return MultiBooleanPropertyState.booleanProperty(name, booleans);\n        case PropertyType.DECIMAL:\n            List<BigDecimal> decimals = Lists.newArrayList();\n            for (Value value : values) {\n                decimals.add(value.getDecimal());\n            }\n            return MultiDecimalPropertyState.decimalProperty(name, decimals);\n        default:\n            List<String> vals = Lists.newArrayList();\n            for (Value value : values) {\n                vals.add(value.getString());\n            }\n            return new MultiGenericPropertyState(name, vals, Type.fromTag(type, true));\n    }\n}", "code_comment": "/**\n * Create a multi valued {@code PropertyState} based on a list of\n * {@link Value} instances. The {@link Type} of the property is determined\n * by the type of the first value in the list or {@link Type#STRING} if the\n * list is empty.\n *\n * @param name  The name of the property state\n * @param values  The values of the property state\n * @return  The new property state\n * @throws RepositoryException forwarded from {@code value}\n */\n", "code_no_comment": "@Nonnull\npublic static PropertyState createProperty(String name, Iterable<Value> values) throws RepositoryException {\n    Value first = Iterables.getFirst(values, null);\n    if (first == null) {\n        return EmptyPropertyState.emptyProperty(name, STRINGS);\n    }\n    int type = first.getType();\n    switch(type) {\n        case PropertyType.STRING:\n            List<String> strings = Lists.newArrayList();\n            for (Value value : values) {\n                strings.add(value.getString());\n            }\n            return MultiStringPropertyState.stringProperty(name, strings);\n        case PropertyType.BINARY:\n            List<Blob> blobs = Lists.newArrayList();\n            for (Value value : values) {\n                blobs.add(new ValueBasedBlob(value));\n            }\n            return MultiBinaryPropertyState.binaryPropertyFromBlob(name, blobs);\n        case PropertyType.LONG:\n            List<Long> longs = Lists.newArrayList();\n            for (Value value : values) {\n                longs.add(value.getLong());\n            }\n            return MultiLongPropertyState.createLongProperty(name, longs);\n        case PropertyType.DOUBLE:\n            List<Double> doubles = Lists.newArrayList();\n            for (Value value : values) {\n                doubles.add(value.getDouble());\n            }\n            return MultiDoublePropertyState.doubleProperty(name, doubles);\n        case PropertyType.DATE:\n            List<Long> dates = Lists.newArrayList();\n            for (Value value : values) {\n                dates.add(value.getLong());\n            }\n            return MultiLongPropertyState.createDatePropertyFromLong(name, dates);\n        case PropertyType.BOOLEAN:\n            List<Boolean> booleans = Lists.newArrayList();\n            for (Value value : values) {\n                booleans.add(value.getBoolean());\n            }\n            return MultiBooleanPropertyState.booleanProperty(name, booleans);\n        case PropertyType.DECIMAL:\n            List<BigDecimal> decimals = Lists.newArrayList();\n            for (Value value : values) {\n                decimals.add(value.getDecimal());\n            }\n            return MultiDecimalPropertyState.decimalProperty(name, decimals);\n        default:\n            List<String> vals = Lists.newArrayList();\n            for (Value value : values) {\n                vals.add(value.getString());\n            }\n            return new MultiGenericPropertyState(name, vals, Type.fromTag(type, true));\n    }\n}", "lc": 2.0, "pi": 0.530612244897959, "ma": 2.3333333333333335, "nbd": 0.5, "ml": 0.4166666666666667, "d": 0.115669797330697, "mi": -1.0243762546601667, "fo": 2.3333333333333335, "r": -0.028571428571428574, "e": 1.037253566671378}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443", "label": 1, "code": "@Override\npublic void offline(String tableName) throws AccumuloSecurityException, AccumuloException {\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void offline(String tableName) throws AccumuloSecurityException, AccumuloException {\n}", "lc": -0.5, "pi": -1.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.0662460567823349, "fo": -0.5, "r": 1.8, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4072_7d5b8645", "label": 1, "code": "/**\n *  return path for current url in original encoding\n *\n *  @return path string\n */\npublic String getPath() {\n    return getPath(getCharset());\n}", "code_comment": "/**\n *  return path for current url in original encoding\n *\n *  @return path string\n */\n", "code_no_comment": "public String getPath() {\n    return getPath(getCharset());\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.1669056495554921, "fo": -0.3333333333333333, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-757_76b7413d", "label": 1, "code": "/**\n * Discards the <code>i</code> first or last elements of the array,\n * depending on the value of <code>front</code>.\n * For example, if the array contains the elements 1,2,3,4, invoking\n * <code>discardExtremeElements(2,false)</code> will cause the last two elements\n * to be discarded, leaving 1,2 in the array.\n * For example, if the array contains the elements 1,2,3,4, invoking\n * <code>discardExtremeElements(2,true)</code> will cause the first two elements\n * to be discarded, leaving 3,4 in the array.\n * Throws illegalArgumentException\n * if i exceeds numElements.\n *\n * @param i  the number of elements to discard from the front/end of the array\n * @param front true if elements are to be discarded from the front\n * of the array, false if elements are to be discarded from the end\n * of the array\n * @throws MathIllegalArgumentException if i is greater than numElements.\n * @since 2.0\n */\nprivate synchronized void discardExtremeElements(int i, boolean front) throws MathIllegalArgumentException {\n    if (i > numElements) {\n        throw new MathIllegalArgumentException(LocalizedFormats.TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY, i, numElements);\n    } else if (i < 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.CANNOT_DISCARD_NEGATIVE_NUMBER_OF_ELEMENTS, i);\n    } else {\n        // \"Subtract\" this number of discarded from numElements\n        numElements -= i;\n        if (front) {\n            startIndex += i;\n        }\n    }\n    if (shouldContract()) {\n        contract();\n    }\n}", "code_comment": "/**\n * Discards the <code>i</code> first or last elements of the array,\n * depending on the value of <code>front</code>.\n * For example, if the array contains the elements 1,2,3,4, invoking\n * <code>discardExtremeElements(2,false)</code> will cause the last two elements\n * to be discarded, leaving 1,2 in the array.\n * For example, if the array contains the elements 1,2,3,4, invoking\n * <code>discardExtremeElements(2,true)</code> will cause the first two elements\n * to be discarded, leaving 3,4 in the array.\n * Throws illegalArgumentException\n * if i exceeds numElements.\n *\n * @param i  the number of elements to discard from the front/end of the array\n * @param front true if elements are to be discarded from the front\n * of the array, false if elements are to be discarded from the end\n * of the array\n * @throws MathIllegalArgumentException if i is greater than numElements.\n * @since 2.0\n */\n", "code_no_comment": "private synchronized void discardExtremeElements(int i, boolean front) throws MathIllegalArgumentException {\n    if (i > numElements) {\n        throw new MathIllegalArgumentException(LocalizedFormats.TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY, i, numElements);\n    } else if (i < 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.CANNOT_DISCARD_NEGATIVE_NUMBER_OF_ELEMENTS, i);\n    } else {\n                numElements -= i;\n        if (front) {\n            startIndex += i;\n        }\n    }\n    if (shouldContract()) {\n        contract();\n    }\n}", "lc": 0.045454545454545456, "pi": 0.09183673469387764, "ma": 0.5, "nbd": 0.5, "ml": 0.25, "d": 0.38062283737024233, "mi": 0.010897619730427174, "fo": -0.3333333333333333, "r": -0.028571428571428574, "e": 0.03103892822114006}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-3077_17654199", "label": 0, "code": "/**\n * Write replication ingest entries for each provided file with the given {@link Status}.\n */\npublic static void updateFiles(Credentials creds, KeyExtent extent, Collection<String> files, Status stat) {\n    if (log.isDebugEnabled()) {\n        log.debug(\"Updating replication for \" + extent + \" with \" + files + \" using \" + ProtobufUtil.toString(stat));\n    }\n    // TODO could use batch writer, would need to handle failure and retry like update does - ACCUMULO-1294\n    if (files.isEmpty()) {\n        return;\n    }\n    Value v = ProtobufUtil.toValue(stat);\n    for (String file : files) {\n        // TODO Can preclude this addition if the extent is for a table we don't need to replicate\n        update(creds, createUpdateMutation(new Path(file), v, extent), extent);\n    }\n}", "code_comment": "/**\n * Write replication ingest entries for each provided file with the given {@link Status}.\n */\n", "code_no_comment": "public static void updateFiles(Credentials creds, KeyExtent extent, Collection<String> files, Status stat) {\n    if (log.isDebugEnabled()) {\n        log.debug(\"Updating replication for \" + extent + \" with \" + files + \" using \" + ProtobufUtil.toString(stat));\n    }\n        if (files.isEmpty()) {\n        return;\n    }\n    Value v = ProtobufUtil.toValue(stat);\n    for (String file : files) {\n                update(creds, createUpdateMutation(new Path(file), v, extent), extent);\n    }\n}", "lc": -0.09090909090909091, "pi": -0.2346938775510204, "ma": 0.0, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.08007909045971327, "mi": 0.0498996271866933, "fo": 0.08333333333333333, "r": 0.0, "e": -0.02836633387727482}
{"project_name": "Time", "project_version": 23, "label": 2, "code": "// -----------------------------------------------------------------------\n/**\n * Converts an old style id to a new style id.\n *\n * @param id  the old style id\n * @return the new style id, null if not found\n */\nprivate static synchronized String getConvertedId(String id) {\n    Map<String, String> map = cZoneIdConversion;\n    if (map == null) {\n        // Backwards compatibility with TimeZone.\n        map = new HashMap<String, String>();\n        map.put(\"GMT\", \"UTC\");\n        map.put(\"MIT\", \"Pacific/Apia\");\n        // JDK 1.1 compatible\n        map.put(\"HST\", \"Pacific/Honolulu\");\n        map.put(\"AST\", \"America/Anchorage\");\n        map.put(\"PST\", \"America/Los_Angeles\");\n        // JDK 1.1 compatible\n        map.put(\"MST\", \"America/Denver\");\n        map.put(\"PNT\", \"America/Phoenix\");\n        map.put(\"CST\", \"America/Chicago\");\n        // JDK 1.1 compatible\n        map.put(\"EST\", \"America/New_York\");\n        map.put(\"IET\", \"America/Indianapolis\");\n        map.put(\"PRT\", \"America/Puerto_Rico\");\n        map.put(\"CNT\", \"America/St_Johns\");\n        map.put(\"AGT\", \"America/Buenos_Aires\");\n        map.put(\"BET\", \"America/Sao_Paulo\");\n        map.put(\"WET\", \"Europe/London\");\n        map.put(\"ECT\", \"Europe/Paris\");\n        map.put(\"ART\", \"Africa/Cairo\");\n        map.put(\"CAT\", \"Africa/Harare\");\n        map.put(\"EET\", \"Europe/Bucharest\");\n        map.put(\"EAT\", \"Africa/Addis_Ababa\");\n        map.put(\"MET\", \"Asia/Tehran\");\n        map.put(\"NET\", \"Asia/Yerevan\");\n        map.put(\"PLT\", \"Asia/Karachi\");\n        map.put(\"IST\", \"Asia/Calcutta\");\n        map.put(\"BST\", \"Asia/Dhaka\");\n        map.put(\"VST\", \"Asia/Saigon\");\n        map.put(\"CTT\", \"Asia/Shanghai\");\n        map.put(\"JST\", \"Asia/Tokyo\");\n        map.put(\"ACT\", \"Australia/Darwin\");\n        map.put(\"AET\", \"Australia/Sydney\");\n        map.put(\"SST\", \"Pacific/Guadalcanal\");\n        map.put(\"NST\", \"Pacific/Auckland\");\n        cZoneIdConversion = map;\n    }\n    return map.get(id);\n}", "code_comment": "/**\n * Converts an old style id to a new style id.\n *\n * @param id  the old style id\n * @return the new style id, null if not found\n */\n", "code_no_comment": "private static synchronized String getConvertedId(String id) {\n    Map<String, String> map = cZoneIdConversion;\n    if (map == null) {\n                map = new HashMap<String, String>();\n        map.put(\"GMT\", \"UTC\");\n        map.put(\"MIT\", \"Pacific/Apia\");\n                map.put(\"HST\", \"Pacific/Honolulu\");\n        map.put(\"AST\", \"America/Anchorage\");\n        map.put(\"PST\", \"America/Los_Angeles\");\n                map.put(\"MST\", \"America/Denver\");\n        map.put(\"PNT\", \"America/Phoenix\");\n        map.put(\"CST\", \"America/Chicago\");\n                map.put(\"EST\", \"America/New_York\");\n        map.put(\"IET\", \"America/Indianapolis\");\n        map.put(\"PRT\", \"America/Puerto_Rico\");\n        map.put(\"CNT\", \"America/St_Johns\");\n        map.put(\"AGT\", \"America/Buenos_Aires\");\n        map.put(\"BET\", \"America/Sao_Paulo\");\n        map.put(\"WET\", \"Europe/London\");\n        map.put(\"ECT\", \"Europe/Paris\");\n        map.put(\"ART\", \"Africa/Cairo\");\n        map.put(\"CAT\", \"Africa/Harare\");\n        map.put(\"EET\", \"Europe/Bucharest\");\n        map.put(\"EAT\", \"Africa/Addis_Ababa\");\n        map.put(\"MET\", \"Asia/Tehran\");\n        map.put(\"NET\", \"Asia/Yerevan\");\n        map.put(\"PLT\", \"Asia/Karachi\");\n        map.put(\"IST\", \"Asia/Calcutta\");\n        map.put(\"BST\", \"Asia/Dhaka\");\n        map.put(\"VST\", \"Asia/Saigon\");\n        map.put(\"CTT\", \"Asia/Shanghai\");\n        map.put(\"JST\", \"Asia/Tokyo\");\n        map.put(\"ACT\", \"Australia/Darwin\");\n        map.put(\"AET\", \"Australia/Sydney\");\n        map.put(\"SST\", \"Pacific/Guadalcanal\");\n        map.put(\"NST\", \"Pacific/Auckland\");\n        cZoneIdConversion = map;\n    }\n    return map.get(id);\n}", "lc": 1.1818181818181819, "pi": -0.5, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": 0.012852199703410812, "mi": -0.7235445942070551, "fo": 2.25, "r": -0.028571428571428574, "e": 0.6516204744711561}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-2174_778f044e", "label": 1, "code": "public List<ModelProperty> getModelProperties() throws IOException {\n    if (modelProperties == null) {\n        Set<String> s = new HashSet<String>();\n        // TODO: Should add all collections from ProjectUri\n        s.addAll(PomTransformer.URIS);\n        s.add(ProjectUri.Build.PluginManagement.Plugins.Plugin.Executions.xUri);\n        s.add(ProjectUri.DependencyManagement.Dependencies.Dependency.Exclusions.xUri);\n        s.add(ProjectUri.Dependencies.Dependency.Exclusions.xUri);\n        s.add(ProjectUri.Build.Plugins.Plugin.Executions.xUri);\n        s.add(ProjectUri.Build.Plugins.Plugin.Executions.Execution.Goals.xURI);\n        s.add(ProjectUri.Reporting.Plugins.Plugin.ReportSets.xUri);\n        s.add(ProjectUri.Reporting.Plugins.Plugin.ReportSets.ReportSet.configuration);\n        s.add(ProjectUri.Build.Plugins.Plugin.Executions.Execution.configuration);\n        modelProperties = ModelMarshaller.marshallXmlToModelProperties(getInputStream(), ProjectUri.baseUri, s);\n    }\n    return new ArrayList<ModelProperty>(modelProperties);\n}", "code_comment": NaN, "code_no_comment": "public List<ModelProperty> getModelProperties() throws IOException {\n    if (modelProperties == null) {\n        Set<String> s = new HashSet<String>();\n                s.addAll(PomTransformer.URIS);\n        s.add(ProjectUri.Build.PluginManagement.Plugins.Plugin.Executions.xUri);\n        s.add(ProjectUri.DependencyManagement.Dependencies.Dependency.Exclusions.xUri);\n        s.add(ProjectUri.Dependencies.Dependency.Exclusions.xUri);\n        s.add(ProjectUri.Build.Plugins.Plugin.Executions.xUri);\n        s.add(ProjectUri.Build.Plugins.Plugin.Executions.Execution.Goals.xURI);\n        s.add(ProjectUri.Reporting.Plugins.Plugin.ReportSets.xUri);\n        s.add(ProjectUri.Reporting.Plugins.Plugin.ReportSets.ReportSet.configuration);\n        s.add(ProjectUri.Build.Plugins.Plugin.Executions.Execution.configuration);\n        modelProperties = ModelMarshaller.marshallXmlToModelProperties(getInputStream(), ProjectUri.baseUri, s);\n    }\n    return new ArrayList<ModelProperty>(modelProperties);\n}", "lc": 0.09090909090909091, "pi": -0.10204081632653071, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": 0.10776075135936737, "mi": -0.20562087754516786, "fo": 0.4166666666666667, "r": -0.028571428571428574, "e": 0.382703517630985}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-621_00b4b8a0", "label": 1, "code": "private PropertyState internalGetProperty(String propertyName) {\n    return getNodeBuilder().getProperty(propertyName);\n}", "code_comment": NaN, "code_no_comment": "private PropertyState internalGetProperty(String propertyName) {\n    return getNodeBuilder().getProperty(propertyName);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.046171494121021, "fo": -0.3333333333333333, "r": 1.8571428571428574, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-7456_02da984a", "label": 3, "code": "public void setPropertyPrefix(String propertyPrefix) {\n    this.propertyPrefix = propertyPrefix;\n}", "code_comment": NaN, "code_no_comment": "public void setPropertyPrefix(String propertyPrefix) {\n    this.propertyPrefix = propertyPrefix;\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.0943504445081733, "fo": -0.5, "r": 1.2857142857142858, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 102, "label": 2, "code": "@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    removeDuplicateDeclarations(root);\n    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    removeDuplicateDeclarations(root);\n    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "lc": -0.13636363636363635, "pi": -0.035714285714285636, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.3333333333333333, "d": -0.3806228373702422, "mi": 0.16117006022368816, "fo": -0.16666666666666666, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1094_2e20589f", "label": 1, "code": "synchronized void refresh(K key, int hash, CacheLoader<K, V> loader) throws ExecutionException {\n    V value;\n    V old = get(key, hash);\n    long start = System.nanoTime();\n    try {\n        ListenableFuture<V> future = loader.reload(key, old);\n        value = future.get();\n        loadSuccessCount++;\n    } catch (Exception e) {\n        loadExceptionCount++;\n        throw new ExecutionException(e);\n    } finally {\n        long time = System.nanoTime() - start;\n        totalLoadTime += time;\n    }\n    put(key, hash, value, cache.sizeOf(key, value));\n}", "code_comment": NaN, "code_no_comment": "synchronized void refresh(K key, int hash, CacheLoader<K, V> loader) throws ExecutionException {\n    V value;\n    V old = get(key, hash);\n    long start = System.nanoTime();\n    try {\n        ListenableFuture<V> future = loader.reload(key, old);\n        value = future.get();\n        loadSuccessCount++;\n    } catch (Exception e) {\n        loadExceptionCount++;\n        throw new ExecutionException(e);\n    } finally {\n        long time = System.nanoTime() - start;\n        totalLoadTime += time;\n    }\n    put(key, hash, value, cache.sizeOf(key, value));\n}", "lc": 0.13636363636363635, "pi": -0.18367346938775503, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.4166666666666667, "d": 0.3509639149777559, "mi": -0.15543447089188422, "fo": 0.08333333333333333, "r": 0.0, "e": 0.29944192461056784}
{"project_name": "Closure", "project_version": 148, "label": 2, "code": "/**\n * Appends the source map in LavaBug format to the given buffer.\n *\n * @param out The stream to which the map will be appended.\n * @param name The name of the generated source file that this source map\n *   represents.\n */\npublic void appendTo(Appendable out, String name) throws IOException {\n    // Write the mappings out to the file. The format of the generated\n    // source map is three sections, each deliminated by a magic comment.\n    // \n    // The first section contains an array for each line of the generated\n    // code, where each element in the array is the ID of the mapping which\n    // best represents the index-th character found on that line of the\n    // generated source code.\n    // \n    // The second section contains an array per generated line. Unused.\n    // \n    // The third and final section contains an array per line, each of which\n    // represents a mapping with a unique ID. The mappings are added in order.\n    // The array itself contains a tuple representing\n    // ['source file', line, col (, 'original name')]\n    // \n    // Example for 2 lines of generated code (with line numbers added for\n    // readability):\n    // \n    // 1)  /** Begin line maps. **/{ \"count\": 2 }\n    // 2)  [0,0,0,0,0,0,1,1,1,1,2]\n    // 3)  [2,2,2,2,2,2,3,4,4,4,4,4]\n    // 4)  /** Begin file information. **/\n    // 5)  []\n    // 6)  []\n    // 7)  /** Begin mapping definitions. **/\n    // 8)  [\"a.js\", 1, 34]\n    // 9)  [\"a.js\", 5, 2]\n    // 10) [\"b.js\", 1, 3, \"event\"]\n    // 11) [\"c.js\", 1, 4]\n    // 12) [\"d.js\", 3, 78, \"foo\"]\n    int maxLine = findLastLine();\n    // Add the line character maps.\n    out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \");\n    out.append(escapeString(name));\n    out.append(\", \\\"count\\\": \");\n    out.append(String.valueOf(maxLine + 1));\n    out.append(\" }\\n\");\n    (new LineMapper(out)).appendLineMappings();\n    // Add the source file maps.\n    out.append(\"/** Begin file information. **/\\n\");\n    // prevent changing the format.\n    for (int i = 0; i <= maxLine; ++i) {\n        out.append(\"[]\\n\");\n    }\n    // Add the mappings themselves.\n    out.append(\"/** Begin mapping definitions. **/\\n\");\n    for (Mapping mapping : mappings) {\n        mapping.appendTo(out);\n        out.append(\"\\n\");\n    }\n}", "code_comment": "/**\n * Appends the source map in LavaBug format to the given buffer.\n *\n * @param out The stream to which the map will be appended.\n * @param name The name of the generated source file that this source map\n *   represents.\n */\n", "code_no_comment": "public void appendTo(Appendable out, String name) throws IOException {\n                                                                                                                            int maxLine = findLastLine();\n        out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \");\n    out.append(escapeString(name));\n    out.append(\", \\\"count\\\": \");\n    out.append(String.valueOf(maxLine + 1));\n    out.append(\" }\\n\");\n    (new LineMapper(out)).appendLineMappings();\n        out.append(\"/** Begin file information. **/\\n\");\n        for (int i = 0; i <= maxLine; ++i) {\n        out.append(\"[]\\n\");\n    }\n        out.append(\"/** Begin mapping definitions. **/\\n\");\n    for (Mapping mapping : mappings) {\n        mapping.appendTo(out);\n        out.append(\"\\n\");\n    }\n}", "lc": 0.18181818181818182, "pi": -0.4693877551020408, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.16666666666666666, "d": 0.41028175976272874, "mi": -0.1821049612847723, "fo": 0.6666666666666666, "r": -0.028571428571428574, "e": 0.33653702014296666}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-434_133cbc2d", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic RealPointValuePair doOptimize() throws OptimizationException {\n    final SimplexTableau tableau = new SimplexTableau(function, linearConstraints, goal, nonNegative, epsilon);\n    solvePhase1(tableau);\n    tableau.dropPhase1Objective();\n    while (!tableau.isOptimal()) {\n        doIteration(tableau);\n    }\n    return tableau.getSolution();\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic RealPointValuePair doOptimize() throws OptimizationException {\n    final SimplexTableau tableau = new SimplexTableau(function, linearConstraints, goal, nonNegative, epsilon);\n    solvePhase1(tableau);\n    tableau.dropPhase1Objective();\n    while (!tableau.isOptimal()) {\n        doIteration(tableau);\n    }\n    return tableau.getSolution();\n}", "lc": -0.18181818181818182, "pi": -0.31632653061224497, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.11369253583786453, "mi": 0.2486377975336967, "fo": -0.08333333333333333, "r": 0.2285714285714286, "e": -0.1026892980585144}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5570_a57830ed", "label": 3, "code": "/**\n * Allows an exception handler to create a new redelivery policy for this exception type\n *\n * @param context      the camel context\n * @param parentPolicy the current redelivery policy, is newer <tt>null</tt>\n * @return a newly created redelivery policy, or return the original policy if no customization is required\n *         for this exception handler.\n */\npublic RedeliveryPolicy createRedeliveryPolicy(CamelContext context, RedeliveryPolicy parentPolicy) {\n    if (redeliveryPolicyRef != null) {\n        return CamelContextHelper.mandatoryLookup(context, redeliveryPolicyRef, RedeliveryPolicy.class);\n    } else if (redeliveryPolicy != null) {\n        return redeliveryPolicy.createRedeliveryPolicy(context, parentPolicy);\n    } else if (!outputs.isEmpty() && parentPolicy.getMaximumRedeliveries() > 0) {\n        // if we have outputs, then do not inherit parent maximumRedeliveries\n        // as you would have to explicit configure maximumRedeliveries on this onException to use it\n        // this is the behavior Camel has always had\n        RedeliveryPolicy answer = parentPolicy.copy();\n        answer.setMaximumRedeliveries(0);\n        return answer;\n    } else {\n        return parentPolicy;\n    }\n}", "code_comment": "/**\n * Allows an exception handler to create a new redelivery policy for this exception type\n *\n * @param context      the camel context\n * @param parentPolicy the current redelivery policy, is newer <tt>null</tt>\n * @return a newly created redelivery policy, or return the original policy if no customization is required\n *         for this exception handler.\n */\n", "code_no_comment": "public RedeliveryPolicy createRedeliveryPolicy(CamelContext context, RedeliveryPolicy parentPolicy) {\n    if (redeliveryPolicyRef != null) {\n        return CamelContextHelper.mandatoryLookup(context, redeliveryPolicyRef, RedeliveryPolicy.class);\n    } else if (redeliveryPolicy != null) {\n        return redeliveryPolicy.createRedeliveryPolicy(context, parentPolicy);\n    } else if (!outputs.isEmpty() && parentPolicy.getMaximumRedeliveries() > 0) {\n                                RedeliveryPolicy answer = parentPolicy.copy();\n        answer.setMaximumRedeliveries(0);\n        return answer;\n    } else {\n        return parentPolicy;\n    }\n}", "lc": -0.045454545454545456, "pi": -0.06632653061224485, "ma": 0.0, "nbd": 0.5, "ml": 0.25, "d": 0.3667820069204153, "mi": 0.03412675652423281, "fo": 0.0, "r": -0.028571428571428574, "e": 0.12854150873090314}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3011_5a86a0a1", "label": 0, "code": "public void restart() {\n    try {\n        synchronized (progressLock) {\n            if (state != JobStatus.RESTARTING) {\n                throw new IllegalStateException(\"Can only restart job from state restarting.\");\n            }\n            if (scheduler == null) {\n                throw new IllegalStateException(\"The execution graph has not been scheduled before - scheduler is null.\");\n            }\n            this.currentExecutions.clear();\n            for (ExecutionJobVertex jv : this.verticesInCreationOrder) {\n                jv.resetForNewExecution();\n            }\n            for (int i = 0; i < stateTimestamps.length; i++) {\n                stateTimestamps[i] = 0;\n            }\n            numFinishedJobVertices = 0;\n            transitionState(JobStatus.RESTARTING, JobStatus.CREATED);\n            // if we have checkpointed state, reload it into the executions\n            if (checkpointCoordinator != null) {\n                checkpointCoordinator.restoreLatestCheckpointedState(getAllVertices(), false, false);\n            }\n        }\n        scheduleForExecution(scheduler);\n    } catch (Throwable t) {\n        fail(t);\n    }\n}", "code_comment": NaN, "code_no_comment": "public void restart() {\n    try {\n        synchronized (progressLock) {\n            if (state != JobStatus.RESTARTING) {\n                throw new IllegalStateException(\"Can only restart job from state restarting.\");\n            }\n            if (scheduler == null) {\n                throw new IllegalStateException(\"The execution graph has not been scheduled before - scheduler is null.\");\n            }\n            this.currentExecutions.clear();\n            for (ExecutionJobVertex jv : this.verticesInCreationOrder) {\n                jv.resetForNewExecution();\n            }\n            for (int i = 0; i < stateTimestamps.length; i++) {\n                stateTimestamps[i] = 0;\n            }\n            numFinishedJobVertices = 0;\n            transitionState(JobStatus.RESTARTING, JobStatus.CREATED);\n                        if (checkpointCoordinator != null) {\n                checkpointCoordinator.restoreLatestCheckpointedState(getAllVertices(), false, false);\n            }\n        }\n        scheduleForExecution(scheduler);\n    } catch (Throwable t) {\n        fail(t);\n    }\n}", "lc": 0.5909090909090909, "pi": 0.7653061224489793, "ma": 0.8333333333333334, "nbd": 0.5, "ml": 0.3333333333333333, "d": 0.21255561047948598, "mi": -0.4098078577573849, "fo": 0.08333333333333333, "r": 0.0, "e": 0.21061670971085444}
{"project_name": "Compress", "project_version": 29, "label": 1, "code": "/**\n * Create an archive input stream from an input stream, autodetecting\n * the archive type from the first few bytes of the stream. The InputStream\n * must support marks, like BufferedInputStream.\n *\n * @param in the input stream\n * @return the archive input stream\n * @throws ArchiveException if the archiver name is not known\n * @throws StreamingNotSupportedException if the format cannot be\n * read from a stream\n * @throws IllegalArgumentException if the stream is null or does not support mark\n */\npublic ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, encoding);\n                }\n            } catch (Exception e) {\n            // NOPMD\n            // can generate IllegalArgumentException as well\n            // as IOException\n            // autodetection, simply not a TAR\n            // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}", "code_comment": "/**\n * Create an archive input stream from an input stream, autodetecting\n * the archive type from the first few bytes of the stream. The InputStream\n * must support marks, like BufferedInputStream.\n *\n * @param in the input stream\n * @return the archive input stream\n * @throws ArchiveException if the archiver name is not known\n * @throws StreamingNotSupportedException if the format cannot be\n * read from a stream\n * @throws IllegalArgumentException if the stream is null or does not support mark\n */\n", "code_no_comment": "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n                final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n                final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n                if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, encoding);\n                }\n            } catch (Exception e) {\n                                                                        } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}", "lc": 2.4545454545454546, "pi": 0.5969387755102042, "ma": 3.1666666666666665, "nbd": 2.5, "ml": 2.1666666666666665, "d": 0.865051903114187, "mi": -1.099512474906797, "fo": 1.25, "r": -0.028571428571428574, "e": 2.2710841567408058}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-843_65390f8c", "label": 3, "code": "@Override\npublic void flush(String tableName, Text start, Text end, boolean wait) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n    throw new NotImplementedException();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void flush(String tableName, Text start, Text end, boolean wait) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n    throw new NotImplementedException();\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.3333333333333333, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7811872669916835, "fo": -0.5, "r": 0.0, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1076_9238264d", "label": 3, "code": "private PropertyValue currentOakProperty(String oakPropertyName, Integer propertyType) {\n    boolean asterisk = oakPropertyName.indexOf('*') >= 0;\n    if (asterisk) {\n        Tree t = currentTree();\n        ArrayList<PropertyValue> list = new ArrayList<PropertyValue>();\n        readOakProperties(list, t, oakPropertyName, propertyType);\n        if (list.size() == 0) {\n            return null;\n        }\n        ArrayList<String> strings = new ArrayList<String>();\n        for (PropertyValue p : list) {\n            Iterables.addAll(strings, p.getValue(Type.STRINGS));\n        }\n        return PropertyValues.newString(strings);\n    }\n    boolean relative = oakPropertyName.indexOf('/') >= 0;\n    Tree t = currentTree();\n    if (relative) {\n        for (String p : PathUtils.elements(PathUtils.getParentPath(oakPropertyName))) {\n            if (t == null) {\n                return null;\n            }\n            if (p.equals(\"..\")) {\n                t = t.isRoot() ? null : t.getParent();\n            } else if (p.equals(\".\")) {\n            // same node\n            } else {\n                t = t.getChild(p);\n            }\n        }\n        oakPropertyName = PathUtils.getName(oakPropertyName);\n    }\n    return currentOakProperty(t, oakPropertyName, propertyType);\n}", "code_comment": NaN, "code_no_comment": "private PropertyValue currentOakProperty(String oakPropertyName, Integer propertyType) {\n    boolean asterisk = oakPropertyName.indexOf('*') >= 0;\n    if (asterisk) {\n        Tree t = currentTree();\n        ArrayList<PropertyValue> list = new ArrayList<PropertyValue>();\n        readOakProperties(list, t, oakPropertyName, propertyType);\n        if (list.size() == 0) {\n            return null;\n        }\n        ArrayList<String> strings = new ArrayList<String>();\n        for (PropertyValue p : list) {\n            Iterables.addAll(strings, p.getValue(Type.STRINGS));\n        }\n        return PropertyValues.newString(strings);\n    }\n    boolean relative = oakPropertyName.indexOf('/') >= 0;\n    Tree t = currentTree();\n    if (relative) {\n        for (String p : PathUtils.elements(PathUtils.getParentPath(oakPropertyName))) {\n            if (t == null) {\n                return null;\n            }\n            if (p.equals(\"..\")) {\n                t = t.isRoot() ? null : t.getParent();\n            } else if (p.equals(\".\")) {\n                        } else {\n                t = t.getChild(p);\n            }\n        }\n        oakPropertyName = PathUtils.getName(oakPropertyName);\n    }\n    return currentOakProperty(t, oakPropertyName, propertyType);\n}", "lc": 0.8636363636363636, "pi": 0.586734693877551, "ma": 1.0, "nbd": 1.0, "ml": 0.75, "d": 0.06821552150271878, "mi": -0.6079724691712076, "fo": 1.0, "r": -0.028571428571428574, "e": 0.3856459412114904}
{"project_name": "Closure", "project_version": 80, "label": 1, "code": "/**\n * @param locals A predicate to apply to unknown local values.\n * @return Whether the node is known to be a value that is not a reference\n *     outside the expression scope.\n */\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch(value.getType()) {\n        case Token.ASSIGN:\n            // value is immutable.\n            return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals));\n        case Token.COMMA:\n            return evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.AND:\n        case Token.OR:\n            return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.HOOK:\n            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.INC:\n        case Token.DEC:\n            if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n                return evaluatesToLocalValue(value.getFirstChild(), locals);\n            } else {\n                return true;\n            }\n        case Token.THIS:\n            return locals.apply(value);\n        case Token.NAME:\n            return isImmutableValue(value) || locals.apply(value);\n        case Token.GETELEM:\n        case Token.GETPROP:\n            // There is no information about the locality of object properties.\n            return locals.apply(value);\n        case Token.CALL:\n            return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value);\n        case Token.NEW:\n            return newHasLocalResult(value) || locals.apply(value);\n        case Token.FUNCTION:\n        case Token.REGEXP:\n        case Token.ARRAYLIT:\n        case Token.OBJECTLIT:\n            // Literals objects with non-literal children are allowed.\n            return true;\n        case Token.IN:\n            // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n            return true;\n        default:\n            // x -= g (x is now an local number)\n            if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) {\n                return true;\n            }\n            throw new IllegalStateException(\"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent());\n    }\n}", "code_comment": "/**\n * @param locals A predicate to apply to unknown local values.\n * @return Whether the node is known to be a value that is not a reference\n *     outside the expression scope.\n */\n", "code_no_comment": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch(value.getType()) {\n        case Token.ASSIGN:\n                        return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals));\n        case Token.COMMA:\n            return evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.AND:\n        case Token.OR:\n            return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.HOOK:\n            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.INC:\n        case Token.DEC:\n            if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n                return evaluatesToLocalValue(value.getFirstChild(), locals);\n            } else {\n                return true;\n            }\n        case Token.THIS:\n            return locals.apply(value);\n        case Token.NAME:\n            return isImmutableValue(value) || locals.apply(value);\n        case Token.GETELEM:\n        case Token.GETPROP:\n                        return locals.apply(value);\n        case Token.CALL:\n            return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value);\n        case Token.NEW:\n            return newHasLocalResult(value) || locals.apply(value);\n        case Token.FUNCTION:\n        case Token.REGEXP:\n        case Token.ARRAYLIT:\n        case Token.OBJECTLIT:\n                        return true;\n        case Token.IN:\n                        return true;\n        default:\n                        if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) {\n                return true;\n            }\n            throw new IllegalStateException(\"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent());\n    }\n}", "lc": 1.3181818181818181, "pi": 0.22959183673469397, "ma": 3.1666666666666665, "nbd": 0.5, "ml": 1.9166666666666667, "d": 0.17696490360850226, "mi": -0.8568970461714942, "fo": 2.25, "r": -0.028571428571428574, "e": 0.7274767539971133}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8081_2e985f9b", "label": 1, "code": "private void aggregateOnTheFly() throws InterruptedException, ExecutionException {\n    boolean timedOut = false;\n    boolean stoppedOnException = false;\n    final StopWatch watch = new StopWatch();\n    int aggregated = 0;\n    boolean done = false;\n    // not a for loop as on the fly may still run\n    while (!done) {\n        // check if we have already aggregate everything\n        if (allTasksSubmitted.get() && aggregated >= total.get()) {\n            LOG.debug(\"Done aggregating {} exchanges on the fly.\", aggregated);\n            break;\n        }\n        Future<Exchange> future;\n        if (timedOut) {\n            // we are timed out but try to grab if some tasks has been completed\n            // poll will return null if no tasks is present\n            future = completion.poll();\n            LOG.trace(\"Polled completion task #{} after timeout to grab already completed tasks: {}\", aggregated, future);\n        } else if (timeout > 0) {\n            long left = timeout - watch.taken();\n            if (left < 0) {\n                left = 0;\n            }\n            LOG.trace(\"Polling completion task #{} using timeout {} millis.\", aggregated, left);\n            future = completion.poll(left, TimeUnit.MILLISECONDS);\n        } else {\n            LOG.trace(\"Polling completion task #{}\", aggregated);\n            // we must not block so poll every second\n            future = completion.poll(1, TimeUnit.SECONDS);\n            if (future == null) {\n                // and continue loop which will recheck if we are done\n                continue;\n            }\n        }\n        if (future == null && timedOut) {\n            // we are timed out and no more tasks complete so break out\n            break;\n        } else if (future == null) {\n            // timeout occurred\n            AggregationStrategy strategy = getAggregationStrategy(null);\n            if (strategy instanceof TimeoutAwareAggregationStrategy) {\n                // notify the strategy we timed out\n                Exchange oldExchange = result.get();\n                if (oldExchange == null) {\n                    // if they all timed out the result may not have been set yet, so use the original exchange\n                    oldExchange = original;\n                }\n                ((TimeoutAwareAggregationStrategy) strategy).timeout(oldExchange, aggregated, total.intValue(), timeout);\n            } else {\n                // log a WARN we timed out since it will not be aggregated and the Exchange will be lost\n                LOG.warn(\"Parallel processing timed out after {} millis for number {}. This task will be cancelled and will not be aggregated.\", timeout, aggregated);\n            }\n            LOG.debug(\"Timeout occurred after {} millis for number {} task.\", timeout, aggregated);\n            timedOut = true;\n            // any already completed tasks in the next loop\n            if (completion instanceof SubmitOrderedCompletionService) {\n                ((SubmitOrderedCompletionService<?>) completion).timeoutTask();\n            }\n        } else {\n            // there is a result to aggregate\n            Exchange subExchange = future.get();\n            // Decide whether to continue with the multicast or not; similar logic to the Pipeline\n            Integer number = getExchangeIndex(subExchange);\n            boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Parallel processing failed for number \" + number, LOG);\n            if (stopOnException && !continueProcessing) {\n                // we want to stop on exception and an exception or failure occurred\n                // this is similar to what the pipeline does, so we should do the same to not surprise end users\n                // so we should set the failed exchange as the result and break out\n                result.set(subExchange);\n                stoppedOnException = true;\n                break;\n            }\n            // we got a result so aggregate it\n            AggregationStrategy strategy = getAggregationStrategy(subExchange);\n            doAggregate(strategy, result, subExchange);\n        }\n        aggregated++;\n    }\n    if (timedOut || stoppedOnException) {\n        if (timedOut) {\n            LOG.debug(\"Cancelling tasks due timeout after {} millis.\", timeout);\n        }\n        if (stoppedOnException) {\n            LOG.debug(\"Cancelling tasks due stopOnException.\");\n        }\n        // cancel tasks as we timed out (its safe to cancel done tasks)\n        running.set(false);\n    }\n}", "code_comment": NaN, "code_no_comment": "private void aggregateOnTheFly() throws InterruptedException, ExecutionException {\n    boolean timedOut = false;\n    boolean stoppedOnException = false;\n    final StopWatch watch = new StopWatch();\n    int aggregated = 0;\n    boolean done = false;\n        while (!done) {\n                if (allTasksSubmitted.get() && aggregated >= total.get()) {\n            LOG.debug(\"Done aggregating {} exchanges on the fly.\", aggregated);\n            break;\n        }\n        Future<Exchange> future;\n        if (timedOut) {\n                                    future = completion.poll();\n            LOG.trace(\"Polled completion task #{} after timeout to grab already completed tasks: {}\", aggregated, future);\n        } else if (timeout > 0) {\n            long left = timeout - watch.taken();\n            if (left < 0) {\n                left = 0;\n            }\n            LOG.trace(\"Polling completion task #{} using timeout {} millis.\", aggregated, left);\n            future = completion.poll(left, TimeUnit.MILLISECONDS);\n        } else {\n            LOG.trace(\"Polling completion task #{}\", aggregated);\n                        future = completion.poll(1, TimeUnit.SECONDS);\n            if (future == null) {\n                                continue;\n            }\n        }\n        if (future == null && timedOut) {\n                        break;\n        } else if (future == null) {\n                        AggregationStrategy strategy = getAggregationStrategy(null);\n            if (strategy instanceof TimeoutAwareAggregationStrategy) {\n                                Exchange oldExchange = result.get();\n                if (oldExchange == null) {\n                                        oldExchange = original;\n                }\n                ((TimeoutAwareAggregationStrategy) strategy).timeout(oldExchange, aggregated, total.intValue(), timeout);\n            } else {\n                                LOG.warn(\"Parallel processing timed out after {} millis for number {}. This task will be cancelled and will not be aggregated.\", timeout, aggregated);\n            }\n            LOG.debug(\"Timeout occurred after {} millis for number {} task.\", timeout, aggregated);\n            timedOut = true;\n                        if (completion instanceof SubmitOrderedCompletionService) {\n                ((SubmitOrderedCompletionService<?>) completion).timeoutTask();\n            }\n        } else {\n                        Exchange subExchange = future.get();\n                        Integer number = getExchangeIndex(subExchange);\n            boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Parallel processing failed for number \" + number, LOG);\n            if (stopOnException && !continueProcessing) {\n                                                                result.set(subExchange);\n                stoppedOnException = true;\n                break;\n            }\n                        AggregationStrategy strategy = getAggregationStrategy(subExchange);\n            doAggregate(strategy, result, subExchange);\n        }\n        aggregated++;\n    }\n    if (timedOut || stoppedOnException) {\n        if (timedOut) {\n            LOG.debug(\"Cancelling tasks due timeout after {} millis.\", timeout);\n        }\n        if (stoppedOnException) {\n            LOG.debug(\"Cancelling tasks due stopOnException.\");\n        }\n                running.set(false);\n    }\n}", "lc": 2.590909090909091, "pi": 0.556122448979592, "ma": 2.6666666666666665, "nbd": 1.5, "ml": 2.3333333333333335, "d": 2.1542263964409294, "mi": -1.142529394895326, "fo": 1.6666666666666667, "r": -0.028571428571428574, "e": 6.430608914644019}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6936_4954d573", "label": 1, "code": "/**\n * Strategy for validating if the given remote file should be included or not\n *\n * @param file        the file\n * @param isDirectory whether the file is a directory or a file\n * @param files       files in the directory\n * @return <tt>true</tt> to include the file, <tt>false</tt> to skip it\n */\nprotected boolean isValidFile(GenericFile<T> file, boolean isDirectory, List<T> files) {\n    if (!isMatched(file, isDirectory, files)) {\n        log.trace(\"File did not match. Will skip this file: {}\", file);\n        return false;\n    }\n    // if its a file then check if its already in progress\n    if (!isDirectory && isInProgress(file)) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Skipping as file is already in progress: {}\", file.getFileName());\n        }\n        return false;\n    }\n    // if its a file then check we have the file in the idempotent registry already\n    if (!isDirectory && endpoint.isIdempotent()) {\n        // use absolute file path as default key, but evaluate if an expression key was configured\n        String key = file.getAbsoluteFilePath();\n        if (endpoint.getIdempotentKey() != null) {\n            Exchange dummy = endpoint.createExchange(file);\n            key = endpoint.getIdempotentKey().evaluate(dummy, String.class);\n        }\n        if (key != null && endpoint.getIdempotentRepository().contains(key)) {\n            log.trace(\"This consumer is idempotent and the file has been consumed before. Will skip this file: {}\", file);\n            return false;\n        }\n    }\n    // file matched\n    return true;\n}", "code_comment": "/**\n * Strategy for validating if the given remote file should be included or not\n *\n * @param file        the file\n * @param isDirectory whether the file is a directory or a file\n * @param files       files in the directory\n * @return <tt>true</tt> to include the file, <tt>false</tt> to skip it\n */\n", "code_no_comment": "protected boolean isValidFile(GenericFile<T> file, boolean isDirectory, List<T> files) {\n    if (!isMatched(file, isDirectory, files)) {\n        log.trace(\"File did not match. Will skip this file: {}\", file);\n        return false;\n    }\n        if (!isDirectory && isInProgress(file)) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Skipping as file is already in progress: {}\", file.getFileName());\n        }\n        return false;\n    }\n        if (!isDirectory && endpoint.isIdempotent()) {\n                String key = file.getAbsoluteFilePath();\n        if (endpoint.getIdempotentKey() != null) {\n            Exchange dummy = endpoint.createExchange(file);\n            key = endpoint.getIdempotentKey().evaluate(dummy, String.class);\n        }\n        if (key != null && endpoint.getIdempotentRepository().contains(key)) {\n            log.trace(\"This consumer is idempotent and the file has been consumed before. Will skip this file: {}\", file);\n            return false;\n        }\n    }\n        return true;\n}", "lc": 0.45454545454545453, "pi": 0.2499999999999999, "ma": 0.5, "nbd": 0.0, "ml": 1.1666666666666667, "d": 0.38655462184873957, "mi": -0.380269572698595, "fo": 0.75, "r": -0.028571428571428574, "e": 0.46213610529336435}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5147_184e51e9", "label": 1, "code": "/**\n *  Servlets and Filters are treated essentially the same with Wicket. This is the entry point\n *  for both of them.\n *\n *  @see #init(FilterConfig)\n *\n *  @param isServlet\n *             True if Servlet, false if Filter\n *  @param filterConfig\n *  @throws ServletException\n */\npublic void init(final boolean isServlet, final FilterConfig filterConfig) throws ServletException {\n    this.filterConfig = filterConfig;\n    this.isServlet = isServlet;\n    initIgnorePaths(filterConfig);\n    final ClassLoader previousClassLoader = Thread.currentThread().getContextClassLoader();\n    final ClassLoader newClassLoader = getClassLoader();\n    try {\n        if (previousClassLoader != newClassLoader) {\n            Thread.currentThread().setContextClassLoader(newClassLoader);\n        }\n        // locate application instance unless it was already specified during construction\n        if (application == null) {\n            applicationFactory = getApplicationFactory();\n            application = applicationFactory.createApplication(this);\n        }\n        application.setName(filterConfig.getFilterName());\n        application.setWicketFilter(this);\n        // Allow the filterPath to be preset via setFilterPath()\n        String configureFilterPath = getFilterPath();\n        if (configureFilterPath == null) {\n            configureFilterPath = getFilterPathFromConfig(filterConfig);\n            if (configureFilterPath == null) {\n                configureFilterPath = getFilterPathFromWebXml(isServlet, filterConfig);\n                if (configureFilterPath == null) {\n                    configureFilterPath = getFilterPathFromAnnotation(isServlet);\n                }\n            }\n            if (configureFilterPath != null) {\n                setFilterPath(configureFilterPath);\n            }\n        }\n        if (getFilterPath() == null) {\n            log.warn(\"Unable to determine filter path from filter init-param, web.xml, \" + \"or servlet 3.0 annotations. Assuming user will set filter path \" + \"manually by calling setFilterPath(String)\");\n        }\n        ThreadContext.setApplication(application);\n        try {\n            application.initApplication();\n            // Give the application the option to log that it is started\n            application.logStarted();\n        } finally {\n            ThreadContext.detach();\n        }\n    } finally {\n        if (newClassLoader != previousClassLoader) {\n            Thread.currentThread().setContextClassLoader(previousClassLoader);\n        }\n    }\n}", "code_comment": "/**\n *  Servlets and Filters are treated essentially the same with Wicket. This is the entry point\n *  for both of them.\n *\n *  @see #init(FilterConfig)\n *\n *  @param isServlet\n *             True if Servlet, false if Filter\n *  @param filterConfig\n *  @throws ServletException\n */\n", "code_no_comment": "public void init(final boolean isServlet, final FilterConfig filterConfig) throws ServletException {\n    this.filterConfig = filterConfig;\n    this.isServlet = isServlet;\n    initIgnorePaths(filterConfig);\n    final ClassLoader previousClassLoader = Thread.currentThread().getContextClassLoader();\n    final ClassLoader newClassLoader = getClassLoader();\n    try {\n        if (previousClassLoader != newClassLoader) {\n            Thread.currentThread().setContextClassLoader(newClassLoader);\n        }\n                if (application == null) {\n            applicationFactory = getApplicationFactory();\n            application = applicationFactory.createApplication(this);\n        }\n        application.setName(filterConfig.getFilterName());\n        application.setWicketFilter(this);\n                String configureFilterPath = getFilterPath();\n        if (configureFilterPath == null) {\n            configureFilterPath = getFilterPathFromConfig(filterConfig);\n            if (configureFilterPath == null) {\n                configureFilterPath = getFilterPathFromWebXml(isServlet, filterConfig);\n                if (configureFilterPath == null) {\n                    configureFilterPath = getFilterPathFromAnnotation(isServlet);\n                }\n            }\n            if (configureFilterPath != null) {\n                setFilterPath(configureFilterPath);\n            }\n        }\n        if (getFilterPath() == null) {\n            log.warn(\"Unable to determine filter path from filter init-param, web.xml, \" + \"or servlet 3.0 annotations. Assuming user will set filter path \" + \"manually by calling setFilterPath(String)\");\n        }\n        ThreadContext.setApplication(application);\n        try {\n            application.initApplication();\n                        application.logStarted();\n        } finally {\n            ThreadContext.detach();\n        }\n    } finally {\n        if (newClassLoader != previousClassLoader) {\n            Thread.currentThread().setContextClassLoader(previousClassLoader);\n        }\n    }\n}", "lc": 1.4090909090909092, "pi": 0.6275510204081632, "ma": 0.8333333333333334, "nbd": 1.0, "ml": 0.6666666666666666, "d": 0.4498269896193773, "mi": -0.7447662747347291, "fo": 1.5, "r": -0.028571428571428574, "e": 0.8473109160916734}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-43_668f08f2", "label": 1, "code": "public void setProperties(String nodePath, Map<String, String> properties) throws Exception {\n    MutableNode node = getOrCreateStagedNode(nodePath);\n    node.getProperties().clear();\n    node.getProperties().putAll(properties);\n    // update change log\n    changeLog.add(new SetProperties(nodePath, properties));\n}", "code_comment": NaN, "code_no_comment": "public void setProperties(String nodePath, Map<String, String> properties) throws Exception {\n    MutableNode node = getOrCreateStagedNode(nodePath);\n    node.getProperties().clear();\n    node.getProperties().putAll(properties);\n        changeLog.add(new SetProperties(nodePath, properties));\n}", "lc": -0.36363636363636365, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.4924003441353601, "fo": 0.0, "r": 0.1142857142857143, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1822_016df669", "label": 1, "code": "/**\n * Apply the changes to the in-memory document.\n *\n * @param doc\n *            the target document.\n * @param update\n *            the changes to apply.\n * @param comparator\n *            the revision comparator.\n */\npublic static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update, @Nonnull Comparator<Revision> comparator) {\n    for (Entry<Key, Operation> e : checkNotNull(update).getChanges().entrySet()) {\n        Key k = e.getKey();\n        Operation op = e.getValue();\n        switch(op.type) {\n            case SET:\n                {\n                    doc.put(k.toString(), op.value);\n                    break;\n                }\n            case INCREMENT:\n                {\n                    Object old = doc.get(k.toString());\n                    Long x = (Long) op.value;\n                    if (old == null) {\n                        old = 0L;\n                    }\n                    doc.put(k.toString(), ((Long) old) + x);\n                    break;\n                }\n            case SET_MAP_ENTRY:\n                {\n                    Object old = doc.get(k.getName());\n                    @SuppressWarnings(\"unchecked\")\n                    Map<Revision, Object> m = (Map<Revision, Object>) old;\n                    if (m == null) {\n                        m = new TreeMap<Revision, Object>(comparator);\n                        doc.put(k.getName(), m);\n                    }\n                    if (k.getRevision() == null) {\n                        throw new IllegalArgumentException(\"Cannot set map entry \" + k.getName() + \" with null revision\");\n                    }\n                    m.put(k.getRevision(), op.value);\n                    break;\n                }\n            case REMOVE_MAP_ENTRY:\n                {\n                    Object old = doc.get(k.getName());\n                    @SuppressWarnings(\"unchecked\")\n                    Map<Revision, Object> m = (Map<Revision, Object>) old;\n                    if (m != null) {\n                        m.remove(k.getRevision());\n                    }\n                    break;\n                }\n            case CONTAINS_MAP_ENTRY:\n                // no effect\n                break;\n        }\n    }\n}", "code_comment": "/**\n * Apply the changes to the in-memory document.\n *\n * @param doc\n *            the target document.\n * @param update\n *            the changes to apply.\n * @param comparator\n *            the revision comparator.\n */\n", "code_no_comment": "public static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update, @Nonnull Comparator<Revision> comparator) {\n    for (Entry<Key, Operation> e : checkNotNull(update).getChanges().entrySet()) {\n        Key k = e.getKey();\n        Operation op = e.getValue();\n        switch(op.type) {\n            case SET:\n                {\n                    doc.put(k.toString(), op.value);\n                    break;\n                }\n            case INCREMENT:\n                {\n                    Object old = doc.get(k.toString());\n                    Long x = (Long) op.value;\n                    if (old == null) {\n                        old = 0L;\n                    }\n                    doc.put(k.toString(), ((Long) old) + x);\n                    break;\n                }\n            case SET_MAP_ENTRY:\n                {\n                    Object old = doc.get(k.getName());\n                    @SuppressWarnings(\"unchecked\")\n                    Map<Revision, Object> m = (Map<Revision, Object>) old;\n                    if (m == null) {\n                        m = new TreeMap<Revision, Object>(comparator);\n                        doc.put(k.getName(), m);\n                    }\n                    if (k.getRevision() == null) {\n                        throw new IllegalArgumentException(\"Cannot set map entry \" + k.getName() + \" with null revision\");\n                    }\n                    m.put(k.getRevision(), op.value);\n                    break;\n                }\n            case REMOVE_MAP_ENTRY:\n                {\n                    Object old = doc.get(k.getName());\n                    @SuppressWarnings(\"unchecked\")\n                    Map<Revision, Object> m = (Map<Revision, Object>) old;\n                    if (m != null) {\n                        m.remove(k.getRevision());\n                    }\n                    break;\n                }\n            case CONTAINS_MAP_ENTRY:\n                                break;\n        }\n    }\n}", "lc": 1.6363636363636365, "pi": 1.5306122448979589, "ma": 2.1666666666666665, "nbd": 1.0, "ml": 0.6666666666666666, "d": 0.6653484923381119, "mi": -0.9019214224261546, "fo": 1.4166666666666667, "r": -0.028571428571428574, "e": 1.683276155233188}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2368_fae1601b", "label": 1, "code": "public Object component(final Component component) {\n    // If component never rendered\n    if (renderedComponents == null || !renderedComponents.contains(component)) {\n        // If auto component ...\n        if (!component.isAuto() && component.isVisibleInHierarchy()) {\n            // Increase number of unrendered components\n            unrenderedComponents.add(component);\n            // Add to explanatory string to buffer\n            buffer.append(Integer.toString(unrenderedComponents.size()) + \". \" + component + \"\\n\");\n            String metadata = component.getMetaData(Component.CONSTRUCTED_AT_KEY);\n            if (metadata != null) {\n                buffer.append(metadata);\n            }\n            metadata = component.getMetaData(Component.ADDED_AT_KEY);\n            if (metadata != null) {\n                buffer.append(metadata);\n            }\n        } else {\n            // not visible\n            return CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;\n        }\n    }\n    return CONTINUE_TRAVERSAL;\n}", "code_comment": NaN, "code_no_comment": "public Object component(final Component component) {\n        if (renderedComponents == null || !renderedComponents.contains(component)) {\n                if (!component.isAuto() && component.isVisibleInHierarchy()) {\n                        unrenderedComponents.add(component);\n                        buffer.append(Integer.toString(unrenderedComponents.size()) + \". \" + component + \"\\n\");\n            String metadata = component.getMetaData(Component.CONSTRUCTED_AT_KEY);\n            if (metadata != null) {\n                buffer.append(metadata);\n            }\n            metadata = component.getMetaData(Component.ADDED_AT_KEY);\n            if (metadata != null) {\n                buffer.append(metadata);\n            }\n        } else {\n                        return CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;\n        }\n    }\n    return CONTINUE_TRAVERSAL;\n}", "lc": 0.22727272727272727, "pi": 0.8520408163265308, "ma": 0.16666666666666666, "nbd": 0.5, "ml": 0.5833333333333334, "d": 0.782006920415225, "mi": -0.2216805276742187, "fo": 0.4166666666666667, "r": -0.028571428571428574, "e": 0.5787023355219482}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1822_3e83a4c1", "label": 1, "code": "/**\n * Increment the value.\n *\n * @param property the key\n * @param value the increment\n */\npublic void increment(@Nonnull String property, long value) {\n    Operation op = new Operation();\n    op.type = Operation.Type.INCREMENT;\n    op.value = value;\n    changes.put(new Key(property, null), op);\n}", "code_comment": "/**\n * Increment the value.\n *\n * @param property the key\n * @param value the increment\n */\n", "code_no_comment": "public void increment(@Nonnull String property, long value) {\n    Operation op = new Operation();\n    op.type = Operation.Type.INCREMENT;\n    op.value = value;\n    changes.put(new Key(property, null), op);\n}", "lc": -0.36363636363636365, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.4955549182678522, "fo": -0.4166666666666667, "r": 2.2285714285714286, "e": -0.16422749602751402}
{"project_name": "Closure", "project_version": 39, "label": 2, "code": "@Override\nString toStringHelper(boolean forAnnotations) {\n    if (hasReferenceName()) {\n        return getReferenceName();\n    } else if (prettyPrint) {\n        // Don't pretty print recursively.\n        prettyPrint = false;\n        // Use a tree set so that the properties are sorted.\n        Set<String> propertyNames = Sets.newTreeSet();\n        for (ObjectType current = this; current != null && !current.isNativeObjectType() && propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES; current = current.getImplicitPrototype()) {\n            propertyNames.addAll(current.getOwnPropertyNames());\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        int i = 0;\n        for (String property : propertyNames) {\n            if (i > 0) {\n                sb.append(\", \");\n            }\n            sb.append(property);\n            sb.append(\": \");\n            sb.append(getPropertyType(property).toString());\n            ++i;\n            if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n                sb.append(\", ...\");\n                break;\n            }\n        }\n        sb.append(\"}\");\n        prettyPrint = true;\n        return sb.toString();\n    } else {\n        return \"{...}\";\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\nString toStringHelper(boolean forAnnotations) {\n    if (hasReferenceName()) {\n        return getReferenceName();\n    } else if (prettyPrint) {\n                prettyPrint = false;\n                Set<String> propertyNames = Sets.newTreeSet();\n        for (ObjectType current = this; current != null && !current.isNativeObjectType() && propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES; current = current.getImplicitPrototype()) {\n            propertyNames.addAll(current.getOwnPropertyNames());\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        int i = 0;\n        for (String property : propertyNames) {\n            if (i > 0) {\n                sb.append(\", \");\n            }\n            sb.append(property);\n            sb.append(\": \");\n            sb.append(getPropertyType(property).toString());\n            ++i;\n            if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n                sb.append(\", ...\");\n                break;\n            }\n        }\n        sb.append(\"}\");\n        prettyPrint = true;\n        return sb.toString();\n    } else {\n        return \"{...}\";\n    }\n}", "lc": 0.8636363636363636, "pi": 0.5969387755102042, "ma": 0.6666666666666666, "nbd": 1.0, "ml": 0.6666666666666666, "d": 1.1576866040533864, "mi": -0.5698308001147121, "fo": 1.0, "r": -0.028571428571428574, "e": 1.4286301669086563}
{"project_name": "Cli", "project_version": 29, "label": 1, "code": "/**\n * Remove the leading and trailing quotes from <code>str</code>.\n * E.g. if str is '\"one two\"', then 'one two' is returned.\n *\n * @param str The string from which the leading and trailing quotes\n * should be removed.\n *\n * @return The string without the leading and trailing quotes.\n */\nstatic String stripLeadingAndTrailingQuotes(String str) {\n    if (str.startsWith(\"\\\"\")) {\n        str = str.substring(1, str.length());\n    }\n    int length = str.length();\n    if (str.endsWith(\"\\\"\")) {\n        str = str.substring(0, length - 1);\n    }\n    return str;\n}", "code_comment": "/**\n * Remove the leading and trailing quotes from <code>str</code>.\n * E.g. if str is '\"one two\"', then 'one two' is returned.\n *\n * @param str The string from which the leading and trailing quotes\n * should be removed.\n *\n * @return The string without the leading and trailing quotes.\n */\n", "code_no_comment": "static String stripLeadingAndTrailingQuotes(String str) {\n    if (str.startsWith(\"\\\"\")) {\n        str = str.substring(1, str.length());\n    }\n    int length = str.length();\n    if (str.endsWith(\"\\\"\")) {\n        str = str.substring(0, length - 1);\n    }\n    return str;\n}", "lc": -0.18181818181818182, "pi": -0.2500000000000001, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.08333333333333333, "d": 0.10380622837370251, "mi": 0.2305706911385143, "fo": 0.0, "r": 0.0, "e": -0.04363095926435128}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1505_b082fc1e", "label": 1, "code": "@Override\npublic void addMutations(Iterable<Mutation> iterable) throws MutationsRejectedException {\n    for (Mutation m : iterable) {\n        acu.addMutation(tablename, m);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void addMutations(Iterable<Mutation> iterable) throws MutationsRejectedException {\n    for (Mutation m : iterable) {\n        acu.addMutation(tablename, m);\n    }\n}", "lc": -0.36363636363636365, "pi": -0.02040816326530614, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.6030972182391743, "fo": -0.4166666666666667, "r": 0.5428571428571429, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-9143_08077733", "label": 1, "code": "protected void doStop() throws Exception {\n    // when stopping we intend to shutdown\n    ServiceHelper.stopAndShutdownServices(statistics, pool);\n    try {\n        ServiceHelper.stopAndShutdownServices(producers.values());\n    } finally {\n        // ensure producers are removed, and also from JMX\n        for (Producer producer : producers.values()) {\n            getCamelContext().removeService(producer);\n        }\n    }\n    producers.clear();\n    if (statistics != null) {\n        statistics.clear();\n    }\n}", "code_comment": NaN, "code_no_comment": "protected void doStop() throws Exception {\n        ServiceHelper.stopAndShutdownServices(statistics, pool);\n    try {\n        ServiceHelper.stopAndShutdownServices(producers.values());\n    } finally {\n                for (Producer producer : producers.values()) {\n            getCamelContext().removeService(producer);\n        }\n    }\n    producers.clear();\n    if (statistics != null) {\n        statistics.clear();\n    }\n}", "lc": 0.0, "pi": 0.08163265306122457, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.25, "d": -0.3806228373702422, "mi": 0.09463722397476335, "fo": 0.16666666666666666, "r": 0.31428571428571433, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3433_e76d23b0", "label": 3, "code": "@Override\npublic String toString() {\n    return \"\" + expression + \".convertTo(\" + type.getCanonicalName() + \".class)\";\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic String toString() {\n    return \"\" + expression + \".convertTo(\" + type.getCanonicalName() + \".class)\";\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8339546888442785, "fo": -0.4166666666666667, "r": 2.0, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-4397_e33516d5", "label": 0, "code": "/**\n * Recursively sync the memberships of an authorizable up-to the specified depth. If the given depth\n * is equal or less than 0, no syncing is performed.\n *\n * @param external the external identity\n * @param auth the authorizable\n * @param depth recursion depth.\n * @throws RepositoryException\n */\nprotected void syncMembership(@Nonnull ExternalIdentity external, @Nonnull Authorizable auth, long depth) throws RepositoryException {\n    if (depth <= 0) {\n        return;\n    }\n    if (log.isDebugEnabled()) {\n        log.debug(\"Syncing membership '{}' -> '{}'\", external.getExternalId().getString(), auth.getID());\n    }\n    final DebugTimer timer = new DebugTimer();\n    Iterable<ExternalIdentityRef> externalGroups;\n    try {\n        externalGroups = external.getDeclaredGroups();\n    } catch (ExternalIdentityException e) {\n        log.error(\"Error while retrieving external declared groups for '{}'\", external.getId(), e);\n        return;\n    }\n    timer.mark(\"fetching\");\n    // first get the set of the existing groups that are synced ones\n    Map<String, Group> declaredExternalGroups = new HashMap<String, Group>();\n    Iterator<Group> grpIter = auth.declaredMemberOf();\n    while (grpIter.hasNext()) {\n        Group grp = grpIter.next();\n        if (isSameIDP(grp)) {\n            declaredExternalGroups.put(grp.getID(), grp);\n        }\n    }\n    timer.mark(\"reading\");\n    for (ExternalIdentityRef ref : externalGroups) {\n        log.debug(\"- processing membership {}\", ref.getId());\n        // get group\n        ExternalGroup extGroup;\n        try {\n            ExternalIdentity extId = idp.getIdentity(ref);\n            if (extId instanceof ExternalGroup) {\n                extGroup = (ExternalGroup) extId;\n            } else {\n                log.warn(\"No external group found for ref '{}'.\", ref.getString());\n                continue;\n            }\n        } catch (ExternalIdentityException e) {\n            log.warn(\"Unable to retrieve external group '{}' from provider.\", ref.getString(), e);\n            continue;\n        }\n        log.debug(\"- idp returned '{}'\", extGroup.getId());\n        Group grp;\n        Authorizable a = userManager.getAuthorizable(extGroup.getId());\n        if (a == null) {\n            grp = createGroup(extGroup);\n            log.debug(\"- created new group\");\n        } else if (a.isGroup()) {\n            grp = (Group) a;\n        } else {\n            log.warn(\"Authorizable '{}' is not a group, but should be one.\", extGroup.getId());\n            continue;\n        }\n        log.debug(\"- user manager returned '{}'\", grp);\n        syncGroup(extGroup, grp);\n        // ensure membership\n        grp.addMember(auth);\n        log.debug(\"- added '{}' as member to '{}'\", auth, grp);\n        // remember the declared group\n        declaredExternalGroups.remove(grp.getID());\n        // recursively apply further membership\n        if (depth > 1) {\n            log.debug(\"- recursively sync group membership of '{}' (depth = {}).\", grp.getID(), depth);\n            syncMembership(extGroup, grp, depth - 1);\n        } else {\n            log.debug(\"- group nesting level for '{}' reached\", grp.getID());\n        }\n    }\n    timer.mark(\"adding\");\n    // remove us from the lost membership groups\n    for (Group grp : declaredExternalGroups.values()) {\n        grp.removeMember(auth);\n        log.debug(\"- removing member '{}' for group '{}'\", auth.getID(), grp.getID());\n    }\n    if (log.isDebugEnabled()) {\n        timer.mark(\"removing\");\n        log.debug(\"syncMembership({}) {}\", external.getId(), timer.getString());\n    }\n}", "code_comment": "/**\n * Recursively sync the memberships of an authorizable up-to the specified depth. If the given depth\n * is equal or less than 0, no syncing is performed.\n *\n * @param external the external identity\n * @param auth the authorizable\n * @param depth recursion depth.\n * @throws RepositoryException\n */\n", "code_no_comment": "protected void syncMembership(@Nonnull ExternalIdentity external, @Nonnull Authorizable auth, long depth) throws RepositoryException {\n    if (depth <= 0) {\n        return;\n    }\n    if (log.isDebugEnabled()) {\n        log.debug(\"Syncing membership '{}' -> '{}'\", external.getExternalId().getString(), auth.getID());\n    }\n    final DebugTimer timer = new DebugTimer();\n    Iterable<ExternalIdentityRef> externalGroups;\n    try {\n        externalGroups = external.getDeclaredGroups();\n    } catch (ExternalIdentityException e) {\n        log.error(\"Error while retrieving external declared groups for '{}'\", external.getId(), e);\n        return;\n    }\n    timer.mark(\"fetching\");\n        Map<String, Group> declaredExternalGroups = new HashMap<String, Group>();\n    Iterator<Group> grpIter = auth.declaredMemberOf();\n    while (grpIter.hasNext()) {\n        Group grp = grpIter.next();\n        if (isSameIDP(grp)) {\n            declaredExternalGroups.put(grp.getID(), grp);\n        }\n    }\n    timer.mark(\"reading\");\n    for (ExternalIdentityRef ref : externalGroups) {\n        log.debug(\"- processing membership {}\", ref.getId());\n                ExternalGroup extGroup;\n        try {\n            ExternalIdentity extId = idp.getIdentity(ref);\n            if (extId instanceof ExternalGroup) {\n                extGroup = (ExternalGroup) extId;\n            } else {\n                log.warn(\"No external group found for ref '{}'.\", ref.getString());\n                continue;\n            }\n        } catch (ExternalIdentityException e) {\n            log.warn(\"Unable to retrieve external group '{}' from provider.\", ref.getString(), e);\n            continue;\n        }\n        log.debug(\"- idp returned '{}'\", extGroup.getId());\n        Group grp;\n        Authorizable a = userManager.getAuthorizable(extGroup.getId());\n        if (a == null) {\n            grp = createGroup(extGroup);\n            log.debug(\"- created new group\");\n        } else if (a.isGroup()) {\n            grp = (Group) a;\n        } else {\n            log.warn(\"Authorizable '{}' is not a group, but should be one.\", extGroup.getId());\n            continue;\n        }\n        log.debug(\"- user manager returned '{}'\", grp);\n        syncGroup(extGroup, grp);\n                grp.addMember(auth);\n        log.debug(\"- added '{}' as member to '{}'\", auth, grp);\n                declaredExternalGroups.remove(grp.getID());\n                if (depth > 1) {\n            log.debug(\"- recursively sync group membership of '{}' (depth = {}).\", grp.getID(), depth);\n            syncMembership(extGroup, grp, depth - 1);\n        } else {\n            log.debug(\"- group nesting level for '{}' reached\", grp.getID());\n        }\n    }\n    timer.mark(\"adding\");\n        for (Group grp : declaredExternalGroups.values()) {\n        grp.removeMember(auth);\n        log.debug(\"- removing member '{}' for group '{}'\", auth.getID(), grp.getID());\n    }\n    if (log.isDebugEnabled()) {\n        timer.mark(\"removing\");\n        log.debug(\"syncMembership({}) {}\", external.getId(), timer.getString());\n    }\n}", "lc": 2.727272727272727, "pi": 0.24489795918367346, "ma": 2.1666666666666665, "nbd": 0.5, "ml": 1.0, "d": 0.6455758774097876, "mi": -1.160596501290508, "fo": 4.0, "r": -0.028571428571428574, "e": 2.862836804707878}
{"project_name": "Time", "project_version": 26, "label": 2, "code": "public long set(long instant, String text, Locale locale) {\n    // cannot verify that new value stuck because set may be lenient\n    long localInstant = iZone.convertUTCToLocal(instant);\n    localInstant = iField.set(localInstant, text, locale);\n    return iZone.convertLocalToUTC(localInstant, false);\n}", "code_comment": NaN, "code_no_comment": "public long set(long instant, String text, Locale locale) {\n        long localInstant = iZone.convertUTCToLocal(instant);\n    localInstant = iField.set(localInstant, text, locale);\n    return iZone.convertLocalToUTC(localInstant, false);\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.605965012905076, "fo": -0.25, "r": 0.05714285714285714, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-93_0be7e8f0", "label": 1, "code": "/**\n * Copy this tree to the parent at {@code destParent} with the name {@code destName}.\n *\n * @param destParent  parent for the copied tree\n * @param destName  name for the copied tree\n * @return  {@code true} if successful, {@code false otherwise}. I.e.\n * when {@code destName} already exists at {@code destParent}\n */\npublic boolean copy(TreeImpl destParent, String destName) {\n    boolean result = builder.copyTo(destParent.builder, destName);\n    if (result) {\n        if (listener != null) {\n            listener.copy(parent, name, destParent.getChild(destName));\n        }\n        return true;\n    }\n    return result;\n}", "code_comment": "/**\n * Copy this tree to the parent at {@code destParent} with the name {@code destName}.\n *\n * @param destParent  parent for the copied tree\n * @param destName  name for the copied tree\n * @return  {@code true} if successful, {@code false otherwise}. I.e.\n * when {@code destName} already exists at {@code destParent}\n */\n", "code_no_comment": "public boolean copy(TreeImpl destParent, String destName) {\n    boolean result = builder.copyTo(destParent.builder, destName);\n    if (result) {\n        if (listener != null) {\n            listener.copy(parent, name, destParent.getChild(destName));\n        }\n        return true;\n    }\n    return result;\n}", "lc": -0.18181818181818182, "pi": 0.2959183673469388, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.06426099851705384, "mi": 0.24175509033553183, "fo": -0.25, "r": 0.08571428571428572, "e": -0.09139930015718624}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2435_7e250001", "label": 3, "code": "@Override\npublic boolean equals(Object obj) {\n    if (obj instanceof Key) {\n        Key other = (Key) obj;\n        return name.equals(other.name) && revision != null ? revision.equals(other.revision) : other.revision == null;\n    }\n    return false;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean equals(Object obj) {\n    if (obj instanceof Key) {\n        Key other = (Key) obj;\n        return name.equals(other.name) && revision != null ? revision.equals(other.revision) : other.revision == null;\n    }\n    return false;\n}", "lc": -0.2727272727272727, "pi": 0.051020408163265356, "ma": -0.16666666666666666, "nbd": -0.5, "ml": 0.16666666666666666, "d": 0.5190311418685122, "mi": 0.33610553484370526, "fo": -0.3333333333333333, "r": 0.7142857142857143, "e": 0.056347197416492134}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_add180fb", "label": 1, "code": "@Override\npublic void removeIterator(String tableName, String name, EnumSet<IteratorScope> scopes) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {\n    Map<String, String> copy = new HashMap<String, String>();\n    for (Entry<String, String> property : this.getProperties(tableName)) {\n        copy.put(property.getKey(), property.getValue());\n    }\n    for (IteratorScope scope : scopes) {\n        String root = String.format(\"%s%s.%s\", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase(), name);\n        for (Entry<String, String> property : copy.entrySet()) {\n            if (property.getKey().equals(root) || property.getKey().startsWith(root + \".opt.\"))\n                this.removeProperty(tableName, property.getKey());\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void removeIterator(String tableName, String name, EnumSet<IteratorScope> scopes) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {\n    Map<String, String> copy = new HashMap<String, String>();\n    for (Entry<String, String> property : this.getProperties(tableName)) {\n        copy.put(property.getKey(), property.getValue());\n    }\n    for (IteratorScope scope : scopes) {\n        String root = String.format(\"%s%s.%s\", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase(), name);\n        for (Entry<String, String> property : copy.entrySet()) {\n            if (property.getKey().equals(root) || property.getKey().startsWith(root + \".opt.\"))\n                this.removeProperty(tableName, property.getKey());\n        }\n    }\n}", "lc": 0.0, "pi": 0.7346938775510204, "ma": 0.16666666666666666, "nbd": 0.0, "ml": 0.0, "d": 0.008897676717745953, "mi": -0.10811585890450236, "fo": 0.6666666666666666, "r": -0.028571428571428574, "e": 0.13671347989772187}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1178_f2bb1a17", "label": 1, "code": "@Override\npublic boolean isNew() {\n    return exists() && !base.exists();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean isNew() {\n    return exists() && !base.exists();\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.14335145823035095, "mi": 0.9125322626899914, "fo": -0.3333333333333333, "r": 2.2571428571428576, "e": -0.1526848009045704}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-834_d3989b40", "label": 1, "code": "/**\n * Loads classes not located via Reflection.getCallerClass.\n *\n * @param lastLoader\n *        The ClassLoader that loaded the Class that called this Class.\n * @param className\n *        The name of the Class.\n * @return The Class object for the Class or null if it could not be located.\n */\nprivate Class<?> loadClass(final ClassLoader lastLoader, final String className) {\n    // XXX: this is overly complicated\n    Class<?> clazz;\n    if (lastLoader != null) {\n        try {\n            clazz = Loader.initializeClass(className, lastLoader);\n            if (clazz != null) {\n                return clazz;\n            }\n        } catch (final Throwable ignore) {\n        // Ignore exception.\n        }\n    }\n    try {\n        clazz = Loader.loadClass(className);\n    } catch (final ClassNotFoundException ignored) {\n        try {\n            clazz = Loader.initializeClass(className, this.getClass().getClassLoader());\n        } catch (final ClassNotFoundException ignore) {\n            return null;\n        }\n    }\n    return clazz;\n}", "code_comment": "/**\n * Loads classes not located via Reflection.getCallerClass.\n *\n * @param lastLoader\n *        The ClassLoader that loaded the Class that called this Class.\n * @param className\n *        The name of the Class.\n * @return The Class object for the Class or null if it could not be located.\n */\n", "code_no_comment": "private Class<?> loadClass(final ClassLoader lastLoader, final String className) {\n        Class<?> clazz;\n    if (lastLoader != null) {\n        try {\n            clazz = Loader.initializeClass(className, lastLoader);\n            if (clazz != null) {\n                return clazz;\n            }\n        } catch (final Throwable ignore) {\n                }\n    }\n    try {\n        clazz = Loader.loadClass(className);\n    } catch (final ClassNotFoundException ignored) {\n        try {\n            clazz = Loader.initializeClass(className, this.getClass().getClassLoader());\n        } catch (final ClassNotFoundException ignore) {\n            return null;\n        }\n    }\n    return clazz;\n}", "lc": 0.36363636363636365, "pi": 0.556122448979592, "ma": 0.3333333333333333, "nbd": 0.5, "ml": -0.08333333333333333, "d": 0.05042016806722697, "mi": -0.22139374820762836, "fo": -0.08333333333333333, "r": 0.1142857142857143, "e": 0.0020858228292666234}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2074_6bc6dbec", "label": 0, "code": "@Override\npublic void evict(int n) {\n    toRemove += n;\n    Integer lastPreAggregateSize = elementsPerPreAggregate.peek();\n    while (lastPreAggregateSize != null && lastPreAggregateSize <= toRemove) {\n        toRemove = max(toRemove - elementsPerPreAggregate.removeFirst(), 0);\n        reduced.removeFirst();\n        lastPreAggregateSize = elementsPerPreAggregate.peek();\n    }\n    if (toRemove > 0 && lastPreAggregateSize == null) {\n        currentReduced = null;\n        toRemove = 0;\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void evict(int n) {\n    toRemove += n;\n    Integer lastPreAggregateSize = elementsPerPreAggregate.peek();\n    while (lastPreAggregateSize != null && lastPreAggregateSize <= toRemove) {\n        toRemove = max(toRemove - elementsPerPreAggregate.removeFirst(), 0);\n        reduced.removeFirst();\n        lastPreAggregateSize = elementsPerPreAggregate.peek();\n    }\n    if (toRemove > 0 && lastPreAggregateSize == null) {\n        currentReduced = null;\n        toRemove = 0;\n    }\n}", "lc": 0.0, "pi": -0.025510204081632563, "ma": -0.16666666666666666, "nbd": -0.5, "ml": 0.08333333333333333, "d": 1.359367276322294, "mi": -0.01462575279609995, "fo": -0.08333333333333333, "r": 0.0, "e": 0.6200504537842481}
{"project_name": "Closure", "project_version": 169, "label": 2, "code": "private boolean hasAlternate(JSType type, boolean tolerateUnknowns) {\n    for (JSType alternate : alternates) {\n        if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) {\n            return true;\n        }\n    }\n    return false;\n}", "code_comment": NaN, "code_no_comment": "private boolean hasAlternate(JSType type, boolean tolerateUnknowns) {\n    for (JSType alternate : alternates) {\n        if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) {\n            return true;\n        }\n    }\n    return false;\n}", "lc": -0.2727272727272727, "pi": 0.43367346938775514, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.3806228373702422, "mi": 0.4688844278749641, "fo": -0.4166666666666667, "r": 0.2571428571428572, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2695_0598498e", "label": 0, "code": "private boolean dispatch(@Nonnull String jsonDiff, @Nonnull DocumentNodeState node, @Nonnull DocumentNodeState base, @Nonnull NodeStateDiff diff, boolean useReadRevision) {\n    if (jsonDiff.trim().isEmpty()) {\n        return true;\n    }\n    Revision nodeRev = useReadRevision ? node.getRevision() : node.getLastRevision();\n    Revision baseRev = useReadRevision ? base.getRevision() : base.getLastRevision();\n    JsopTokenizer t = new JsopTokenizer(jsonDiff);\n    boolean continueComparison = true;\n    while (continueComparison) {\n        int r = t.read();\n        if (r == JsopReader.END) {\n            break;\n        }\n        switch(r) {\n            case '+':\n                {\n                    String name = unshareString(t.readString());\n                    t.read(':');\n                    t.read('{');\n                    while (t.read() != '}') {\n                    // skip properties\n                    }\n                    NodeState child = getNode(concat(node.getPath(), name), nodeRev);\n                    continueComparison = diff.childNodeAdded(name, child);\n                    break;\n                }\n            case '-':\n                {\n                    String name = unshareString(t.readString());\n                    NodeState child = getNode(concat(base.getPath(), name), baseRev);\n                    continueComparison = diff.childNodeDeleted(name, child);\n                    break;\n                }\n            case '^':\n                {\n                    String name = unshareString(t.readString());\n                    t.read(':');\n                    if (t.matches('{')) {\n                        t.read('}');\n                        NodeState nodeChild = getNode(concat(node.getPath(), name), nodeRev);\n                        NodeState baseChild = getNode(concat(base.getPath(), name), baseRev);\n                        continueComparison = diff.childNodeChanged(name, baseChild, nodeChild);\n                    } else if (t.matches('[')) {\n                        // ignore multi valued property\n                        while (t.read() != ']') {\n                        // skip values\n                        }\n                    } else {\n                        // ignore single valued property\n                        t.read();\n                    }\n                    break;\n                }\n            default:\n                throw new IllegalArgumentException(\"jsonDiff: illegal token '\" + t.getToken() + \"' at pos: \" + t.getLastPos() + ' ' + jsonDiff);\n        }\n    }\n    return continueComparison;\n}", "code_comment": NaN, "code_no_comment": "private boolean dispatch(@Nonnull String jsonDiff, @Nonnull DocumentNodeState node, @Nonnull DocumentNodeState base, @Nonnull NodeStateDiff diff, boolean useReadRevision) {\n    if (jsonDiff.trim().isEmpty()) {\n        return true;\n    }\n    Revision nodeRev = useReadRevision ? node.getRevision() : node.getLastRevision();\n    Revision baseRev = useReadRevision ? base.getRevision() : base.getLastRevision();\n    JsopTokenizer t = new JsopTokenizer(jsonDiff);\n    boolean continueComparison = true;\n    while (continueComparison) {\n        int r = t.read();\n        if (r == JsopReader.END) {\n            break;\n        }\n        switch(r) {\n            case '+':\n                {\n                    String name = unshareString(t.readString());\n                    t.read(':');\n                    t.read('{');\n                    while (t.read() != '}') {\n                                        }\n                    NodeState child = getNode(concat(node.getPath(), name), nodeRev);\n                    continueComparison = diff.childNodeAdded(name, child);\n                    break;\n                }\n            case '-':\n                {\n                    String name = unshareString(t.readString());\n                    NodeState child = getNode(concat(base.getPath(), name), baseRev);\n                    continueComparison = diff.childNodeDeleted(name, child);\n                    break;\n                }\n            case '^':\n                {\n                    String name = unshareString(t.readString());\n                    t.read(':');\n                    if (t.matches('{')) {\n                        t.read('}');\n                        NodeState nodeChild = getNode(concat(node.getPath(), name), nodeRev);\n                        NodeState baseChild = getNode(concat(base.getPath(), name), baseRev);\n                        continueComparison = diff.childNodeChanged(name, baseChild, nodeChild);\n                    } else if (t.matches('[')) {\n                                                while (t.read() != ']') {\n                                                }\n                    } else {\n                                                t.read();\n                    }\n                    break;\n                }\n            default:\n                throw new IllegalArgumentException(\"jsonDiff: illegal token '\" + t.getToken() + \"' at pos: \" + t.getLastPos() + ' ' + jsonDiff);\n        }\n    }\n    return continueComparison;\n}", "lc": 1.8636363636363635, "pi": 2.1785714285714284, "ma": 2.5, "nbd": 2.0, "ml": 1.1666666666666667, "d": 0.7108255066732576, "mi": -0.9876684829366219, "fo": 2.75, "r": -0.028571428571428574, "e": 2.1618718439616074}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-846_7acb091a", "label": 3, "code": "/**\n * Get the revision of the latest change made to this node.\n *\n * @param nodeMap the document\n * @param changeRev the revision of the current change\n * @param handler the conflict handler, which is called for un-committed revisions\n *                preceding <code>before</code>.\n * @return the revision, or null if deleted\n */\n@SuppressWarnings(\"unchecked\")\n@Nullable\nRevision getNewestRevision(Map<String, Object> nodeMap, Revision changeRev, CollisionHandler handler) {\n    if (nodeMap == null) {\n        return null;\n    }\n    SortedSet<String> revisions = new TreeSet<String>(Collections.reverseOrder());\n    if (nodeMap.containsKey(UpdateOp.REVISIONS)) {\n        revisions.addAll(((Map<String, String>) nodeMap.get(UpdateOp.REVISIONS)).keySet());\n    }\n    if (nodeMap.containsKey(UpdateOp.COMMIT_ROOT)) {\n        revisions.addAll(((Map<String, Integer>) nodeMap.get(UpdateOp.COMMIT_ROOT)).keySet());\n    }\n    Map<String, String> deletedMap = (Map<String, String>) nodeMap.get(UpdateOp.DELETED);\n    if (deletedMap != null) {\n        revisions.addAll(deletedMap.keySet());\n    }\n    Revision newestRev = null;\n    for (String r : revisions) {\n        Revision propRev = Revision.fromString(r);\n        if (isRevisionNewer(propRev, changeRev)) {\n            // we have seen a previous change from another cluster node\n            // (which might be conflicting or not) - we need to make\n            // sure this change is visible from now on\n            publishRevision(propRev, changeRev);\n        }\n        if (newestRev == null || isRevisionNewer(propRev, newestRev)) {\n            if (!propRev.equals(changeRev)) {\n                if (!isValidRevision(propRev, changeRev, nodeMap, new HashSet<Revision>())) {\n                    handler.uncommittedModification(propRev);\n                } else {\n                    newestRev = propRev;\n                }\n            }\n        }\n    }\n    if (newestRev == null) {\n        return null;\n    }\n    if (deletedMap != null) {\n        String value = deletedMap.get(newestRev.toString());\n        if (\"true\".equals(value)) {\n            // deleted in the newest revision\n            return null;\n        }\n    }\n    return newestRev;\n}", "code_comment": "/**\n * Get the revision of the latest change made to this node.\n *\n * @param nodeMap the document\n * @param changeRev the revision of the current change\n * @param handler the conflict handler, which is called for un-committed revisions\n *                preceding <code>before</code>.\n * @return the revision, or null if deleted\n */\n", "code_no_comment": "@SuppressWarnings(\"unchecked\")\n@Nullable\nRevision getNewestRevision(Map<String, Object> nodeMap, Revision changeRev, CollisionHandler handler) {\n    if (nodeMap == null) {\n        return null;\n    }\n    SortedSet<String> revisions = new TreeSet<String>(Collections.reverseOrder());\n    if (nodeMap.containsKey(UpdateOp.REVISIONS)) {\n        revisions.addAll(((Map<String, String>) nodeMap.get(UpdateOp.REVISIONS)).keySet());\n    }\n    if (nodeMap.containsKey(UpdateOp.COMMIT_ROOT)) {\n        revisions.addAll(((Map<String, Integer>) nodeMap.get(UpdateOp.COMMIT_ROOT)).keySet());\n    }\n    Map<String, String> deletedMap = (Map<String, String>) nodeMap.get(UpdateOp.DELETED);\n    if (deletedMap != null) {\n        revisions.addAll(deletedMap.keySet());\n    }\n    Revision newestRev = null;\n    for (String r : revisions) {\n        Revision propRev = Revision.fromString(r);\n        if (isRevisionNewer(propRev, changeRev)) {\n                                                publishRevision(propRev, changeRev);\n        }\n        if (newestRev == null || isRevisionNewer(propRev, newestRev)) {\n            if (!propRev.equals(changeRev)) {\n                if (!isValidRevision(propRev, changeRev, nodeMap, new HashSet<Revision>())) {\n                    handler.uncommittedModification(propRev);\n                } else {\n                    newestRev = propRev;\n                }\n            }\n        }\n    }\n    if (newestRev == null) {\n        return null;\n    }\n    if (deletedMap != null) {\n        String value = deletedMap.get(newestRev.toString());\n        if (\"true\".equals(value)) {\n                        return null;\n        }\n    }\n    return newestRev;\n}", "lc": 1.3636363636363635, "pi": 0.9540816326530611, "ma": 1.5, "nbd": 1.0, "ml": 1.6666666666666667, "d": 0.7582797825012358, "mi": -0.8038428448523088, "fo": 1.3333333333333333, "r": -0.028571428571428574, "e": 1.6863213709038425}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-413_51aa6e6c", "label": 1, "code": "/**\n * {@inheritDoc}\n */\npublic UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max) throws FunctionEvaluationException {\n    optima = new UnivariateRealPointValuePair[starts];\n    totalEvaluations = 0;\n    // Multi-start loop.\n    for (int i = 0; i < starts; ++i) {\n        try {\n            final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n            final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n            optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n        } catch (FunctionEvaluationException fee) {\n            optima[i] = null;\n        } catch (ConvergenceException ce) {\n            optima[i] = null;\n        }\n        final int usedEvaluations = optimizer.getEvaluations();\n        optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\n        totalEvaluations += usedEvaluations;\n    }\n    sortPairs(goal);\n    if (optima[0] == null) {\n        throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT, starts);\n    }\n    // Return the point with the best objective function value.\n    return optima[0];\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max) throws FunctionEvaluationException {\n    optima = new UnivariateRealPointValuePair[starts];\n    totalEvaluations = 0;\n        for (int i = 0; i < starts; ++i) {\n        try {\n            final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n            final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n            optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n        } catch (FunctionEvaluationException fee) {\n            optima[i] = null;\n        } catch (ConvergenceException ce) {\n            optima[i] = null;\n        }\n        final int usedEvaluations = optimizer.getEvaluations();\n        optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\n        totalEvaluations += usedEvaluations;\n    }\n    sortPairs(goal);\n    if (optima[0] == null) {\n        throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT, starts);\n    }\n        return optima[0];\n}", "lc": 0.4090909090909091, "pi": 0.3061224489795919, "ma": 0.6666666666666666, "nbd": 0.0, "ml": 0.08333333333333333, "d": 1.6717745921898177, "mi": -0.42558072841984534, "fo": 0.25, "r": 0.0, "e": 2.3188781956561777}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5881_8c83c5c5", "label": 1, "code": "/**\n *  Update the model of a {@link FormComponent} containing a {@link Collection}.\n *\n *  If the model object does not yet exists, a new {@link ArrayList} is filled with the converted\n *  input and used as the new model object. Otherwise the existing collection is modified\n *  in-place, then {@link Model#setObject(Object)} is called with the same instance: it allows\n *  the Model to be notified of changes even when {@link Model#getObject()} returns a different\n *  {@link Collection} at every invocation.\n *\n *  @param <S>\n *             collection type\n *  @param formComponent\n *             the form component to update\n *  @see FormComponent#updateModel()\n *  @throws WicketRuntimeException\n *              if the existing model object collection is unmodifiable and no setter exists\n */\npublic static <S> void updateCollectionModel(FormComponent<Collection<S>> formComponent) {\n    Collection<S> convertedInput = formComponent.getConvertedInput();\n    Collection<S> collection = formComponent.getModelObject();\n    if (collection == null) {\n        collection = new ArrayList<>(convertedInput);\n        formComponent.setModelObject(collection);\n    } else {\n        boolean modified = false;\n        formComponent.modelChanging();\n        try {\n            collection.clear();\n            if (convertedInput != null) {\n                collection.addAll(convertedInput);\n            }\n            modified = true;\n        } catch (UnsupportedOperationException unmodifiable) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"An error occurred while trying to modify the collection attached to \" + formComponent, unmodifiable);\n            }\n            collection = new ArrayList<>(convertedInput);\n        }\n        try {\n            formComponent.getModel().setObject(collection);\n        } catch (Exception noSetter) {\n            if (!modified) {\n                throw new WicketRuntimeException(\"An error occurred while trying to set the collection attached to \" + formComponent, noSetter);\n            } else if (logger.isDebugEnabled()) {\n                logger.debug(\"An error occurred while trying to set the collection attached to \" + formComponent, noSetter);\n            }\n        }\n        formComponent.modelChanged();\n    }\n}", "code_comment": "/**\n *  Update the model of a {@link FormComponent} containing a {@link Collection}.\n *\n *  If the model object does not yet exists, a new {@link ArrayList} is filled with the converted\n *  input and used as the new model object. Otherwise the existing collection is modified\n *  in-place, then {@link Model#setObject(Object)} is called with the same instance: it allows\n *  the Model to be notified of changes even when {@link Model#getObject()} returns a different\n *  {@link Collection} at every invocation.\n *\n *  @param <S>\n *             collection type\n *  @param formComponent\n *             the form component to update\n *  @see FormComponent#updateModel()\n *  @throws WicketRuntimeException\n *              if the existing model object collection is unmodifiable and no setter exists\n */\n", "code_no_comment": "public static <S> void updateCollectionModel(FormComponent<Collection<S>> formComponent) {\n    Collection<S> convertedInput = formComponent.getConvertedInput();\n    Collection<S> collection = formComponent.getModelObject();\n    if (collection == null) {\n        collection = new ArrayList<>(convertedInput);\n        formComponent.setModelObject(collection);\n    } else {\n        boolean modified = false;\n        formComponent.modelChanging();\n        try {\n            collection.clear();\n            if (convertedInput != null) {\n                collection.addAll(convertedInput);\n            }\n            modified = true;\n        } catch (UnsupportedOperationException unmodifiable) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"An error occurred while trying to modify the collection attached to \" + formComponent, unmodifiable);\n            }\n            collection = new ArrayList<>(convertedInput);\n        }\n        try {\n            formComponent.getModel().setObject(collection);\n        } catch (Exception noSetter) {\n            if (!modified) {\n                throw new WicketRuntimeException(\"An error occurred while trying to set the collection attached to \" + formComponent, noSetter);\n            } else if (logger.isDebugEnabled()) {\n                logger.debug(\"An error occurred while trying to set the collection attached to \" + formComponent, noSetter);\n            }\n        }\n        formComponent.modelChanged();\n    }\n}", "lc": 0.8636363636363636, "pi": 0.6173469387755104, "ma": 0.8333333333333334, "nbd": 1.0, "ml": 0.3333333333333333, "d": 0.48541769649036093, "mi": -0.5597935187840551, "fo": 0.5833333333333334, "r": -0.028571428571428574, "e": 0.6362187929638815}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-4351_59a83d23", "label": 3, "code": "@Override\npublic IndexRow next() {\n    final IndexRow pathRow = pathCursor.next();\n    return new IndexRow() {\n\n        @Override\n        public boolean isVirtualRow() {\n            return currentRow.isVirutal;\n        }\n\n        @Override\n        public String getPath() {\n            String sub = pathRow.getPath();\n            if (isVirtualRow()) {\n                return sub;\n            } else if (PathUtils.isAbsolute(sub)) {\n                return pathPrefix + sub;\n            } else {\n                return PathUtils.concat(pathPrefix, sub);\n            }\n        }\n\n        @Override\n        public PropertyValue getValue(String columnName) {\n            // overlay the score\n            if (QueryImpl.JCR_SCORE.equals(columnName)) {\n                return PropertyValues.newDouble(currentRow.score);\n            }\n            if (QueryImpl.REP_SPELLCHECK.equals(columnName) || QueryImpl.REP_SUGGEST.equals(columnName)) {\n                return PropertyValues.newString(currentRow.suggestion);\n            }\n            if (QueryImpl.OAK_SCORE_EXPLANATION.equals(columnName)) {\n                return PropertyValues.newString(currentRow.explanation);\n            }\n            if (QueryImpl.REP_EXCERPT.equals(columnName)) {\n                return PropertyValues.newString(currentRow.excerpt);\n            }\n            if (columnName.startsWith(QueryImpl.REP_FACET)) {\n                String facetFieldName = FacetHelper.parseFacetField(columnName);\n                Facets facets = currentRow.facets;\n                try {\n                    if (facets != null) {\n                        FacetResult topChildren = facets.getTopChildren(10, facetFieldName);\n                        if (topChildren != null) {\n                            JsopWriter writer = new JsopBuilder();\n                            writer.object();\n                            for (LabelAndValue lav : topChildren.labelValues) {\n                                writer.key(lav.label).value(lav.value.intValue());\n                            }\n                            writer.endObject();\n                            return PropertyValues.newString(writer.toString());\n                        } else {\n                            return null;\n                        }\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return pathRow.getValue(columnName);\n        }\n    };\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic IndexRow next() {\n    final IndexRow pathRow = pathCursor.next();\n    return new IndexRow() {\n\n        @Override\n        public boolean isVirtualRow() {\n            return currentRow.isVirutal;\n        }\n\n        @Override\n        public String getPath() {\n            String sub = pathRow.getPath();\n            if (isVirtualRow()) {\n                return sub;\n            } else if (PathUtils.isAbsolute(sub)) {\n                return pathPrefix + sub;\n            } else {\n                return PathUtils.concat(pathPrefix, sub);\n            }\n        }\n\n        @Override\n        public PropertyValue getValue(String columnName) {\n                        if (QueryImpl.JCR_SCORE.equals(columnName)) {\n                return PropertyValues.newDouble(currentRow.score);\n            }\n            if (QueryImpl.REP_SPELLCHECK.equals(columnName) || QueryImpl.REP_SUGGEST.equals(columnName)) {\n                return PropertyValues.newString(currentRow.suggestion);\n            }\n            if (QueryImpl.OAK_SCORE_EXPLANATION.equals(columnName)) {\n                return PropertyValues.newString(currentRow.explanation);\n            }\n            if (QueryImpl.REP_EXCERPT.equals(columnName)) {\n                return PropertyValues.newString(currentRow.excerpt);\n            }\n            if (columnName.startsWith(QueryImpl.REP_FACET)) {\n                String facetFieldName = FacetHelper.parseFacetField(columnName);\n                Facets facets = currentRow.facets;\n                try {\n                    if (facets != null) {\n                        FacetResult topChildren = facets.getTopChildren(10, facetFieldName);\n                        if (topChildren != null) {\n                            JsopWriter writer = new JsopBuilder();\n                            writer.object();\n                            for (LabelAndValue lav : topChildren.labelValues) {\n                                writer.key(lav.label).value(lav.value.intValue());\n                            }\n                            writer.endObject();\n                            return PropertyValues.newString(writer.toString());\n                        } else {\n                            return null;\n                        }\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return pathRow.getValue(columnName);\n        }\n    };\n}", "lc": 2.0454545454545454, "pi": 2.392857142857143, "ma": 1.5, "nbd": 2.0, "ml": 1.4166666666666667, "d": 0.43598615916955025, "mi": -0.9532549469457992, "fo": 1.5833333333333333, "r": -0.028571428571428574, "e": 1.284961088910875}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4184_a0150366", "label": 1, "code": "/**\n *  Inserts the string into this string buffer.\n *  <p>\n *  The characters of the <code>String</code> argument are inserted, in order, into this string\n *  buffer at the indicated offset, moving up any characters originally above that position and\n *  increasing the length of this string buffer by the length of the argument. If\n *  <code>str</code> is <code>null</code>, then the four characters <code>\"null\"</code> are\n *  inserted into this string buffer.\n *  <p>\n *  The character at index <i>k</i> in the new character sequence is equal to:\n *  <ul>\n *  <li>the character at index <i>k</i> in the old character sequence, if <i>k</i> is less than\n *  <code>offset</code>\n *  <li>the character at index <i>k</i><code>-offset</code> in the argument <code>str</code>, if\n *  <i>k</i> is not less than <code>offset</code> but is less than\n *  <code>offset+str.length()</code>\n *  <li>the character at index <i>k</i><code>-str.length()</code> in the old character sequence,\n *  if <i>k</i> is not less than <code>offset+str.length()</code>\n *  </ul>\n *  <p>\n *  The offset argument must be greater than or equal to <code>0</code>, and less than or equal\n *  to the length of this string buffer.\n *\n *  @param offset\n *             the offset.\n *  @param str\n *             a string.\n *  @return a reference to this <code>AppendingStringBuffer</code> object.\n *  @exception StringIndexOutOfBoundsException\n *                 if the offset is invalid.\n *  @see java.lang.StringBuffer#length()\n */\npublic AppendingStringBuffer insert(final int offset, StringBuilder str) {\n    if ((offset < 0) || (offset > count)) {\n        throw new StringIndexOutOfBoundsException();\n    }\n    if (str == null) {\n        str = SB_NULL;\n    }\n    int len = str.length();\n    int newcount = count + len;\n    if (newcount > value.length) {\n        expandCapacity(newcount);\n    }\n    System.arraycopy(value, offset, value, offset + len, count - offset);\n    str.getChars(0, len, value, offset);\n    count = newcount;\n    return this;\n}", "code_comment": "/**\n *  Inserts the string into this string buffer.\n *  <p>\n *  The characters of the <code>String</code> argument are inserted, in order, into this string\n *  buffer at the indicated offset, moving up any characters originally above that position and\n *  increasing the length of this string buffer by the length of the argument. If\n *  <code>str</code> is <code>null</code>, then the four characters <code>\"null\"</code> are\n *  inserted into this string buffer.\n *  <p>\n *  The character at index <i>k</i> in the new character sequence is equal to:\n *  <ul>\n *  <li>the character at index <i>k</i> in the old character sequence, if <i>k</i> is less than\n *  <code>offset</code>\n *  <li>the character at index <i>k</i><code>-offset</code> in the argument <code>str</code>, if\n *  <i>k</i> is not less than <code>offset</code> but is less than\n *  <code>offset+str.length()</code>\n *  <li>the character at index <i>k</i><code>-str.length()</code> in the old character sequence,\n *  if <i>k</i> is not less than <code>offset+str.length()</code>\n *  </ul>\n *  <p>\n *  The offset argument must be greater than or equal to <code>0</code>, and less than or equal\n *  to the length of this string buffer.\n *\n *  @param offset\n *             the offset.\n *  @param str\n *             a string.\n *  @return a reference to this <code>AppendingStringBuffer</code> object.\n *  @exception StringIndexOutOfBoundsException\n *                 if the offset is invalid.\n *  @see java.lang.StringBuffer#length()\n */\n", "code_no_comment": "public AppendingStringBuffer insert(final int offset, StringBuilder str) {\n    if ((offset < 0) || (offset > count)) {\n        throw new StringIndexOutOfBoundsException();\n    }\n    if (str == null) {\n        str = SB_NULL;\n    }\n    int len = str.length();\n    int newcount = count + len;\n    if (newcount > value.length) {\n        expandCapacity(newcount);\n    }\n    System.arraycopy(value, offset, value, offset + len, count - offset);\n    str.getChars(0, len, value, offset);\n    count = newcount;\n    return this;\n}", "lc": 0.13636363636363635, "pi": -0.43877551020408156, "ma": 0.16666666666666666, "nbd": -0.5, "ml": 0.3333333333333333, "d": 0.961937716262976, "mi": -0.150272440493261, "fo": -0.16666666666666666, "r": -0.028571428571428574, "e": 0.5875424552747333}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "public void recv_setTableProperty() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\n    setTableProperty_result result = new setTableProperty_result();\n    receiveBase(result, \"setTableProperty\");\n    if (result.ouch1 != null) {\n        throw result.ouch1;\n    }\n    if (result.ouch2 != null) {\n        throw result.ouch2;\n    }\n    return;\n}", "code_comment": NaN, "code_no_comment": "public void recv_setTableProperty() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\n    setTableProperty_result result = new setTableProperty_result();\n    receiveBase(result, \"setTableProperty\");\n    if (result.ouch1 != null) {\n        throw result.ouch1;\n    }\n    if (result.ouch2 != null) {\n        throw result.ouch2;\n    }\n    return;\n}", "lc": -0.13636363636363635, "pi": -0.3112244897959183, "ma": 0.16666666666666666, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.06426099851705384, "mi": 0.17866360768568987, "fo": -0.4166666666666667, "r": -0.028571428571428574, "e": -0.08859821570063517}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2447_5546a1ef", "label": 1, "code": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\nprivate <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoWithTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\n    // check if type is a subclass of tuple\n    if (isClassType(t) && Tuple.class.isAssignableFrom(typeToClass(t))) {\n        Type curT = t;\n        // do not allow usage of Tuple as type\n        if (typeToClass(t).equals(Tuple.class)) {\n            throw new InvalidTypesException(\"Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead.\");\n        }\n        // collect the types while moving up for a later top-down\n        while (!(isClassType(curT) && typeToClass(curT).getSuperclass().equals(Tuple.class))) {\n            typeHierarchy.add(curT);\n            curT = typeToClass(curT).getGenericSuperclass();\n        }\n        // check if immediate child of Tuple has generics\n        if (curT instanceof Class<?>) {\n            throw new InvalidTypesException(\"Tuple needs to be parameterized by using generics.\");\n        }\n        typeHierarchy.add(curT);\n        ParameterizedType tupleChild = (ParameterizedType) curT;\n        Type[] subtypes = new Type[tupleChild.getActualTypeArguments().length];\n        // materialize possible type variables\n        for (int i = 0; i < subtypes.length; i++) {\n            // materialize immediate TypeVariables\n            if (tupleChild.getActualTypeArguments()[i] instanceof TypeVariable<?>) {\n                subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) tupleChild.getActualTypeArguments()[i]);\n            } else // class or parameterized type\n            {\n                subtypes[i] = tupleChild.getActualTypeArguments()[i];\n            }\n        }\n        TypeInformation<?>[] tupleSubTypes = new TypeInformation<?>[subtypes.length];\n        for (int i = 0; i < subtypes.length; i++) {\n            // try to derive the type info of the TypeVariable from the immediate base child input as a last attempt\n            if (subtypes[i] instanceof TypeVariable<?>) {\n                tupleSubTypes[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], typeHierarchy, in1Type, in2Type);\n                // variable could not be determined\n                if (tupleSubTypes[i] == null) {\n                    throw new InvalidTypesException(\"Type of TypeVariable '\" + ((TypeVariable<?>) subtypes[i]).getName() + \"' in '\" + ((TypeVariable<?>) subtypes[i]).getGenericDeclaration() + \"' could not be determined. This is most likely a type erasure problem. \" + \"The type extraction currently supports types with generic variables only in cases where \" + \"all variables in the return type can be deduced from the input type(s).\");\n                }\n            } else {\n                tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new ArrayList<Type>(typeHierarchy), subtypes[i], in1Type, in2Type);\n            }\n        }\n        Class<?> tAsClass = null;\n        if (isClassType(t)) {\n            tAsClass = typeToClass(t);\n        }\n        Preconditions.checkNotNull(tAsClass, \"t has a unexpected type\");\n        // check if the class we assumed to be a Tuple so far is actually a pojo because it contains additional fields.\n        // check for additional fields.\n        int fieldCount = countFieldsInClass(tAsClass);\n        if (fieldCount != tupleSubTypes.length) {\n            // the class is not a real tuple because it contains additional fields. treat as a pojo\n            if (t instanceof ParameterizedType) {\n                return (TypeInformation<OUT>) analyzePojo(tAsClass, new ArrayList<Type>(typeHierarchy), (ParameterizedType) t, in1Type, in2Type);\n            } else {\n                return (TypeInformation<OUT>) analyzePojo(tAsClass, new ArrayList<Type>(typeHierarchy), null, in1Type, in2Type);\n            }\n        }\n        return new TupleTypeInfo(tAsClass, tupleSubTypes);\n    } else // e.g. class MyMapper<E> extends MapFunction<String, E>\n    if (t instanceof TypeVariable) {\n        Type typeVar = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) t);\n        if (!(typeVar instanceof TypeVariable)) {\n            return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);\n        } else // try to derive the type info of the TypeVariable from the immediate base child input as a last attempt\n        {\n            TypeInformation<OUT> typeInfo = (TypeInformation<OUT>) createTypeInfoFromInputs((TypeVariable<?>) t, typeHierarchy, in1Type, in2Type);\n            if (typeInfo != null) {\n                return typeInfo;\n            } else {\n                throw new InvalidTypesException(\"Type of TypeVariable '\" + ((TypeVariable<?>) t).getName() + \"' in '\" + ((TypeVariable<?>) t).getGenericDeclaration() + \"' could not be determined. This is most likely a type erasure problem. \" + \"The type extraction currently supports types with generic variables only in cases where \" + \"all variables in the return type can be deduced from the input type(s).\");\n            }\n        }\n    } else // arrays with generics\n    if (t instanceof GenericArrayType) {\n        GenericArrayType genericArray = (GenericArrayType) t;\n        Type componentType = genericArray.getGenericComponentType();\n        // due to a Java 6 bug, it is possible that the JVM classifies e.g. String[] or int[] as GenericArrayType instead of Class\n        if (componentType instanceof Class) {\n            Class<?> componentClass = (Class<?>) componentType;\n            String className;\n            // for int[], double[] etc.\n            if (componentClass.isPrimitive()) {\n                className = encodePrimitiveClass(componentClass);\n            } else // for String[], Integer[] etc.\n            {\n                className = \"L\" + componentClass.getName() + \";\";\n            }\n            Class<OUT> classArray;\n            try {\n                classArray = (Class<OUT>) Class.forName(\"[\" + className);\n            } catch (ClassNotFoundException e) {\n                throw new InvalidTypesException(\"Could not convert GenericArrayType to Class.\");\n            }\n            return getForClass(classArray);\n        }\n        TypeInformation<?> componentInfo = createTypeInfoWithTypeHierarchy(typeHierarchy, genericArray.getGenericComponentType(), in1Type, in2Type);\n        return ObjectArrayTypeInfo.getInfoFor(t, componentInfo);\n    } else // objects with generics are treated as Class first\n    if (t instanceof ParameterizedType) {\n        return (TypeInformation<OUT>) privateGetForClass(typeToClass(t), typeHierarchy, (ParameterizedType) t, in1Type, in2Type);\n    } else // no tuple, no TypeVariable, no generic type\n    if (t instanceof Class) {\n        return privateGetForClass((Class<OUT>) t, typeHierarchy);\n    }\n    throw new InvalidTypesException(\"Type Information could not be created.\");\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\nprivate <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoWithTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\n        if (isClassType(t) && Tuple.class.isAssignableFrom(typeToClass(t))) {\n        Type curT = t;\n                if (typeToClass(t).equals(Tuple.class)) {\n            throw new InvalidTypesException(\"Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead.\");\n        }\n                while (!(isClassType(curT) && typeToClass(curT).getSuperclass().equals(Tuple.class))) {\n            typeHierarchy.add(curT);\n            curT = typeToClass(curT).getGenericSuperclass();\n        }\n                if (curT instanceof Class<?>) {\n            throw new InvalidTypesException(\"Tuple needs to be parameterized by using generics.\");\n        }\n        typeHierarchy.add(curT);\n        ParameterizedType tupleChild = (ParameterizedType) curT;\n        Type[] subtypes = new Type[tupleChild.getActualTypeArguments().length];\n                for (int i = 0; i < subtypes.length; i++) {\n                        if (tupleChild.getActualTypeArguments()[i] instanceof TypeVariable<?>) {\n                subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) tupleChild.getActualTypeArguments()[i]);\n            } else             {\n                subtypes[i] = tupleChild.getActualTypeArguments()[i];\n            }\n        }\n        TypeInformation<?>[] tupleSubTypes = new TypeInformation<?>[subtypes.length];\n        for (int i = 0; i < subtypes.length; i++) {\n                        if (subtypes[i] instanceof TypeVariable<?>) {\n                tupleSubTypes[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], typeHierarchy, in1Type, in2Type);\n                                if (tupleSubTypes[i] == null) {\n                    throw new InvalidTypesException(\"Type of TypeVariable '\" + ((TypeVariable<?>) subtypes[i]).getName() + \"' in '\" + ((TypeVariable<?>) subtypes[i]).getGenericDeclaration() + \"' could not be determined. This is most likely a type erasure problem. \" + \"The type extraction currently supports types with generic variables only in cases where \" + \"all variables in the return type can be deduced from the input type(s).\");\n                }\n            } else {\n                tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new ArrayList<Type>(typeHierarchy), subtypes[i], in1Type, in2Type);\n            }\n        }\n        Class<?> tAsClass = null;\n        if (isClassType(t)) {\n            tAsClass = typeToClass(t);\n        }\n        Preconditions.checkNotNull(tAsClass, \"t has a unexpected type\");\n                        int fieldCount = countFieldsInClass(tAsClass);\n        if (fieldCount != tupleSubTypes.length) {\n                        if (t instanceof ParameterizedType) {\n                return (TypeInformation<OUT>) analyzePojo(tAsClass, new ArrayList<Type>(typeHierarchy), (ParameterizedType) t, in1Type, in2Type);\n            } else {\n                return (TypeInformation<OUT>) analyzePojo(tAsClass, new ArrayList<Type>(typeHierarchy), null, in1Type, in2Type);\n            }\n        }\n        return new TupleTypeInfo(tAsClass, tupleSubTypes);\n    } else     if (t instanceof TypeVariable) {\n        Type typeVar = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) t);\n        if (!(typeVar instanceof TypeVariable)) {\n            return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);\n        } else         {\n            TypeInformation<OUT> typeInfo = (TypeInformation<OUT>) createTypeInfoFromInputs((TypeVariable<?>) t, typeHierarchy, in1Type, in2Type);\n            if (typeInfo != null) {\n                return typeInfo;\n            } else {\n                throw new InvalidTypesException(\"Type of TypeVariable '\" + ((TypeVariable<?>) t).getName() + \"' in '\" + ((TypeVariable<?>) t).getGenericDeclaration() + \"' could not be determined. This is most likely a type erasure problem. \" + \"The type extraction currently supports types with generic variables only in cases where \" + \"all variables in the return type can be deduced from the input type(s).\");\n            }\n        }\n    } else     if (t instanceof GenericArrayType) {\n        GenericArrayType genericArray = (GenericArrayType) t;\n        Type componentType = genericArray.getGenericComponentType();\n                if (componentType instanceof Class) {\n            Class<?> componentClass = (Class<?>) componentType;\n            String className;\n                        if (componentClass.isPrimitive()) {\n                className = encodePrimitiveClass(componentClass);\n            } else             {\n                className = \"L\" + componentClass.getName() + \";\";\n            }\n            Class<OUT> classArray;\n            try {\n                classArray = (Class<OUT>) Class.forName(\"[\" + className);\n            } catch (ClassNotFoundException e) {\n                throw new InvalidTypesException(\"Could not convert GenericArrayType to Class.\");\n            }\n            return getForClass(classArray);\n        }\n        TypeInformation<?> componentInfo = createTypeInfoWithTypeHierarchy(typeHierarchy, genericArray.getGenericComponentType(), in1Type, in2Type);\n        return ObjectArrayTypeInfo.getInfoFor(t, componentInfo);\n    } else     if (t instanceof ParameterizedType) {\n        return (TypeInformation<OUT>) privateGetForClass(typeToClass(t), typeHierarchy, (ParameterizedType) t, in1Type, in2Type);\n    } else     if (t instanceof Class) {\n        return privateGetForClass((Class<OUT>) t, typeHierarchy);\n    }\n    throw new InvalidTypesException(\"Type Information could not be created.\");\n}", "lc": 3.727272727272727, "pi": 0.5204081632653061, "ma": 4.0, "nbd": 1.5, "ml": 2.75, "d": 2.605042016806723, "mi": -1.4252939489532555, "fo": 3.25, "r": -0.028571428571428574, "e": 14.03937793653445}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-2712_06090da4", "label": 1, "code": "public void resolve(RepositoryMetadata metadata, List remoteRepositories, ArtifactRepository localRepository) throws RepositoryMetadataResolutionException {\n    boolean alreadyResolved = alreadyResolved(metadata);\n    if (!alreadyResolved) {\n        for (Iterator i = remoteRepositories.iterator(); i.hasNext(); ) {\n            ArtifactRepository repository = (ArtifactRepository) i.next();\n            ArtifactRepositoryPolicy policy = metadata.isSnapshot() ? repository.getSnapshots() : repository.getReleases();\n            if (!policy.isEnabled()) {\n                getLogger().debug(\"Skipping disabled repository \" + repository.getId());\n            } else if (repository.isBlacklisted()) {\n                getLogger().debug(\"Skipping blacklisted repository \" + repository.getId());\n            } else {\n                File file = new File(localRepository.getBasedir(), localRepository.pathOfLocalRepositoryMetadata(metadata, repository));\n                boolean checkForUpdates = policy.checkOutOfDate(new Date(file.lastModified())) || !file.exists();\n                boolean metadataIsEmpty = true;\n                if (checkForUpdates) {\n                    getLogger().info(metadata.getKey() + \": checking for updates from \" + repository.getId());\n                    try {\n                        resolveAlways(metadata, repository, file, policy.getChecksumPolicy(), true);\n                        metadataIsEmpty = false;\n                    } catch (TransferFailedException e) {\n                        // TODO: [jc; 08-Nov-2005] revisit this for 2.1\n                        // suppressing logging to avoid logging this error twice.\n                        metadataIsEmpty = true;\n                    }\n                }\n                // touch file so that this is not checked again until interval has passed\n                if (file.exists()) {\n                    file.setLastModified(System.currentTimeMillis());\n                } else if (!metadataIsEmpty) {\n                    // this ensures that files are not continuously checked when they don't exist remotely\n                    try {\n                        metadata.storeInLocalRepository(localRepository, repository);\n                    } catch (RepositoryMetadataStoreException e) {\n                        throw new RepositoryMetadataResolutionException(\"Unable to store local copy of metadata: \" + e.getMessage(), e);\n                    }\n                }\n            }\n        }\n        cachedMetadata.add(metadata.getKey());\n    }\n    try {\n        mergeMetadata(metadata, remoteRepositories, localRepository);\n    } catch (RepositoryMetadataStoreException e) {\n        throw new RepositoryMetadataResolutionException(\"Unable to store local copy of metadata: \" + e.getMessage(), e);\n    } catch (RepositoryMetadataReadException e) {\n        throw new RepositoryMetadataResolutionException(\"Unable to read local copy of metadata: \" + e.getMessage(), e);\n    }\n}", "code_comment": NaN, "code_no_comment": "public void resolve(RepositoryMetadata metadata, List remoteRepositories, ArtifactRepository localRepository) throws RepositoryMetadataResolutionException {\n    boolean alreadyResolved = alreadyResolved(metadata);\n    if (!alreadyResolved) {\n        for (Iterator i = remoteRepositories.iterator(); i.hasNext(); ) {\n            ArtifactRepository repository = (ArtifactRepository) i.next();\n            ArtifactRepositoryPolicy policy = metadata.isSnapshot() ? repository.getSnapshots() : repository.getReleases();\n            if (!policy.isEnabled()) {\n                getLogger().debug(\"Skipping disabled repository \" + repository.getId());\n            } else if (repository.isBlacklisted()) {\n                getLogger().debug(\"Skipping blacklisted repository \" + repository.getId());\n            } else {\n                File file = new File(localRepository.getBasedir(), localRepository.pathOfLocalRepositoryMetadata(metadata, repository));\n                boolean checkForUpdates = policy.checkOutOfDate(new Date(file.lastModified())) || !file.exists();\n                boolean metadataIsEmpty = true;\n                if (checkForUpdates) {\n                    getLogger().info(metadata.getKey() + \": checking for updates from \" + repository.getId());\n                    try {\n                        resolveAlways(metadata, repository, file, policy.getChecksumPolicy(), true);\n                        metadataIsEmpty = false;\n                    } catch (TransferFailedException e) {\n                                                                        metadataIsEmpty = true;\n                    }\n                }\n                                if (file.exists()) {\n                    file.setLastModified(System.currentTimeMillis());\n                } else if (!metadataIsEmpty) {\n                                        try {\n                        metadata.storeInLocalRepository(localRepository, repository);\n                    } catch (RepositoryMetadataStoreException e) {\n                        throw new RepositoryMetadataResolutionException(\"Unable to store local copy of metadata: \" + e.getMessage(), e);\n                    }\n                }\n            }\n        }\n        cachedMetadata.add(metadata.getKey());\n    }\n    try {\n        mergeMetadata(metadata, remoteRepositories, localRepository);\n    } catch (RepositoryMetadataStoreException e) {\n        throw new RepositoryMetadataResolutionException(\"Unable to store local copy of metadata: \" + e.getMessage(), e);\n    } catch (RepositoryMetadataReadException e) {\n        throw new RepositoryMetadataResolutionException(\"Unable to read local copy of metadata: \" + e.getMessage(), e);\n    }\n}", "lc": 1.3636363636363635, "pi": 2.0204081632653064, "ma": 2.0, "nbd": 2.5, "ml": 0.9166666666666666, "d": 0.46366782006920415, "mi": -0.8462862059076574, "fo": 2.5, "r": -0.028571428571428574, "e": 1.432215041052591}
{"project_name": "Closure", "project_version": 82, "label": 2, "code": "public final boolean isEmptyType() {\n    return isNoType() || isNoObjectType() || isNoResolvedType();\n}", "code_comment": NaN, "code_no_comment": "public final boolean isEmptyType() {\n    return isNoType() || isNoObjectType() || isNoResolvedType();\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.1015199311729282, "fo": -0.25, "r": 2.5714285714285716, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-43_668f08f2", "label": 1, "code": "public void moveNode(String srcPath, String destPath) throws NotFoundException, Exception {\n    if (PathUtils.isAncestor(srcPath, destPath)) {\n        throw new Exception(\"target path cannot be descendant of source path: \" + destPath);\n    }\n    String srcParentPath = PathUtils.getParentPath(srcPath);\n    String srcNodeName = PathUtils.getName(srcPath);\n    String destParentPath = PathUtils.getParentPath(destPath);\n    String destNodeName = PathUtils.getName(destPath);\n    MutableNode srcParent = getOrCreateStagedNode(srcParentPath);\n    if (srcParentPath.equals(destParentPath)) {\n        if (srcParent.getChildNodeEntry(destNodeName) != null) {\n            throw new Exception(\"node already exists at move destination path: \" + destPath);\n        }\n        if (srcParent.rename(srcNodeName, destNodeName) == null) {\n            throw new NotFoundException(srcPath);\n        }\n    } else {\n        ChildNode srcCNE = srcParent.remove(srcNodeName);\n        if (srcCNE == null) {\n            throw new NotFoundException(srcPath);\n        }\n        MutableNode destParent = getOrCreateStagedNode(destParentPath);\n        if (destParent.getChildNodeEntry(destNodeName) != null) {\n            throw new Exception(\"node already exists at move destination path: \" + destPath);\n        }\n        destParent.add(new ChildNode(destNodeName, srcCNE.getId()));\n    }\n    // update staging area\n    moveStagedNodes(srcPath, destPath);\n    // update change log\n    changeLog.add(new MoveNode(srcPath, destPath));\n}", "code_comment": NaN, "code_no_comment": "public void moveNode(String srcPath, String destPath) throws NotFoundException, Exception {\n    if (PathUtils.isAncestor(srcPath, destPath)) {\n        throw new Exception(\"target path cannot be descendant of source path: \" + destPath);\n    }\n    String srcParentPath = PathUtils.getParentPath(srcPath);\n    String srcNodeName = PathUtils.getName(srcPath);\n    String destParentPath = PathUtils.getParentPath(destPath);\n    String destNodeName = PathUtils.getName(destPath);\n    MutableNode srcParent = getOrCreateStagedNode(srcParentPath);\n    if (srcParentPath.equals(destParentPath)) {\n        if (srcParent.getChildNodeEntry(destNodeName) != null) {\n            throw new Exception(\"node already exists at move destination path: \" + destPath);\n        }\n        if (srcParent.rename(srcNodeName, destNodeName) == null) {\n            throw new NotFoundException(srcPath);\n        }\n    } else {\n        ChildNode srcCNE = srcParent.remove(srcNodeName);\n        if (srcCNE == null) {\n            throw new NotFoundException(srcPath);\n        }\n        MutableNode destParent = getOrCreateStagedNode(destParentPath);\n        if (destParent.getChildNodeEntry(destNodeName) != null) {\n            throw new Exception(\"node already exists at move destination path: \" + destPath);\n        }\n        destParent.add(new ChildNode(destNodeName, srcCNE.getId()));\n    }\n        moveStagedNodes(srcPath, destPath);\n        changeLog.add(new MoveNode(srcPath, destPath));\n}", "lc": 0.7272727272727273, "pi": 0.09183673469387764, "ma": 1.3333333333333333, "nbd": 0.0, "ml": 1.0, "d": 0.6969846762234307, "mi": -0.5706911385144827, "fo": 0.8333333333333334, "r": -0.028571428571428574, "e": 1.1014772079955113}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5500_825da305", "label": 1, "code": "/**\n *  Loads page class with given name.\n *\n *  @param name\n *  @return class\n */\nprotected Class<? extends IRequestablePage> getPageClass(String name) {\n    Args.notEmpty(name, \"name\");\n    return WicketObjects.resolveClass(name);\n}", "code_comment": "/**\n *  Loads page class with given name.\n *\n *  @param name\n *  @return class\n */\n", "code_no_comment": "protected Class<? extends IRequestablePage> getPageClass(String name) {\n    Args.notEmpty(name, \"name\");\n    return WicketObjects.resolveClass(name);\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8150272440493259, "fo": -0.3333333333333333, "r": 2.685714285714286, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-3077_17654199", "label": 0, "code": "/**\n * Gets this class's ZooKeeper reader/writer.\n *\n * @return reader/writer\n */\nstatic IZooReaderWriter getZooReaderWriter() {\n    return zoo;\n}", "code_comment": "/**\n * Gets this class's ZooKeeper reader/writer.\n *\n * @return reader/writer\n */\n", "code_no_comment": "static IZooReaderWriter getZooReaderWriter() {\n    return zoo;\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.2001720676799543, "fo": -0.5, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "Compress", "project_version": 12, "label": 1, "code": "/**\n * Get the next entry in this tar archive. This will skip\n * over any remaining data in the current entry, if there\n * is one, and place the input stream at the header of the\n * next entry, and read the header and instantiate a new\n * TarEntry from the header bytes and return that entry.\n * If there are no more entries in the archive, null will\n * be returned to indicate that the end of the archive has\n * been reached.\n *\n * @return The next TarEntry in the archive, or null.\n * @throws IOException on error\n */\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n    if (currEntry.isGNULongNameEntry()) {\n        // read in the name\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            // Malformed tar file - long entry name not followed by entry\n            return null;\n        }\n        // remove trailing null terminator\n        if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n    if (currEntry.isPaxHeader()) {\n        // Process Pax headers\n        paxHeaders();\n    }\n    if (currEntry.isGNUSparse()) {\n        // Process sparse files\n        readGNUSparse();\n    }\n    // If the size of the next element in the archive has changed\n    // due to a new size being reported in the posix header\n    // information, we update entrySize here so that it contains\n    // the correct value.\n    entrySize = currEntry.getSize();\n    return currEntry;\n}", "code_comment": "/**\n * Get the next entry in this tar archive. This will skip\n * over any remaining data in the current entry, if there\n * is one, and place the input stream at the header of the\n * next entry, and read the header and instantiate a new\n * TarEntry from the header bytes and return that entry.\n * If there are no more entries in the archive, null will\n * be returned to indicate that the end of the archive has\n * been reached.\n *\n * @return The next TarEntry in the archive, or null.\n * @throws IOException on error\n */\n", "code_no_comment": "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n    if (currEntry.isGNULongNameEntry()) {\n                StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n                        return null;\n        }\n                if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n    if (currEntry.isPaxHeader()) {\n                paxHeaders();\n    }\n    if (currEntry.isGNUSparse()) {\n                readGNUSparse();\n    }\n                    entrySize = currEntry.getSize();\n    return currEntry;\n}", "lc": 1.5454545454545454, "pi": 0.1632653061224489, "ma": 1.5, "nbd": 0.5, "ml": 1.3333333333333333, "d": 1.4720711814137422, "mi": -0.8190421565815891, "fo": 1.0833333333333333, "r": -0.028571428571428574, "e": 2.3765788222596274}
{"project_name": "Math", "project_version": 13, "label": 0, "code": "/**\n * Computes the square-root of the weight matrix.\n *\n * @param m Symmetric, positive-definite (weight) matrix.\n * @return the square-root of the weight matrix.\n */\nprivate RealMatrix squareRoot(RealMatrix m) {\n    final EigenDecomposition dec = new EigenDecomposition(m);\n    return dec.getSquareRoot();\n}", "code_comment": "/**\n * Computes the square-root of the weight matrix.\n *\n * @param m Symmetric, positive-definite (weight) matrix.\n * @return the square-root of the weight matrix.\n */\n", "code_no_comment": "private RealMatrix squareRoot(RealMatrix m) {\n    final EigenDecomposition dec = new EigenDecomposition(m);\n    return dec.getSquareRoot();\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8422712933753946, "fo": -0.4166666666666667, "r": 2.7714285714285714, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5071_d3d42d42", "label": 1, "code": "private boolean matches(final Request request) {\n    boolean matches = false;\n    Url url = request.getUrl();\n    Url baseUrl = request.getClientUrl();\n    String namespace = getContext().getNamespace();\n    String bookmarkableIdentifier = getContext().getBookmarkableIdentifier();\n    String pageIdentifier = getContext().getPageIdentifier();\n    if (url.getSegments().size() >= 3 && urlStartsWith(url, namespace, bookmarkableIdentifier)) {\n        matches = true;\n    } else // baseUrl = 'wicket/bookmarkable/com.example.SomePage[?...]', requestUrl = 'bookmarkable/com.example.SomePage'\n    if (baseUrl.getSegments().size() == 3 && urlStartsWith(baseUrl, namespace, bookmarkableIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier)) {\n        matches = true;\n    } else // baseUrl = 'wicket/page[?...]', requestUrl = 'bookmarkable/com.example.SomePage'\n    if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, namespace, pageIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier)) {\n        matches = true;\n    }\n    return matches;\n}", "code_comment": NaN, "code_no_comment": "private boolean matches(final Request request) {\n    boolean matches = false;\n    Url url = request.getUrl();\n    Url baseUrl = request.getClientUrl();\n    String namespace = getContext().getNamespace();\n    String bookmarkableIdentifier = getContext().getBookmarkableIdentifier();\n    String pageIdentifier = getContext().getPageIdentifier();\n    if (url.getSegments().size() >= 3 && urlStartsWith(url, namespace, bookmarkableIdentifier)) {\n        matches = true;\n    } else     if (baseUrl.getSegments().size() == 3 && urlStartsWith(baseUrl, namespace, bookmarkableIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier)) {\n        matches = true;\n    } else     if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, namespace, pageIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier)) {\n        matches = true;\n    }\n    return matches;\n}", "lc": 0.18181818181818182, "pi": -0.4693877551020408, "ma": 0.0, "nbd": 0.5, "ml": 1.3333333333333333, "d": 0.7899159663865548, "mi": -0.25035847433323793, "fo": 1.4166666666666667, "r": -0.028571428571428574, "e": 0.956548926893409}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-447_0343e9c7", "label": 1, "code": "/**\n * Formats a {@link org.apache.logging.log4j.core.LogEvent} in conformance with the log4j.dtd.\n *\n * @param event The LogEvent.\n * @return The XML representation of the LogEvent.\n */\n@Override\npublic String toSerializable(final LogEvent event) {\n    final StringBuilder buf = new StringBuilder(DEFAULT_SIZE);\n    buf.append(this.indent1);\n    buf.append('<');\n    if (!complete) {\n        buf.append(this.namespacePrefix);\n    }\n    buf.append(\"Event logger=\\\"\");\n    String name = event.getLoggerName();\n    if (name.isEmpty()) {\n        name = \"root\";\n    }\n    buf.append(Transform.escapeHtmlTags(name));\n    buf.append(\"\\\" timestamp=\\\"\");\n    buf.append(event.getMillis());\n    buf.append(\"\\\" level=\\\"\");\n    buf.append(Transform.escapeHtmlTags(String.valueOf(event.getLevel())));\n    buf.append(\"\\\" thread=\\\"\");\n    buf.append(Transform.escapeHtmlTags(event.getThreadName()));\n    buf.append(\"\\\">\");\n    buf.append(this.eol);\n    final Message msg = event.getMessage();\n    if (msg != null) {\n        boolean xmlSupported = false;\n        if (msg instanceof MultiformatMessage) {\n            final String[] formats = ((MultiformatMessage) msg).getFormats();\n            for (final String format : formats) {\n                if (format.equalsIgnoreCase(\"XML\")) {\n                    xmlSupported = true;\n                    break;\n                }\n            }\n        }\n        buf.append(this.indent2);\n        buf.append('<');\n        if (!complete) {\n            buf.append(this.namespacePrefix);\n        }\n        buf.append(\"Message>\");\n        if (xmlSupported) {\n            buf.append(((MultiformatMessage) msg).getFormattedMessage(FORMATS));\n        } else {\n            buf.append(\"<![CDATA[\");\n            // Append the rendered message. Also make sure to escape any\n            // existing CDATA sections.\n            Transform.appendEscapingCDATA(buf, event.getMessage().getFormattedMessage());\n            buf.append(\"]]>\");\n        }\n        buf.append(\"</\");\n        if (!complete) {\n            buf.append(this.namespacePrefix);\n        }\n        buf.append(\"Message>\");\n        buf.append(this.eol);\n    }\n    if (event.getContextStack().getDepth() > 0) {\n        buf.append(this.indent2);\n        buf.append('<');\n        if (!complete) {\n            buf.append(this.namespacePrefix);\n        }\n        buf.append(\"NDC><![CDATA[\");\n        Transform.appendEscapingCDATA(buf, event.getContextStack().toString());\n        buf.append(\"]]></\");\n        if (!complete) {\n            buf.append(this.namespacePrefix);\n        }\n        buf.append(\"NDC>\");\n        buf.append(this.eol);\n    }\n    final Throwable throwable = event.getThrown();\n    if (throwable != null) {\n        final List<String> s = Throwables.toStringList(throwable);\n        buf.append(this.indent2);\n        buf.append('<');\n        if (!complete) {\n            buf.append(this.namespacePrefix);\n        }\n        buf.append(\"Throwable><![CDATA[\");\n        for (final String str : s) {\n            Transform.appendEscapingCDATA(buf, str);\n            buf.append(this.eol);\n        }\n        buf.append(\"]]></\");\n        if (!complete) {\n            buf.append(this.namespacePrefix);\n        }\n        buf.append(\"Throwable>\");\n        buf.append(this.eol);\n    }\n    if (locationInfo) {\n        final StackTraceElement element = event.getSource();\n        buf.append(this.indent2);\n        buf.append('<');\n        if (!complete) {\n            buf.append(this.namespacePrefix);\n        }\n        buf.append(\"LocationInfo class=\\\"\");\n        buf.append(Transform.escapeHtmlTags(element.getClassName()));\n        buf.append(\"\\\" method=\\\"\");\n        buf.append(Transform.escapeHtmlTags(element.getMethodName()));\n        buf.append(\"\\\" file=\\\"\");\n        buf.append(Transform.escapeHtmlTags(element.getFileName()));\n        buf.append(\"\\\" line=\\\"\");\n        buf.append(element.getLineNumber());\n        buf.append(\"\\\"/>\");\n        buf.append(this.eol);\n    }\n    if (properties && event.getContextMap().size() > 0) {\n        buf.append(this.indent2);\n        buf.append('<');\n        if (!complete) {\n            buf.append(this.namespacePrefix);\n        }\n        buf.append(\"Properties>\");\n        buf.append(this.eol);\n        for (final Map.Entry<String, String> entry : event.getContextMap().entrySet()) {\n            buf.append(this.indent3);\n            buf.append('<');\n            if (!complete) {\n                buf.append(this.namespacePrefix);\n            }\n            buf.append(\"Data name=\\\"\");\n            buf.append(Transform.escapeHtmlTags(entry.getKey()));\n            buf.append(\"\\\" value=\\\"\");\n            buf.append(Transform.escapeHtmlTags(String.valueOf(entry.getValue())));\n            buf.append(\"\\\"/>\");\n            buf.append(this.eol);\n        }\n        buf.append(this.indent2);\n        buf.append(\"</\");\n        if (!complete) {\n            buf.append(this.namespacePrefix);\n        }\n        buf.append(\"Properties>\");\n        buf.append(this.eol);\n    }\n    buf.append(this.indent1);\n    buf.append(\"</\");\n    if (!complete) {\n        buf.append(this.namespacePrefix);\n    }\n    buf.append(\"Event>\");\n    buf.append(this.eol);\n    return buf.toString();\n}", "code_comment": "/**\n * Formats a {@link org.apache.logging.log4j.core.LogEvent} in conformance with the log4j.dtd.\n *\n * @param event The LogEvent.\n * @return The XML representation of the LogEvent.\n */\n", "code_no_comment": "@Override\npublic String toSerializable(final LogEvent event) {\n    final StringBuilder buf = new StringBuilder(DEFAULT_SIZE);\n    buf.append(this.indent1);\n    buf.append('<');\n    if (!complete) {\n        buf.append(this.namespacePrefix);\n    }\n    buf.append(\"Event logger=\\\"\");\n    String name = event.getLoggerName();\n    if (name.isEmpty()) {\n        name = \"root\";\n    }\n    buf.append(Transform.escapeHtmlTags(name));\n    buf.append(\"\\\" timestamp=\\\"\");\n    buf.append(event.getMillis());\n    buf.append(\"\\\" level=\\\"\");\n    buf.append(Transform.escapeHtmlTags(String.valueOf(event.getLevel())));\n    buf.append(\"\\\" thread=\\\"\");\n    buf.append(Transform.escapeHtmlTags(event.getThreadName()));\n    buf.append(\"\\\">\");\n    buf.append(this.eol);\n    final Message msg = event.getMessage();\n    if (msg != null) {\n        boolean xmlSupported = false;\n        if (msg instanceof MultiformatMessage) {\n            final String[] formats = ((MultiformatMessage) msg).getFormats();\n            for (final String format : formats) {\n                if (format.equalsIgnoreCase(\"XML\")) {\n                    xmlSupported = true;\n                    break;\n                }\n            }\n        }\n        buf.append(this.indent2);\n        buf.append('<');\n        if (!complete) {\n            buf.append(this.namespacePrefix);\n        }\n        buf.append(\"Message>\");\n        if (xmlSupported) {\n            buf.append(((MultiformatMessage) msg).getFormattedMessage(FORMATS));\n        } else {\n            buf.append(\"<![CDATA[\");\n                                    Transform.appendEscapingCDATA(buf, event.getMessage().getFormattedMessage());\n            buf.append(\"]]>\");\n        }\n        buf.append(\"</\");\n        if (!complete) {\n            buf.append(this.namespacePrefix);\n        }\n        buf.append(\"Message>\");\n        buf.append(this.eol);\n    }\n    if (event.getContextStack().getDepth() > 0) {\n        buf.append(this.indent2);\n        buf.append('<');\n        if (!complete) {\n            buf.append(this.namespacePrefix);\n        }\n        buf.append(\"NDC><![CDATA[\");\n        Transform.appendEscapingCDATA(buf, event.getContextStack().toString());\n        buf.append(\"]]></\");\n        if (!complete) {\n            buf.append(this.namespacePrefix);\n        }\n        buf.append(\"NDC>\");\n        buf.append(this.eol);\n    }\n    final Throwable throwable = event.getThrown();\n    if (throwable != null) {\n        final List<String> s = Throwables.toStringList(throwable);\n        buf.append(this.indent2);\n        buf.append('<');\n        if (!complete) {\n            buf.append(this.namespacePrefix);\n        }\n        buf.append(\"Throwable><![CDATA[\");\n        for (final String str : s) {\n            Transform.appendEscapingCDATA(buf, str);\n            buf.append(this.eol);\n        }\n        buf.append(\"]]></\");\n        if (!complete) {\n            buf.append(this.namespacePrefix);\n        }\n        buf.append(\"Throwable>\");\n        buf.append(this.eol);\n    }\n    if (locationInfo) {\n        final StackTraceElement element = event.getSource();\n        buf.append(this.indent2);\n        buf.append('<');\n        if (!complete) {\n            buf.append(this.namespacePrefix);\n        }\n        buf.append(\"LocationInfo class=\\\"\");\n        buf.append(Transform.escapeHtmlTags(element.getClassName()));\n        buf.append(\"\\\" method=\\\"\");\n        buf.append(Transform.escapeHtmlTags(element.getMethodName()));\n        buf.append(\"\\\" file=\\\"\");\n        buf.append(Transform.escapeHtmlTags(element.getFileName()));\n        buf.append(\"\\\" line=\\\"\");\n        buf.append(element.getLineNumber());\n        buf.append(\"\\\"/>\");\n        buf.append(this.eol);\n    }\n    if (properties && event.getContextMap().size() > 0) {\n        buf.append(this.indent2);\n        buf.append('<');\n        if (!complete) {\n            buf.append(this.namespacePrefix);\n        }\n        buf.append(\"Properties>\");\n        buf.append(this.eol);\n        for (final Map.Entry<String, String> entry : event.getContextMap().entrySet()) {\n            buf.append(this.indent3);\n            buf.append('<');\n            if (!complete) {\n                buf.append(this.namespacePrefix);\n            }\n            buf.append(\"Data name=\\\"\");\n            buf.append(Transform.escapeHtmlTags(entry.getKey()));\n            buf.append(\"\\\" value=\\\"\");\n            buf.append(Transform.escapeHtmlTags(String.valueOf(entry.getValue())));\n            buf.append(\"\\\"/>\");\n            buf.append(this.eol);\n        }\n        buf.append(this.indent2);\n        buf.append(\"</\");\n        if (!complete) {\n            buf.append(this.namespacePrefix);\n        }\n        buf.append(\"Properties>\");\n        buf.append(this.eol);\n    }\n    buf.append(this.indent1);\n    buf.append(\"</\");\n    if (!complete) {\n        buf.append(this.namespacePrefix);\n    }\n    buf.append(\"Event>\");\n    buf.append(this.eol);\n    return buf.toString();\n}", "lc": 5.954545454545454, "pi": 0.21428571428571425, "ma": 3.6666666666666665, "nbd": 1.0, "ml": 2.25, "d": 1.179436480474543, "mi": -1.6329222827645546, "fo": 9.5, "r": -0.028571428571428574, "e": 8.866700074095966}
{"project_name": "Closure", "project_version": 57, "label": 2, "code": "private static String extractClassNameIfGoog(Node node, Node parent, String functionName) {\n    String className = null;\n    if (NodeUtil.isExprCall(parent)) {\n        Node callee = node.getFirstChild();\n        if (callee != null && callee.getType() == Token.GETPROP) {\n            String qualifiedName = callee.getQualifiedName();\n            if (functionName.equals(qualifiedName)) {\n                Node target = callee.getNext();\n                if (target != null) {\n                    className = target.getString();\n                }\n            }\n        }\n    }\n    return className;\n}", "code_comment": NaN, "code_no_comment": "private static String extractClassNameIfGoog(Node node, Node parent, String functionName) {\n    String className = null;\n    if (NodeUtil.isExprCall(parent)) {\n        Node callee = node.getFirstChild();\n        if (callee != null && callee.getType() == Token.GETPROP) {\n            String qualifiedName = callee.getQualifiedName();\n            if (functionName.equals(qualifiedName)) {\n                Node target = callee.getNext();\n                if (target != null) {\n                    className = target.getString();\n                }\n            }\n        }\n    }\n    return className;\n}", "lc": 0.09090909090909091, "pi": 1.4795918367346939, "ma": 0.16666666666666666, "nbd": 1.0, "ml": 0.5833333333333334, "d": 0.374691052891745, "mi": -0.11098365357040452, "fo": 0.08333333333333333, "r": 0.1142857142857143, "e": 0.2277958377769497}
{"project_name": "Closure", "project_version": 157, "label": 2, "code": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n        Preconditions.checkState(childCount == 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p = NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        // For right-hand-side of operations, only pass context if it's\n        // the IN_FOR_INIT_CLAUSE one.\n        Context rhsContext = getContextForNoInOperator(context);\n        // we can simply generate a * b * c.\n        if (last.getType() == type && NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n            // Assignments are the only right-associative binary operators\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() == Token.BLOCK && !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount >= 2 && childCount <= 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                // second child contains the catch block, or nothing if there\n                // isn't a catch block\n                Node catchblock = first.getNext().getFirstChild();\n                if (catchblock != null) {\n                    add(catchblock);\n                }\n                if (childCount == 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount == 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount == 1);\n            add(\"throw\");\n            add(first);\n            // Must have a ';' after a throw statement, otherwise safari can't\n            // parse this.\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount == 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount == 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first != null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first == null || first.getType() == Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount == 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"=\", true);\n                if (first.getType() == Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    // Add expression, consider nearby code at lowest level of\n                    // precedence.\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount == 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount == ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                // All of these unary operators are right-associative\n                Preconditions.checkState(childCount == 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount == 1);\n                // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n                if (n.getFirstChild().getType() == Token.NUMBER) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type));\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount == 3);\n                int p = NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() != Token.STRING || last.getType() != Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n            // I only use one .add because whitespace matters\n            if (childCount == 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount == 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount == 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() != Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount == 3);\n            boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context == Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);\n            Preconditions.checkState(childCount == 1);\n            Preconditions.checkState(first.getType() == Token.FUNCTION);\n            // Get methods are unnamed\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type == Token.GET) {\n                // Get methods have no parameters.\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                // Set methods have one parameter.\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            // The name is on the GET or SET node.\n            String name = n.getString();\n            Node fn = first;\n            Node parameters = fn.getChildAtIndex(1);\n            Node body = fn.getLastChild();\n            // Add the property name.\n            if (TokenStream.isJSIdentifier(name) && // unicode escaped.\n            NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                // Determine if the string is a simple number.\n                add(jsString(n.getString(), outputCharsetEncoder));\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() != Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().getType() == Token.SCRIPT);\n                for (Node c = first; c != null; c = c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    // VAR doesn't include ';' since it gets used in expressions\n                    if (c.getType() == Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() == Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    // because top level statements are more homogeneous.\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount == 4) {\n                add(\"for(\");\n                if (first.getType() == Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount == 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount == 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount == 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount == 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount == 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() == Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens = (first.getType() == Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount == 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount == 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount == 1);\n                String o = type == Token.INC ? \"++\" : \"--\";\n                int postProp = n.getIntProp(Node.INCRDECR_PROP);\n                // is a pre-inc/dec.\n                if (postProp != 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            // that must be preserved.\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse = childCount == 3;\n            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount == 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount == 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount <= 1);\n            add(\"continue\");\n            if (childCount == 1) {\n                if (first.getType() != Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount == 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount <= 1);\n            add(\"break\");\n            if (childCount == 1) {\n                if (first.getType() != Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount == 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence = NodeUtil.precedence(type);\n            // first viable parentheses (don't traverse into functions).\n            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                precedence = NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            // '()' is optional when no arguments are present\n            Node next = first.getNext();\n            if (next != null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount != ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount == 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens = (context == Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c = first; c != null; c = c.getNext()) {\n                    if (c != first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() == Token.GET || c.getType() == Token.SET) {\n                        add(c);\n                    } else {\n                        // are not JavaScript keywords\n                        if (c.getType() == Token.STRING && !c.isQuotedString() && !TokenStream.isKeyword(c.getString()) && TokenStream.isJSIdentifier(c.getString()) && // were unicode escaped.\n                        NodeUtil.isLatin(c.getString())) {\n                            add(c.getString());\n                        } else {\n                            // Determine if the string is a simple number.\n                            addExpr(c, 1);\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context == Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount == 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount == 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount == 2);\n            if (first.getType() != Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        // ignored for our purposes.\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}", "code_comment": NaN, "code_no_comment": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n        if (opstr != null && first != last) {\n        Preconditions.checkState(childCount == 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p = NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n                        Context rhsContext = getContextForNoInOperator(context);\n                if (last.getType() == type && NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n                        addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() == Token.BLOCK && !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount >= 2 && childCount <= 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                                                Node catchblock = first.getNext().getFirstChild();\n                if (catchblock != null) {\n                    add(catchblock);\n                }\n                if (childCount == 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount == 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount == 1);\n            add(\"throw\");\n            add(first);\n                                    cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount == 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount == 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first != null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first == null || first.getType() == Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount == 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"=\", true);\n                if (first.getType() == Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                                                            addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount == 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount == ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                                Preconditions.checkState(childCount == 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount == 1);\n                                if (n.getFirstChild().getType() == Token.NUMBER) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type));\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount == 3);\n                int p = NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() != Token.STRING || last.getType() != Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n                        if (childCount == 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount == 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount == 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() != Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount == 3);\n            boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context == Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);\n            Preconditions.checkState(childCount == 1);\n            Preconditions.checkState(first.getType() == Token.FUNCTION);\n                        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type == Token.GET) {\n                                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n                        String name = n.getString();\n            Node fn = first;\n            Node parameters = fn.getChildAtIndex(1);\n            Node body = fn.getLastChild();\n                        if (TokenStream.isJSIdentifier(name) &&             NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                                add(jsString(n.getString(), outputCharsetEncoder));\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() != Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().getType() == Token.SCRIPT);\n                for (Node c = first; c != null; c = c.getNext()) {\n                    add(c, Context.STATEMENT);\n                                        if (c.getType() == Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() == Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                                        if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount == 4) {\n                add(\"for(\");\n                if (first.getType() == Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount == 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount == 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount == 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount == 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount == 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() == Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens = (first.getType() == Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount == 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount == 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount == 1);\n                String o = type == Token.INC ? \"++\" : \"--\";\n                int postProp = n.getIntProp(Node.INCRDECR_PROP);\n                                if (postProp != 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n                        if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse = childCount == 3;\n            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount == 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount == 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount <= 1);\n            add(\"continue\");\n            if (childCount == 1) {\n                if (first.getType() != Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount == 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount <= 1);\n            add(\"break\");\n            if (childCount == 1) {\n                if (first.getType() != Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount == 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence = NodeUtil.precedence(type);\n                        if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                precedence = NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n                        Node next = first.getNext();\n            if (next != null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount != ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount == 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens = (context == Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c = first; c != null; c = c.getNext()) {\n                    if (c != first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() == Token.GET || c.getType() == Token.SET) {\n                        add(c);\n                    } else {\n                                                if (c.getType() == Token.STRING && !c.isQuotedString() && !TokenStream.isKeyword(c.getString()) && TokenStream.isJSIdentifier(c.getString()) &&                         NodeUtil.isLatin(c.getString())) {\n                            add(c.getString());\n                        } else {\n                                                        addExpr(c, 1);\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context == Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount == 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount == 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount == 2);\n            if (first.getType() != Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n                case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}", "lc": 21.454545454545453, "pi": 0.5255102040816325, "ma": 26.166666666666668, "nbd": 1.5, "ml": 13.0, "d": 4.928324270884826, "mi": -3.2887869228563247, "fo": 28.666666666666668, "r": -0.028571428571428574, "e": 120.09251716413756}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5082_217fbb3b", "label": 1, "code": "@Override\npublic void renderHead(final Component component, final IHeaderResponse response) {\n    super.renderHead(component, response);\n    if (component.isEnabledInHierarchy()) {\n        CharSequence js = getCallbackScript(component);\n        AjaxRequestTarget target = component.getRequestCycle().find(AjaxRequestTarget.class);\n        if (target == null) {\n            response.render(OnDomReadyHeaderItem.forScript(js.toString()));\n        } else {\n            target.appendJavaScript(js);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void renderHead(final Component component, final IHeaderResponse response) {\n    super.renderHead(component, response);\n    if (component.isEnabledInHierarchy()) {\n        CharSequence js = getCallbackScript(component);\n        AjaxRequestTarget target = component.getRequestCycle().find(AjaxRequestTarget.class);\n        if (target == null) {\n            response.render(OnDomReadyHeaderItem.forScript(js.toString()));\n        } else {\n            target.appendJavaScript(js);\n        }\n    }\n}", "lc": -0.045454545454545456, "pi": 0.5204081632653061, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.07019278299555112, "mi": 0.05649555491826783, "fo": 0.25, "r": 0.0, "e": -0.05462542990650202}
{"project_name": "Closure", "project_version": 168, "label": 2, "code": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (t.inGlobalScope()) {\n        return;\n    }\n    if (n.isReturn() && n.getFirstChild() != null) {\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n    }\n    if (t.getScopeDepth() <= 2) {\n        // no reason to do this extra computation for them.\n        return;\n    }\n    if (n.isName() && NodeUtil.isLValue(n) && // in the inner scope, not the scope where the name appears.\n    !NodeUtil.isBleedingFunctionName(n)) {\n        String name = n.getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n            Scope ownerScope = var.getScope();\n            if (ownerScope.isLocal()) {\n                data.get(ownerScope.getRootNode()).recordAssignedName(name);\n            }\n            if (scope != ownerScope && ownerScope.isLocal()) {\n                data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n            }\n        }\n    } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) {\n        String name = NodeUtil.getRootOfQualifiedName(n).getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n            Scope ownerScope = var.getScope();\n            if (scope != ownerScope && ownerScope.isLocal()) {\n                data.get(ownerScope.getRootNode()).recordEscapedQualifiedName(n.getQualifiedName());\n            }\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (t.inGlobalScope()) {\n        return;\n    }\n    if (n.isReturn() && n.getFirstChild() != null) {\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n    }\n    if (t.getScopeDepth() <= 2) {\n                return;\n    }\n    if (n.isName() && NodeUtil.isLValue(n) &&     !NodeUtil.isBleedingFunctionName(n)) {\n        String name = n.getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n            Scope ownerScope = var.getScope();\n            if (ownerScope.isLocal()) {\n                data.get(ownerScope.getRootNode()).recordAssignedName(name);\n            }\n            if (scope != ownerScope && ownerScope.isLocal()) {\n                data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n            }\n        }\n    } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) {\n        String name = NodeUtil.getRootOfQualifiedName(n).getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n            Scope ownerScope = var.getScope();\n            if (scope != ownerScope && ownerScope.isLocal()) {\n                data.get(ownerScope.getRootNode()).recordEscapedQualifiedName(n.getQualifiedName());\n            }\n        }\n    }\n}", "lc": 1.0454545454545454, "pi": 0.6326530612244897, "ma": 1.1666666666666667, "nbd": 1.0, "ml": 2.1666666666666665, "d": 0.6613939693524469, "mi": -0.70117579581302, "fo": 2.4166666666666665, "r": -0.028571428571428574, "e": 1.4310928940684682}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4", "label": 1, "code": "/**\n *  Traverses all child components of the given class in this container,\n *  calling the visitor's visit method at each one.\n *\n *  @param clazz\n *             The class of child to visit, or null to visit all children\n *  @param visitor\n *             The visitor to call back to\n *  @return The return value from a visitor which halted the traversal, or\n *          null if the entire traversal occurred\n */\npublic final Object visitChildren(final Class clazz, final IVisitor visitor) {\n    if (visitor == null) {\n        throw new IllegalArgumentException(\"argument visitor may not be null\");\n    }\n    // Iterate through children of this container\n    for (int i = 0; i < children_size(); i++) {\n        // Get next child component\n        final Component child = children_get(i);\n        Object value = null;\n        // Is the child of the correct class (or was no class specified)?\n        if (clazz == null || clazz.isInstance(child)) {\n            // Call visitor\n            value = visitor.component(child);\n            // If visitor returns a non-null value, it halts the traversal\n            if ((value != IVisitor.CONTINUE_TRAVERSAL) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {\n                return value;\n            }\n        }\n        // If child is a container\n        if ((child instanceof MarkupContainer) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {\n            // visit the children in the container\n            value = ((MarkupContainer<?>) child).visitChildren(clazz, visitor);\n            // If visitor returns a non-null value, it halts the traversal\n            if ((value != IVisitor.CONTINUE_TRAVERSAL) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {\n                return value;\n            }\n        }\n    }\n    return null;\n}", "code_comment": "/**\n *  Traverses all child components of the given class in this container,\n *  calling the visitor's visit method at each one.\n *\n *  @param clazz\n *             The class of child to visit, or null to visit all children\n *  @param visitor\n *             The visitor to call back to\n *  @return The return value from a visitor which halted the traversal, or\n *          null if the entire traversal occurred\n */\n", "code_no_comment": "public final Object visitChildren(final Class clazz, final IVisitor visitor) {\n    if (visitor == null) {\n        throw new IllegalArgumentException(\"argument visitor may not be null\");\n    }\n        for (int i = 0; i < children_size(); i++) {\n                final Component child = children_get(i);\n        Object value = null;\n                if (clazz == null || clazz.isInstance(child)) {\n                        value = visitor.component(child);\n                        if ((value != IVisitor.CONTINUE_TRAVERSAL) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {\n                return value;\n            }\n        }\n                if ((child instanceof MarkupContainer) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {\n                        value = ((MarkupContainer<?>) child).visitChildren(clazz, visitor);\n                        if ((value != IVisitor.CONTINUE_TRAVERSAL) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {\n                return value;\n            }\n        }\n    }\n    return null;\n}", "lc": 0.36363636363636365, "pi": 0.7193877551020407, "ma": 0.6666666666666666, "nbd": 0.5, "ml": 1.0, "d": 1.1833910034602078, "mi": -0.3429882420418701, "fo": -0.08333333333333333, "r": -0.028571428571428574, "e": 1.0864481478150256}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2506_0f8a2990", "label": 1, "code": "private void applyEnclosureVisibilityToChildren(final MarkupContainer container, final MarkupStream markupStream, ComponentTag enclosureOpenTag) {\n    DirectChildTagIterator it = new DirectChildTagIterator(markupStream, enclosureOpenTag);\n    while (it.hasNext()) {\n        final ComponentTag tag = it.next();\n        final Component child = container.get(tag.getId());\n        // record original visiblity allowed value, will restore later\n        changes.put(child, child.isVisibilityAllowed());\n        child.setVisibilityAllowed(isVisible());\n    }\n    it.rewind();\n}", "code_comment": NaN, "code_no_comment": "private void applyEnclosureVisibilityToChildren(final MarkupContainer container, final MarkupStream markupStream, ComponentTag enclosureOpenTag) {\n    DirectChildTagIterator it = new DirectChildTagIterator(markupStream, enclosureOpenTag);\n    while (it.hasNext()) {\n        final ComponentTag tag = it.next();\n        final Component child = container.get(tag.getId());\n                changes.put(child, child.isVisibilityAllowed());\n        child.setVisibilityAllowed(isVisible());\n    }\n    it.rewind();\n}", "lc": -0.18181818181818182, "pi": -0.015306122448979493, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.3806228373702422, "mi": 0.17464869515342715, "fo": 0.25, "r": 0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-320_c06cc933", "label": 1, "code": "/**\n * Solve the linear equation A &times; X = B in least square sense.\n * <p>The m&times;n matrix A may not be square, the solution X is\n * such that ||A &times; X - B|| is minimal.</p>\n * @param b right-hand side of the equation A &times; X = B\n * @return a matrix X that minimizes the two norm of A &times; X - B\n * @exception IllegalArgumentException if matrices dimensions don't match\n * @exception InvalidMatrixException if decomposed matrix is singular\n */\npublic RealMatrix solve(final RealMatrix b) throws IllegalArgumentException, InvalidMatrixException {\n    if (b.getRowDimension() != singularValues.length) {\n        throw MathRuntimeException.createIllegalArgumentException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\", b.getRowDimension(), b.getColumnDimension(), singularValues.length, \"n\");\n    }\n    final RealMatrix w = uT.multiply(b);\n    for (int i = 0; i < singularValues.length; ++i) {\n        final double si = singularValues[i];\n        if (si == 0) {\n            throw new SingularMatrixException();\n        }\n        final double inv = 1.0 / si;\n        for (int j = 0; j < b.getColumnDimension(); ++j) {\n            w.multiplyEntry(i, j, inv);\n        }\n    }\n    return v.multiply(w);\n}", "code_comment": "/**\n * Solve the linear equation A &times; X = B in least square sense.\n * <p>The m&times;n matrix A may not be square, the solution X is\n * such that ||A &times; X - B|| is minimal.</p>\n * @param b right-hand side of the equation A &times; X = B\n * @return a matrix X that minimizes the two norm of A &times; X - B\n * @exception IllegalArgumentException if matrices dimensions don't match\n * @exception InvalidMatrixException if decomposed matrix is singular\n */\n", "code_no_comment": "public RealMatrix solve(final RealMatrix b) throws IllegalArgumentException, InvalidMatrixException {\n    if (b.getRowDimension() != singularValues.length) {\n        throw MathRuntimeException.createIllegalArgumentException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\", b.getRowDimension(), b.getColumnDimension(), singularValues.length, \"n\");\n    }\n    final RealMatrix w = uT.multiply(b);\n    for (int i = 0; i < singularValues.length; ++i) {\n        final double si = singularValues[i];\n        if (si == 0) {\n            throw new SingularMatrixException();\n        }\n        final double inv = 1.0 / si;\n        for (int j = 0; j < b.getColumnDimension(); ++j) {\n            w.multiplyEntry(i, j, inv);\n        }\n    }\n    return v.multiply(w);\n}", "lc": 0.13636363636363635, "pi": 0.1887755102040817, "ma": 0.5, "nbd": 0.0, "ml": 0.4166666666666667, "d": 0.8749382105783491, "mi": -0.20217952394608543, "fo": 0.16666666666666666, "r": 0.0, "e": 0.7463219705243681}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2460_a17d4e82", "label": 1, "code": "@Override\npublic boolean isReleased() {\n    return isReleased.get();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean isReleased() {\n    return isReleased.get();\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.0332664181244626, "fo": -0.4166666666666667, "r": 1.7714285714285716, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-428_4a6a573b", "label": 3, "code": "/**\n *  @see java.util.Map#values()\n */\npublic Collection values() {\n    return new AbstractList() {\n\n        public Object get(final int index) {\n            int keyIndex = nextKey(0);\n            for (int i = 0; i < index; i++) {\n                keyIndex = nextKey(keyIndex + 1);\n            }\n            return values[keyIndex];\n        }\n\n        public int size() {\n            return size;\n        }\n    };\n}", "code_comment": "/**\n *  @see java.util.Map#values()\n */\n", "code_no_comment": "public Collection values() {\n    return new AbstractList() {\n\n        public Object get(final int index) {\n            int keyIndex = nextKey(0);\n            for (int i = 0; i < index; i++) {\n                keyIndex = nextKey(keyIndex + 1);\n            }\n            return values[keyIndex];\n        }\n\n        public int size() {\n            return size;\n        }\n    };\n}", "lc": 0.0, "pi": 0.8316326530612247, "ma": -0.3333333333333333, "nbd": 0.0, "ml": -0.16666666666666666, "d": 0.31932773109243706, "mi": 0.07599655864640069, "fo": -0.3333333333333333, "r": 2.428571428571429, "e": 0.015418813522299459}
{"project_name": "Closure", "project_version": 98, "label": 1, "code": "/**\n * @return Whether the variable is only assigned a value once for its\n *     lifetime.\n */\nboolean isAssignedOnceInLifetime() {\n    Reference ref = getOneAndOnlyAssignment();\n    if (ref == null) {\n        return false;\n    }\n    return true;\n}", "code_comment": "/**\n * @return Whether the variable is only assigned a value once for its\n *     lifetime.\n */\n", "code_no_comment": "boolean isAssignedOnceInLifetime() {\n    Reference ref = getOneAndOnlyAssignment();\n    if (ref == null) {\n        return false;\n    }\n    return true;\n}", "lc": -0.3181818181818182, "pi": -0.2346938775510204, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.15916955017301035, "mi": 0.5732721537137941, "fo": -0.4166666666666667, "r": 2.7142857142857144, "e": -0.14662006758579926}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1115_2a6c6409", "label": 1, "code": "/**\n * Build a parallellepipedic box boundary.\n * @param xMin low bound along the x direction\n * @param xMax high bound along the x direction\n * @param yMin low bound along the y direction\n * @param yMax high bound along the y direction\n * @param zMin low bound along the z direction\n * @param zMax high bound along the z direction\n * @param tolerance tolerance below which points are considered identical\n * @return boundary tree\n * @since 3.3\n */\nprivate static BSPTree<Euclidean3D> buildBoundary(final double xMin, final double xMax, final double yMin, final double yMax, final double zMin, final double zMax, final double tolerance) {\n    final Plane pxMin = new Plane(new Vector3D(xMin, 0, 0), Vector3D.MINUS_I, tolerance);\n    final Plane pxMax = new Plane(new Vector3D(xMax, 0, 0), Vector3D.PLUS_I, tolerance);\n    final Plane pyMin = new Plane(new Vector3D(0, yMin, 0), Vector3D.MINUS_J, tolerance);\n    final Plane pyMax = new Plane(new Vector3D(0, yMax, 0), Vector3D.PLUS_J, tolerance);\n    final Plane pzMin = new Plane(new Vector3D(0, 0, zMin), Vector3D.MINUS_K, tolerance);\n    final Plane pzMax = new Plane(new Vector3D(0, 0, zMax), Vector3D.PLUS_K, tolerance);\n    @SuppressWarnings(\"unchecked\")\n    final Region<Euclidean3D> boundary = new RegionFactory<Euclidean3D>().buildConvex(pxMin, pxMax, pyMin, pyMax, pzMin, pzMax);\n    return boundary.getTree(false);\n}", "code_comment": "/**\n * Build a parallellepipedic box boundary.\n * @param xMin low bound along the x direction\n * @param xMax high bound along the x direction\n * @param yMin low bound along the y direction\n * @param yMax high bound along the y direction\n * @param zMin low bound along the z direction\n * @param zMax high bound along the z direction\n * @param tolerance tolerance below which points are considered identical\n * @return boundary tree\n * @since 3.3\n */\n", "code_no_comment": "private static BSPTree<Euclidean3D> buildBoundary(final double xMin, final double xMax, final double yMin, final double yMax, final double zMin, final double zMax, final double tolerance) {\n    final Plane pxMin = new Plane(new Vector3D(xMin, 0, 0), Vector3D.MINUS_I, tolerance);\n    final Plane pxMax = new Plane(new Vector3D(xMax, 0, 0), Vector3D.PLUS_I, tolerance);\n    final Plane pyMin = new Plane(new Vector3D(0, yMin, 0), Vector3D.MINUS_J, tolerance);\n    final Plane pyMax = new Plane(new Vector3D(0, yMax, 0), Vector3D.PLUS_J, tolerance);\n    final Plane pzMin = new Plane(new Vector3D(0, 0, zMin), Vector3D.MINUS_K, tolerance);\n    final Plane pzMax = new Plane(new Vector3D(0, 0, zMax), Vector3D.PLUS_K, tolerance);\n    @SuppressWarnings(\"unchecked\")\n    final Region<Euclidean3D> boundary = new RegionFactory<Euclidean3D>().buildConvex(pxMin, pxMax, pyMin, pyMax, pzMin, pzMax);\n    return boundary.getTree(false);\n}", "lc": -0.13636363636363635, "pi": -0.7551020408163265, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": -0.016346429595641167, "fo": -0.3333333333333333, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1061_86d8944f", "label": 1, "code": "@Override\npublic boolean remove(final Marker marker) {\n    return this.marker.remove(MarkerManager.getMarker(marker.getName()));\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean remove(final Marker marker) {\n    return this.marker.remove(MarkerManager.getMarker(marker.getName()));\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.855176369371953, "fo": -0.25, "r": 0.2285714285714286, "e": -0.16422749602751402}
{"project_name": "Lang", "project_version": 65, "label": 1, "code": "// -----------------------------------------------------------------------\n/**\n * <p>Internal calculation method.</p>\n *\n * @param val  the calendar\n * @param field  the field constant\n * @param round  true to round, false to truncate\n * @throws ArithmeticException if the year is over 280 million\n */\nprivate static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) > 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n    // see http://issues.apache.org/jira/browse/LANG-59\n    // \n    // Manually truncate milliseconds, seconds and minutes, rather than using\n    // Calendar methods.\n    // truncate milliseconds\n    // truncate seconds\n    // truncate minutes\n    // reset time\n    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n    boolean roundUp = false;\n    for (int i = 0; i < fields.length; i++) {\n        for (int j = 0; j < fields[i].length; j++) {\n            if (fields[i][j] == field) {\n                // This is our field... we stop looping\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        // we subtract 15 days and add 1 month\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        // We need at add one to this field since the\n                        // last number causes us to round up\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        // We have various fields that are not easy roundings\n        int offset = 0;\n        boolean offsetSet = false;\n        // These are special types of fields that require different rounding rules\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] == Calendar.DATE) {\n                    // If we're going to drop the DATE field's value,\n                    // we want to do this our own way.\n                    // We need to subtrace 1 since the date has a minimum of 1\n                    offset = val.get(Calendar.DATE) - 1;\n                    // bottom half of the month and should stay accordingly.\n                    if (offset >= 15) {\n                        offset -= 15;\n                    }\n                    // Record whether we're in the top or bottom half of that range\n                    roundUp = offset > 7;\n                    offsetSet = true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                    // If we're going to drop the HOUR field's value,\n                    // we want to do this our own way.\n                    offset = val.get(Calendar.HOUR_OF_DAY);\n                    if (offset >= 12) {\n                        offset -= 12;\n                    }\n                    roundUp = offset > 6;\n                    offsetSet = true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min = val.getActualMinimum(fields[i][0]);\n            int max = val.getActualMaximum(fields[i][0]);\n            // Calculate the offset from the minimum allowed value\n            offset = val.get(fields[i][0]) - min;\n            // Set roundUp if this is more than half way between the minimum and maximum\n            roundUp = offset > ((max - min) / 2);\n        }\n        // We need to remove this field\n        val.set(fields[i][0], val.get(fields[i][0]) - offset);\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}", "code_comment": "/**\n * <p>Internal calculation method.</p>\n *\n * @param val  the calendar\n * @param field  the field constant\n * @param round  true to round, false to truncate\n * @throws ArithmeticException if the year is over 280 million\n */\n", "code_no_comment": "private static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) > 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n                                            boolean roundUp = false;\n    for (int i = 0; i < fields.length; i++) {\n        for (int j = 0; j < fields[i].length; j++) {\n            if (fields[i][j] == field) {\n                                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                                                if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                                                                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n                int offset = 0;\n        boolean offsetSet = false;\n                switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] == Calendar.DATE) {\n                                                                                offset = val.get(Calendar.DATE) - 1;\n                                        if (offset >= 15) {\n                        offset -= 15;\n                    }\n                                        roundUp = offset > 7;\n                    offsetSet = true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                                                            offset = val.get(Calendar.HOUR_OF_DAY);\n                    if (offset >= 12) {\n                        offset -= 12;\n                    }\n                    roundUp = offset > 6;\n                    offsetSet = true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min = val.getActualMinimum(fields[i][0]);\n            int max = val.getActualMaximum(fields[i][0]);\n                        offset = val.get(fields[i][0]) - min;\n                        roundUp = offset > ((max - min) / 2);\n        }\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}", "lc": 1.9545454545454546, "pi": 2.1938775510204085, "ma": 2.5, "nbd": 2.0, "ml": 1.75, "d": 3.8843302026693034, "mi": -1.0215084599942648, "fo": 0.5833333333333334, "r": -0.028571428571428574, "e": 10.044354786899149}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1069_e9b628ec", "label": 3, "code": "@Override\nprotected int[] getEventIndices(final String text, final int beginIndex) {\n    // Scan the text for the end of the next JSON object.\n    final int start = text.indexOf(EVENT_START_MARKER, beginIndex);\n    if (start == END) {\n        return END_PAIR;\n    }\n    final char[] charArray = text.toCharArray();\n    int stack = 0;\n    boolean inStr = false;\n    boolean inEsc = false;\n    for (int i = start; i < charArray.length; i++) {\n        final char c = charArray[i];\n        if (!inEsc) {\n            inEsc = false;\n            switch(c) {\n                case EVENT_START_MARKER:\n                    if (!inStr) {\n                        stack++;\n                    }\n                    break;\n                case EVENT_END_MARKER:\n                    if (!inStr) {\n                        stack--;\n                    }\n                    break;\n                case JSON_STR_DELIM:\n                    inStr = !inStr;\n                    break;\n                case JSON_ESC:\n                    inEsc = true;\n                    break;\n            }\n            if (stack == 0) {\n                return new int[] { start, i };\n            }\n        }\n    }\n    return END_PAIR;\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected int[] getEventIndices(final String text, final int beginIndex) {\n        final int start = text.indexOf(EVENT_START_MARKER, beginIndex);\n    if (start == END) {\n        return END_PAIR;\n    }\n    final char[] charArray = text.toCharArray();\n    int stack = 0;\n    boolean inStr = false;\n    boolean inEsc = false;\n    for (int i = start; i < charArray.length; i++) {\n        final char c = charArray[i];\n        if (!inEsc) {\n            inEsc = false;\n            switch(c) {\n                case EVENT_START_MARKER:\n                    if (!inStr) {\n                        stack++;\n                    }\n                    break;\n                case EVENT_END_MARKER:\n                    if (!inStr) {\n                        stack--;\n                    }\n                    break;\n                case JSON_STR_DELIM:\n                    inStr = !inStr;\n                    break;\n                case JSON_ESC:\n                    inEsc = true;\n                    break;\n            }\n            if (stack == 0) {\n                return new int[] { start, i };\n            }\n        }\n    }\n    return END_PAIR;\n}", "lc": 1.1363636363636365, "pi": 2.2397959183673475, "ma": 1.8333333333333333, "nbd": 1.5, "ml": 1.0, "d": 0.8769154720711817, "mi": -0.6521365070260974, "fo": -0.3333333333333333, "r": 0.20000000000000004, "e": 0.8209190469460043}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-865_b55e0206", "label": 1, "code": "/**\n * Checks dimensions and values of boundaries and inputSigma if defined.\n */\nprivate void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n        if (hasInfiniteBounds) {\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n        }\n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}", "code_comment": "/**\n * Checks dimensions and values of boundaries and inputSigma if defined.\n */\n", "code_no_comment": "private void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n        boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n        boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n        if (hasInfiniteBounds) {\n                        throw new MathUnsupportedOperationException();\n        } else {\n                        boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n        }\n    } else {\n                boundaries = null;\n    }\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}", "lc": 1.4090909090909092, "pi": 0.8112244897959185, "ma": 2.5, "nbd": 1.0, "ml": 1.5833333333333333, "d": 2.6604053386060316, "mi": -0.8362489245770004, "fo": 0.08333333333333333, "r": -0.028571428571428574, "e": 4.227217632269864}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2430_be3a9114", "label": 1, "code": "@Override\npublic boolean childNodeAdded(String name, NodeState after) {\n    if (!loader.isRunning()) {\n        return false;\n    }\n    NodeBuilder child = EmptyNodeState.EMPTY_NODE.builder();\n    boolean success = EmptyNodeState.compareAgainstEmptyState(after, new StandbyApplyDiff(child, store, loader, path + name + \"/\"));\n    if (success) {\n        builder.setChildNode(name, child.getNodeState());\n    }\n    return success;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean childNodeAdded(String name, NodeState after) {\n    if (!loader.isRunning()) {\n        return false;\n    }\n    NodeBuilder child = EmptyNodeState.EMPTY_NODE.builder();\n    boolean success = EmptyNodeState.compareAgainstEmptyState(after, new StandbyApplyDiff(child, store, loader, path + name + \"/\"));\n    if (success) {\n        builder.setChildNode(name, child.getNodeState());\n    }\n    return success;\n}", "lc": -0.09090909090909091, "pi": -0.2346938775510204, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.09787444389520514, "mi": 0.08373960424433617, "fo": -0.08333333333333333, "r": 0.028571428571428574, "e": -0.05735370329919779}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-367_3a15d8ce", "label": 3, "code": "/**\n * {@inheritDoc}\n */\npublic boolean hasNext() {\n    return current != null;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public boolean hasNext() {\n    return current != null;\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.144536851161457, "fo": -0.5, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-9673_7944093f", "label": 3, "code": "public void done(boolean doneSync) {\n    if (e == null) {\n        exchange.removeProperty(Exchange.FAILURE_ENDPOINT);\n    } else {\n        // set exception back on exchange\n        exchange.setException(e);\n        exchange.setProperty(Exchange.EXCEPTION_CAUGHT, e);\n    }\n    if (!doneSync) {\n        // signal callback to continue routing async\n        ExchangeHelper.prepareOutToIn(exchange);\n        LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n    }\n    callback.done(doneSync);\n}", "code_comment": NaN, "code_no_comment": "public void done(boolean doneSync) {\n    if (e == null) {\n        exchange.removeProperty(Exchange.FAILURE_ENDPOINT);\n    } else {\n                exchange.setException(e);\n        exchange.setProperty(Exchange.EXCEPTION_CAUGHT, e);\n    }\n    if (!doneSync) {\n                ExchangeHelper.prepareOutToIn(exchange);\n        LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n    }\n    callback.done(doneSync);\n}", "lc": -0.045454545454545456, "pi": -0.1173469387755102, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.0682155215027187, "mi": 0.07829079437912259, "fo": 0.08333333333333333, "r": -0.028571428571428574, "e": -0.06917479366629405}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1985_495a5c3c", "label": 0, "code": "public JobGraph createJobGraph(String jobName) {\n    jobGraph = new JobGraph(jobName);\n    // make sure that all vertices start immediately\n    jobGraph.setScheduleMode(ScheduleMode.ALL);\n    init();\n    setChaining();\n    setPhysicalEdges();\n    setSlotSharing();\n    configureCheckpointing();\n    return jobGraph;\n}", "code_comment": NaN, "code_no_comment": "public JobGraph createJobGraph(String jobName) {\n    jobGraph = new JobGraph(jobName);\n        jobGraph.setScheduleMode(ScheduleMode.ALL);\n    init();\n    setChaining();\n    setPhysicalEdges();\n    setSlotSharing();\n    configureCheckpointing();\n    return jobGraph;\n}", "lc": -0.18181818181818182, "pi": -0.7244897959183674, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.3085747060510466, "fo": 0.0, "r": 2.0285714285714285, "e": -0.16422749602751402}
{"project_name": "Math", "project_version": 77, "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic double getLInfNorm() {\n    double max = 0;\n    for (double a : data) {\n        max += Math.max(max, Math.abs(a));\n    }\n    return max;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic double getLInfNorm() {\n    double max = 0;\n    for (double a : data) {\n        max += Math.max(max, Math.abs(a));\n    }\n    return max;\n}", "lc": -0.2727272727272727, "pi": -0.1887755102040817, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.05042016806722688, "mi": 0.44049326068253525, "fo": -0.3333333333333333, "r": 2.3714285714285714, "e": -0.12224549320929755}
{"project_name": "Math", "project_version": 44, "label": 1, "code": "/**\n * Accept a step, triggering events and step handlers.\n * @param interpolator step interpolator\n * @param y state vector at step end time, must be reset if an event\n * asks for resetting or if an events stops integration during the step\n * @param yDot placeholder array where to put the time derivative of the state vector\n * @param tEnd final integration time\n * @return time at end of step\n * @exception MathIllegalStateException if the value of one event state cannot be evaluated\n * @since 2.2\n */\nprotected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MathIllegalStateException {\n    double previousT = interpolator.getGlobalPreviousTime();\n    final double currentT = interpolator.getGlobalCurrentTime();\n    resetOccurred = false;\n    // initialize the events states if needed\n    if (!statesInitialized) {\n        for (EventState state : eventsStates) {\n            state.reinitializeBegin(interpolator);\n        }\n        statesInitialized = true;\n    }\n    // search for next events that may occur during the step\n    final int orderingSign = interpolator.isForward() ? +1 : -1;\n    SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public int compare(EventState es0, EventState es1) {\n            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n        }\n    });\n    for (final EventState state : eventsStates) {\n        if (state.evaluateStep(interpolator)) {\n            // the event occurs during the current step\n            occuringEvents.add(state);\n        }\n    }\n    while (!occuringEvents.isEmpty()) {\n        // handle the chronologically first event\n        final Iterator<EventState> iterator = occuringEvents.iterator();\n        final EventState currentEvent = iterator.next();\n        iterator.remove();\n        // restrict the interpolator to the first part of the step, up to the event\n        final double eventT = currentEvent.getEventTime();\n        interpolator.setSoftPreviousTime(previousT);\n        interpolator.setSoftCurrentTime(eventT);\n        // trigger the event\n        interpolator.setInterpolatedTime(eventT);\n        final double[] eventY = interpolator.getInterpolatedState();\n        currentEvent.stepAccepted(eventT, eventY);\n        isLastStep = currentEvent.stop();\n        // handle the first part of the step, up to the event\n        for (final StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, isLastStep);\n        }\n        if (isLastStep) {\n            // the event asked to stop integration\n            System.arraycopy(eventY, 0, y, 0, y.length);\n            return eventT;\n        }\n        if (currentEvent.reset(eventT, eventY)) {\n            // some event handler has triggered changes that\n            // invalidate the derivatives, we need to recompute them\n            System.arraycopy(eventY, 0, y, 0, y.length);\n            computeDerivatives(eventT, y, yDot);\n            resetOccurred = true;\n            return eventT;\n        }\n        // prepare handling of the remaining part of the step\n        previousT = eventT;\n        interpolator.setSoftPreviousTime(eventT);\n        interpolator.setSoftCurrentTime(currentT);\n        // check if the same event occurs again in the remaining part of the step\n        if (currentEvent.evaluateStep(interpolator)) {\n            // the event occurs during the current step\n            occuringEvents.add(currentEvent);\n        }\n    }\n    interpolator.setInterpolatedTime(currentT);\n    final double[] currentY = interpolator.getInterpolatedState();\n    for (final EventState state : eventsStates) {\n        state.stepAccepted(currentT, currentY);\n        isLastStep = isLastStep || state.stop();\n    }\n    isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n    // handle the remaining part of the step, after all events if any\n    for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, isLastStep);\n    }\n    return currentT;\n}", "code_comment": "/**\n * Accept a step, triggering events and step handlers.\n * @param interpolator step interpolator\n * @param y state vector at step end time, must be reset if an event\n * asks for resetting or if an events stops integration during the step\n * @param yDot placeholder array where to put the time derivative of the state vector\n * @param tEnd final integration time\n * @return time at end of step\n * @exception MathIllegalStateException if the value of one event state cannot be evaluated\n * @since 2.2\n */\n/**\n * {@inheritDoc}\n */\n", "code_no_comment": "protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MathIllegalStateException {\n    double previousT = interpolator.getGlobalPreviousTime();\n    final double currentT = interpolator.getGlobalCurrentTime();\n    resetOccurred = false;\n        if (!statesInitialized) {\n        for (EventState state : eventsStates) {\n            state.reinitializeBegin(interpolator);\n        }\n        statesInitialized = true;\n    }\n        final int orderingSign = interpolator.isForward() ? +1 : -1;\n    SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public int compare(EventState es0, EventState es1) {\n            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n        }\n    });\n    for (final EventState state : eventsStates) {\n        if (state.evaluateStep(interpolator)) {\n                        occuringEvents.add(state);\n        }\n    }\n    while (!occuringEvents.isEmpty()) {\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n        final EventState currentEvent = iterator.next();\n        iterator.remove();\n                final double eventT = currentEvent.getEventTime();\n        interpolator.setSoftPreviousTime(previousT);\n        interpolator.setSoftCurrentTime(eventT);\n                interpolator.setInterpolatedTime(eventT);\n        final double[] eventY = interpolator.getInterpolatedState();\n        currentEvent.stepAccepted(eventT, eventY);\n        isLastStep = currentEvent.stop();\n                for (final StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, isLastStep);\n        }\n        if (isLastStep) {\n                        System.arraycopy(eventY, 0, y, 0, y.length);\n            return eventT;\n        }\n        if (currentEvent.reset(eventT, eventY)) {\n                                    System.arraycopy(eventY, 0, y, 0, y.length);\n            computeDerivatives(eventT, y, yDot);\n            resetOccurred = true;\n            return eventT;\n        }\n                previousT = eventT;\n        interpolator.setSoftPreviousTime(eventT);\n        interpolator.setSoftCurrentTime(currentT);\n                if (currentEvent.evaluateStep(interpolator)) {\n                        occuringEvents.add(currentEvent);\n        }\n    }\n    interpolator.setInterpolatedTime(currentT);\n    final double[] currentY = interpolator.getInterpolatedState();\n    for (final EventState state : eventsStates) {\n        state.stepAccepted(currentT, currentY);\n        isLastStep = isLastStep || state.stop();\n    }\n    isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n        for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, isLastStep);\n    }\n    return currentT;\n}", "lc": 2.409090909090909, "pi": -0.03061224489795921, "ma": 1.5, "nbd": 0.0, "ml": 1.0, "d": 1.2941176470588238, "mi": -1.0699741898480073, "fo": 2.4166666666666665, "r": -0.028571428571428574, "e": 4.207143193664581}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-939_49444ee6", "label": 1, "code": "/**\n * Throws MathIllegalArgumentException if the matrix does not have at least\n * two columns and two rows.\n * @param matrix matrix to check\n * @throws MathIllegalArgumentException if the matrix does not contain sufficient data\n * to compute covariance\n */\nprivate void checkSufficientData(final RealMatrix matrix) throws MathIllegalArgumentException {\n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n    if (nRows < 2 || nCols < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS, nRows, nCols);\n    }\n}", "code_comment": "/**\n * Throws MathIllegalArgumentException if the matrix does not have at least\n * two columns and two rows.\n * @param matrix matrix to check\n * @throws MathIllegalArgumentException if the matrix does not contain sufficient data\n * to compute covariance\n */\n", "code_no_comment": "private void checkSufficientData(final RealMatrix matrix) throws MathIllegalArgumentException {\n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n    if (nRows < 2 || nCols < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS, nRows, nCols);\n    }\n}", "lc": -0.3181818181818182, "pi": -0.2346938775510204, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.05042016806722688, "mi": 0.42013191855463133, "fo": -0.3333333333333333, "r": 1.8571428571428574, "e": -0.09450447788042711}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-428_d906576c", "label": 3, "code": "/**\n *  @see java.util.Map#values()\n */\npublic Collection values() {\n    return new AbstractList() {\n\n        public Object get(final int index) {\n            return value;\n        }\n\n        public int size() {\n            return MicroMap.this.size();\n        }\n    };\n}", "code_comment": "/**\n *  @see java.util.Map#values()\n */\n", "code_no_comment": "public Collection values() {\n    return new AbstractList() {\n\n        public Object get(final int index) {\n            return value;\n        }\n\n        public int size() {\n            return MicroMap.this.size();\n        }\n    };\n}", "lc": -0.18181818181818182, "pi": 0.5408163265306123, "ma": -0.5, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.4143963292228278, "fo": -0.4166666666666667, "r": 2.742857142857143, "e": -0.16422749602751402}
{"project_name": "Cli", "project_version": 37, "label": 1, "code": "/**\n * Tells if the token looks like a short option.\n *\n * @param token\n */\nprivate boolean isShortOption(String token) {\n    // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n    return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n// remove leading \"-\" and \"=value\"\n}", "code_comment": "/**\n * Tells if the token looks like a short option.\n *\n * @param token\n */\n", "code_no_comment": "private boolean isShortOption(String token) {\n        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.11764705882352938, "mi": 0.8718095784341845, "fo": -0.16666666666666666, "r": 2.4571428571428573, "e": -0.12291792479902006}
{"project_name": "Math", "project_version": 17, "label": 1, "code": "/**\n * Multiply this by a single digit x.\n * @param x multiplicand\n * @return product of this and x\n */\npublic Dfp multiply(final int x) {\n    return multiplyFast(x);\n}", "code_comment": "/**\n * Multiply this by a single digit x.\n * @param x multiplicand\n * @return product of this and x\n */\n", "code_no_comment": "public Dfp multiply(final int x) {\n    return multiplyFast(x);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.1172928018353891, "fo": -0.4166666666666667, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-366_db4a291f", "label": 1, "code": "private synchronized void retry(ZooRunnable op) {\n    int sleepTime = 100;\n    while (true) {\n        ZooKeeper zooKeeper = getZooKeeper();\n        try {\n            op.run(zooKeeper);\n            return;\n        } catch (KeeperException e) {\n            if (e.code() == Code.NONODE) {\n                log.error(\"Looked up non existant node in cache \" + e.getPath(), e);\n            }\n            log.warn(\"Zookeeper error, will retry\", e);\n        } catch (InterruptedException e) {\n            log.warn(\"Zookeeper error, will retry\", e);\n        } catch (ConcurrentModificationException e) {\n            log.debug(\"Zookeeper was modified, will retry\");\n        }\n        try {\n            // do not hold lock while sleeping\n            wait(sleepTime);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        if (sleepTime < 10000)\n            sleepTime = (int) (sleepTime + sleepTime * Math.random());\n    }\n}", "code_comment": NaN, "code_no_comment": "private synchronized void retry(ZooRunnable op) {\n    int sleepTime = 100;\n    while (true) {\n        ZooKeeper zooKeeper = getZooKeeper();\n        try {\n            op.run(zooKeeper);\n            return;\n        } catch (KeeperException e) {\n            if (e.code() == Code.NONODE) {\n                log.error(\"Looked up non existant node in cache \" + e.getPath(), e);\n            }\n            log.warn(\"Zookeeper error, will retry\", e);\n        } catch (InterruptedException e) {\n            log.warn(\"Zookeeper error, will retry\", e);\n        } catch (ConcurrentModificationException e) {\n            log.debug(\"Zookeeper was modified, will retry\");\n        }\n        try {\n                        wait(sleepTime);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        if (sleepTime < 10000)\n            sleepTime = (int) (sleepTime + sleepTime * Math.random());\n    }\n}", "lc": 0.5454545454545454, "pi": 0.42346938775510207, "ma": 0.6666666666666666, "nbd": 0.5, "ml": 0.0, "d": 0.2956005931784479, "mi": -0.3971895612274165, "fo": 0.4166666666666667, "r": -0.028571428571428574, "e": 0.29763021402169765}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-4358_74cbba24", "label": 1, "code": "@Override\nprotected Revision computeNext() {\n    while (unfiltered.hasNext()) {\n        Revision next = unfiltered.next();\n        if (min.isRevisionNewer(next)) {\n            return next;\n        } else {\n            // further revisions with this clusterId\n            // are older than min revision\n            clusterIds.remove(next.getClusterId());\n            // no more revisions to check\n            if (clusterIds.isEmpty()) {\n                return endOfData();\n            }\n        }\n    }\n    return endOfData();\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected Revision computeNext() {\n    while (unfiltered.hasNext()) {\n        Revision next = unfiltered.next();\n        if (min.isRevisionNewer(next)) {\n            return next;\n        } else {\n                                    clusterIds.remove(next.getClusterId());\n                        if (clusterIds.isEmpty()) {\n                return endOfData();\n            }\n        }\n    }\n    return endOfData();\n}", "lc": 0.045454545454545456, "pi": 0.9540816326530611, "ma": 0.0, "nbd": 0.5, "ml": 0.16666666666666666, "d": -0.3806228373702422, "mi": 0.07198164611413799, "fo": 0.16666666666666666, "r": 0.5428571428571429, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-434_133cbc2d", "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic int hashCode() {\n    return Boolean.valueOf(restrictToNonNegative).hashCode() ^ numDecisionVariables ^ numSlackVariables ^ numArtificialVariables ^ Double.valueOf(epsilon).hashCode() ^ f.hashCode() ^ constraints.hashCode() ^ tableau.hashCode();\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic int hashCode() {\n    return Boolean.valueOf(restrictToNonNegative).hashCode() ^ numDecisionVariables ^ numSlackVariables ^ numArtificialVariables ^ Double.valueOf(epsilon).hashCode() ^ f.hashCode() ^ constraints.hashCode() ^ tableau.hashCode();\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7192429022082021, "fo": 0.08333333333333333, "r": 1.885714285714286, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5853_b80f6640", "label": 3, "code": "/**\n *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,Locale)\n */\n@Override\npublic Byte convertToObject(final String value, final Locale locale) {\n    final Number number = parse(value, Byte.MIN_VALUE, Byte.MAX_VALUE, locale);\n    if (number == null) {\n        return null;\n    }\n    return number.byteValue();\n}", "code_comment": "/**\n *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,Locale)\n */\n", "code_no_comment": "@Override\npublic Byte convertToObject(final String value, final Locale locale) {\n    final Number number = parse(value, Byte.MIN_VALUE, Byte.MAX_VALUE, locale);\n    if (number == null) {\n        return null;\n    }\n    return number.byteValue();\n}", "lc": -0.2727272727272727, "pi": -0.1887755102040817, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.08996539792387542, "mi": 0.3642099225695442, "fo": -0.3333333333333333, "r": 0.2285714285714286, "e": -0.10260363798339052}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443", "label": 1, "code": "@Override\npublic Collection<Text> getSplits(String tableName, int maxSplits) {\n    return Collections.emptyList();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Collection<Text> getSplits(String tableName, int maxSplits) {\n    return Collections.emptyList();\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8543160309721824, "fo": -0.4166666666666667, "r": 0.8285714285714285, "e": -0.16422749602751402}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3740_f2f5bd5b", "label": 1, "code": "// ------------------------------------------------------------------------\n// Checkpointing\n// ------------------------------------------------------------------------\n@Override\npublic StreamTaskState snapshotOperatorState(long checkpointId, long timestamp) throws Exception {\n    StreamTaskState taskState = super.snapshotOperatorState(checkpointId, timestamp);\n    AbstractStateBackend.CheckpointStateOutputView out = getStateBackend().createCheckpointStateOutputView(checkpointId, timestamp);\n    out.writeInt(watermarkTimersQueue.size());\n    for (Timer<K, W> timer : watermarkTimersQueue) {\n        keySerializer.serialize(timer.key, out);\n        windowSerializer.serialize(timer.window, out);\n        out.writeLong(timer.timestamp);\n    }\n    out.writeInt(processingTimeTimers.size());\n    for (Timer<K, W> timer : processingTimeTimersQueue) {\n        keySerializer.serialize(timer.key, out);\n        windowSerializer.serialize(timer.window, out);\n        out.writeLong(timer.timestamp);\n    }\n    taskState.setOperatorState(out.closeAndGetHandle());\n    return taskState;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic StreamTaskState snapshotOperatorState(long checkpointId, long timestamp) throws Exception {\n    StreamTaskState taskState = super.snapshotOperatorState(checkpointId, timestamp);\n    AbstractStateBackend.CheckpointStateOutputView out = getStateBackend().createCheckpointStateOutputView(checkpointId, timestamp);\n    out.writeInt(watermarkTimersQueue.size());\n    for (Timer<K, W> timer : watermarkTimersQueue) {\n        keySerializer.serialize(timer.key, out);\n        windowSerializer.serialize(timer.window, out);\n        out.writeLong(timer.timestamp);\n    }\n    out.writeInt(processingTimeTimers.size());\n    for (Timer<K, W> timer : processingTimeTimersQueue) {\n        keySerializer.serialize(timer.key, out);\n        windowSerializer.serialize(timer.window, out);\n        out.writeLong(timer.timestamp);\n    }\n    taskState.setOperatorState(out.closeAndGetHandle());\n    return taskState;\n}", "lc": 0.22727272727272727, "pi": -0.17346938775510198, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": -0.2368798394034989, "fo": 0.75, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2659_019edb16", "label": 0, "code": "@Override\nprotected void setupIterators(JobConf job, Scanner scanner, String tableName, org.apache.accumulo.core.client.mapred.RangeInputSplit split) {\n    List<IteratorSetting> iterators = null;\n    if (null == split) {\n        iterators = getIterators(job);\n    } else {\n        iterators = split.getIterators();\n    }\n    setupIterators(iterators, scanner);\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected void setupIterators(JobConf job, Scanner scanner, String tableName, org.apache.accumulo.core.client.mapred.RangeInputSplit split) {\n    List<IteratorSetting> iterators = null;\n    if (null == split) {\n        iterators = getIterators(job);\n    } else {\n        iterators = split.getIterators();\n    }\n    setupIterators(iterators, scanner);\n}", "lc": -0.18181818181818182, "pi": -0.11224489795918377, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.09391992090954028, "mi": 0.1829652996845425, "fo": -0.25, "r": 0.0, "e": -0.061396858845045206}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3433_b76b31f7", "label": 0, "code": "/**\n * Recover the correct _lastRev updates for the given candidate nodes.\n *\n * @param suspects the potential suspects\n * @param clusterId the cluster id for which _lastRev recovery needed\n * @param dryRun if {@code true}, this method will only perform a check\n *               but not apply the changes to the _lastRev fields.\n * @return the number of documents that required recovery. This method\n *          returns the number of the affected documents even if\n *          {@code dryRun} is set true and no document was changed.\n */\npublic int recover(Iterator<NodeDocument> suspects, int clusterId, boolean dryRun) {\n    UnsavedModifications unsaved = new UnsavedModifications();\n    UnsavedModifications unsavedParents = new UnsavedModifications();\n    // Map of known last rev of checked paths\n    Map<String, Revision> knownLastRevOrModification = MapFactory.getInstance().create();\n    final DocumentStore docStore = nodeStore.getDocumentStore();\n    final JournalEntry changes = JOURNAL.newDocument(docStore);\n    long count = 0;\n    while (suspects.hasNext()) {\n        NodeDocument doc = suspects.next();\n        count++;\n        if (count % 100000 == 0) {\n            log.info(\"Scanned {} suspects so far...\", count);\n        }\n        Revision currentLastRev = doc.getLastRev().get(clusterId);\n        // 1. determine last committed modification on document\n        Revision lastModifiedRev = determineLastModification(doc, clusterId);\n        Revision lastRevForParents = Utils.max(lastModifiedRev, currentLastRev);\n        // _lastRev entry or an explicit modification on the document\n        if (lastRevForParents != null) {\n            knownLastRevOrModification.put(doc.getPath(), lastRevForParents);\n        }\n        // 2. Update lastRev for parent paths aka rollup\n        if (lastRevForParents != null) {\n            String path = doc.getPath();\n            // track all changes\n            changes.modified(path);\n            while (true) {\n                if (PathUtils.denotesRoot(path)) {\n                    break;\n                }\n                path = PathUtils.getParentPath(path);\n                unsavedParents.put(path, lastRevForParents);\n            }\n        }\n    }\n    for (String parentPath : unsavedParents.getPaths()) {\n        Revision calcLastRev = unsavedParents.get(parentPath);\n        Revision knownLastRev = knownLastRevOrModification.get(parentPath);\n        if (knownLastRev == null) {\n            // we don't know when the document was last modified with\n            // the given clusterId. need to read from store\n            String id = Utils.getIdFromPath(parentPath);\n            NodeDocument doc = docStore.find(NODES, id);\n            if (doc != null) {\n                Revision lastRev = doc.getLastRev().get(clusterId);\n                Revision lastMod = determineLastModification(doc, clusterId);\n                knownLastRev = Utils.max(lastRev, lastMod);\n            } else {\n                log.warn(\"Unable to find document: {}\", id);\n                continue;\n            }\n        }\n        // This check ensures that unnecessary updates are not made\n        if (knownLastRev == null || calcLastRev.compareRevisionTime(knownLastRev) > 0) {\n            unsaved.put(parentPath, calcLastRev);\n        }\n    }\n    // take the root's lastRev\n    final Revision lastRootRev = unsaved.get(\"/\");\n    // Note the size before persist as persist operation\n    // would empty the internal state\n    int size = unsaved.getPaths().size();\n    String updates = unsaved.toString();\n    if (dryRun) {\n        log.info(\"Dry run of lastRev recovery identified [{}] documents for \" + \"cluster node [{}]: {}\", size, clusterId, updates);\n    } else {\n        // UnsavedModifications is designed to be used in concurrent\n        // access mode. For recovery case there is no concurrent access\n        // involve so just pass a new lock instance\n        // the lock uses to do the persisting is a plain reentrant lock\n        // thus it doesn't matter, where exactly the check is done\n        // as to whether the recovered lastRev has already been\n        // written to the journal.\n        unsaved.persist(nodeStore, new UnsavedModifications.Snapshot() {\n\n            @Override\n            public void acquiring() {\n                if (lastRootRev == null) {\n                    // then we cannot and probably don't have to persist anything\n                    return;\n                }\n                // lastRootRev never null at this point\n                final String id = JournalEntry.asId(lastRootRev);\n                final JournalEntry existingEntry = docStore.find(Collection.JOURNAL, id);\n                if (existingEntry != null) {\n                    // hence: nothing to be done here. return.\n                    return;\n                }\n                // otherwise store a new journal entry now\n                docStore.create(JOURNAL, singletonList(changes.asUpdateOp(lastRootRev)));\n            }\n        }, new ReentrantLock());\n        log.info(\"Updated lastRev of [{}] documents while performing lastRev recovery for \" + \"cluster node [{}]: {}\", size, clusterId, updates);\n    }\n    return size;\n}", "code_comment": "/**\n * Recover the correct _lastRev updates for the given candidate nodes.\n *\n * @param suspects the potential suspects\n * @param clusterId the cluster id for which _lastRev recovery needed\n * @param dryRun if {@code true}, this method will only perform a check\n *               but not apply the changes to the _lastRev fields.\n * @return the number of documents that required recovery. This method\n *          returns the number of the affected documents even if\n *          {@code dryRun} is set true and no document was changed.\n */\n", "code_no_comment": "public int recover(Iterator<NodeDocument> suspects, int clusterId, boolean dryRun) {\n    UnsavedModifications unsaved = new UnsavedModifications();\n    UnsavedModifications unsavedParents = new UnsavedModifications();\n        Map<String, Revision> knownLastRevOrModification = MapFactory.getInstance().create();\n    final DocumentStore docStore = nodeStore.getDocumentStore();\n    final JournalEntry changes = JOURNAL.newDocument(docStore);\n    long count = 0;\n    while (suspects.hasNext()) {\n        NodeDocument doc = suspects.next();\n        count++;\n        if (count % 100000 == 0) {\n            log.info(\"Scanned {} suspects so far...\", count);\n        }\n        Revision currentLastRev = doc.getLastRev().get(clusterId);\n                Revision lastModifiedRev = determineLastModification(doc, clusterId);\n        Revision lastRevForParents = Utils.max(lastModifiedRev, currentLastRev);\n                if (lastRevForParents != null) {\n            knownLastRevOrModification.put(doc.getPath(), lastRevForParents);\n        }\n                if (lastRevForParents != null) {\n            String path = doc.getPath();\n                        changes.modified(path);\n            while (true) {\n                if (PathUtils.denotesRoot(path)) {\n                    break;\n                }\n                path = PathUtils.getParentPath(path);\n                unsavedParents.put(path, lastRevForParents);\n            }\n        }\n    }\n    for (String parentPath : unsavedParents.getPaths()) {\n        Revision calcLastRev = unsavedParents.get(parentPath);\n        Revision knownLastRev = knownLastRevOrModification.get(parentPath);\n        if (knownLastRev == null) {\n                                    String id = Utils.getIdFromPath(parentPath);\n            NodeDocument doc = docStore.find(NODES, id);\n            if (doc != null) {\n                Revision lastRev = doc.getLastRev().get(clusterId);\n                Revision lastMod = determineLastModification(doc, clusterId);\n                knownLastRev = Utils.max(lastRev, lastMod);\n            } else {\n                log.warn(\"Unable to find document: {}\", id);\n                continue;\n            }\n        }\n                if (knownLastRev == null || calcLastRev.compareRevisionTime(knownLastRev) > 0) {\n            unsaved.put(parentPath, calcLastRev);\n        }\n    }\n        final Revision lastRootRev = unsaved.get(\"/\");\n            int size = unsaved.getPaths().size();\n    String updates = unsaved.toString();\n    if (dryRun) {\n        log.info(\"Dry run of lastRev recovery identified [{}] documents for \" + \"cluster node [{}]: {}\", size, clusterId, updates);\n    } else {\n                                                                unsaved.persist(nodeStore, new UnsavedModifications.Snapshot() {\n\n            @Override\n            public void acquiring() {\n                if (lastRootRev == null) {\n                                        return;\n                }\n                                final String id = JournalEntry.asId(lastRootRev);\n                final JournalEntry existingEntry = docStore.find(Collection.JOURNAL, id);\n                if (existingEntry != null) {\n                                        return;\n                }\n                                docStore.create(JOURNAL, singletonList(changes.asUpdateOp(lastRootRev)));\n            }\n        }, new ReentrantLock());\n        log.info(\"Updated lastRev of [{}] documents while performing lastRev recovery for \" + \"cluster node [{}]: {}\", size, clusterId, updates);\n    }\n    return size;\n}", "lc": 2.727272727272727, "pi": 0.9948979591836733, "ma": 2.0, "nbd": 1.0, "ml": 1.5833333333333333, "d": 1.6361838853188333, "mi": -1.1783768282190998, "fo": 3.0, "r": -0.028571428571428574, "e": 6.8375199695050135}
{"project_name": "Cli", "project_version": 33, "label": 1, "code": "/**\n * Print the specified text to the specified PrintWriter.\n *\n * @param pw The printWriter to write the help to\n * @param width The number of characters to display per line\n * @param nextLineTabStop The position on the next line for the first tab.\n * @param text The text to be written to the PrintWriter\n */\npublic void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text) {\n    StringBuffer sb = new StringBuffer(text.length());\n    renderWrappedText(sb, width, nextLineTabStop, text);\n    pw.println(sb.toString());\n}", "code_comment": "/**\n * Print the specified text to the specified PrintWriter.\n *\n * @param pw The printWriter to write the help to\n * @param width The number of characters to display per line\n * @param nextLineTabStop The position on the next line for the first tab.\n * @param text The text to be written to the PrintWriter\n */\n", "code_no_comment": "public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text) {\n    StringBuffer sb = new StringBuffer(text.length());\n    renderWrappedText(sb, width, nextLineTabStop, text);\n    pw.println(sb.toString());\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.6022368798394037, "fo": -0.16666666666666666, "r": 0.4571428571428572, "e": -0.16422749602751402}
{"project_name": "JxPath", "project_version": 13, "label": 1, "code": "/**\n * Get the prefix associated with the specifed namespace URI.\n * @param namespaceURI the ns URI to check.\n * @return String prefix\n */\npublic synchronized String getPrefix(String namespaceURI) {\n    /**\n     * Get the nearest prefix found that matches an externally-registered namespace.\n     * @param namespaceURI\n     * @return String prefix if found.\n     * @since JXPath 1.3\n     */\n    if (reverseMap == null) {\n        reverseMap = new HashMap();\n        NodeIterator ni = pointer.namespaceIterator();\n        if (ni != null) {\n            for (int position = 1; ni.setPosition(position); position++) {\n                NodePointer nsPointer = ni.getNodePointer();\n                String uri = nsPointer.getNamespaceURI();\n                String prefix = nsPointer.getName().getName();\n                if (!\"\".equals(prefix)) {\n                    reverseMap.put(uri, prefix);\n                }\n            }\n        }\n        Iterator it = namespaceMap.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry entry = (Map.Entry) it.next();\n            reverseMap.put(entry.getValue(), entry.getKey());\n        }\n    }\n    String prefix = (String) reverseMap.get(namespaceURI);\n    if (prefix == null && parent != null) {\n        return parent.getPrefix(namespaceURI);\n    }\n    return prefix;\n}", "code_comment": "/**\n * Get the prefix associated with the specifed namespace URI.\n * @param namespaceURI the ns URI to check.\n * @return String prefix\n */\n/**\n * Get the nearest prefix found that matches an externally-registered namespace.\n * @param namespaceURI\n * @return String prefix if found.\n * @since JXPath 1.3\n */\n", "code_no_comment": "public synchronized String getPrefix(String namespaceURI) {\n    /**\n     * Get the nearest prefix found that matches an externally-registered namespace.\n     * @param namespaceURI\n     * @return String prefix if found.\n     * @since JXPath 1.3\n     */\n    if (reverseMap == null) {\n        reverseMap = new HashMap();\n        NodeIterator ni = pointer.namespaceIterator();\n        if (ni != null) {\n            for (int position = 1; ni.setPosition(position); position++) {\n                NodePointer nsPointer = ni.getNodePointer();\n                String uri = nsPointer.getNamespaceURI();\n                String prefix = nsPointer.getName().getName();\n                if (!\"\".equals(prefix)) {\n                    reverseMap.put(uri, prefix);\n                }\n            }\n        }\n        Iterator it = namespaceMap.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry entry = (Map.Entry) it.next();\n            reverseMap.put(entry.getValue(), entry.getKey());\n        }\n    }\n    String prefix = (String) reverseMap.get(namespaceURI);\n    if (prefix == null && parent != null) {\n        return parent.getPrefix(namespaceURI);\n    }\n    return prefix;\n}", "lc": 0.8181818181818182, "pi": 1.0255102040816328, "ma": 0.5, "nbd": 1.0, "ml": 0.8333333333333334, "d": 0.7899159663865548, "mi": -0.5549182678520221, "fo": 0.9166666666666666, "r": -0.028571428571428574, "e": 1.095673737905868}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4102_e743fd7e", "label": 1, "code": "@Override\nprotected void executeInsideBufferedZone() {\n    TextLabel.super.onComponentTagBody(markupStream, openTag);\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected void executeInsideBufferedZone() {\n    TextLabel.super.onComponentTagBody(markupStream, openTag);\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9326068253513053, "fo": -0.4166666666666667, "r": 0.3428571428571429, "e": -0.16422749602751402}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1471_d033fa8f", "label": 1, "code": "private static void validateInputType(Class<?> baseClass, Class<?> clazz, int inputParamPos, TypeInformation<?> inType) {\n    ArrayList<Type> typeHierarchy = new ArrayList<Type>();\n    try {\n        validateInfo(typeHierarchy, getParameterType(baseClass, typeHierarchy, clazz, inputParamPos), inType);\n    } catch (InvalidTypesException e) {\n        throw new InvalidTypesException(\"Input mismatch: \" + e.getMessage());\n    }\n}", "code_comment": NaN, "code_no_comment": "private static void validateInputType(Class<?> baseClass, Class<?> clazz, int inputParamPos, TypeInformation<?> inType) {\n    ArrayList<Type> typeHierarchy = new ArrayList<Type>();\n    try {\n        validateInfo(typeHierarchy, getParameterType(baseClass, typeHierarchy, clazz, inputParamPos), inType);\n    } catch (InvalidTypesException e) {\n        throw new InvalidTypesException(\"Input mismatch: \" + e.getMessage());\n    }\n}", "lc": -0.2727272727272727, "pi": -0.09693877551020405, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.054374691052891735, "mi": 0.31861198738170354, "fo": -0.25, "r": -0.028571428571428574, "e": -0.07432724718499578}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-621_00b4b8a0", "label": 1, "code": "@Override\npublic boolean remove() {\n    root.checkLive();\n    if (isDisconnected()) {\n        throw new IllegalStateException(\"Cannot remove a disconnected tree\");\n    }\n    if (!isRoot() && parent.hasChild(name)) {\n        NodeBuilder builder = parent.getNodeBuilder();\n        builder.removeNode(name);\n        if (parent.hasOrderableChildren()) {\n            builder.setProperty(MemoryPropertyBuilder.copy(Type.STRING, parent.internalGetProperty(OAK_CHILD_ORDER)).removeValue(name).getPropertyState());\n        }\n        root.updated();\n        return true;\n    } else {\n        return false;\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean remove() {\n    root.checkLive();\n    if (isDisconnected()) {\n        throw new IllegalStateException(\"Cannot remove a disconnected tree\");\n    }\n    if (!isRoot() && parent.hasChild(name)) {\n        NodeBuilder builder = parent.getNodeBuilder();\n        builder.removeNode(name);\n        if (parent.hasOrderableChildren()) {\n            builder.setProperty(MemoryPropertyBuilder.copy(Type.STRING, parent.internalGetProperty(OAK_CHILD_ORDER)).removeValue(name).getPropertyState());\n        }\n        root.updated();\n        return true;\n    } else {\n        return false;\n    }\n}", "lc": 0.18181818181818182, "pi": 0.14285714285714277, "ma": 0.16666666666666666, "nbd": 0.0, "ml": 0.3333333333333333, "d": -0.12753336628769152, "mi": -0.13880126182965313, "fo": 0.5833333333333334, "r": 0.0, "e": -0.05493808918070422}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1531_21f47d9c", "label": 3, "code": "/**\n *  Require makes sure that at least required number of bytes are kept in the buffer. If not, then\n *  it will load exactly the difference between required and currently available number of bytes.\n *  Thus, it will only load the data which is required and never prefetch data.\n *\n *  @param required the number of bytes being available in the buffer\n *  @return the number of bytes remaining, which is equal to required\n *  @throws KryoException\n */\n@Override\nprotected int require(int required) throws KryoException {\n    if (required > capacity) {\n        throw new KryoException(\"Buffer too small: capacity: \" + capacity + \", \" + \"required: \" + required);\n    }\n    position = 0;\n    int bytesRead = 0;\n    int count;\n    while (true) {\n        count = fill(buffer, bytesRead, required - bytesRead);\n        if (count == -1) {\n            throw new KryoException(\"Buffer underflow\");\n        }\n        bytesRead += count;\n        if (bytesRead == required) {\n            break;\n        }\n    }\n    limit = required;\n    return required;\n}", "code_comment": "/**\n *  Require makes sure that at least required number of bytes are kept in the buffer. If not, then\n *  it will load exactly the difference between required and currently available number of bytes.\n *  Thus, it will only load the data which is required and never prefetch data.\n *\n *  @param required the number of bytes being available in the buffer\n *  @return the number of bytes remaining, which is equal to required\n *  @throws KryoException\n */\n", "code_no_comment": "@Override\nprotected int require(int required) throws KryoException {\n    if (required > capacity) {\n        throw new KryoException(\"Buffer too small: capacity: \" + capacity + \", \" + \"required: \" + required);\n    }\n    position = 0;\n    int bytesRead = 0;\n    int count;\n    while (true) {\n        count = fill(buffer, bytesRead, required - bytesRead);\n        if (count == -1) {\n            throw new KryoException(\"Buffer underflow\");\n        }\n        bytesRead += count;\n        if (bytesRead == required) {\n            break;\n        }\n    }\n    limit = required;\n    return required;\n}", "lc": 0.3181818181818182, "pi": 0.18367346938775503, "ma": 0.6666666666666666, "nbd": 0.0, "ml": 0.25, "d": 0.7424616905585765, "mi": -0.24318898766848313, "fo": -0.4166666666666667, "r": -0.028571428571428574, "e": 0.36713908198097495}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-781_3c4cb189", "label": 1, "code": "/**\n * Removes the phase 1 objective function, positive cost non-artificial variables,\n * and the non-basic artificial variables from this tableau.\n */\nprotected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    // positive cost non-artificial variables\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    // non-basic artificial variables\n    for (int i = 0; i < getNumArtificialVariables(); i++) {\n        int col = i + getArtificialVariableOffset();\n        if (getBasicRow(col) == null) {\n            columnsToDrop.add(col);\n        }\n    }\n    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n    for (int i = 1; i < getHeight(); i++) {\n        int col = 0;\n        for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n                matrix[i - 1][col++] = tableau.getEntry(i, j);\n            }\n        }\n    }\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n        columnLabels.remove((int) columnsToDrop.get(i));\n    }\n    this.tableau = new Array2DRowRealMatrix(matrix);\n    this.numArtificialVariables = 0;\n}", "code_comment": "/**\n * Removes the phase 1 objective function, positive cost non-artificial variables,\n * and the non-basic artificial variables from this tableau.\n */\n", "code_no_comment": "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n            columnsToDrop.add(i);\n        }\n    }\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n        int col = i + getArtificialVariableOffset();\n        if (getBasicRow(col) == null) {\n            columnsToDrop.add(col);\n        }\n    }\n    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n    for (int i = 1; i < getHeight(); i++) {\n        int col = 0;\n        for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n                matrix[i - 1][col++] = tableau.getEntry(i, j);\n            }\n        }\n    }\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n        columnLabels.remove((int) columnsToDrop.get(i));\n    }\n    this.tableau = new Array2DRowRealMatrix(matrix);\n    this.numArtificialVariables = 0;\n}", "lc": 0.8636363636363636, "pi": 0.2653061224489796, "ma": 1.0, "nbd": 0.5, "ml": 1.4166666666666667, "d": 2.264953040039546, "mi": -0.6352165184972759, "fo": 1.25, "r": -0.028571428571428574, "e": 3.715938341877926}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1820_39d526e6", "label": 0, "code": "/**\n *  Static utility to parse a field of type float from a byte sequence that represents text characters\n *  (such as when read from a file stream).\n *\n *  @param bytes The bytes containing the text data that should be parsed.\n *  @param startPos The offset to start the parsing.\n *  @param length The length of the byte sequence (counting from the offset).\n *  @param delimiter The delimiter that terminates the field.\n *\n *  @return The parsed value.\n *\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n */\npublic static final float parseField(byte[] bytes, int startPos, int length, char delimiter) {\n    if (length <= 0) {\n        throw new NumberFormatException(\"Invalid input: Empty string\");\n    }\n    int i = 0;\n    final byte delByte = (byte) delimiter;\n    while (i < length && bytes[i] != delByte) {\n        i++;\n    }\n    String str = new String(bytes, startPos, i);\n    return Float.parseFloat(str);\n}", "code_comment": "/**\n *  Static utility to parse a field of type float from a byte sequence that represents text characters\n *  (such as when read from a file stream).\n *\n *  @param bytes The bytes containing the text data that should be parsed.\n *  @param startPos The offset to start the parsing.\n *  @param length The length of the byte sequence (counting from the offset).\n *  @param delimiter The delimiter that terminates the field.\n *\n *  @return The parsed value.\n *\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n */\n", "code_no_comment": "public static final float parseField(byte[] bytes, int startPos, int length, char delimiter) {\n    if (length <= 0) {\n        throw new NumberFormatException(\"Invalid input: Empty string\");\n    }\n    int i = 0;\n    final byte delByte = (byte) delimiter;\n    while (i < length && bytes[i] != delByte) {\n        i++;\n    }\n    String str = new String(bytes, startPos, i);\n    return Float.parseFloat(str);\n}", "lc": -0.09090909090909091, "pi": -0.3622448979591837, "ma": 0.0, "nbd": -0.5, "ml": 0.08333333333333333, "d": 0.7661888284725656, "mi": 0.08718095784341821, "fo": -0.4166666666666667, "r": 0.14285714285714285, "e": 0.239484155027604}
{"project_name": "Closure", "project_version": 135, "label": 2, "code": "/**\n * Replaces references to \"this\" with references to name.  Do not\n * traverse function boundaries.\n */\nprivate void replaceReferencesToThis(Node node, String name) {\n    if (NodeUtil.isFunction(node)) {\n        return;\n    }\n    for (Node child : node.children()) {\n        if (NodeUtil.isThis(child)) {\n            Node newName = Node.newString(Token.NAME, name);\n            node.replaceChild(child, newName);\n        } else {\n            replaceReferencesToThis(child, name);\n        }\n    }\n}", "code_comment": "/**\n * Replaces references to \"this\" with references to name.  Do not\n * traverse function boundaries.\n */\n", "code_no_comment": "private void replaceReferencesToThis(Node node, String name) {\n    if (NodeUtil.isFunction(node)) {\n        return;\n    }\n    for (Node child : node.children()) {\n        if (NodeUtil.isThis(child)) {\n            Node newName = Node.newString(Token.NAME, name);\n            node.replaceChild(child, newName);\n        } else {\n            replaceReferencesToThis(child, name);\n        }\n    }\n}", "lc": -0.045454545454545456, "pi": 0.5051020408163264, "ma": 0.0, "nbd": 0.0, "ml": 0.08333333333333333, "d": -0.3806228373702422, "mi": 0.08718095784341821, "fo": 0.0, "r": 0.2285714285714286, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3861_d1e0e411", "label": 3, "code": "@Override\npublic void onComponentTag(final Component component, final ComponentTag tag) {\n    tag.put(\"xmlns:wicket\", \"http://wicket.apache.org\");\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void onComponentTag(final Component component, final ComponentTag tag) {\n    tag.put(\"xmlns:wicket\", \"http://wicket.apache.org\");\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8399770576426728, "fo": -0.4166666666666667, "r": 0.1142857142857143, "e": -0.16422749602751402}
{"project_name": "JxPath", "project_version": 16, "label": 3, "code": "/**\n * Test a Node.\n * @param node to test\n * @param test to execute\n * @return true if node passes test\n */\npublic static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType() != Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        int nodeType = node.getNodeType();\n        switch(((NodeTypeTest) test).getNodeType()) {\n            case Compiler.NODE_TYPE_NODE:\n                return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE;\n            case Compiler.NODE_TYPE_TEXT:\n                return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;\n            case Compiler.NODE_TYPE_COMMENT:\n                return nodeType == Node.COMMENT_NODE;\n            case Compiler.NODE_TYPE_PI:\n                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n        }\n        return false;\n    }\n    if (test instanceof ProcessingInstructionTest) {\n        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n    }\n    return false;\n}", "code_comment": "/**\n * Test a Node.\n * @param node to test\n * @param test to execute\n * @return true if node passes test\n */\n", "code_no_comment": "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType() != Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        int nodeType = node.getNodeType();\n        switch(((NodeTypeTest) test).getNodeType()) {\n            case Compiler.NODE_TYPE_NODE:\n                return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE;\n            case Compiler.NODE_TYPE_TEXT:\n                return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;\n            case Compiler.NODE_TYPE_COMMENT:\n                return nodeType == Node.COMMENT_NODE;\n            case Compiler.NODE_TYPE_PI:\n                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n        }\n        return false;\n    }\n    if (test instanceof ProcessingInstructionTest) {\n        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n    }\n    return false;\n}", "lc": 1.4090909090909092, "pi": 0.4591836734693877, "ma": 1.5, "nbd": 0.5, "ml": 1.4166666666666667, "d": 0.6159169550173011, "mi": -0.8247777459133929, "fo": 1.0, "r": -0.028571428571428574, "e": 1.5757170819038808}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2899_31aea2ad", "label": 0, "code": "public synchronized void open(String address) throws IOException {\n    String filename = UUID.randomUUID().toString();\n    String logger = StringUtil.join(Arrays.asList(address.split(\":\")), \"+\");\n    log.debug(\"DfsLogger.open() begin\");\n    VolumeManager fs = conf.getFileSystem();\n    logPath = fs.choose(ServerConstants.getWalDirs()) + \"/\" + logger + \"/\" + filename;\n    try {\n        short replication = (short) conf.getConfiguration().getCount(Property.TSERV_WAL_REPLICATION);\n        if (replication == 0)\n            replication = fs.getDefaultReplication(new Path(logPath));\n        long blockSize = conf.getConfiguration().getMemoryInBytes(Property.TSERV_WAL_BLOCKSIZE);\n        if (blockSize == 0)\n            blockSize = (long) (conf.getConfiguration().getMemoryInBytes(Property.TSERV_WALOG_MAX_SIZE) * 1.1);\n        if (conf.getConfiguration().getBoolean(Property.TSERV_WAL_SYNC))\n            logFile = fs.createSyncable(new Path(logPath), 0, replication, blockSize);\n        else\n            logFile = fs.create(new Path(logPath), true, 0, replication, blockSize);\n        String syncMethod = conf.getConfiguration().get(Property.TSERV_WAL_SYNC_METHOD);\n        try {\n            // hsync: send data to datanodes and sync the data to disk\n            sync = logFile.getClass().getMethod(syncMethod);\n        } catch (Exception ex) {\n            log.warn(\"Could not find configured \" + syncMethod + \" method, trying to fall back to old Hadoop sync method\", ex);\n            try {\n                // sync: send data to datanodes\n                sync = logFile.getClass().getMethod(\"sync\");\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n        // Initialize the crypto operations.\n        org.apache.accumulo.core.security.crypto.CryptoModule cryptoModule = org.apache.accumulo.core.security.crypto.CryptoModuleFactory.getCryptoModule(conf.getConfiguration().get(Property.CRYPTO_MODULE_CLASS));\n        // Initialize the log file with a header and the crypto params used to set up this log file.\n        logFile.write(LOG_FILE_HEADER_V3.getBytes(Constants.UTF8));\n        CryptoModuleParameters params = CryptoModuleFactory.createParamsObjectFromAccumuloConfiguration(conf.getConfiguration());\n        NoFlushOutputStream nfos = new NoFlushOutputStream(logFile);\n        params.setPlaintextOutputStream(nfos);\n        // In order to bootstrap the reading of this file later, we have to record the CryptoModule that was used to encipher it here,\n        // so that that crypto module can re-read its own parameters.\n        logFile.writeUTF(conf.getConfiguration().get(Property.CRYPTO_MODULE_CLASS));\n        params = cryptoModule.getEncryptingOutputStream(params);\n        OutputStream encipheringOutputStream = params.getEncryptedOutputStream();\n        // another data OutputStream.\n        if (encipheringOutputStream == nfos) {\n            log.debug(\"No enciphering, using raw output stream\");\n            encryptingLogFile = nfos;\n        } else {\n            log.debug(\"Enciphering found, wrapping in DataOutputStream\");\n            encryptingLogFile = new DataOutputStream(encipheringOutputStream);\n        }\n        LogFileKey key = new LogFileKey();\n        key.event = OPEN;\n        key.tserverSession = filename;\n        key.filename = filename;\n        write(key, EMPTY);\n        sync.invoke(logFile);\n        log.debug(\"Got new write-ahead log: \" + this);\n    } catch (Exception ex) {\n        if (logFile != null)\n            logFile.close();\n        logFile = null;\n        encryptingLogFile = null;\n        throw new IOException(ex);\n    }\n    syncThread = new Daemon(new LoggingRunnable(log, new LogSyncingTask()));\n    syncThread.setName(\"Accumulo WALog thread \" + toString());\n    syncThread.start();\n}", "code_comment": NaN, "code_no_comment": "public synchronized void open(String address) throws IOException {\n    String filename = UUID.randomUUID().toString();\n    String logger = StringUtil.join(Arrays.asList(address.split(\":\")), \"+\");\n    log.debug(\"DfsLogger.open() begin\");\n    VolumeManager fs = conf.getFileSystem();\n    logPath = fs.choose(ServerConstants.getWalDirs()) + \"/\" + logger + \"/\" + filename;\n    try {\n        short replication = (short) conf.getConfiguration().getCount(Property.TSERV_WAL_REPLICATION);\n        if (replication == 0)\n            replication = fs.getDefaultReplication(new Path(logPath));\n        long blockSize = conf.getConfiguration().getMemoryInBytes(Property.TSERV_WAL_BLOCKSIZE);\n        if (blockSize == 0)\n            blockSize = (long) (conf.getConfiguration().getMemoryInBytes(Property.TSERV_WALOG_MAX_SIZE) * 1.1);\n        if (conf.getConfiguration().getBoolean(Property.TSERV_WAL_SYNC))\n            logFile = fs.createSyncable(new Path(logPath), 0, replication, blockSize);\n        else\n            logFile = fs.create(new Path(logPath), true, 0, replication, blockSize);\n        String syncMethod = conf.getConfiguration().get(Property.TSERV_WAL_SYNC_METHOD);\n        try {\n                        sync = logFile.getClass().getMethod(syncMethod);\n        } catch (Exception ex) {\n            log.warn(\"Could not find configured \" + syncMethod + \" method, trying to fall back to old Hadoop sync method\", ex);\n            try {\n                                sync = logFile.getClass().getMethod(\"sync\");\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n                org.apache.accumulo.core.security.crypto.CryptoModule cryptoModule = org.apache.accumulo.core.security.crypto.CryptoModuleFactory.getCryptoModule(conf.getConfiguration().get(Property.CRYPTO_MODULE_CLASS));\n                logFile.write(LOG_FILE_HEADER_V3.getBytes(Constants.UTF8));\n        CryptoModuleParameters params = CryptoModuleFactory.createParamsObjectFromAccumuloConfiguration(conf.getConfiguration());\n        NoFlushOutputStream nfos = new NoFlushOutputStream(logFile);\n        params.setPlaintextOutputStream(nfos);\n                        logFile.writeUTF(conf.getConfiguration().get(Property.CRYPTO_MODULE_CLASS));\n        params = cryptoModule.getEncryptingOutputStream(params);\n        OutputStream encipheringOutputStream = params.getEncryptedOutputStream();\n                if (encipheringOutputStream == nfos) {\n            log.debug(\"No enciphering, using raw output stream\");\n            encryptingLogFile = nfos;\n        } else {\n            log.debug(\"Enciphering found, wrapping in DataOutputStream\");\n            encryptingLogFile = new DataOutputStream(encipheringOutputStream);\n        }\n        LogFileKey key = new LogFileKey();\n        key.event = OPEN;\n        key.tserverSession = filename;\n        key.filename = filename;\n        write(key, EMPTY);\n        sync.invoke(logFile);\n        log.debug(\"Got new write-ahead log: \" + this);\n    } catch (Exception ex) {\n        if (logFile != null)\n            logFile.close();\n        logFile = null;\n        encryptingLogFile = null;\n        throw new IOException(ex);\n    }\n    syncThread = new Daemon(new LoggingRunnable(log, new LogSyncingTask()));\n    syncThread.setName(\"Accumulo WALog thread \" + toString());\n    syncThread.start();\n}", "lc": 2.1363636363636362, "pi": 0.12755102040816327, "ma": 1.1666666666666667, "nbd": 0.5, "ml": 0.5, "d": 0.44389520514088, "mi": -1.072555205047319, "fo": 3.5833333333333335, "r": -0.028571428571428574, "e": 3.0415836834688905}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4309_b4274415", "label": 1, "code": "/**\n *  Convert to object types, returning null if text is null.\n *\n *  @return converted\n *  @throws StringValueConversionException\n */\npublic final Double toOptionalDouble() throws StringValueConversionException {\n    return (text == null) ? null : toDoubleObject();\n}", "code_comment": "/**\n *  Convert to object types, returning null if text is null.\n *\n *  @return converted\n *  @throws StringValueConversionException\n */\n", "code_no_comment": "public final Double toOptionalDouble() throws StringValueConversionException {\n    return (text == null) ? null : toDoubleObject();\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.3333333333333333, "nbd": -1.0, "ml": -0.25, "d": -0.3806228373702422, "mi": 1.012044737596788, "fo": -0.4166666666666667, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-2974_5eceb10e", "label": 0, "code": "@Override\npublic Path getFullPath(FileType fileType, String path) {\n    int colon = path.indexOf(':');\n    if (colon > -1) {\n        // Check if this is really an absolute path or if this is a 1.4 style relative path for a WAL\n        if (fileType == FileType.WAL && path.charAt(colon + 1) != '/') {\n            path = path.substring(path.indexOf('/'));\n        } else {\n            return new Path(path);\n        }\n    }\n    // normalize the path\n    Path fullPath = new Path(defaultVolume.getBasePath(), fileType.getDirectory());\n    if (path.startsWith(\"/\"))\n        path = path.substring(1);\n    fullPath = new Path(fullPath, path);\n    FileSystem fs = getVolumeByPath(fullPath).getFileSystem();\n    return fs.makeQualified(fullPath);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Path getFullPath(FileType fileType, String path) {\n    int colon = path.indexOf(':');\n    if (colon > -1) {\n                if (fileType == FileType.WAL && path.charAt(colon + 1) != '/') {\n            path = path.substring(path.indexOf('/'));\n        } else {\n            return new Path(path);\n        }\n    }\n        Path fullPath = new Path(defaultVolume.getBasePath(), fileType.getDirectory());\n    if (path.startsWith(\"/\"))\n        path = path.substring(1);\n    fullPath = new Path(fullPath, path);\n    FileSystem fs = getVolumeByPath(fullPath).getFileSystem();\n    return fs.makeQualified(fullPath);\n}", "lc": 0.13636363636363635, "pi": 0.2806122448979591, "ma": 0.0, "nbd": 0.0, "ml": 0.25, "d": 0.8966880869995059, "mi": -0.18583309435044468, "fo": 0.4166666666666667, "r": -0.028571428571428574, "e": 0.7850703055066579}
{"project_name": "Closure", "project_version": 91, "label": 2, "code": "/**\n * Since this pass reports errors only when a global {@code this} keyword\n * is encountered, there is no reason to traverse non global contexts.\n */\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // or @override annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {}; // or\n        // var a = {x: function() {}};\n        int pType = parent.getType();\n        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN || // object literal keys\n        pType == Token.STRING || pType == Token.NUMBER)) {\n            return false;\n        }\n    // Don't traverse functions that are getting lent to a prototype.\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // property or subproperty.\n            if (NodeUtil.isGet(lhs)) {\n                if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                Node llhs = lhs.getFirstChild();\n                if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "code_comment": "/**\n * Since this pass reports errors only when a global {@code this} keyword\n * is encountered, there is no reason to traverse non global contexts.\n */\n", "code_no_comment": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n                        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) {\n            return false;\n        }\n                                                        int pType = parent.getType();\n        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN ||         pType == Token.STRING || pType == Token.NUMBER)) {\n            return false;\n        }\n        }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n                        if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n                        if (NodeUtil.isGet(lhs)) {\n                if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                Node llhs = lhs.getFirstChild();\n                if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "lc": 0.8636363636363636, "pi": 1.0765306122448979, "ma": 1.0, "nbd": 1.0, "ml": 2.75, "d": 1.0568462679189323, "mi": -0.6415256667622601, "fo": 1.1666666666666667, "r": -0.028571428571428574, "e": 2.038752617986046}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1761_380ef878", "label": 1, "code": "private void notifyAllChannelsOfErrorAndClose(Throwable cause) {\n    if (channelError.compareAndSet(false, true)) {\n        for (RemoteInputChannel inputChannel : inputChannels.values()) {\n            inputChannel.onError(cause);\n        }\n        inputChannels.clear();\n        ctx.close();\n    }\n}", "code_comment": NaN, "code_no_comment": "private void notifyAllChannelsOfErrorAndClose(Throwable cause) {\n    if (channelError.compareAndSet(false, true)) {\n        for (RemoteInputChannel inputChannel : inputChannels.values()) {\n            inputChannel.onError(cause);\n        }\n        inputChannels.clear();\n        ctx.close();\n    }\n}", "lc": -0.22727272727272727, "pi": 0.40816326530612235, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.25, "d": -0.3806228373702422, "mi": 0.3409807857757386, "fo": -0.08333333333333333, "r": 0.2571428571428572, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2933_44585b0c", "label": 1, "code": "private Validator visibleValidator(@Nonnull Tree source, @Nonnull Tree dest) {\n    // TODO improve: avoid calculating the 'before' permissions in case the current parent permissions already point to the correct tree.\n    ImmutableTree parent = (ImmutableTree) moveCtx.rootBefore.getTree(\"/\");\n    TreePermission tp = getPermissionProvider().getTreePermission(parent, TreePermission.EMPTY);\n    for (String n : PathUtils.elements(source.getPath())) {\n        tp = tp.getChildPermission(n, parent.getChild(n).getNodeState());\n    }\n    Validator validator = createValidator(source, dest, tp, this);\n    return new VisibleValidator(validator, true, false);\n}", "code_comment": NaN, "code_no_comment": "private Validator visibleValidator(@Nonnull Tree source, @Nonnull Tree dest) {\n        ImmutableTree parent = (ImmutableTree) moveCtx.rootBefore.getTree(\"/\");\n    TreePermission tp = getPermissionProvider().getTreePermission(parent, TreePermission.EMPTY);\n    for (String n : PathUtils.elements(source.getPath())) {\n        tp = tp.getChildPermission(n, parent.getChild(n).getNodeState());\n    }\n    Validator validator = createValidator(source, dest, tp, this);\n    return new VisibleValidator(validator, true, false);\n}", "lc": -0.22727272727272727, "pi": -0.3826530612244898, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.16690564955549167, "fo": 0.25, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "JxPath", "project_version": 19, "label": 1, "code": "/**\n * Get relative position of this among like-named siblings.\n * @return 1..n\n */\nprivate int getRelativePositionByQName() {\n    int count = 1;\n    Node n = node.getPreviousSibling();\n    while (n != null) {\n        if (n.getNodeType() == Node.ELEMENT_NODE) {\n            String nm = n.getNodeName();\n            if (nm.equals(node.getNodeName())) {\n                count++;\n            }\n        }\n        n = n.getPreviousSibling();\n    }\n    return count;\n}", "code_comment": "/**\n * Get relative position of this among like-named siblings.\n * @return 1..n\n */\n", "code_no_comment": "private int getRelativePositionByQName() {\n    int count = 1;\n    Node n = node.getPreviousSibling();\n    while (n != null) {\n        if (n.getNodeType() == Node.ELEMENT_NODE) {\n            String nm = n.getNodeName();\n            if (nm.equals(node.getNodeName())) {\n                count++;\n            }\n        }\n        n = n.getPreviousSibling();\n    }\n    return count;\n}", "lc": 0.0, "pi": 0.8265306122448978, "ma": 0.0, "nbd": 0.5, "ml": 0.16666666666666666, "d": 0.33119130004943165, "mi": 0.033266418124462196, "fo": 0.0, "r": 1.9714285714285713, "e": 0.05846728427580833}
{"project_name": "Closure", "project_version": 62, "label": 2, "code": "private String format(JSError error, boolean warning) {\n    // extract source excerpt\n    SourceExcerptProvider source = getSource();\n    String sourceExcerpt = source == null ? null : excerpt.get(source, error.sourceName, error.lineNumber, excerptFormatter);\n    // formatting the message\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n        b.append(error.sourceName);\n        if (error.lineNumber > 0) {\n            b.append(':');\n            b.append(error.lineNumber);\n        }\n        b.append(\": \");\n    }\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n        b.append(sourceExcerpt);\n        b.append('\\n');\n        int charno = error.getCharno();\n        // at the end of the line\n        if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) {\n            for (int i = 0; i < charno; i++) {\n                char c = sourceExcerpt.charAt(i);\n                if (Character.isWhitespace(c)) {\n                    b.append(c);\n                } else {\n                    b.append(' ');\n                }\n            }\n            b.append(\"^\\n\");\n        }\n    }\n    return b.toString();\n}", "code_comment": NaN, "code_no_comment": "private String format(JSError error, boolean warning) {\n        SourceExcerptProvider source = getSource();\n    String sourceExcerpt = source == null ? null : excerpt.get(source, error.sourceName, error.lineNumber, excerptFormatter);\n        StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n        b.append(error.sourceName);\n        if (error.lineNumber > 0) {\n            b.append(':');\n            b.append(error.lineNumber);\n        }\n        b.append(\": \");\n    }\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n        b.append(sourceExcerpt);\n        b.append('\\n');\n        int charno = error.getCharno();\n                if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) {\n            for (int i = 0; i < charno; i++) {\n                char c = sourceExcerpt.charAt(i);\n                if (Character.isWhitespace(c)) {\n                    b.append(c);\n                } else {\n                    b.append(' ');\n                }\n            }\n            b.append(\"^\\n\");\n        }\n    }\n    return b.toString();\n}", "lc": 0.9090909090909091, "pi": 1.1428571428571428, "ma": 0.8333333333333334, "nbd": 1.0, "ml": 1.3333333333333333, "d": 1.596638655462185, "mi": -0.6435331230283913, "fo": 1.3333333333333333, "r": -0.028571428571428574, "e": 2.760665750103863}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3189_a5b05566", "label": 3, "code": "public static InfoOptions parseInfoCommand(String[] args) throws CliArgsException {\n    try {\n        PosixParser parser = new PosixParser();\n        CommandLine line = parser.parse(INFO_OPTIONS, args, false);\n        return new InfoOptions(line);\n    } catch (ParseException e) {\n        throw new CliArgsException(e.getMessage());\n    }\n}", "code_comment": NaN, "code_no_comment": "public static InfoOptions parseInfoCommand(String[] args) throws CliArgsException {\n    try {\n        PosixParser parser = new PosixParser();\n        CommandLine line = parser.parse(INFO_OPTIONS, args, false);\n        return new InfoOptions(line);\n    } catch (ParseException e) {\n        throw new CliArgsException(e.getMessage());\n    }\n}", "lc": -0.22727272727272727, "pi": 0.06122448979591842, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.2968167479208488, "fo": -0.3333333333333333, "r": 0.9714285714285714, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1044_ea2f9856", "label": 0, "code": "public List<Short> check(Environment env, Mutation mutation) {\n    ArrayList<Short> violations = null;\n    Collection<ColumnUpdate> colUpdates = mutation.getUpdates();\n    // check the row, it should contains at least one ; or end with <\n    boolean containsSemiC = false;\n    byte[] row = mutation.getRow();\n    // always allow rows that fall within reserved area\n    if (row.length > 0 && row[0] == '~')\n        return null;\n    for (byte b : row) {\n        if (b == ';') {\n            containsSemiC = true;\n        }\n        if (b == ';' || b == '<')\n            break;\n        if (!validTableNameChars[0xff & b]) {\n            if (violations == null)\n                violations = new ArrayList<Short>();\n            if (!violations.contains((short) 4))\n                violations.add((short) 4);\n        }\n    }\n    if (!containsSemiC) {\n        // see if last row char is <\n        if (row.length == 0 || row[row.length - 1] != '<') {\n            if (violations == null)\n                violations = new ArrayList<Short>();\n            if (!violations.contains((short) 4))\n                violations.add((short) 4);\n        }\n    } else {\n        if (row.length == 0) {\n            if (violations == null)\n                violations = new ArrayList<Short>();\n            if (!violations.contains((short) 4))\n                violations.add((short) 4);\n        }\n    }\n    if (row.length > 0 && row[0] == '!') {\n        if (row.length < 3 || row[1] != '0' || (row[2] != '<' && row[2] != ';')) {\n            if (violations == null)\n                violations = new ArrayList<Short>();\n            if (!violations.contains((short) 4))\n                violations.add((short) 4);\n        }\n    }\n    // ensure row is not less than Constants.METADATA_TABLE_ID\n    if (new Text(row).compareTo(new Text(Constants.METADATA_TABLE_ID)) < 0) {\n        if (violations == null)\n            violations = new ArrayList<Short>();\n        violations.add((short) 5);\n    }\n    for (ColumnUpdate columnUpdate : colUpdates) {\n        Text columnFamily = new Text(columnUpdate.getColumnFamily());\n        if (columnUpdate.isDeleted()) {\n            if (!isValidColumn(columnUpdate)) {\n                if (violations == null)\n                    violations = new ArrayList<Short>();\n                violations.add((short) 2);\n            }\n            continue;\n        }\n        if (columnUpdate.getValue().length == 0 && !columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {\n            if (violations == null)\n                violations = new ArrayList<Short>();\n            violations.add((short) 6);\n        }\n        if (columnFamily.equals(Constants.METADATA_DATAFILE_COLUMN_FAMILY)) {\n            try {\n                DataFileValue dfv = new DataFileValue(columnUpdate.getValue());\n                if (dfv.getSize() < 0 || dfv.getNumEntries() < 0) {\n                    if (violations == null)\n                        violations = new ArrayList<Short>();\n                    violations.add((short) 1);\n                }\n            } catch (NumberFormatException nfe) {\n                if (violations == null)\n                    violations = new ArrayList<Short>();\n                violations.add((short) 1);\n            } catch (ArrayIndexOutOfBoundsException aiooe) {\n                if (violations == null)\n                    violations = new ArrayList<Short>();\n                violations.add((short) 1);\n            }\n        } else if (columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {\n        } else {\n            if (!isValidColumn(columnUpdate)) {\n                if (violations == null)\n                    violations = new ArrayList<Short>();\n                violations.add((short) 2);\n            } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_PREV_ROW_COLUMN) && columnUpdate.getValue().length > 0 && (violations == null || !violations.contains((short) 4))) {\n                KeyExtent ke = new KeyExtent(new Text(mutation.getRow()), (Text) null);\n                Text per = KeyExtent.decodePrevEndRow(new Value(columnUpdate.getValue()));\n                boolean prevEndRowLessThanEndRow = per == null || ke.getEndRow() == null || per.compareTo(ke.getEndRow()) < 0;\n                if (!prevEndRowLessThanEndRow) {\n                    if (violations == null)\n                        violations = new ArrayList<Short>();\n                    violations.add((short) 3);\n                }\n            } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_LOCK_COLUMN)) {\n                if (zooCache == null) {\n                    zooCache = new ZooCache();\n                }\n                if (zooRoot == null) {\n                    zooRoot = ZooUtil.getRoot(HdfsZooInstance.getInstance());\n                }\n                boolean lockHeld = false;\n                String lockId = new String(columnUpdate.getValue());\n                try {\n                    lockHeld = ZooLock.isLockHeld(zooCache, new ZooUtil.LockID(zooRoot, lockId));\n                } catch (Exception e) {\n                    log.debug(\"Failed to verify lock was held \" + lockId + \" \" + e.getMessage());\n                }\n                if (!lockHeld) {\n                    if (violations == null)\n                        violations = new ArrayList<Short>();\n                    violations.add((short) 7);\n                }\n            }\n        }\n    }\n    if (violations != null) {\n        log.debug(\" violating metadata mutation : \" + mutation);\n    }\n    return violations;\n}", "code_comment": NaN, "code_no_comment": "public List<Short> check(Environment env, Mutation mutation) {\n    ArrayList<Short> violations = null;\n    Collection<ColumnUpdate> colUpdates = mutation.getUpdates();\n        boolean containsSemiC = false;\n    byte[] row = mutation.getRow();\n        if (row.length > 0 && row[0] == '~')\n        return null;\n    for (byte b : row) {\n        if (b == ';') {\n            containsSemiC = true;\n        }\n        if (b == ';' || b == '<')\n            break;\n        if (!validTableNameChars[0xff & b]) {\n            if (violations == null)\n                violations = new ArrayList<Short>();\n            if (!violations.contains((short) 4))\n                violations.add((short) 4);\n        }\n    }\n    if (!containsSemiC) {\n                if (row.length == 0 || row[row.length - 1] != '<') {\n            if (violations == null)\n                violations = new ArrayList<Short>();\n            if (!violations.contains((short) 4))\n                violations.add((short) 4);\n        }\n    } else {\n        if (row.length == 0) {\n            if (violations == null)\n                violations = new ArrayList<Short>();\n            if (!violations.contains((short) 4))\n                violations.add((short) 4);\n        }\n    }\n    if (row.length > 0 && row[0] == '!') {\n        if (row.length < 3 || row[1] != '0' || (row[2] != '<' && row[2] != ';')) {\n            if (violations == null)\n                violations = new ArrayList<Short>();\n            if (!violations.contains((short) 4))\n                violations.add((short) 4);\n        }\n    }\n        if (new Text(row).compareTo(new Text(Constants.METADATA_TABLE_ID)) < 0) {\n        if (violations == null)\n            violations = new ArrayList<Short>();\n        violations.add((short) 5);\n    }\n    for (ColumnUpdate columnUpdate : colUpdates) {\n        Text columnFamily = new Text(columnUpdate.getColumnFamily());\n        if (columnUpdate.isDeleted()) {\n            if (!isValidColumn(columnUpdate)) {\n                if (violations == null)\n                    violations = new ArrayList<Short>();\n                violations.add((short) 2);\n            }\n            continue;\n        }\n        if (columnUpdate.getValue().length == 0 && !columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {\n            if (violations == null)\n                violations = new ArrayList<Short>();\n            violations.add((short) 6);\n        }\n        if (columnFamily.equals(Constants.METADATA_DATAFILE_COLUMN_FAMILY)) {\n            try {\n                DataFileValue dfv = new DataFileValue(columnUpdate.getValue());\n                if (dfv.getSize() < 0 || dfv.getNumEntries() < 0) {\n                    if (violations == null)\n                        violations = new ArrayList<Short>();\n                    violations.add((short) 1);\n                }\n            } catch (NumberFormatException nfe) {\n                if (violations == null)\n                    violations = new ArrayList<Short>();\n                violations.add((short) 1);\n            } catch (ArrayIndexOutOfBoundsException aiooe) {\n                if (violations == null)\n                    violations = new ArrayList<Short>();\n                violations.add((short) 1);\n            }\n        } else if (columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {\n        } else {\n            if (!isValidColumn(columnUpdate)) {\n                if (violations == null)\n                    violations = new ArrayList<Short>();\n                violations.add((short) 2);\n            } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_PREV_ROW_COLUMN) && columnUpdate.getValue().length > 0 && (violations == null || !violations.contains((short) 4))) {\n                KeyExtent ke = new KeyExtent(new Text(mutation.getRow()), (Text) null);\n                Text per = KeyExtent.decodePrevEndRow(new Value(columnUpdate.getValue()));\n                boolean prevEndRowLessThanEndRow = per == null || ke.getEndRow() == null || per.compareTo(ke.getEndRow()) < 0;\n                if (!prevEndRowLessThanEndRow) {\n                    if (violations == null)\n                        violations = new ArrayList<Short>();\n                    violations.add((short) 3);\n                }\n            } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_LOCK_COLUMN)) {\n                if (zooCache == null) {\n                    zooCache = new ZooCache();\n                }\n                if (zooRoot == null) {\n                    zooRoot = ZooUtil.getRoot(HdfsZooInstance.getInstance());\n                }\n                boolean lockHeld = false;\n                String lockId = new String(columnUpdate.getValue());\n                try {\n                    lockHeld = ZooLock.isLockHeld(zooCache, new ZooUtil.LockID(zooRoot, lockId));\n                } catch (Exception e) {\n                    log.debug(\"Failed to verify lock was held \" + lockId + \" \" + e.getMessage());\n                }\n                if (!lockHeld) {\n                    if (violations == null)\n                        violations = new ArrayList<Short>();\n                    violations.add((short) 7);\n                }\n            }\n        }\n    }\n    if (violations != null) {\n        log.debug(\" violating metadata mutation : \" + mutation);\n    }\n    return violations;\n}", "lc": 4.909090909090909, "pi": 1.3010204081632655, "ma": 7.5, "nbd": 2.5, "ml": 5.666666666666667, "d": 3.233811171527435, "mi": -1.7135073128763985, "fo": 3.5, "r": -0.028571428571428574, "e": 22.040170292229348}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1250_0c3b3306", "label": 1, "code": "@Override\n@Nonnull\npublic synchronized String checkpoint(long lifetime) {\n    checkArgument(lifetime > 0);\n    // TODO: Guard the checkpoint from garbage collection\n    return head.getRecordId().toString();\n}", "code_comment": NaN, "code_no_comment": "@Override\n@Nonnull\npublic synchronized String checkpoint(long lifetime) {\n    checkArgument(lifetime > 0);\n        return head.getRecordId().toString();\n}", "lc": -0.36363636363636365, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.6154287353025524, "fo": -0.25, "r": 2.285714285714286, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6447_020c451a", "label": 1, "code": "/**\n * Ends the current block and returns back to the {@link ChoiceDefinition choice()} DSL.\n *\n * @return the builder\n */\npublic ChoiceDefinition endChoice() {\n    // are we already a choice?\n    ProcessorDefinition<?> def = this;\n    if (def instanceof ChoiceDefinition) {\n        return (ChoiceDefinition) def;\n    }\n    // okay end this and get back to the choice\n    def = end();\n    if (def instanceof WhenDefinition) {\n        return (ChoiceDefinition) def.getParent();\n    } else if (def instanceof OtherwiseDefinition) {\n        return (ChoiceDefinition) def.getParent();\n    } else {\n        return (ChoiceDefinition) def;\n    }\n}", "code_comment": "/**\n * Ends the current block and returns back to the {@link ChoiceDefinition choice()} DSL.\n *\n * @return the builder\n */\n", "code_no_comment": "public ChoiceDefinition endChoice() {\n        ProcessorDefinition<?> def = this;\n    if (def instanceof ChoiceDefinition) {\n        return (ChoiceDefinition) def;\n    }\n        def = end();\n    if (def instanceof WhenDefinition) {\n        return (ChoiceDefinition) def.getParent();\n    } else if (def instanceof OtherwiseDefinition) {\n        return (ChoiceDefinition) def.getParent();\n    } else {\n        return (ChoiceDefinition) def;\n    }\n}", "lc": 0.0, "pi": -0.2346938775510204, "ma": 0.0, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.3806228373702422, "mi": 0.11585890450243742, "fo": -0.25, "r": 0.3428571428571429, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1312_d9ab8449", "label": 1, "code": "@Override\npublic Connector getConnector(String principal, AuthenticationToken token) throws AccumuloException, AccumuloSecurityException {\n    Connector conn = new MockConnector(principal, acu, this);\n    if (!acu.users.containsKey(principal))\n        conn.securityOperations().createLocalUser(principal, (PasswordToken) token);\n    else if (!acu.users.get(principal).token.equals(token))\n        throw new AccumuloSecurityException(principal, SecurityErrorCode.BAD_CREDENTIALS);\n    return conn;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Connector getConnector(String principal, AuthenticationToken token) throws AccumuloException, AccumuloSecurityException {\n    Connector conn = new MockConnector(principal, acu, this);\n    if (!acu.users.containsKey(principal))\n        conn.securityOperations().createLocalUser(principal, (PasswordToken) token);\n    else if (!acu.users.get(principal).token.equals(token))\n        throw new AccumuloSecurityException(principal, SecurityErrorCode.BAD_CREDENTIALS);\n    return conn;\n}", "lc": -0.22727272727272727, "pi": -0.035714285714285636, "ma": 0.0, "nbd": -1.0, "ml": 0.08333333333333333, "d": -0.04844290657439445, "mi": 0.20275308287926572, "fo": -0.08333333333333333, "r": -0.028571428571428574, "e": -0.03212252817145721}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-757_76b7413d", "label": 1, "code": "/**\n * Expands the internal storage array using the expansion factor.\n * <p>\n * if <code>expansionMode</code> is set to MULTIPLICATIVE_MODE,\n * the new array size will be <code>internalArray.length * expansionFactor.</code>\n * If <code>expansionMode</code> is set to ADDITIVE_MODE,  the length\n * after expansion will be <code>internalArray.length + expansionFactor</code>\n * </p>\n */\nprotected synchronized void expand() {\n    // notice the use of FastMath.ceil(), this guarantees that we will always\n    // have an array of at least currentSize + 1.   Assume that the\n    // current initial capacity is 1 and the expansion factor\n    // is 1.000000000000000001.  The newly calculated size will be\n    // rounded up to 2 after the multiplication is performed.\n    int newSize = 0;\n    if (expansionMode == ExpansionMode.MULTIPLICATIVE) {\n        newSize = (int) FastMath.ceil(internalArray.length * expansionFactor);\n    } else {\n        newSize = (int) (internalArray.length + FastMath.round(expansionFactor));\n    }\n    final double[] tempArray = new double[newSize];\n    // Copy and swap\n    System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\n    internalArray = tempArray;\n}", "code_comment": "/**\n * Expands the internal storage array using the expansion factor.\n * <p>\n * if <code>expansionMode</code> is set to MULTIPLICATIVE_MODE,\n * the new array size will be <code>internalArray.length * expansionFactor.</code>\n * If <code>expansionMode</code> is set to ADDITIVE_MODE,  the length\n * after expansion will be <code>internalArray.length + expansionFactor</code>\n * </p>\n */\n", "code_no_comment": "protected synchronized void expand() {\n                        int newSize = 0;\n    if (expansionMode == ExpansionMode.MULTIPLICATIVE) {\n        newSize = (int) FastMath.ceil(internalArray.length * expansionFactor);\n    } else {\n        newSize = (int) (internalArray.length + FastMath.round(expansionFactor));\n    }\n    final double[] tempArray = new double[newSize];\n        System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\n    internalArray = tempArray;\n}", "lc": -0.13636363636363635, "pi": -0.3112244897959183, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": 0.38655462184873957, "mi": 0.1353599082305707, "fo": -0.25, "r": 0.0, "e": 0.1155168943083163}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-4138_50db442b", "label": 1, "code": "/**\n * Starts a full major compaction of the tablets in the range (start, end]. The compaction is preformed even for tablets that have only one file.\n *\n * @param tableName\n *          the table to compact\n * @param start\n *          first tablet to be compacted contains the row after this row, null means the first tablet in table\n * @param end\n *          last tablet to be merged contains this row, null means the last tablet in table\n * @param iterators\n *          A set of iterators that will be applied to each tablet compacted\n * @param flush\n *          when true, table memory is flushed before compaction starts\n * @param wait\n *          when true, the call will not return until compactions are finished\n * @since 1.5.0\n */\nvoid compact(String tableName, Text start, Text end, List<IteratorSetting> iterators, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException;", "code_comment": "/**\n * Starts a full major compaction of the tablets in the range (start, end]. The compaction is preformed even for tablets that have only one file.\n *\n * @param tableName\n *          the table to compact\n * @param start\n *          first tablet to be compacted contains the row after this row, null means the first tablet in table\n * @param end\n *          last tablet to be merged contains this row, null means the last tablet in table\n * @param iterators\n *          A set of iterators that will be applied to each tablet compacted\n * @param flush\n *          when true, table memory is flushed before compaction starts\n * @param wait\n *          when true, the call will not return until compactions are finished\n * @since 1.5.0\n */\n", "code_no_comment": "void compact(String tableName, Text start, Text end, List<IteratorSetting> iterators, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException;", "lc": -0.5909090909090909, "pi": -1.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.4040722684255813, "fo": -0.5, "r": 0.3428571428571429, "e": -0.16422749602751402}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1640_8f321c72", "label": 1, "code": "/**\n *  Returns the final component of this path.\n *\n *  @return the final component of the path\n */\npublic String getName() {\n    final String path = uri.getPath();\n    if (path.endsWith(SEPARATOR)) {\n        final int slash = path.lastIndexOf(SEPARATOR, path.length() - SEPARATOR.length() - 1);\n        return path.substring(slash + 1, path.length() - SEPARATOR.length());\n    } else {\n        final int slash = path.lastIndexOf(SEPARATOR);\n        return path.substring(slash + 1);\n    }\n}", "code_comment": "/**\n *  Returns the final component of this path.\n *\n *  @return the final component of the path\n */\n", "code_no_comment": "public String getName() {\n    final String path = uri.getPath();\n    if (path.endsWith(SEPARATOR)) {\n        final int slash = path.lastIndexOf(SEPARATOR, path.length() - SEPARATOR.length() - 1);\n        return path.substring(slash + 1, path.length() - SEPARATOR.length());\n    } else {\n        final int slash = path.lastIndexOf(SEPARATOR);\n        return path.substring(slash + 1);\n    }\n}", "lc": -0.18181818181818182, "pi": -0.015306122448979493, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": 0.15126050420168072, "mi": 0.18009750501864075, "fo": 0.3333333333333333, "r": 0.05714285714285714, "e": 0.029497046868910106}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2172_ea4a3f8a", "label": 3, "code": "/**\n *  @see java.util.Map#putAll(java.util.Map)\n */\n@Override\npublic void putAll(final Map map) {\n    checkMutability();\n    super.putAll(map);\n}", "code_comment": "/**\n *  @see java.util.Map#putAll(java.util.Map)\n */\n", "code_no_comment": "@Override\npublic void putAll(final Map map) {\n    checkMutability();\n    super.putAll(map);\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8213363923143101, "fo": -0.3333333333333333, "r": 2.685714285714286, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4365_1485a856", "label": 1, "code": "/**\n *  Process the form. Though you can override this method to provide your own algorithm, it is\n *  not recommended to do so.\n *\n *  <p>\n *  See the class documentation for further details on the form processing\n *  </p>\n *\n *  @param submittingComponent\n *             component responsible for submitting the form, or <code>null</code> if none (eg\n *             the form has been submitted via the enter key or javascript calling\n *             form.onsubmit())\n *\n *  @see #delegateSubmit(IFormSubmitter) for an easy way to process submitting component in the\n *       default manner\n */\npublic void process(IFormSubmitter submittingComponent) {\n    // save the page in case the component is removed during submit\n    final Page page = getPage();\n    String hiddenFieldId = getHiddenFieldId();\n    if (!isEnabledInHierarchy() || !isVisibleInHierarchy()) {\n        // FIXME throw listener exception\n        return;\n    }\n    // run validation\n    validate();\n    // If a validation error occurred\n    if (hasError()) {\n        // mark all children as invalid\n        markFormComponentsInvalid();\n        // let subclass handle error\n        callOnError(submittingComponent);\n    } else {\n        // mark all children as valid\n        markFormComponentsValid();\n        // before updating, call the interception method for clients\n        beforeUpdateFormComponentModels();\n        // Update model using form data\n        updateFormComponentModels();\n        // validate model objects after input values have been bound\n        onValidateModelObjects();\n        if (hasError()) {\n            callOnError(submittingComponent);\n            return;\n        }\n        // Form has no error\n        delegateSubmit(submittingComponent);\n    }\n}", "code_comment": "/**\n *  Process the form. Though you can override this method to provide your own algorithm, it is\n *  not recommended to do so.\n *\n *  <p>\n *  See the class documentation for further details on the form processing\n *  </p>\n *\n *  @param submittingComponent\n *             component responsible for submitting the form, or <code>null</code> if none (eg\n *             the form has been submitted via the enter key or javascript calling\n *             form.onsubmit())\n *\n *  @see #delegateSubmit(IFormSubmitter) for an easy way to process submitting component in the\n *       default manner\n */\n", "code_no_comment": "public void process(IFormSubmitter submittingComponent) {\n        final Page page = getPage();\n    String hiddenFieldId = getHiddenFieldId();\n    if (!isEnabledInHierarchy() || !isVisibleInHierarchy()) {\n                return;\n    }\n        validate();\n        if (hasError()) {\n                markFormComponentsInvalid();\n                callOnError(submittingComponent);\n    } else {\n                markFormComponentsValid();\n                beforeUpdateFormComponentModels();\n                updateFormComponentModels();\n                onValidateModelObjects();\n        if (hasError()) {\n            callOnError(submittingComponent);\n            return;\n        }\n                delegateSubmit(submittingComponent);\n    }\n}", "lc": 0.36363636363636365, "pi": 0.056122448979591774, "ma": 0.0, "nbd": 0.0, "ml": 0.16666666666666666, "d": -0.13544241225902123, "mi": -0.17436191568683682, "fo": 0.75, "r": 0.0, "e": -0.08885519592600684}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-867_bfbb156d", "label": 1, "code": "/**\n * @param x Normalized objective variables.\n * @return the original objective variables.\n */\npublic double[] decode(final double[] x) {\n    if (boundaries == null) {\n        return x;\n    }\n    double[] res = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        double diff = boundaries[1][i] - boundaries[0][i];\n        res[i] = diff * x[i];\n    }\n    return res;\n}", "code_comment": "/**\n * @param x Normalized objective variables.\n * @return the original objective variables.\n */\n", "code_no_comment": "public double[] decode(final double[] x) {\n    if (boundaries == null) {\n        return x;\n    }\n    double[] res = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        double diff = boundaries[1][i] - boundaries[0][i];\n        res[i] = diff * x[i];\n    }\n    return res;\n}", "lc": -0.13636363636363635, "pi": -0.17857142857142863, "ma": -0.16666666666666666, "nbd": -0.5, "ml": 0.0, "d": 1.1300049431537322, "mi": 0.14511041009463732, "fo": -0.5, "r": 2.1142857142857143, "e": 0.33041232477160887}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3314_4badd9c5", "label": 1, "code": "/**\n * Inspects this processor definition and resolves any property placeholders from its properties.\n * <p/>\n * This implementation will check all the getter/setter pairs on this instance and for all the values\n * (which is a String type) will be property placeholder resolved.\n *\n * @param routeContext the route context\n * @throws Exception is thrown if property placeholders was used and there was an error resolving them\n * @see org.apache.camel.CamelContext#resolvePropertyPlaceholders(String)\n * @see org.apache.camel.component.properties.PropertiesComponent\n */\nprotected void resolvePropertyPlaceholders(RouteContext routeContext) throws Exception {\n    if (log.isTraceEnabled()) {\n        log.trace(\"Resolving property placeholders for: \" + this);\n    }\n    // find all String getter/setter\n    Map<Object, Object> properties = new HashMap<Object, Object>();\n    IntrospectionSupport.getProperties(this, properties, null);\n    if (!properties.isEmpty()) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"There are \" + properties.size() + \" properties on: \" + this);\n        }\n        // lookup and resolve properties for String based properties\n        for (Map.Entry entry : properties.entrySet()) {\n            // the name is always a String\n            String name = (String) entry.getKey();\n            Object value = entry.getValue();\n            if (value instanceof String) {\n                // we can only resolve String typed values\n                String text = (String) value;\n                text = routeContext.getCamelContext().resolvePropertyPlaceholders(text);\n                if (text != value) {\n                    // invoke setter as the text has changed\n                    IntrospectionSupport.setProperty(this, name, text);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Changed property [\" + name + \"] from: \" + value + \" to: \" + text);\n                    }\n                }\n            }\n        }\n    }\n}", "code_comment": "/**\n * Inspects this processor definition and resolves any property placeholders from its properties.\n * <p/>\n * This implementation will check all the getter/setter pairs on this instance and for all the values\n * (which is a String type) will be property placeholder resolved.\n *\n * @param routeContext the route context\n * @throws Exception is thrown if property placeholders was used and there was an error resolving them\n * @see org.apache.camel.CamelContext#resolvePropertyPlaceholders(String)\n * @see org.apache.camel.component.properties.PropertiesComponent\n */\n", "code_no_comment": "protected void resolvePropertyPlaceholders(RouteContext routeContext) throws Exception {\n    if (log.isTraceEnabled()) {\n        log.trace(\"Resolving property placeholders for: \" + this);\n    }\n        Map<Object, Object> properties = new HashMap<Object, Object>();\n    IntrospectionSupport.getProperties(this, properties, null);\n    if (!properties.isEmpty()) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"There are \" + properties.size() + \" properties on: \" + this);\n        }\n                for (Map.Entry entry : properties.entrySet()) {\n                        String name = (String) entry.getKey();\n            Object value = entry.getValue();\n            if (value instanceof String) {\n                                String text = (String) value;\n                text = routeContext.getCamelContext().resolvePropertyPlaceholders(text);\n                if (text != value) {\n                                        IntrospectionSupport.setProperty(this, name, text);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Changed property [\" + name + \"] from: \" + value + \" to: \" + text);\n                    }\n                }\n            }\n        }\n    }\n}", "lc": 0.5454545454545454, "pi": 1.7653061224489799, "ma": 0.6666666666666666, "nbd": 1.5, "ml": 0.5, "d": 0.41028175976272874, "mi": -0.44565529108115887, "fo": 0.75, "r": -0.028571428571428574, "e": 0.5834093566500057}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5853_b80f6640", "label": 3, "code": "/**\n *  Parses a value as a String and returns a Number.\n *\n *  @param value\n *             The object to parse (after converting with toString())\n *  @param min\n *             The minimum allowed value\n *  @param max\n *             The maximum allowed value\n *  @param locale\n *  @return The number\n *  @throws ConversionException\n *              if value is unparsable or out of range\n */\nprotected N parse(Object value, final double min, final double max, Locale locale) {\n    if (locale == null) {\n        locale = Locale.getDefault();\n    }\n    if (value == null) {\n        return null;\n    } else if (value instanceof String) {\n        // Convert spaces to no-break space (U+00A0) as required by Java formats:\n        // http://bugs.sun.com/view_bug.do?bug_id=4510618\n        value = ((String) value).replaceAll(\"(\\\\d+)\\\\s(?=\\\\d)\", \"$1\\u00A0\");\n    }\n    final NumberFormat numberFormat = getNumberFormat(locale);\n    final N number = parse(numberFormat, value, locale);\n    if (number == null) {\n        return null;\n    }\n    if (number.doubleValue() < min) {\n        throw newConversionException(\"Value cannot be less than \" + min, value, locale).setFormat(numberFormat);\n    }\n    if (number.doubleValue() > max) {\n        throw newConversionException(\"Value cannot be greater than \" + max, value, locale).setFormat(numberFormat);\n    }\n    return number;\n}", "code_comment": "/**\n *  Parses a value as a String and returns a Number.\n *\n *  @param value\n *             The object to parse (after converting with toString())\n *  @param min\n *             The minimum allowed value\n *  @param max\n *             The maximum allowed value\n *  @param locale\n *  @return The number\n *  @throws ConversionException\n *              if value is unparsable or out of range\n */\n", "code_no_comment": "protected N parse(Object value, final double min, final double max, Locale locale) {\n    if (locale == null) {\n        locale = Locale.getDefault();\n    }\n    if (value == null) {\n        return null;\n    } else if (value instanceof String) {\n                        value = ((String) value).replaceAll(\"(\\\\d+)\\\\s(?=\\\\d)\", \"$1\\u00A0\");\n    }\n    final NumberFormat numberFormat = getNumberFormat(locale);\n    final N number = parse(numberFormat, value, locale);\n    if (number == null) {\n        return null;\n    }\n    if (number.doubleValue() < min) {\n        throw newConversionException(\"Value cannot be less than \" + min, value, locale).setFormat(numberFormat);\n    }\n    if (number.doubleValue() > max) {\n        throw newConversionException(\"Value cannot be greater than \" + max, value, locale).setFormat(numberFormat);\n    }\n    return number;\n}", "lc": 0.36363636363636365, "pi": -0.36734693877551033, "ma": 0.8333333333333334, "nbd": 0.0, "ml": 0.5833333333333334, "d": 0.592189817103312, "mi": -0.3375394321766561, "fo": 0.3333333333333333, "r": -0.028571428571428574, "e": 0.5518735999931472}
{"project_name": "Codec", "project_version": 1, "label": 1, "code": "/**\n * Find the metaphone value of a String. This is similar to the\n * soundex algorithm, but better at finding similar sounding words.\n * All input is converted to upper case.\n * Limitations: Input format is expected to be a single ASCII word\n * with only characters in the A - Z range, no punctuation or numbers.\n *\n * @param txt String to find the metaphone code for\n * @return A metaphone code corresponding to the String supplied\n */\npublic String metaphone(String txt) {\n    boolean hard = false;\n    if ((txt == null) || (txt.length() == 0)) {\n        return \"\";\n    }\n    // single character is itself\n    if (txt.length() == 1) {\n        return txt.toUpperCase();\n    }\n    char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();\n    // manipulate\n    StringBuffer local = new StringBuffer(40);\n    // output\n    StringBuffer code = new StringBuffer(10);\n    // handle initial 2 characters exceptions\n    switch(inwd[0]) {\n        case 'K':\n        case 'G':\n        case 'P':\n            /* looking for KN, etc*/\n            if (inwd[1] == 'N') {\n                local.append(inwd, 1, inwd.length - 1);\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'A':\n            /* looking for AE */\n            if (inwd[1] == 'E') {\n                local.append(inwd, 1, inwd.length - 1);\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'W':\n            /* looking for WR or WH */\n            if (inwd[1] == 'R') {\n                // WR -> R\n                local.append(inwd, 1, inwd.length - 1);\n                break;\n            }\n            if (inwd[1] == 'H') {\n                local.append(inwd, 1, inwd.length - 1);\n                // WH -> W\n                local.setCharAt(0, 'W');\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'X':\n            /* initial X becomes S */\n            inwd[0] = 'S';\n            local.append(inwd);\n            break;\n        default:\n            local.append(inwd);\n    }\n    // now local has working string with initials fixed\n    int wdsz = local.length();\n    int n = 0;\n    while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {\n        // max code size of 4 works well\n        char symb = local.charAt(n);\n        // remove duplicate letters except C\n        if ((symb != 'C') && (isPreviousChar(local, n, symb))) {\n            n++;\n        } else {\n            // not dup\n            switch(symb) {\n                case 'A':\n                case 'E':\n                case 'I':\n                case 'O':\n                case 'U':\n                    if (n == 0) {\n                        code.append(symb);\n                    }\n                    // only use vowel if leading char\n                    break;\n                case 'B':\n                    if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {\n                        // B is silent if word ends in MB\n                        break;\n                    }\n                    code.append(symb);\n                    break;\n                case // lots of C special cases\n                'C':\n                    /* discard if SCI, SCE or SCY */\n                    if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {\n                        break;\n                    }\n                    if (regionMatch(local, n, \"CIA\")) {\n                        // \"CIA\" -> X\n                        code.append('X');\n                        break;\n                    }\n                    if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {\n                        code.append('S');\n                        // CI,CE,CY -> S\n                        break;\n                    }\n                    if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {\n                        // SCH->sk\n                        code.append('K');\n                        break;\n                    }\n                    if (isNextChar(local, n, 'H')) {\n                        // detect CH\n                        if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {\n                            // CH consonant -> K consonant\n                            code.append('K');\n                        } else {\n                            // CHvowel -> X\n                            code.append('X');\n                        }\n                    } else {\n                        code.append('K');\n                    }\n                    break;\n                case 'D':\n                    if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {\n                        // DGE DGI DGY -> J\n                        code.append('J');\n                        n += 2;\n                    } else {\n                        code.append('T');\n                    }\n                    break;\n                case // GH silent at end or before consonant\n                'G':\n                    if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {\n                        break;\n                    }\n                    if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {\n                        break;\n                    }\n                    if ((n > 0) && (regionMatch(local, n, \"GN\") || regionMatch(local, n, \"GNED\"))) {\n                        // silent G\n                        break;\n                    }\n                    if (isPreviousChar(local, n, 'G')) {\n                        hard = true;\n                    } else {\n                        hard = false;\n                    }\n                    if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {\n                        code.append('J');\n                    } else {\n                        code.append('K');\n                    }\n                    break;\n                case 'H':\n                    if (isLastChar(wdsz, n)) {\n                        // terminal H\n                        break;\n                    }\n                    if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {\n                        break;\n                    }\n                    if (isVowel(local, n + 1)) {\n                        // Hvowel\n                        code.append('H');\n                    }\n                    break;\n                case 'F':\n                case 'J':\n                case 'L':\n                case 'M':\n                case 'N':\n                case 'R':\n                    code.append(symb);\n                    break;\n                case 'K':\n                    if (n > 0) {\n                        // not initial\n                        if (!isPreviousChar(local, n, 'C')) {\n                            code.append(symb);\n                        }\n                    } else {\n                        // initial K\n                        code.append(symb);\n                    }\n                    break;\n                case 'P':\n                    if (isNextChar(local, n, 'H')) {\n                        // PH -> F\n                        code.append('F');\n                    } else {\n                        code.append(symb);\n                    }\n                    break;\n                case 'Q':\n                    code.append('K');\n                    break;\n                case 'S':\n                    if (regionMatch(local, n, \"SH\") || regionMatch(local, n, \"SIO\") || regionMatch(local, n, \"SIA\")) {\n                        code.append('X');\n                    } else {\n                        code.append('S');\n                    }\n                    break;\n                case 'T':\n                    if (regionMatch(local, n, \"TIA\") || regionMatch(local, n, \"TIO\")) {\n                        code.append('X');\n                        break;\n                    }\n                    if (regionMatch(local, n, \"TCH\")) {\n                        // Silent if in \"TCH\"\n                        break;\n                    }\n                    // substitute numeral 0 for TH (resembles theta after all)\n                    if (regionMatch(local, n, \"TH\")) {\n                        code.append('0');\n                    } else {\n                        code.append('T');\n                    }\n                    break;\n                case 'V':\n                    code.append('F');\n                    break;\n                case 'W':\n                case // silent if not followed by vowel\n                'Y':\n                    if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {\n                        code.append(symb);\n                    }\n                    break;\n                case 'X':\n                    code.append('K');\n                    code.append('S');\n                    break;\n                case 'Z':\n                    code.append('S');\n                    break;\n            }\n            // end switch\n            n++;\n        }\n        // end else from symb != 'C'\n        if (code.length() > this.getMaxCodeLen()) {\n            code.setLength(this.getMaxCodeLen());\n        }\n    }\n    return code.toString();\n}", "code_comment": "/**\n * Find the metaphone value of a String. This is similar to the\n * soundex algorithm, but better at finding similar sounding words.\n * All input is converted to upper case.\n * Limitations: Input format is expected to be a single ASCII word\n * with only characters in the A - Z range, no punctuation or numbers.\n *\n * @param txt String to find the metaphone code for\n * @return A metaphone code corresponding to the String supplied\n */\n", "code_no_comment": "public String metaphone(String txt) {\n    boolean hard = false;\n    if ((txt == null) || (txt.length() == 0)) {\n        return \"\";\n    }\n        if (txt.length() == 1) {\n        return txt.toUpperCase();\n    }\n    char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();\n        StringBuffer local = new StringBuffer(40);\n        StringBuffer code = new StringBuffer(10);\n        switch(inwd[0]) {\n        case 'K':\n        case 'G':\n        case 'P':\n                        if (inwd[1] == 'N') {\n                local.append(inwd, 1, inwd.length - 1);\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'A':\n                        if (inwd[1] == 'E') {\n                local.append(inwd, 1, inwd.length - 1);\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'W':\n                        if (inwd[1] == 'R') {\n                                local.append(inwd, 1, inwd.length - 1);\n                break;\n            }\n            if (inwd[1] == 'H') {\n                local.append(inwd, 1, inwd.length - 1);\n                                local.setCharAt(0, 'W');\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'X':\n                        inwd[0] = 'S';\n            local.append(inwd);\n            break;\n        default:\n            local.append(inwd);\n    }\n        int wdsz = local.length();\n    int n = 0;\n    while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {\n                char symb = local.charAt(n);\n                if ((symb != 'C') && (isPreviousChar(local, n, symb))) {\n            n++;\n        } else {\n                        switch(symb) {\n                case 'A':\n                case 'E':\n                case 'I':\n                case 'O':\n                case 'U':\n                    if (n == 0) {\n                        code.append(symb);\n                    }\n                                        break;\n                case 'B':\n                    if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {\n                                                break;\n                    }\n                    code.append(symb);\n                    break;\n                case                 'C':\n                                        if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {\n                        break;\n                    }\n                    if (regionMatch(local, n, \"CIA\")) {\n                                                code.append('X');\n                        break;\n                    }\n                    if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {\n                        code.append('S');\n                                                break;\n                    }\n                    if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {\n                                                code.append('K');\n                        break;\n                    }\n                    if (isNextChar(local, n, 'H')) {\n                                                if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {\n                                                        code.append('K');\n                        } else {\n                                                        code.append('X');\n                        }\n                    } else {\n                        code.append('K');\n                    }\n                    break;\n                case 'D':\n                    if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {\n                                                code.append('J');\n                        n += 2;\n                    } else {\n                        code.append('T');\n                    }\n                    break;\n                case                 'G':\n                    if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {\n                        break;\n                    }\n                    if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {\n                        break;\n                    }\n                    if ((n > 0) && (regionMatch(local, n, \"GN\") || regionMatch(local, n, \"GNED\"))) {\n                                                break;\n                    }\n                    if (isPreviousChar(local, n, 'G')) {\n                        hard = true;\n                    } else {\n                        hard = false;\n                    }\n                    if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {\n                        code.append('J');\n                    } else {\n                        code.append('K');\n                    }\n                    break;\n                case 'H':\n                    if (isLastChar(wdsz, n)) {\n                                                break;\n                    }\n                    if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {\n                        break;\n                    }\n                    if (isVowel(local, n + 1)) {\n                                                code.append('H');\n                    }\n                    break;\n                case 'F':\n                case 'J':\n                case 'L':\n                case 'M':\n                case 'N':\n                case 'R':\n                    code.append(symb);\n                    break;\n                case 'K':\n                    if (n > 0) {\n                                                if (!isPreviousChar(local, n, 'C')) {\n                            code.append(symb);\n                        }\n                    } else {\n                                                code.append(symb);\n                    }\n                    break;\n                case 'P':\n                    if (isNextChar(local, n, 'H')) {\n                                                code.append('F');\n                    } else {\n                        code.append(symb);\n                    }\n                    break;\n                case 'Q':\n                    code.append('K');\n                    break;\n                case 'S':\n                    if (regionMatch(local, n, \"SH\") || regionMatch(local, n, \"SIO\") || regionMatch(local, n, \"SIA\")) {\n                        code.append('X');\n                    } else {\n                        code.append('S');\n                    }\n                    break;\n                case 'T':\n                    if (regionMatch(local, n, \"TIA\") || regionMatch(local, n, \"TIO\")) {\n                        code.append('X');\n                        break;\n                    }\n                    if (regionMatch(local, n, \"TCH\")) {\n                                                break;\n                    }\n                                        if (regionMatch(local, n, \"TH\")) {\n                        code.append('0');\n                    } else {\n                        code.append('T');\n                    }\n                    break;\n                case 'V':\n                    code.append('F');\n                    break;\n                case 'W':\n                case                 'Y':\n                    if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {\n                        code.append(symb);\n                    }\n                    break;\n                case 'X':\n                    code.append('K');\n                    code.append('S');\n                    break;\n                case 'Z':\n                    code.append('S');\n                    break;\n            }\n                        n++;\n        }\n                if (code.length() > this.getMaxCodeLen()) {\n            code.setLength(this.getMaxCodeLen());\n        }\n    }\n    return code.toString();\n}", "lc": 9.0, "pi": 1.576530612244898, "ma": 16.166666666666668, "nbd": 2.0, "ml": 10.166666666666666, "d": 6.090954028670292, "mi": -2.336392314310296, "fo": 7.666666666666667, "r": -0.028571428571428574, "e": 46.297822949190724}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-428_4a6a573b", "label": 3, "code": "/**\n *  @see java.util.Map#keySet()\n */\npublic Set keySet() {\n    return new AbstractSet() {\n\n        public Iterator iterator() {\n            return new Iterator() {\n\n                public boolean hasNext() {\n                    return i < size;\n                }\n\n                public Object next() {\n                    // Find next key\n                    i = nextKey(nextIndex(i));\n                    // Just in case... (WICKET-428)\n                    if (!hasNext()) {\n                        throw new NoSuchElementException();\n                    }\n                    // Get key\n                    return keys[i];\n                }\n\n                public void remove() {\n                    keys[i] = null;\n                    values[i] = null;\n                    size--;\n                }\n\n                int i = -1;\n            };\n        }\n\n        public int size() {\n            return size;\n        }\n    };\n}", "code_comment": "/**\n *  @see java.util.Map#keySet()\n */\n", "code_no_comment": "public Set keySet() {\n    return new AbstractSet() {\n\n        public Iterator iterator() {\n            return new Iterator() {\n\n                public boolean hasNext() {\n                    return i < size;\n                }\n\n                public Object next() {\n                                        i = nextKey(nextIndex(i));\n                                        if (!hasNext()) {\n                        throw new NoSuchElementException();\n                    }\n                                        return keys[i];\n                }\n\n                public void remove() {\n                    keys[i] = null;\n                    values[i] = null;\n                    size--;\n                }\n\n                int i = -1;\n            };\n        }\n\n        public int size() {\n            return size;\n        }\n    };\n}", "lc": 0.5909090909090909, "pi": 1.8061224489795917, "ma": -0.16666666666666666, "nbd": 0.5, "ml": -0.25, "d": 0.2857142857142858, "mi": -0.3008316604531119, "fo": -0.25, "r": 2.085714285714286, "e": 0.1003593440151447}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-5645_af1ecd5f", "label": 3, "code": "private static Integer getNextIntegerToken(StringTokenizer tok) {\n    String s = tok.nextToken();\n    if ((s.length() > 1) && s.startsWith(\"0\")) {\n        throw new NumberFormatException(\"Number part has a leading 0: '\" + s + \"'\");\n    }\n    return Integer.valueOf(s);\n}", "code_comment": NaN, "code_no_comment": "private static Integer getNextIntegerToken(StringTokenizer tok) {\n    String s = tok.nextToken();\n    if ((s.length() > 1) && s.startsWith(\"0\")) {\n        throw new NumberFormatException(\"Number part has a leading 0: '\" + s + \"'\");\n    }\n    return Integer.valueOf(s);\n}", "lc": -0.3181818181818182, "pi": -0.2346938775510204, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.08333333333333333, "d": 0.1631240731586753, "mi": 0.39919701749354763, "fo": -0.16666666666666666, "r": 1.0, "e": -0.031874113953597946}
{"project_name": "Closure", "project_version": 16, "label": 2, "code": "private void fixTypeNode(Node typeNode) {\n    if (typeNode.isString()) {\n        String name = typeNode.getString();\n        int endIndex = name.indexOf('.');\n        if (endIndex == -1) {\n            endIndex = name.length();\n        }\n        String baseName = name.substring(0, endIndex);\n        Var aliasVar = aliases.get(baseName);\n        if (aliasVar != null) {\n            Node aliasedNode = aliasVar.getInitialValue();\n            aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));\n        }\n    }\n    for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) {\n        fixTypeNode(child);\n    }\n}", "code_comment": NaN, "code_no_comment": "private void fixTypeNode(Node typeNode) {\n    if (typeNode.isString()) {\n        String name = typeNode.getString();\n        int endIndex = name.indexOf('.');\n        if (endIndex == -1) {\n            endIndex = name.length();\n        }\n        String baseName = name.substring(0, endIndex);\n        Var aliasVar = aliases.get(baseName);\n        if (aliasVar != null) {\n            Node aliasedNode = aliasVar.getInitialValue();\n            aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));\n        }\n    }\n    for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) {\n        fixTypeNode(child);\n    }\n}", "lc": 0.18181818181818182, "pi": 0.2346938775510204, "ma": 0.16666666666666666, "nbd": 0.0, "ml": 0.25, "d": 0.35689569945625316, "mi": -0.22368798394034986, "fo": 0.5833333333333334, "r": 0.0, "e": 0.40168579027843804}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-888_6d82cb64", "label": 1, "code": "/**\n * Calculate the number of elements in the path. The root path has zero\n * elements.\n *\n * @param path the path\n * @return the number of elements\n */\npublic static int getDepth(String path) {\n    assert isValid(path);\n    int count = 1, i = 0;\n    if (isAbsolutePath(path)) {\n        if (denotesRootPath(path)) {\n            return 0;\n        }\n        i++;\n    }\n    while (true) {\n        i = path.indexOf('/', i) + 1;\n        if (i == 0) {\n            return count;\n        }\n        count++;\n    }\n}", "code_comment": "/**\n * Calculate the number of elements in the path. The root path has zero\n * elements.\n *\n * @param path the path\n * @return the number of elements\n */\n", "code_no_comment": "public static int getDepth(String path) {\n    assert isValid(path);\n    int count = 1, i = 0;\n    if (isAbsolutePath(path)) {\n        if (denotesRootPath(path)) {\n            return 0;\n        }\n        i++;\n    }\n    while (true) {\n        i = path.indexOf('/', i) + 1;\n        if (i == 0) {\n            return count;\n        }\n        count++;\n    }\n}", "lc": 0.13636363636363635, "pi": 0.1887755102040817, "ma": 0.16666666666666666, "nbd": 0.0, "ml": 0.25, "d": -0.3806228373702422, "mi": 0.3679380556352166, "fo": -0.16666666666666666, "r": 0.39999999999999997, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1369_ce0b0955", "label": 1, "code": "@Override\npublic String toString() {\n    String leftExpr;\n    boolean leftExprIsName;\n    if (left == null) {\n        leftExprIsName = false;\n        leftExpr = \"\";\n    } else {\n        leftExprIsName = left.isName();\n        leftExpr = left.toString();\n        if (left.getPrecedence() < precedence) {\n            leftExpr = \"(\" + leftExpr + \")\";\n        }\n    }\n    boolean impossible = false;\n    String rightExpr;\n    if (right == null) {\n        rightExpr = \"\";\n    } else {\n        if (left != null && left instanceof Property && ((Property) left).implicitAsterisk) {\n            throw new IllegalArgumentException(\"Missing @ in front of the property name: \" + left);\n        }\n        if (leftExprIsName && !\"like\".equals(operator)) {\n            // need to de-escape _x0020_ and so on\n            if (!(right instanceof Literal)) {\n                throw new IllegalArgumentException(\"Can only compare a name against a string literal, not \" + right);\n            }\n            Literal l = (Literal) right;\n            String raw = l.rawText;\n            String decoded = ISO9075.decode(raw);\n            String encoded = ISO9075.encode(decoded);\n            rightExpr = SQL2Parser.escapeStringLiteral(decoded);\n            if (!encoded.equalsIgnoreCase(raw)) {\n                // nothing can potentially match\n                impossible = true;\n            }\n        } else {\n            rightExpr = right.toString();\n        }\n        if (right.getPrecedence() < precedence) {\n            rightExpr = \"(\" + right + \")\";\n        }\n    }\n    if (impossible) {\n        // a condition that can not possibly be true\n        return \"upper(\" + leftExpr + \") = 'never matches'\";\n    }\n    return (leftExpr + \" \" + operator + \" \" + rightExpr).trim();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic String toString() {\n    String leftExpr;\n    boolean leftExprIsName;\n    if (left == null) {\n        leftExprIsName = false;\n        leftExpr = \"\";\n    } else {\n        leftExprIsName = left.isName();\n        leftExpr = left.toString();\n        if (left.getPrecedence() < precedence) {\n            leftExpr = \"(\" + leftExpr + \")\";\n        }\n    }\n    boolean impossible = false;\n    String rightExpr;\n    if (right == null) {\n        rightExpr = \"\";\n    } else {\n        if (left != null && left instanceof Property && ((Property) left).implicitAsterisk) {\n            throw new IllegalArgumentException(\"Missing @ in front of the property name: \" + left);\n        }\n        if (leftExprIsName && !\"like\".equals(operator)) {\n                        if (!(right instanceof Literal)) {\n                throw new IllegalArgumentException(\"Can only compare a name against a string literal, not \" + right);\n            }\n            Literal l = (Literal) right;\n            String raw = l.rawText;\n            String decoded = ISO9075.decode(raw);\n            String encoded = ISO9075.encode(decoded);\n            rightExpr = SQL2Parser.escapeStringLiteral(decoded);\n            if (!encoded.equalsIgnoreCase(raw)) {\n                                impossible = true;\n            }\n        } else {\n            rightExpr = right.toString();\n        }\n        if (right.getPrecedence() < precedence) {\n            rightExpr = \"(\" + right + \")\";\n        }\n    }\n    if (impossible) {\n                return \"upper(\" + leftExpr + \") = 'never matches'\";\n    }\n    return (leftExpr + \" \" + operator + \" \" + rightExpr).trim();\n}", "lc": 1.4545454545454546, "pi": 0.5, "ma": 1.3333333333333333, "nbd": 0.5, "ml": 1.5833333333333333, "d": 0.9995056846267921, "mi": -0.8167479208488676, "fo": 0.4166666666666667, "r": -0.028571428571428574, "e": 2.0619065362920326}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3395_8433e6db", "label": 3, "code": "@SuppressWarnings(\"unchecked\")\nprivate Iterable<ProcessorExchangePair> createProcessorExchangePairsIterable(final Exchange exchange, final Object value) {\n    final Iterator iterator = ObjectHelper.createIterator(value);\n    return new Iterable() {\n\n        public Iterator iterator() {\n            return new Iterator() {\n\n                private int index;\n\n                private boolean closed;\n\n                public boolean hasNext() {\n                    if (closed) {\n                        return false;\n                    }\n                    boolean answer = iterator.hasNext();\n                    if (!answer) {\n                        // we are now closed\n                        closed = true;\n                        // nothing more so we need to close the expression value in case it needs to be\n                        if (value instanceof Closeable) {\n                            IOHelper.close((Closeable) value, value.getClass().getName(), LOG);\n                        } else if (value instanceof Scanner) {\n                            // special for Scanner as it does not implement Closeable\n                            ((Scanner) value).close();\n                        }\n                    }\n                    return answer;\n                }\n\n                public Object next() {\n                    Object part = iterator.next();\n                    Exchange newExchange = exchange.copy();\n                    if (part instanceof Message) {\n                        newExchange.setIn((Message) part);\n                    } else {\n                        Message in = newExchange.getIn();\n                        in.setBody(part);\n                    }\n                    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);\n                }\n\n                public void remove() {\n                    throw new UnsupportedOperationException(\"Remove is not supported by this iterator\");\n                }\n            };\n        }\n    };\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings(\"unchecked\")\nprivate Iterable<ProcessorExchangePair> createProcessorExchangePairsIterable(final Exchange exchange, final Object value) {\n    final Iterator iterator = ObjectHelper.createIterator(value);\n    return new Iterable() {\n\n        public Iterator iterator() {\n            return new Iterator() {\n\n                private int index;\n\n                private boolean closed;\n\n                public boolean hasNext() {\n                    if (closed) {\n                        return false;\n                    }\n                    boolean answer = iterator.hasNext();\n                    if (!answer) {\n                                                closed = true;\n                                                if (value instanceof Closeable) {\n                            IOHelper.close((Closeable) value, value.getClass().getName(), LOG);\n                        } else if (value instanceof Scanner) {\n                                                        ((Scanner) value).close();\n                        }\n                    }\n                    return answer;\n                }\n\n                public Object next() {\n                    Object part = iterator.next();\n                    Exchange newExchange = exchange.copy();\n                    if (part instanceof Message) {\n                        newExchange.setIn((Message) part);\n                    } else {\n                        Message in = newExchange.getIn();\n                        in.setBody(part);\n                    }\n                    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);\n                }\n\n                public void remove() {\n                    throw new UnsupportedOperationException(\"Remove is not supported by this iterator\");\n                }\n            };\n        }\n    };\n}", "lc": 1.2272727272727273, "pi": 2.3163265306122445, "ma": 0.5, "nbd": 1.5, "ml": 0.3333333333333333, "d": -0.004943153732081051, "mi": -0.6616002294235737, "fo": 0.75, "r": -0.028571428571428574, "e": 0.21833896548327275}
{"project_name": "Math", "project_version": 6, "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\nprotected PointValuePair doOptimize() {\n    checkParameters();\n    final GoalType goal = getGoalType();\n    final double[] guess = getStartPoint();\n    final int n = guess.length;\n    final double[][] direc = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        direc[i][i] = 1;\n    }\n    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n    double[] x = guess;\n    double fVal = computeObjectiveValue(x);\n    double[] x1 = x.clone();\n    int iter = 0;\n    while (true) {\n        ++iter;\n        double fX = fVal;\n        double fX2 = 0;\n        double delta = 0;\n        int bigInd = 0;\n        double alphaMin = 0;\n        for (int i = 0; i < n; i++) {\n            final double[] d = MathArrays.copyOf(direc[i]);\n            fX2 = fVal;\n            final UnivariatePointValuePair optimum = line.search(x, d);\n            fVal = optimum.getValue();\n            alphaMin = optimum.getPoint();\n            final double[][] result = newPointAndDirection(x, d, alphaMin);\n            x = result[0];\n            if ((fX2 - fVal) > delta) {\n                delta = fX2 - fVal;\n                bigInd = i;\n            }\n        }\n        // Default convergence check.\n        boolean stop = 2 * (fX - fVal) <= (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) + absoluteThreshold);\n        final PointValuePair previous = new PointValuePair(x1, fX);\n        final PointValuePair current = new PointValuePair(x, fVal);\n        if (!stop) {\n            // User-defined stopping criteria.\n            if (checker != null) {\n                stop = checker.converged(iter, previous, current);\n            }\n        }\n        if (stop) {\n            if (goal == GoalType.MINIMIZE) {\n                return (fVal < fX) ? current : previous;\n            } else {\n                return (fVal > fX) ? current : previous;\n            }\n        }\n        final double[] d = new double[n];\n        final double[] x2 = new double[n];\n        for (int i = 0; i < n; i++) {\n            d[i] = x[i] - x1[i];\n            x2[i] = 2 * x[i] - x1[i];\n        }\n        x1 = x.clone();\n        fX2 = computeObjectiveValue(x2);\n        if (fX > fX2) {\n            double t = 2 * (fX + fX2 - 2 * fVal);\n            double temp = fX - fVal - delta;\n            t *= temp * temp;\n            temp = fX - fX2;\n            t -= delta * temp * temp;\n            if (t < 0.0) {\n                final UnivariatePointValuePair optimum = line.search(x, d);\n                fVal = optimum.getValue();\n                alphaMin = optimum.getPoint();\n                final double[][] result = newPointAndDirection(x, d, alphaMin);\n                x = result[0];\n                final int lastInd = n - 1;\n                direc[bigInd] = direc[lastInd];\n                direc[lastInd] = result[1];\n            }\n        }\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\nprotected PointValuePair doOptimize() {\n    checkParameters();\n    final GoalType goal = getGoalType();\n    final double[] guess = getStartPoint();\n    final int n = guess.length;\n    final double[][] direc = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        direc[i][i] = 1;\n    }\n    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n    double[] x = guess;\n    double fVal = computeObjectiveValue(x);\n    double[] x1 = x.clone();\n    int iter = 0;\n    while (true) {\n        ++iter;\n        double fX = fVal;\n        double fX2 = 0;\n        double delta = 0;\n        int bigInd = 0;\n        double alphaMin = 0;\n        for (int i = 0; i < n; i++) {\n            final double[] d = MathArrays.copyOf(direc[i]);\n            fX2 = fVal;\n            final UnivariatePointValuePair optimum = line.search(x, d);\n            fVal = optimum.getValue();\n            alphaMin = optimum.getPoint();\n            final double[][] result = newPointAndDirection(x, d, alphaMin);\n            x = result[0];\n            if ((fX2 - fVal) > delta) {\n                delta = fX2 - fVal;\n                bigInd = i;\n            }\n        }\n                boolean stop = 2 * (fX - fVal) <= (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) + absoluteThreshold);\n        final PointValuePair previous = new PointValuePair(x1, fX);\n        final PointValuePair current = new PointValuePair(x, fVal);\n        if (!stop) {\n                        if (checker != null) {\n                stop = checker.converged(iter, previous, current);\n            }\n        }\n        if (stop) {\n            if (goal == GoalType.MINIMIZE) {\n                return (fVal < fX) ? current : previous;\n            } else {\n                return (fVal > fX) ? current : previous;\n            }\n        }\n        final double[] d = new double[n];\n        final double[] x2 = new double[n];\n        for (int i = 0; i < n; i++) {\n            d[i] = x[i] - x1[i];\n            x2[i] = 2 * x[i] - x1[i];\n        }\n        x1 = x.clone();\n        fX2 = computeObjectiveValue(x2);\n        if (fX > fX2) {\n            double t = 2 * (fX + fX2 - 2 * fVal);\n            double temp = fX - fVal - delta;\n            t *= temp * temp;\n            temp = fX - fX2;\n            t -= delta * temp * temp;\n            if (t < 0.0) {\n                final UnivariatePointValuePair optimum = line.search(x, d);\n                fVal = optimum.getValue();\n                alphaMin = optimum.getPoint();\n                final double[][] result = newPointAndDirection(x, d, alphaMin);\n                x = result[0];\n                final int lastInd = n - 1;\n                direc[bigInd] = direc[lastInd];\n                direc[lastInd] = result[1];\n            }\n        }\n    }\n}", "lc": 2.8636363636363638, "pi": 0.6683673469387755, "ma": 1.6666666666666667, "nbd": 0.5, "ml": 1.5, "d": 4.058329214038557, "mi": -1.205620877545168, "fo": 1.1666666666666667, "r": -0.028571428571428574, "e": 17.69224476509866}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3324_5f863af6", "label": 1, "code": "private boolean hasPermissions(@Nonnull Iterator<PermissionEntry> entries, long permissions, @Nullable String path) {\n    // calculate readable paths if the given permissions includes any read permission.\n    boolean isReadable = Permissions.diff(Permissions.READ, permissions) != Permissions.READ && readPolicy.isReadablePath(path, false);\n    if (!entries.hasNext() && !isReadable) {\n        return false;\n    }\n    boolean respectParent = (path != null) && Permissions.respectParentPermissions(permissions);\n    long allows = (isReadable) ? Permissions.READ : Permissions.NO_PERMISSION;\n    long denies = Permissions.NO_PERMISSION;\n    PrivilegeBits allowBits = PrivilegeBits.getInstance();\n    if (isReadable) {\n        allowBits.add(bitsProvider.getBits(PrivilegeConstants.JCR_READ));\n    }\n    PrivilegeBits denyBits = PrivilegeBits.getInstance();\n    PrivilegeBits parentAllowBits;\n    PrivilegeBits parentDenyBits;\n    String parentPath;\n    if (respectParent) {\n        parentAllowBits = PrivilegeBits.getInstance();\n        parentDenyBits = PrivilegeBits.getInstance();\n        parentPath = PermissionUtil.getParentPathOrNull(path);\n    } else {\n        parentAllowBits = PrivilegeBits.EMPTY;\n        parentDenyBits = PrivilegeBits.EMPTY;\n        parentPath = null;\n    }\n    while (entries.hasNext()) {\n        PermissionEntry entry = entries.next();\n        if (respectParent && (parentPath != null)) {\n            boolean matchesParent = entry.matchesParent(parentPath);\n            if (matchesParent) {\n                if (entry.isAllow) {\n                    parentAllowBits.addDifference(entry.privilegeBits, parentDenyBits);\n                } else {\n                    parentDenyBits.addDifference(entry.privilegeBits, parentAllowBits);\n                }\n            }\n        }\n        if (entry.isAllow) {\n            allowBits.addDifference(entry.privilegeBits, denyBits);\n            long ap = PrivilegeBits.calculatePermissions(allowBits, parentAllowBits, true);\n            allows |= Permissions.diff(ap, denies);\n            if ((allows | ~permissions) == -1) {\n                return true;\n            }\n        } else {\n            denyBits.addDifference(entry.privilegeBits, allowBits);\n            long dp = PrivilegeBits.calculatePermissions(denyBits, parentDenyBits, false);\n            denies |= Permissions.diff(dp, allows);\n            if (Permissions.includes(denies, permissions)) {\n                return false;\n            }\n        }\n    }\n    return (allows | ~permissions) == -1;\n}", "code_comment": NaN, "code_no_comment": "private boolean hasPermissions(@Nonnull Iterator<PermissionEntry> entries, long permissions, @Nullable String path) {\n        boolean isReadable = Permissions.diff(Permissions.READ, permissions) != Permissions.READ && readPolicy.isReadablePath(path, false);\n    if (!entries.hasNext() && !isReadable) {\n        return false;\n    }\n    boolean respectParent = (path != null) && Permissions.respectParentPermissions(permissions);\n    long allows = (isReadable) ? Permissions.READ : Permissions.NO_PERMISSION;\n    long denies = Permissions.NO_PERMISSION;\n    PrivilegeBits allowBits = PrivilegeBits.getInstance();\n    if (isReadable) {\n        allowBits.add(bitsProvider.getBits(PrivilegeConstants.JCR_READ));\n    }\n    PrivilegeBits denyBits = PrivilegeBits.getInstance();\n    PrivilegeBits parentAllowBits;\n    PrivilegeBits parentDenyBits;\n    String parentPath;\n    if (respectParent) {\n        parentAllowBits = PrivilegeBits.getInstance();\n        parentDenyBits = PrivilegeBits.getInstance();\n        parentPath = PermissionUtil.getParentPathOrNull(path);\n    } else {\n        parentAllowBits = PrivilegeBits.EMPTY;\n        parentDenyBits = PrivilegeBits.EMPTY;\n        parentPath = null;\n    }\n    while (entries.hasNext()) {\n        PermissionEntry entry = entries.next();\n        if (respectParent && (parentPath != null)) {\n            boolean matchesParent = entry.matchesParent(parentPath);\n            if (matchesParent) {\n                if (entry.isAllow) {\n                    parentAllowBits.addDifference(entry.privilegeBits, parentDenyBits);\n                } else {\n                    parentDenyBits.addDifference(entry.privilegeBits, parentAllowBits);\n                }\n            }\n        }\n        if (entry.isAllow) {\n            allowBits.addDifference(entry.privilegeBits, denyBits);\n            long ap = PrivilegeBits.calculatePermissions(allowBits, parentAllowBits, true);\n            allows |= Permissions.diff(ap, denies);\n            if ((allows | ~permissions) == -1) {\n                return true;\n            }\n        } else {\n            denyBits.addDifference(entry.privilegeBits, allowBits);\n            long dp = PrivilegeBits.calculatePermissions(denyBits, parentDenyBits, false);\n            denies |= Permissions.diff(dp, allows);\n            if (Permissions.includes(denies, permissions)) {\n                return false;\n            }\n        }\n    }\n    return (allows | ~permissions) == -1;\n}", "lc": 1.8636363636363635, "pi": 0.8775510204081634, "ma": 1.3333333333333333, "nbd": 1.0, "ml": 1.5, "d": 1.9920909540286704, "mi": -0.9592773157441931, "fo": 1.4166666666666667, "r": -0.028571428571428574, "e": 5.543281894458222}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443", "label": 1, "code": "@Override\npublic void setLocalityGroups(String tableName, Map<String, Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void setLocalityGroups(String tableName, Map<String, Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n}", "lc": -0.5, "pi": -1.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9374820762833384, "fo": -0.5, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-934_724795b5", "label": 3, "code": "/**\n * {@inheritDoc}\n */\npublic Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    if (isInfinite) {\n        return ZERO;\n    }\n    if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n        double q = real / imaginary;\n        double scale = 1. / (real * q + imaginary);\n        return createComplex(scale * q, -scale);\n    } else {\n        double q = imaginary / real;\n        double scale = 1. / (imaginary * q + real);\n        return createComplex(scale, -scale * q);\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    if (isInfinite) {\n        return ZERO;\n    }\n    if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n        double q = real / imaginary;\n        double scale = 1. / (real * q + imaginary);\n        return createComplex(scale * q, -scale);\n    } else {\n        double q = imaginary / real;\n        double scale = 1. / (imaginary * q + real);\n        return createComplex(scale, -scale * q);\n    }\n}", "lc": 0.2727272727272727, "pi": -0.20408163265306117, "ma": 0.16666666666666666, "nbd": -0.5, "ml": 0.5, "d": 1.6955017301038064, "mi": -0.24003441353599103, "fo": -0.16666666666666666, "r": 0.4857142857142857, "e": 1.114167748125115}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5259_a9e56e1e", "label": 1, "code": "/**\n *  Parses the given URL string.\n *\n *  @param _url\n *             absolute or relative url with query string\n *  @param charset\n *  @return Url object\n */\npublic static Url parse(CharSequence _url, Charset charset) {\n    Args.notNull(_url, \"_url\");\n    final Url result = new Url(charset);\n    // the url object resolved the charset, use that\n    charset = result.getCharset();\n    String url = _url.toString();\n    // extract query string part\n    final String queryString;\n    final String absoluteUrl;\n    final int queryAt = url.indexOf('?');\n    if (queryAt == -1) {\n        queryString = \"\";\n        absoluteUrl = url;\n    } else {\n        absoluteUrl = url.substring(0, queryAt);\n        queryString = url.substring(queryAt + 1);\n    }\n    // get absolute / relative part of url\n    String relativeUrl;\n    final int idxOfFirstSlash = absoluteUrl.indexOf('/');\n    final int protocolAt = absoluteUrl.indexOf(\"://\");\n    // full urls start either with a \"scheme://\" or with \"//\"\n    boolean protocolLess = absoluteUrl.startsWith(\"//\");\n    final boolean isFull = (protocolAt > 1 && (protocolAt < idxOfFirstSlash)) || protocolLess;\n    if (isFull) {\n        if (protocolLess == false) {\n            result.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);\n        }\n        final String afterProto = absoluteUrl.substring(protocolAt + 3);\n        final String hostAndPort;\n        int relativeAt = afterProto.indexOf('/');\n        if (relativeAt == -1) {\n            relativeAt = afterProto.indexOf(';');\n        }\n        if (relativeAt == -1) {\n            relativeUrl = \"\";\n            hostAndPort = afterProto;\n        } else {\n            relativeUrl = afterProto.substring(relativeAt);\n            hostAndPort = afterProto.substring(0, relativeAt);\n        }\n        final int portAt = hostAndPort.lastIndexOf(':');\n        if (portAt == -1) {\n            result.host = hostAndPort;\n            result.port = getDefaultPortForProtocol(result.protocol);\n        } else {\n            result.host = hostAndPort.substring(0, portAt);\n            result.port = Integer.parseInt(hostAndPort.substring(portAt + 1));\n        }\n        if (relativeAt < 0) {\n            relativeUrl = \"/\";\n        }\n    } else {\n        relativeUrl = absoluteUrl;\n    }\n    if (relativeUrl.length() > 0) {\n        boolean removeLast = false;\n        if (relativeUrl.endsWith(\"/\")) {\n            // we need to append something and remove it after splitting\n            // because otherwise the\n            // trailing slashes will be lost\n            relativeUrl += \"/x\";\n            removeLast = true;\n        }\n        String[] segmentArray = Strings.split(relativeUrl, '/');\n        if (removeLast) {\n            segmentArray[segmentArray.length - 1] = null;\n        }\n        for (String s : segmentArray) {\n            if (s != null) {\n                result.segments.add(decodeSegment(s, charset));\n            }\n        }\n    }\n    if (queryString.length() > 0) {\n        String[] queryArray = Strings.split(queryString, '&');\n        for (String s : queryArray) {\n            if (Strings.isEmpty(s) == false) {\n                result.parameters.add(parseQueryParameter(s, charset));\n            }\n        }\n    }\n    return result;\n}", "code_comment": "/**\n *  Parses the given URL string.\n *\n *  @param _url\n *             absolute or relative url with query string\n *  @param charset\n *  @return Url object\n */\n", "code_no_comment": "public static Url parse(CharSequence _url, Charset charset) {\n    Args.notNull(_url, \"_url\");\n    final Url result = new Url(charset);\n        charset = result.getCharset();\n    String url = _url.toString();\n        final String queryString;\n    final String absoluteUrl;\n    final int queryAt = url.indexOf('?');\n    if (queryAt == -1) {\n        queryString = \"\";\n        absoluteUrl = url;\n    } else {\n        absoluteUrl = url.substring(0, queryAt);\n        queryString = url.substring(queryAt + 1);\n    }\n        String relativeUrl;\n    final int idxOfFirstSlash = absoluteUrl.indexOf('/');\n    final int protocolAt = absoluteUrl.indexOf(\"://\");\n        boolean protocolLess = absoluteUrl.startsWith(\"//\");\n    final boolean isFull = (protocolAt > 1 && (protocolAt < idxOfFirstSlash)) || protocolLess;\n    if (isFull) {\n        if (protocolLess == false) {\n            result.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);\n        }\n        final String afterProto = absoluteUrl.substring(protocolAt + 3);\n        final String hostAndPort;\n        int relativeAt = afterProto.indexOf('/');\n        if (relativeAt == -1) {\n            relativeAt = afterProto.indexOf(';');\n        }\n        if (relativeAt == -1) {\n            relativeUrl = \"\";\n            hostAndPort = afterProto;\n        } else {\n            relativeUrl = afterProto.substring(relativeAt);\n            hostAndPort = afterProto.substring(0, relativeAt);\n        }\n        final int portAt = hostAndPort.lastIndexOf(':');\n        if (portAt == -1) {\n            result.host = hostAndPort;\n            result.port = getDefaultPortForProtocol(result.protocol);\n        } else {\n            result.host = hostAndPort.substring(0, portAt);\n            result.port = Integer.parseInt(hostAndPort.substring(portAt + 1));\n        }\n        if (relativeAt < 0) {\n            relativeUrl = \"/\";\n        }\n    } else {\n        relativeUrl = absoluteUrl;\n    }\n    if (relativeUrl.length() > 0) {\n        boolean removeLast = false;\n        if (relativeUrl.endsWith(\"/\")) {\n                                                relativeUrl += \"/x\";\n            removeLast = true;\n        }\n        String[] segmentArray = Strings.split(relativeUrl, '/');\n        if (removeLast) {\n            segmentArray[segmentArray.length - 1] = null;\n        }\n        for (String s : segmentArray) {\n            if (s != null) {\n                result.segments.add(decodeSegment(s, charset));\n            }\n        }\n    }\n    if (queryString.length() > 0) {\n        String[] queryArray = Strings.split(queryString, '&');\n        for (String s : queryArray) {\n            if (Strings.isEmpty(s) == false) {\n                result.parameters.add(parseQueryParameter(s, charset));\n            }\n        }\n    }\n    return result;\n}", "lc": 2.8636363636363638, "pi": 0.20918367346938782, "ma": 2.0, "nbd": 0.5, "ml": 1.5833333333333333, "d": 2.5714285714285716, "mi": -1.1984513908804133, "fo": 2.0833333333333335, "r": -0.028571428571428574, "e": 10.202898736942194}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2447_5546a1ef", "label": 1, "code": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\nprivate <OUT, IN1, IN2> TypeInformation<OUT> privateGetForClass(Class<OUT> clazz, ArrayList<Type> typeHierarchy, ParameterizedType parameterizedType, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\n    Preconditions.checkNotNull(clazz);\n    if (clazz.equals(Object.class)) {\n        return new GenericTypeInfo<OUT>(clazz);\n    }\n    // check for arrays\n    if (clazz.isArray()) {\n        // primitive arrays: int[], byte[], ...\n        PrimitiveArrayTypeInfo<OUT> primitiveArrayInfo = PrimitiveArrayTypeInfo.getInfoFor(clazz);\n        if (primitiveArrayInfo != null) {\n            return primitiveArrayInfo;\n        }\n        // basic type arrays: String[], Integer[], Double[]\n        BasicArrayTypeInfo<OUT, ?> basicArrayInfo = BasicArrayTypeInfo.getInfoFor(clazz);\n        if (basicArrayInfo != null) {\n            return basicArrayInfo;\n        } else // object arrays\n        {\n            return ObjectArrayTypeInfo.getInfoFor(clazz);\n        }\n    }\n    // check for writable types\n    if (Writable.class.isAssignableFrom(clazz) && !Writable.class.equals(clazz)) {\n        return (TypeInformation<OUT>) WritableTypeInfo.getWritableTypeInfo((Class<? extends Writable>) clazz);\n    }\n    // check for basic types\n    TypeInformation<OUT> basicTypeInfo = BasicTypeInfo.getInfoFor(clazz);\n    if (basicTypeInfo != null) {\n        return basicTypeInfo;\n    }\n    // check for subclasses of Value\n    if (Value.class.isAssignableFrom(clazz)) {\n        Class<? extends Value> valueClass = clazz.asSubclass(Value.class);\n        return (TypeInformation<OUT>) ValueTypeInfo.getValueTypeInfo(valueClass);\n    }\n    // check for subclasses of Tuple\n    if (Tuple.class.isAssignableFrom(clazz)) {\n        throw new InvalidTypesException(\"Type information extraction for tuples cannot be done based on the class.\");\n    }\n    // check for Enums\n    if (Enum.class.isAssignableFrom(clazz)) {\n        return (TypeInformation<OUT>) new EnumTypeInfo(clazz);\n    }\n    // special case for POJOs generated by Avro.\n    if (SpecificRecordBase.class.isAssignableFrom(clazz)) {\n        return (TypeInformation<OUT>) new AvroTypeInfo(clazz);\n    }\n    if (alreadySeen.contains(clazz)) {\n        return new GenericTypeInfo<OUT>(clazz);\n    }\n    alreadySeen.add(clazz);\n    if (Modifier.isInterface(clazz.getModifiers())) {\n        // Interface has no members and is therefore not handled as POJO\n        return new GenericTypeInfo<OUT>(clazz);\n    }\n    if (clazz.equals(Class.class)) {\n        // special case handling for Class, this should not be handled by the POJO logic\n        return new GenericTypeInfo<OUT>(clazz);\n    }\n    try {\n        TypeInformation<OUT> pojoType = analyzePojo(clazz, new ArrayList<Type>(typeHierarchy), parameterizedType, in1Type, in2Type);\n        if (pojoType != null) {\n            return pojoType;\n        }\n    } catch (InvalidTypesException e) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Unable to handle type \" + clazz + \" as POJO. Message: \" + e.getMessage(), e);\n        }\n    // ignore and create generic type info\n    }\n    // return a generic type\n    return new GenericTypeInfo<OUT>(clazz);\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\nprivate <OUT, IN1, IN2> TypeInformation<OUT> privateGetForClass(Class<OUT> clazz, ArrayList<Type> typeHierarchy, ParameterizedType parameterizedType, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\n    Preconditions.checkNotNull(clazz);\n    if (clazz.equals(Object.class)) {\n        return new GenericTypeInfo<OUT>(clazz);\n    }\n        if (clazz.isArray()) {\n                PrimitiveArrayTypeInfo<OUT> primitiveArrayInfo = PrimitiveArrayTypeInfo.getInfoFor(clazz);\n        if (primitiveArrayInfo != null) {\n            return primitiveArrayInfo;\n        }\n                BasicArrayTypeInfo<OUT, ?> basicArrayInfo = BasicArrayTypeInfo.getInfoFor(clazz);\n        if (basicArrayInfo != null) {\n            return basicArrayInfo;\n        } else         {\n            return ObjectArrayTypeInfo.getInfoFor(clazz);\n        }\n    }\n        if (Writable.class.isAssignableFrom(clazz) && !Writable.class.equals(clazz)) {\n        return (TypeInformation<OUT>) WritableTypeInfo.getWritableTypeInfo((Class<? extends Writable>) clazz);\n    }\n        TypeInformation<OUT> basicTypeInfo = BasicTypeInfo.getInfoFor(clazz);\n    if (basicTypeInfo != null) {\n        return basicTypeInfo;\n    }\n        if (Value.class.isAssignableFrom(clazz)) {\n        Class<? extends Value> valueClass = clazz.asSubclass(Value.class);\n        return (TypeInformation<OUT>) ValueTypeInfo.getValueTypeInfo(valueClass);\n    }\n        if (Tuple.class.isAssignableFrom(clazz)) {\n        throw new InvalidTypesException(\"Type information extraction for tuples cannot be done based on the class.\");\n    }\n        if (Enum.class.isAssignableFrom(clazz)) {\n        return (TypeInformation<OUT>) new EnumTypeInfo(clazz);\n    }\n        if (SpecificRecordBase.class.isAssignableFrom(clazz)) {\n        return (TypeInformation<OUT>) new AvroTypeInfo(clazz);\n    }\n    if (alreadySeen.contains(clazz)) {\n        return new GenericTypeInfo<OUT>(clazz);\n    }\n    alreadySeen.add(clazz);\n    if (Modifier.isInterface(clazz.getModifiers())) {\n                return new GenericTypeInfo<OUT>(clazz);\n    }\n    if (clazz.equals(Class.class)) {\n                return new GenericTypeInfo<OUT>(clazz);\n    }\n    try {\n        TypeInformation<OUT> pojoType = analyzePojo(clazz, new ArrayList<Type>(typeHierarchy), parameterizedType, in1Type, in2Type);\n        if (pojoType != null) {\n            return pojoType;\n        }\n    } catch (InvalidTypesException e) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Unable to handle type \" + clazz + \" as POJO. Message: \" + e.getMessage(), e);\n        }\n        }\n        return new GenericTypeInfo<OUT>(clazz);\n}", "lc": 2.1363636363636362, "pi": -0.08163265306122457, "ma": 2.3333333333333335, "nbd": 0.0, "ml": 2.4166666666666665, "d": 0.6198714780029659, "mi": -1.0404359047892173, "fo": 1.5833333333333333, "r": -0.028571428571428574, "e": 2.1403925801242933}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-107_88641f49", "label": 1, "code": "/**\n * Extract options.\n *\n * @param pattern conversion pattern.\n * @param i       start of options.\n * @param options array to receive extracted options\n * @return position in pattern after options.\n */\nprivate static int extractOptions(String pattern, int i, List<String> options) {\n    while ((i < pattern.length()) && (pattern.charAt(i) == '{')) {\n        int begin = i;\n        int end;\n        int depth = 0;\n        do {\n            end = pattern.indexOf('}', i);\n            if (end != -1) {\n                int next = pattern.indexOf(\"{\", i + 1);\n                if (next != -1 && next < end) {\n                    i = end + 1;\n                    ++depth;\n                } else if (depth > 0) {\n                    --depth;\n                }\n            }\n        } while (depth > 0);\n        if (end == -1) {\n            break;\n        }\n        String r = pattern.substring(begin + 1, end);\n        options.add(r);\n        i = end + 1;\n    }\n    return i;\n}", "code_comment": "/**\n * Extract options.\n *\n * @param pattern conversion pattern.\n * @param i       start of options.\n * @param options array to receive extracted options\n * @return position in pattern after options.\n */\n", "code_no_comment": "private static int extractOptions(String pattern, int i, List<String> options) {\n    while ((i < pattern.length()) && (pattern.charAt(i) == '{')) {\n        int begin = i;\n        int end;\n        int depth = 0;\n        do {\n            end = pattern.indexOf('}', i);\n            if (end != -1) {\n                int next = pattern.indexOf(\"{\", i + 1);\n                if (next != -1 && next < end) {\n                    i = end + 1;\n                    ++depth;\n                } else if (depth > 0) {\n                    --depth;\n                }\n            }\n        } while (depth > 0);\n        if (end == -1) {\n            break;\n        }\n        String r = pattern.substring(begin + 1, end);\n        options.add(r);\n        i = end + 1;\n    }\n    return i;\n}", "lc": 0.5454545454545454, "pi": 1.3010204081632655, "ma": 0.6666666666666666, "nbd": 1.5, "ml": 0.75, "d": 2.537815126050421, "mi": -0.44536851161456853, "fo": 0.0, "r": 0.0, "e": 2.592202363361473}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1270_70564c7c", "label": 1, "code": "@Override\npublic boolean visit(FullTextOr or) {\n    BooleanQuery q = new BooleanQuery();\n    for (FullTextExpression e : or.list) {\n        Query x = getFullTextQuery(e, analyzer);\n        q.add(x, SHOULD);\n    }\n    result.set(q);\n    return true;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean visit(FullTextOr or) {\n    BooleanQuery q = new BooleanQuery();\n    for (FullTextExpression e : or.list) {\n        Query x = getFullTextQuery(e, analyzer);\n        q.add(x, SHOULD);\n    }\n    result.set(q);\n    return true;\n}", "lc": -0.18181818181818182, "pi": -0.11224489795918377, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.23458560367077702, "fo": -0.25, "r": 0.7428571428571429, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2147_a1556c30", "label": 1, "code": "/**\n * set the value of the :next at the given position. If the property :next won't be there by the\n * time this method is invoked it won't perform any action\n *\n * @param node\n * @param value\n * @param lane\n */\nstatic void setPropertyNext(@Nonnull final NodeBuilder node, final String value, final int lane) {\n    if (node != null && value != null && lane >= 0 && lane < OrderedIndex.LANES) {\n        PropertyState next = node.getProperty(NEXT);\n        if (next != null) {\n            String[] values;\n            if (next.isArray()) {\n                values = Iterables.toArray(next.getValue(Type.STRINGS), String.class);\n                if (values.length < OrderedIndex.LANES) {\n                    // it could be we increased the number of lanes and running on some existing\n                    // content\n                    LOG.debug(\"topping-up the number of lanes.\");\n                    List<String> vv = Lists.newArrayList(values);\n                    for (int i = vv.size(); i <= OrderedIndex.LANES; i++) {\n                        vv.add(\"\");\n                    }\n                    values = vv.toArray(new String[vv.size()]);\n                }\n            } else {\n                values = Iterables.toArray(EMPTY_NEXT, String.class);\n                values[0] = next.getValue(Type.STRING);\n            }\n            values[lane] = value;\n            setPropertyNext(node, values);\n        }\n    }\n}", "code_comment": "/**\n * set the value of the :next at the given position. If the property :next won't be there by the\n * time this method is invoked it won't perform any action\n *\n * @param node\n * @param value\n * @param lane\n */\n", "code_no_comment": "static void setPropertyNext(@Nonnull final NodeBuilder node, final String value, final int lane) {\n    if (node != null && value != null && lane >= 0 && lane < OrderedIndex.LANES) {\n        PropertyState next = node.getProperty(NEXT);\n        if (next != null) {\n            String[] values;\n            if (next.isArray()) {\n                values = Iterables.toArray(next.getValue(Type.STRINGS), String.class);\n                if (values.length < OrderedIndex.LANES) {\n                                                            LOG.debug(\"topping-up the number of lanes.\");\n                    List<String> vv = Lists.newArrayList(values);\n                    for (int i = vv.size(); i <= OrderedIndex.LANES; i++) {\n                        vv.add(\"\");\n                    }\n                    values = vv.toArray(new String[vv.size()]);\n                }\n            } else {\n                values = Iterables.toArray(EMPTY_NEXT, String.class);\n                values[0] = next.getValue(Type.STRING);\n            }\n            values[lane] = value;\n            setPropertyNext(node, values);\n        }\n    }\n}", "lc": 0.45454545454545453, "pi": 1.7397959183673468, "ma": 0.3333333333333333, "nbd": 1.5, "ml": 0.8333333333333334, "d": 0.934256055363322, "mi": -0.43016919988528834, "fo": 0.5833333333333334, "r": -0.028571428571428574, "e": 1.4059559450233639}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3885_beb9086d", "label": 1, "code": "@Override\npublic void sendRedirect(String url) {\n    try {\n        redirect = true;\n        url = getAbsoluteURL(url);\n        url = encodeRedirectURL(url);\n        // wicket redirects should never be cached\n        disableCaching();\n        if (webRequest.isAjax()) {\n            httpServletResponse.addHeader(\"Ajax-Location\", url);\n            /*\n\t\t\t\t * usually the Ajax-Location header is enough and we do not need to the redirect url\n\t\t\t\t * into the response, but sometimes the response is processed via an iframe (eg\n\t\t\t\t * using multipart ajax handling) and the headers are not available because XHR is\n\t\t\t\t * not used and that is the only way javascript has access to response headers.\n\t\t\t\t */\n            httpServletResponse.getWriter().write(\"<ajax-response><redirect><![CDATA[\" + url + \"]]></redirect></ajax-response>\");\n            setContentType(\"text/xml;charset=\" + webRequest.getContainerRequest().getCharacterEncoding());\n        } else {\n            httpServletResponse.sendRedirect(url);\n        }\n    } catch (IOException e) {\n        throw new WicketRuntimeException(e);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void sendRedirect(String url) {\n    try {\n        redirect = true;\n        url = getAbsoluteURL(url);\n        url = encodeRedirectURL(url);\n                disableCaching();\n        if (webRequest.isAjax()) {\n            httpServletResponse.addHeader(\"Ajax-Location\", url);\n                        httpServletResponse.getWriter().write(\"<ajax-response><redirect><![CDATA[\" + url + \"]]></redirect></ajax-response>\");\n            setContentType(\"text/xml;charset=\" + webRequest.getContainerRequest().getCharacterEncoding());\n        } else {\n            httpServletResponse.sendRedirect(url);\n        }\n    } catch (IOException e) {\n        throw new WicketRuntimeException(e);\n    }\n}", "lc": 0.18181818181818182, "pi": 0.47959183673469385, "ma": 0.0, "nbd": 0.0, "ml": -0.25, "d": -0.09194265941670784, "mi": -0.13708058503011192, "fo": 0.4166666666666667, "r": -0.028571428571428574, "e": -0.034829386545372}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-193_c831e44d", "label": 3, "code": "public String toString() {\n    String labelString = new ColumnVisibility(colVisibility).toString();\n    String s = toPrintableString(row, 0, row.length, Constants.MAX_DATA_TO_PRINT) + \" \" + toPrintableString(colFamily, 0, colFamily.length, Constants.MAX_DATA_TO_PRINT) + \":\" + toPrintableString(colQualifier, 0, colQualifier.length, Constants.MAX_DATA_TO_PRINT) + \" \" + labelString + \" \" + Long.toString(timestamp) + \" \" + deleted;\n    return s;\n}", "code_comment": NaN, "code_no_comment": "public String toString() {\n    String labelString = new ColumnVisibility(colVisibility).toString();\n    String s = toPrintableString(row, 0, row.length, Constants.MAX_DATA_TO_PRINT) + \" \" + toPrintableString(colFamily, 0, colFamily.length, Constants.MAX_DATA_TO_PRINT) + \":\" + toPrintableString(colQualifier, 0, colQualifier.length, Constants.MAX_DATA_TO_PRINT) + \" \" + labelString + \" \" + Long.toString(timestamp) + \" \" + deleted;\n    return s;\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": 0.03460207612456753, "mi": 0.48236306280470315, "fo": -0.08333333333333333, "r": -0.028571428571428574, "e": 0.016266848266025938}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1075_79467350", "label": 1, "code": "/**\n * \"operand2 always evaluates to a scalar value\"\n *\n * for multi-valued properties: if any of the value matches, then return true\n *\n * @param p1\n * @param p2\n * @return\n */\nprivate boolean evaluate(PropertyValue p1, PropertyValue p2) {\n    switch(operator) {\n        case EQUAL:\n            return PropertyValues.match(p1, p2);\n        case NOT_EQUAL:\n            return !PropertyValues.match(p1, p2);\n        case GREATER_OR_EQUAL:\n            return p1.compareTo(p2) >= 0;\n        case GREATER_THAN:\n            return p1.compareTo(p2) > 0;\n        case LESS_OR_EQUAL:\n            return p1.compareTo(p2) <= 0;\n        case LESS_THAN:\n            return p1.compareTo(p2) < 0;\n        case LIKE:\n            return evaluateLike(p1, p2);\n    }\n    throw new IllegalArgumentException(\"Unknown operator: \" + operator);\n}", "code_comment": "/**\n * \"operand2 always evaluates to a scalar value\"\n *\n * for multi-valued properties: if any of the value matches, then return true\n *\n * @param p1\n * @param p2\n * @return\n */\n", "code_no_comment": "private boolean evaluate(PropertyValue p1, PropertyValue p2) {\n    switch(operator) {\n        case EQUAL:\n            return PropertyValues.match(p1, p2);\n        case NOT_EQUAL:\n            return !PropertyValues.match(p1, p2);\n        case GREATER_OR_EQUAL:\n            return p1.compareTo(p2) >= 0;\n        case GREATER_THAN:\n            return p1.compareTo(p2) > 0;\n        case LESS_OR_EQUAL:\n            return p1.compareTo(p2) <= 0;\n        case LESS_THAN:\n            return p1.compareTo(p2) < 0;\n        case LIKE:\n            return evaluateLike(p1, p2);\n    }\n    throw new IllegalArgumentException(\"Unknown operator: \" + operator);\n}", "lc": 0.22727272727272727, "pi": 0.4438775510204082, "ma": 0.8333333333333334, "nbd": 0.0, "ml": 0.25, "d": 0.9243697478991598, "mi": -0.21422426154287355, "fo": 0.08333333333333333, "r": 0.05714285714285714, "e": 0.500130631614564}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5215_033eb6fe", "label": 3, "code": "public void process(Exchange exchange) throws Exception {\n    endpoint.configureExchange(exchange);\n    String target = createFileName(exchange);\n    // use lock for same file name to avoid concurrent writes to the same file\n    // for example when you concurrently append to the same file\n    Lock lock;\n    synchronized (locks) {\n        lock = locks.get(target);\n        if (lock == null) {\n            lock = new ReentrantLock();\n            locks.put(target, lock);\n        }\n    }\n    lock.lock();\n    try {\n        processExchange(exchange, target);\n    } finally {\n        // do not remove as the locks cache has an upper bound\n        // this ensure the locks is appropriate reused\n        lock.unlock();\n    }\n}", "code_comment": NaN, "code_no_comment": "public void process(Exchange exchange) throws Exception {\n    endpoint.configureExchange(exchange);\n    String target = createFileName(exchange);\n            Lock lock;\n    synchronized (locks) {\n        lock = locks.get(target);\n        if (lock == null) {\n            lock = new ReentrantLock();\n            locks.put(target, lock);\n        }\n    }\n    lock.lock();\n    try {\n        processExchange(exchange, target);\n    } finally {\n                        lock.unlock();\n    }\n}", "lc": 0.18181818181818182, "pi": 0.14285714285714277, "ma": -0.3333333333333333, "nbd": 0.0, "ml": -0.25, "d": -0.026693030153237728, "mi": -0.09176942930886159, "fo": 0.08333333333333333, "r": 0.0, "e": -0.03630273983750283}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5", "label": 3, "code": "@Override\npublic String toString() {\n    StringBuilder sb = new StringBuilder(\"update_result(\");\n    boolean first = true;\n    sb.append(\"ouch1:\");\n    if (this.ouch1 == null) {\n        sb.append(\"null\");\n    } else {\n        sb.append(this.ouch1);\n    }\n    first = false;\n    if (!first)\n        sb.append(\", \");\n    sb.append(\"ouch2:\");\n    if (this.ouch2 == null) {\n        sb.append(\"null\");\n    } else {\n        sb.append(this.ouch2);\n    }\n    first = false;\n    sb.append(\")\");\n    return sb.toString();\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic String toString() {\n    StringBuilder sb = new StringBuilder(\"update_result(\");\n    boolean first = true;\n    sb.append(\"ouch1:\");\n    if (this.ouch1 == null) {\n        sb.append(\"null\");\n    } else {\n        sb.append(this.ouch1);\n    }\n    first = false;\n    if (!first)\n        sb.append(\", \");\n    sb.append(\"ouch2:\");\n    if (this.ouch2 == null) {\n        sb.append(\"null\");\n    } else {\n        sb.append(this.ouch2);\n    }\n    first = false;\n    sb.append(\")\");\n    return sb.toString();\n}", "lc": 0.4090909090909091, "pi": -0.3520408163265306, "ma": 0.0, "nbd": -0.5, "ml": 0.08333333333333333, "d": 0.11369253583786461, "mi": -0.26584456552910807, "fo": 0.25, "r": 0.0, "e": 0.08033201845118018}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-398_2c966ad9", "label": 1, "code": "@SuppressWarnings(\"unchecked\")\nprotected void doConfigure() {\n    boolean setRoot = false;\n    boolean setLoggers = false;\n    for (final Node child : rootNode.getChildren()) {\n        createConfiguration(child, null);\n        if (child.getObject() == null) {\n            continue;\n        }\n        if (child.getName().equalsIgnoreCase(\"Properties\")) {\n            if (tempLookup == subst.getVariableResolver()) {\n                subst.setVariableResolver((StrLookup) child.getObject());\n            } else {\n                LOGGER.error(\"Properties declaration must be the first element in the configuration\");\n            }\n            continue;\n        } else if (tempLookup == subst.getVariableResolver()) {\n            final Map<String, String> map = (Map<String, String>) componentMap.get(CONTEXT_PROPERTIES);\n            final StrLookup lookup = map == null ? null : new MapLookup(map);\n            subst.setVariableResolver(new Interpolator(lookup));\n        }\n        if (child.getName().equalsIgnoreCase(\"Appenders\")) {\n            appenders = (ConcurrentMap<String, Appender>) child.getObject();\n        } else if (child.getObject() instanceof Filter) {\n            addFilter((Filter) child.getObject());\n        } else if (child.getName().equalsIgnoreCase(\"Loggers\")) {\n            final Loggers l = (Loggers) child.getObject();\n            loggers = l.getMap();\n            setLoggers = true;\n            if (l.getRoot() != null) {\n                root = l.getRoot();\n                setRoot = true;\n            }\n        } else {\n            LOGGER.error(\"Unknown object \\\"\" + child.getName() + \"\\\" of type \" + child.getObject().getClass().getName() + \" is ignored\");\n        }\n    }\n    if (!setLoggers) {\n        LOGGER.warn(\"No Loggers were configured, using default. Is the Loggers element missing?\");\n        setToDefault();\n        return;\n    } else if (!setRoot) {\n        LOGGER.warn(\"No Root logger was configured, creating default ERROR-level Root logger with Console appender\");\n        setToDefault();\n    // return; // LOG4J2-219: creating default root=ok, but don't exclude configured Loggers\n    }\n    for (final Map.Entry<String, LoggerConfig> entry : loggers.entrySet()) {\n        final LoggerConfig l = entry.getValue();\n        for (final AppenderRef ref : l.getAppenderRefs()) {\n            final Appender app = appenders.get(ref.getRef());\n            if (app != null) {\n                l.addAppender(app, ref.getLevel(), ref.getFilter());\n            } else {\n                LOGGER.error(\"Unable to locate appender \" + ref.getRef() + \" for logger \" + l.getName());\n            }\n        }\n    }\n    setParents();\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings(\"unchecked\")\nprotected void doConfigure() {\n    boolean setRoot = false;\n    boolean setLoggers = false;\n    for (final Node child : rootNode.getChildren()) {\n        createConfiguration(child, null);\n        if (child.getObject() == null) {\n            continue;\n        }\n        if (child.getName().equalsIgnoreCase(\"Properties\")) {\n            if (tempLookup == subst.getVariableResolver()) {\n                subst.setVariableResolver((StrLookup) child.getObject());\n            } else {\n                LOGGER.error(\"Properties declaration must be the first element in the configuration\");\n            }\n            continue;\n        } else if (tempLookup == subst.getVariableResolver()) {\n            final Map<String, String> map = (Map<String, String>) componentMap.get(CONTEXT_PROPERTIES);\n            final StrLookup lookup = map == null ? null : new MapLookup(map);\n            subst.setVariableResolver(new Interpolator(lookup));\n        }\n        if (child.getName().equalsIgnoreCase(\"Appenders\")) {\n            appenders = (ConcurrentMap<String, Appender>) child.getObject();\n        } else if (child.getObject() instanceof Filter) {\n            addFilter((Filter) child.getObject());\n        } else if (child.getName().equalsIgnoreCase(\"Loggers\")) {\n            final Loggers l = (Loggers) child.getObject();\n            loggers = l.getMap();\n            setLoggers = true;\n            if (l.getRoot() != null) {\n                root = l.getRoot();\n                setRoot = true;\n            }\n        } else {\n            LOGGER.error(\"Unknown object \\\"\" + child.getName() + \"\\\" of type \" + child.getObject().getClass().getName() + \" is ignored\");\n        }\n    }\n    if (!setLoggers) {\n        LOGGER.warn(\"No Loggers were configured, using default. Is the Loggers element missing?\");\n        setToDefault();\n        return;\n    } else if (!setRoot) {\n        LOGGER.warn(\"No Root logger was configured, creating default ERROR-level Root logger with Console appender\");\n        setToDefault();\n        }\n    for (final Map.Entry<String, LoggerConfig> entry : loggers.entrySet()) {\n        final LoggerConfig l = entry.getValue();\n        for (final AppenderRef ref : l.getAppenderRefs()) {\n            final Appender app = appenders.get(ref.getRef());\n            if (app != null) {\n                l.addAppender(app, ref.getLevel(), ref.getFilter());\n            } else {\n                LOGGER.error(\"Unable to locate appender \" + ref.getRef() + \" for logger \" + l.getName());\n            }\n        }\n    }\n    setParents();\n}", "lc": 2.0, "pi": 0.5612244897959184, "ma": 2.3333333333333335, "nbd": 1.5, "ml": 1.5, "d": 0.4873949579831933, "mi": -1.0238026957269863, "fo": 3.25, "r": -0.028571428571428574, "e": 1.9289235526659558}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-4383_0f3d4d24", "label": 1, "code": "public void validateEffectiveModel(Model model, ModelBuildingRequest request, ModelProblemCollector problems) {\n    validateStringNotEmpty(\"modelVersion\", problems, false, model.getModelVersion());\n    validateId(\"groupId\", problems, model.getGroupId());\n    validateId(\"artifactId\", problems, model.getArtifactId());\n    validateStringNotEmpty(\"packaging\", problems, false, model.getPackaging());\n    if (!model.getModules().isEmpty() && !\"pom\".equals(model.getPackaging())) {\n        addViolation(problems, false, \"Packaging '\" + model.getPackaging() + \"' is invalid. Aggregator projects \" + \"require 'pom' as packaging.\");\n    }\n    Parent parent = model.getParent();\n    if (parent != null) {\n        if (parent.getGroupId().equals(model.getGroupId()) && parent.getArtifactId().equals(model.getArtifactId())) {\n            addViolation(problems, false, \"The parent element cannot have the same ID as the project.\");\n        }\n    }\n    validateStringNotEmpty(\"version\", problems, false, model.getVersion());\n    boolean warnOnBadBoolean = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;\n    boolean warnOnBadDependencyScope = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;\n    for (Dependency d : model.getDependencies()) {\n        validateId(\"dependencies.dependency.artifactId\", problems, d.getArtifactId());\n        validateId(\"dependencies.dependency.groupId\", problems, d.getGroupId());\n        validateStringNotEmpty(\"dependencies.dependency.type\", problems, false, d.getType(), d.getManagementKey());\n        validateStringNotEmpty(\"dependencies.dependency.version\", problems, false, d.getVersion(), d.getManagementKey());\n        if (\"system\".equals(d.getScope())) {\n            String systemPath = d.getSystemPath();\n            if (StringUtils.isEmpty(systemPath)) {\n                addViolation(problems, false, \"For dependency \" + d + \": system-scoped dependency must specify systemPath.\");\n            } else {\n                if (!new File(systemPath).isAbsolute()) {\n                    addViolation(problems, false, \"For dependency \" + d + \": system-scoped dependency must \" + \"specify an absolute path systemPath.\");\n                }\n            }\n        } else if (StringUtils.isNotEmpty(d.getSystemPath())) {\n            addViolation(problems, false, \"For dependency \" + d + \": only dependency with system scope can specify systemPath.\");\n        }\n        if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\n            validateBoolean(\"dependencies.dependency.optional\", problems, warnOnBadBoolean, d.getOptional(), d.getManagementKey());\n            /*\n                 * TODO: Extensions like Flex Mojos use custom scopes like \"merged\", \"internal\", \"external\", etc. In\n                 * order to don't break backward-compat with those, only warn but don't error our.\n                 */\n            validateEnum(\"dependencies.dependency.scope\", problems, true, d.getScope(), d.getManagementKey(), \"provided\", \"compile\", \"runtime\", \"test\", \"system\");\n        }\n    }\n    DependencyManagement mgmt = model.getDependencyManagement();\n    if (mgmt != null) {\n        for (Dependency d : mgmt.getDependencies()) {\n            validateSubElementStringNotEmpty(d, \"dependencyManagement.dependencies.dependency.artifactId\", problems, d.getArtifactId());\n            validateSubElementStringNotEmpty(d, \"dependencyManagement.dependencies.dependency.groupId\", problems, d.getGroupId());\n            if (\"system\".equals(d.getScope())) {\n                String systemPath = d.getSystemPath();\n                if (StringUtils.isEmpty(systemPath)) {\n                    addViolation(problems, false, \"For managed dependency \" + d + \": system-scoped dependency must specify systemPath.\");\n                } else {\n                    if (!new File(systemPath).isAbsolute()) {\n                        addViolation(problems, false, \"For managed dependency \" + d + \": system-scoped dependency must \" + \"specify an absolute path systemPath.\");\n                    }\n                }\n            } else if (StringUtils.isNotEmpty(d.getSystemPath())) {\n                addViolation(problems, false, \"For managed dependency \" + d + \": only dependency with system scope can specify systemPath.\");\n            }\n            if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\n                validateBoolean(\"dependencyManagement.dependencies.dependency.optional\", problems, warnOnBadBoolean, d.getOptional(), d.getManagementKey());\n            }\n        }\n    }\n    if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\n        boolean warnOnMissingPluginVersion = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1;\n        Build build = model.getBuild();\n        if (build != null) {\n            for (Plugin p : build.getPlugins()) {\n                validateStringNotEmpty(\"build.plugins.plugin.artifactId\", problems, false, p.getArtifactId());\n                validateStringNotEmpty(\"build.plugins.plugin.groupId\", problems, false, p.getGroupId());\n                validateStringNotEmpty(\"build.plugins.plugin.version\", problems, warnOnMissingPluginVersion, p.getVersion(), p.getKey());\n                validateBoolean(\"build.plugins.plugin.inherited\", problems, warnOnBadBoolean, p.getInherited(), p.getKey());\n                validateBoolean(\"build.plugins.plugin.extensions\", problems, warnOnBadBoolean, p.getExtensions(), p.getKey());\n                for (Dependency d : p.getDependencies()) {\n                    validateEnum(\"build.plugins.plugin[\" + p.getKey() + \"].dependencies.dependency.scope\", problems, warnOnBadDependencyScope, d.getScope(), d.getManagementKey(), \"compile\", \"runtime\", \"system\");\n                }\n            }\n            validateResources(problems, build.getResources(), \"build.resources.resource\", request);\n            validateResources(problems, build.getTestResources(), \"build.testResources.testResource\", request);\n        }\n        Reporting reporting = model.getReporting();\n        if (reporting != null) {\n            for (ReportPlugin p : reporting.getPlugins()) {\n                validateStringNotEmpty(\"reporting.plugins.plugin.artifactId\", problems, false, p.getArtifactId());\n                validateStringNotEmpty(\"reporting.plugins.plugin.groupId\", problems, false, p.getGroupId());\n                validateStringNotEmpty(\"reporting.plugins.plugin.version\", problems, warnOnMissingPluginVersion, p.getVersion(), p.getKey());\n            }\n        }\n        forcePluginExecutionIdCollision(model, problems);\n        for (Repository repository : model.getRepositories()) {\n            validateRepositoryLayout(problems, repository, \"repositories.repository\", request);\n        }\n        for (Repository repository : model.getPluginRepositories()) {\n            validateRepositoryLayout(problems, repository, \"pluginRepositories.pluginRepository\", request);\n        }\n        DistributionManagement distMgmt = model.getDistributionManagement();\n        if (distMgmt != null) {\n            validateRepositoryLayout(problems, distMgmt.getRepository(), \"distributionManagement.repository\", request);\n            validateRepositoryLayout(problems, distMgmt.getSnapshotRepository(), \"distributionManagement.snapshotRepository\", request);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "public void validateEffectiveModel(Model model, ModelBuildingRequest request, ModelProblemCollector problems) {\n    validateStringNotEmpty(\"modelVersion\", problems, false, model.getModelVersion());\n    validateId(\"groupId\", problems, model.getGroupId());\n    validateId(\"artifactId\", problems, model.getArtifactId());\n    validateStringNotEmpty(\"packaging\", problems, false, model.getPackaging());\n    if (!model.getModules().isEmpty() && !\"pom\".equals(model.getPackaging())) {\n        addViolation(problems, false, \"Packaging '\" + model.getPackaging() + \"' is invalid. Aggregator projects \" + \"require 'pom' as packaging.\");\n    }\n    Parent parent = model.getParent();\n    if (parent != null) {\n        if (parent.getGroupId().equals(model.getGroupId()) && parent.getArtifactId().equals(model.getArtifactId())) {\n            addViolation(problems, false, \"The parent element cannot have the same ID as the project.\");\n        }\n    }\n    validateStringNotEmpty(\"version\", problems, false, model.getVersion());\n    boolean warnOnBadBoolean = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;\n    boolean warnOnBadDependencyScope = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;\n    for (Dependency d : model.getDependencies()) {\n        validateId(\"dependencies.dependency.artifactId\", problems, d.getArtifactId());\n        validateId(\"dependencies.dependency.groupId\", problems, d.getGroupId());\n        validateStringNotEmpty(\"dependencies.dependency.type\", problems, false, d.getType(), d.getManagementKey());\n        validateStringNotEmpty(\"dependencies.dependency.version\", problems, false, d.getVersion(), d.getManagementKey());\n        if (\"system\".equals(d.getScope())) {\n            String systemPath = d.getSystemPath();\n            if (StringUtils.isEmpty(systemPath)) {\n                addViolation(problems, false, \"For dependency \" + d + \": system-scoped dependency must specify systemPath.\");\n            } else {\n                if (!new File(systemPath).isAbsolute()) {\n                    addViolation(problems, false, \"For dependency \" + d + \": system-scoped dependency must \" + \"specify an absolute path systemPath.\");\n                }\n            }\n        } else if (StringUtils.isNotEmpty(d.getSystemPath())) {\n            addViolation(problems, false, \"For dependency \" + d + \": only dependency with system scope can specify systemPath.\");\n        }\n        if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\n            validateBoolean(\"dependencies.dependency.optional\", problems, warnOnBadBoolean, d.getOptional(), d.getManagementKey());\n                        validateEnum(\"dependencies.dependency.scope\", problems, true, d.getScope(), d.getManagementKey(), \"provided\", \"compile\", \"runtime\", \"test\", \"system\");\n        }\n    }\n    DependencyManagement mgmt = model.getDependencyManagement();\n    if (mgmt != null) {\n        for (Dependency d : mgmt.getDependencies()) {\n            validateSubElementStringNotEmpty(d, \"dependencyManagement.dependencies.dependency.artifactId\", problems, d.getArtifactId());\n            validateSubElementStringNotEmpty(d, \"dependencyManagement.dependencies.dependency.groupId\", problems, d.getGroupId());\n            if (\"system\".equals(d.getScope())) {\n                String systemPath = d.getSystemPath();\n                if (StringUtils.isEmpty(systemPath)) {\n                    addViolation(problems, false, \"For managed dependency \" + d + \": system-scoped dependency must specify systemPath.\");\n                } else {\n                    if (!new File(systemPath).isAbsolute()) {\n                        addViolation(problems, false, \"For managed dependency \" + d + \": system-scoped dependency must \" + \"specify an absolute path systemPath.\");\n                    }\n                }\n            } else if (StringUtils.isNotEmpty(d.getSystemPath())) {\n                addViolation(problems, false, \"For managed dependency \" + d + \": only dependency with system scope can specify systemPath.\");\n            }\n            if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\n                validateBoolean(\"dependencyManagement.dependencies.dependency.optional\", problems, warnOnBadBoolean, d.getOptional(), d.getManagementKey());\n            }\n        }\n    }\n    if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\n        boolean warnOnMissingPluginVersion = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1;\n        Build build = model.getBuild();\n        if (build != null) {\n            for (Plugin p : build.getPlugins()) {\n                validateStringNotEmpty(\"build.plugins.plugin.artifactId\", problems, false, p.getArtifactId());\n                validateStringNotEmpty(\"build.plugins.plugin.groupId\", problems, false, p.getGroupId());\n                validateStringNotEmpty(\"build.plugins.plugin.version\", problems, warnOnMissingPluginVersion, p.getVersion(), p.getKey());\n                validateBoolean(\"build.plugins.plugin.inherited\", problems, warnOnBadBoolean, p.getInherited(), p.getKey());\n                validateBoolean(\"build.plugins.plugin.extensions\", problems, warnOnBadBoolean, p.getExtensions(), p.getKey());\n                for (Dependency d : p.getDependencies()) {\n                    validateEnum(\"build.plugins.plugin[\" + p.getKey() + \"].dependencies.dependency.scope\", problems, warnOnBadDependencyScope, d.getScope(), d.getManagementKey(), \"compile\", \"runtime\", \"system\");\n                }\n            }\n            validateResources(problems, build.getResources(), \"build.resources.resource\", request);\n            validateResources(problems, build.getTestResources(), \"build.testResources.testResource\", request);\n        }\n        Reporting reporting = model.getReporting();\n        if (reporting != null) {\n            for (ReportPlugin p : reporting.getPlugins()) {\n                validateStringNotEmpty(\"reporting.plugins.plugin.artifactId\", problems, false, p.getArtifactId());\n                validateStringNotEmpty(\"reporting.plugins.plugin.groupId\", problems, false, p.getGroupId());\n                validateStringNotEmpty(\"reporting.plugins.plugin.version\", problems, warnOnMissingPluginVersion, p.getVersion(), p.getKey());\n            }\n        }\n        forcePluginExecutionIdCollision(model, problems);\n        for (Repository repository : model.getRepositories()) {\n            validateRepositoryLayout(problems, repository, \"repositories.repository\", request);\n        }\n        for (Repository repository : model.getPluginRepositories()) {\n            validateRepositoryLayout(problems, repository, \"pluginRepositories.pluginRepository\", request);\n        }\n        DistributionManagement distMgmt = model.getDistributionManagement();\n        if (distMgmt != null) {\n            validateRepositoryLayout(problems, distMgmt.getRepository(), \"distributionManagement.repository\", request);\n            validateRepositoryLayout(problems, distMgmt.getSnapshotRepository(), \"distributionManagement.snapshotRepository\", request);\n        }\n    }\n}", "lc": 3.909090909090909, "pi": 0.9948979591836733, "ma": 3.6666666666666665, "nbd": 1.5, "ml": 2.9166666666666665, "d": 1.5076618882847261, "mi": -1.480068827071982, "fo": 9.416666666666666, "r": -0.028571428571428574, "e": 12.314616606918765}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-334_9d8cc45d", "label": 1, "code": "@Override\npublic SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {\n    return new TimestampFilter(getSource(), hasStart, start, startInclusive, hasEnd, end, endInclusive);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {\n    return new TimestampFilter(getSource(), hasStart, start, startInclusive, hasEnd, end, endInclusive);\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.756524232864927, "fo": -0.4166666666666667, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1655_c91bfa54", "label": 1, "code": "@Override\npublic boolean apply(DataIdentifier input) {\n    try {\n        DataRecord dr = delegate.getRecord(input);\n        if (dr != null && dr.getLastModified() < maxLastModifiedTime) {\n            return true;\n        }\n    } catch (DataStoreException e) {\n        log.warn(\"Error occurred while fetching DataRecord for identifier {}\", input, e);\n    }\n    return false;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean apply(DataIdentifier input) {\n    try {\n        DataRecord dr = delegate.getRecord(input);\n        if (dr != null && dr.getLastModified() < maxLastModifiedTime) {\n            return true;\n        }\n    } catch (DataStoreException e) {\n        log.warn(\"Error occurred while fetching DataRecord for identifier {}\", input, e);\n    }\n    return false;\n}", "lc": -0.09090909090909091, "pi": 0.3469387755102042, "ma": -0.16666666666666666, "nbd": 0.0, "ml": 0.0, "d": 0.11962432031636186, "mi": 0.13105821623171765, "fo": -0.25, "r": 0.2285714285714286, "e": -0.027179941836808982}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5359_61122bab", "label": 3, "code": "/**\n *  Convert to enum, returning null if text is null or empty.\n *\n *  @param eClass\n *             enum type\n *\n *  @return converted\n *  @throws StringValueConversionException\n */\npublic final <T extends Enum<T>> T toOptionalEnum(Class<T> eClass) throws StringValueConversionException {\n    return Strings.isEmpty(text) ? null : toEnum(eClass);\n}", "code_comment": "/**\n *  Convert to enum, returning null if text is null or empty.\n *\n *  @param eClass\n *             enum type\n *\n *  @return converted\n *  @throws StringValueConversionException\n */\n", "code_no_comment": "public final <T extends Enum<T>> T toOptionalEnum(Class<T> eClass) throws StringValueConversionException {\n    return Strings.isEmpty(text) ? null : toEnum(eClass);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.3333333333333333, "nbd": -1.0, "ml": -0.16666666666666666, "d": -0.3806228373702422, "mi": 0.8999139661600231, "fo": -0.3333333333333333, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-8125_36e7b668", "label": 3, "code": "private void doStartCamel() throws Exception {\n    if (applicationContextClassLoader == null) {\n        // Using the TCCL as the default value of ApplicationClassLoader\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if (cl == null) {\n            // use the classloader that loaded this class\n            cl = this.getClass().getClassLoader();\n        }\n        setApplicationContextClassLoader(cl);\n    }\n    if (log.isDebugEnabled()) {\n        log.debug(\"Using ClassResolver={}, PackageScanClassResolver={}, ApplicationContextClassLoader={}\", new Object[] { getClassResolver(), getPackageScanClassResolver(), getApplicationContextClassLoader() });\n    }\n    if (isStreamCaching()) {\n        log.info(\"StreamCaching is enabled on CamelContext: {}\", getName());\n    }\n    if (isTracing()) {\n        // tracing is added in the DefaultChannel so we can enable it on the fly\n        log.info(\"Tracing is enabled on CamelContext: {}\", getName());\n    }\n    if (isUseMDCLogging()) {\n        // log if MDC has been enabled\n        log.info(\"MDC logging is enabled on CamelContext: {}\", getName());\n    }\n    if (isHandleFault()) {\n        // only add a new handle fault if not already configured\n        if (HandleFault.getHandleFault(this) == null) {\n            log.info(\"HandleFault is enabled on CamelContext: {}\", getName());\n            addInterceptStrategy(new HandleFault());\n        }\n    }\n    if (getDelayer() != null && getDelayer() > 0) {\n        log.info(\"Delayer is enabled with: {} ms. on CamelContext: {}\", getDelayer(), getName());\n    }\n    // register debugger\n    if (getDebugger() != null) {\n        log.info(\"Debugger: {} is enabled on CamelContext: {}\", getDebugger(), getName());\n        // register this camel context on the debugger\n        getDebugger().setCamelContext(this);\n        startService(getDebugger());\n        addInterceptStrategy(new Debug(getDebugger()));\n    }\n    // start management strategy before lifecycles are started\n    ManagementStrategy managementStrategy = getManagementStrategy();\n    // inject CamelContext if aware\n    if (managementStrategy instanceof CamelContextAware) {\n        ((CamelContextAware) managementStrategy).setCamelContext(this);\n    }\n    ServiceHelper.startService(managementStrategy);\n    // start lifecycle strategies\n    ServiceHelper.startServices(lifecycleStrategies);\n    Iterator<LifecycleStrategy> it = lifecycleStrategies.iterator();\n    while (it.hasNext()) {\n        LifecycleStrategy strategy = it.next();\n        try {\n            strategy.onContextStart(this);\n        } catch (VetoCamelContextStartException e) {\n            // okay we should not start Camel since it was vetoed\n            log.warn(\"Lifecycle strategy vetoed starting CamelContext ({}) due {}\", getName(), e.getMessage());\n            throw e;\n        } catch (Exception e) {\n            log.warn(\"Lifecycle strategy \" + strategy + \" failed starting CamelContext ({}) due {}\", getName(), e.getMessage());\n            throw e;\n        }\n    }\n    // start notifiers as services\n    for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {\n        if (notifier instanceof Service) {\n            Service service = (Service) notifier;\n            for (LifecycleStrategy strategy : lifecycleStrategies) {\n                strategy.onServiceAdd(this, service, null);\n            }\n        }\n        if (notifier instanceof Service) {\n            startService((Service) notifier);\n        }\n    }\n    // must let some bootstrap service be started before we can notify the starting event\n    EventHelper.notifyCamelContextStarting(this);\n    forceLazyInitialization();\n    // re-create endpoint registry as the cache size limit may be set after the constructor of this instance was called.\n    // and we needed to create endpoints up-front as it may be accessed before this context is started\n    endpoints = new EndpointRegistry(this, endpoints);\n    addService(endpoints);\n    // special for executorServiceManager as want to stop it manually\n    doAddService(executorServiceManager, false);\n    addService(producerServicePool);\n    addService(inflightRepository);\n    addService(shutdownStrategy);\n    addService(packageScanClassResolver);\n    addService(restRegistry);\n    if (runtimeEndpointRegistry != null) {\n        if (runtimeEndpointRegistry instanceof EventNotifier) {\n            getManagementStrategy().addEventNotifier((EventNotifier) runtimeEndpointRegistry);\n        }\n        addService(runtimeEndpointRegistry);\n    }\n    // eager lookup any configured properties component to avoid subsequent lookup attempts which may impact performance\n    // due we use properties component for property placeholder resolution at runtime\n    Component existing = lookupPropertiesComponent();\n    if (existing != null) {\n        // store reference to the existing properties component\n        if (existing instanceof PropertiesComponent) {\n            propertiesComponent = (PropertiesComponent) existing;\n        } else {\n            // properties component must be expected type\n            throw new IllegalArgumentException(\"Found properties component of type: \" + existing.getClass() + \" instead of expected: \" + PropertiesComponent.class);\n        }\n    }\n    // start components\n    startServices(components.values());\n    // start the route definitions before the routes is started\n    startRouteDefinitions(routeDefinitions);\n    // is there any stream caching enabled then log an info about this and its limit of spooling to disk, so people is aware of this\n    boolean streamCachingInUse = isStreamCaching();\n    if (!streamCachingInUse) {\n        for (RouteDefinition route : routeDefinitions) {\n            Boolean routeCache = CamelContextHelper.parseBoolean(this, route.getStreamCache());\n            if (routeCache != null && routeCache) {\n                streamCachingInUse = true;\n                break;\n            }\n        }\n    }\n    if (isAllowUseOriginalMessage()) {\n        log.info(\"AllowUseOriginalMessage is enabled. If access to the original message is not needed,\" + \" then its recommended to turn this option off as it may improve performance.\");\n    }\n    if (streamCachingInUse) {\n        // stream caching is in use so enable the strategy\n        getStreamCachingStrategy().setEnabled(true);\n        addService(getStreamCachingStrategy());\n    } else {\n        // log if stream caching is not in use as this can help people to enable it if they use streams\n        log.info(\"StreamCaching is not in use. If using streams then its recommended to enable stream caching.\" + \" See more details at http://camel.apache.org/stream-caching.html\");\n    }\n    // start routes\n    if (doNotStartRoutesOnFirstStart) {\n        log.debug(\"Skip starting of routes as CamelContext has been configured with autoStartup=false\");\n    }\n    // invoke this logic to warmup the routes and if possible also start the routes\n    doStartOrResumeRoutes(routeServices, true, !doNotStartRoutesOnFirstStart, false, true);\n// starting will continue in the start method\n}", "code_comment": NaN, "code_no_comment": "private void doStartCamel() throws Exception {\n    if (applicationContextClassLoader == null) {\n                ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if (cl == null) {\n                        cl = this.getClass().getClassLoader();\n        }\n        setApplicationContextClassLoader(cl);\n    }\n    if (log.isDebugEnabled()) {\n        log.debug(\"Using ClassResolver={}, PackageScanClassResolver={}, ApplicationContextClassLoader={}\", new Object[] { getClassResolver(), getPackageScanClassResolver(), getApplicationContextClassLoader() });\n    }\n    if (isStreamCaching()) {\n        log.info(\"StreamCaching is enabled on CamelContext: {}\", getName());\n    }\n    if (isTracing()) {\n                log.info(\"Tracing is enabled on CamelContext: {}\", getName());\n    }\n    if (isUseMDCLogging()) {\n                log.info(\"MDC logging is enabled on CamelContext: {}\", getName());\n    }\n    if (isHandleFault()) {\n                if (HandleFault.getHandleFault(this) == null) {\n            log.info(\"HandleFault is enabled on CamelContext: {}\", getName());\n            addInterceptStrategy(new HandleFault());\n        }\n    }\n    if (getDelayer() != null && getDelayer() > 0) {\n        log.info(\"Delayer is enabled with: {} ms. on CamelContext: {}\", getDelayer(), getName());\n    }\n        if (getDebugger() != null) {\n        log.info(\"Debugger: {} is enabled on CamelContext: {}\", getDebugger(), getName());\n                getDebugger().setCamelContext(this);\n        startService(getDebugger());\n        addInterceptStrategy(new Debug(getDebugger()));\n    }\n        ManagementStrategy managementStrategy = getManagementStrategy();\n        if (managementStrategy instanceof CamelContextAware) {\n        ((CamelContextAware) managementStrategy).setCamelContext(this);\n    }\n    ServiceHelper.startService(managementStrategy);\n        ServiceHelper.startServices(lifecycleStrategies);\n    Iterator<LifecycleStrategy> it = lifecycleStrategies.iterator();\n    while (it.hasNext()) {\n        LifecycleStrategy strategy = it.next();\n        try {\n            strategy.onContextStart(this);\n        } catch (VetoCamelContextStartException e) {\n                        log.warn(\"Lifecycle strategy vetoed starting CamelContext ({}) due {}\", getName(), e.getMessage());\n            throw e;\n        } catch (Exception e) {\n            log.warn(\"Lifecycle strategy \" + strategy + \" failed starting CamelContext ({}) due {}\", getName(), e.getMessage());\n            throw e;\n        }\n    }\n        for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {\n        if (notifier instanceof Service) {\n            Service service = (Service) notifier;\n            for (LifecycleStrategy strategy : lifecycleStrategies) {\n                strategy.onServiceAdd(this, service, null);\n            }\n        }\n        if (notifier instanceof Service) {\n            startService((Service) notifier);\n        }\n    }\n        EventHelper.notifyCamelContextStarting(this);\n    forceLazyInitialization();\n            endpoints = new EndpointRegistry(this, endpoints);\n    addService(endpoints);\n        doAddService(executorServiceManager, false);\n    addService(producerServicePool);\n    addService(inflightRepository);\n    addService(shutdownStrategy);\n    addService(packageScanClassResolver);\n    addService(restRegistry);\n    if (runtimeEndpointRegistry != null) {\n        if (runtimeEndpointRegistry instanceof EventNotifier) {\n            getManagementStrategy().addEventNotifier((EventNotifier) runtimeEndpointRegistry);\n        }\n        addService(runtimeEndpointRegistry);\n    }\n            Component existing = lookupPropertiesComponent();\n    if (existing != null) {\n                if (existing instanceof PropertiesComponent) {\n            propertiesComponent = (PropertiesComponent) existing;\n        } else {\n                        throw new IllegalArgumentException(\"Found properties component of type: \" + existing.getClass() + \" instead of expected: \" + PropertiesComponent.class);\n        }\n    }\n        startServices(components.values());\n        startRouteDefinitions(routeDefinitions);\n        boolean streamCachingInUse = isStreamCaching();\n    if (!streamCachingInUse) {\n        for (RouteDefinition route : routeDefinitions) {\n            Boolean routeCache = CamelContextHelper.parseBoolean(this, route.getStreamCache());\n            if (routeCache != null && routeCache) {\n                streamCachingInUse = true;\n                break;\n            }\n        }\n    }\n    if (isAllowUseOriginalMessage()) {\n        log.info(\"AllowUseOriginalMessage is enabled. If access to the original message is not needed,\" + \" then its recommended to turn this option off as it may improve performance.\");\n    }\n    if (streamCachingInUse) {\n                getStreamCachingStrategy().setEnabled(true);\n        addService(getStreamCachingStrategy());\n    } else {\n                log.info(\"StreamCaching is not in use. If using streams then its recommended to enable stream caching.\" + \" See more details at http://camel.apache.org/stream-caching.html\");\n    }\n        if (doNotStartRoutesOnFirstStart) {\n        log.debug(\"Skip starting of routes as CamelContext has been configured with autoStartup=false\");\n    }\n        doStartOrResumeRoutes(routeServices, true, !doNotStartRoutesOnFirstStart, false, true);\n}", "lc": 4.590909090909091, "pi": 0.18367346938775503, "ma": 4.833333333333333, "nbd": 0.5, "ml": 3.25, "d": 0.8116658428077115, "mi": -1.517063378262117, "fo": 6.666666666666667, "r": -0.028571428571428574, "e": 4.617532047575605}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1364_05c89637", "label": 1, "code": "boolean containsValue(Object value) {\n    for (Segment<K, V> s : segments) {\n        for (K k : s.keySet()) {\n            V v = find(k).value;\n            if (v != null && v.equals(value)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "code_comment": NaN, "code_no_comment": "boolean containsValue(Object value) {\n    for (Segment<K, V> s : segments) {\n        for (K k : s.keySet()) {\n            V v = find(k).value;\n            if (v != null && v.equals(value)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "lc": -0.13636363636363635, "pi": 1.040816326530612, "ma": 0.0, "nbd": 0.5, "ml": 0.0, "d": -0.08996539792387542, "mi": 0.171780900487525, "fo": -0.25, "r": 0.6571428571428571, "e": -0.08800716118228036}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1807_077efee5", "label": 3, "code": "/**\n * Create a simple revision id. The format is similar to MongoDB ObjectId.\n *\n * @param clusterId the unique machineId + processId\n * @return the unique revision id\n */\nstatic Revision newRevision(int clusterId) {\n    long timestamp = getCurrentTimestamp();\n    int c;\n    synchronized (Revision.class) {\n        if (timestamp == lastRevisionTimestamp) {\n            c = ++lastRevisionCount;\n        } else {\n            lastRevisionTimestamp = timestamp;\n            lastRevisionCount = c = 0;\n        }\n    }\n    return new Revision(timestamp, c, clusterId);\n}", "code_comment": "/**\n * Create a simple revision id. The format is similar to MongoDB ObjectId.\n *\n * @param clusterId the unique machineId + processId\n * @return the unique revision id\n */\n", "code_no_comment": "static Revision newRevision(int clusterId) {\n    long timestamp = getCurrentTimestamp();\n    int c;\n    synchronized (Revision.class) {\n        if (timestamp == lastRevisionTimestamp) {\n            c = ++lastRevisionCount;\n        } else {\n            lastRevisionTimestamp = timestamp;\n            lastRevisionCount = c = 0;\n        }\n    }\n    return new Revision(timestamp, c, clusterId);\n}", "lc": -0.045454545454545456, "pi": 0.5204081632653061, "ma": -0.3333333333333333, "nbd": 0.0, "ml": -0.16666666666666666, "d": 0.03460207612456753, "mi": 0.1304846572985374, "fo": -0.4166666666666667, "r": 2.2571428571428576, "e": -0.07103361729648237}
{"project_name": "Cli", "project_version": 9, "label": 1, "code": "/**\n * <p>Throws a {@link MissingOptionException} if all of the\n * required options are no present.</p>\n *\n * @throws MissingOptionException if any of the required Options\n * are not present.\n */\nprotected void checkRequiredOptions() throws MissingOptionException {\n    // processsed\n    if (getRequiredOptions().size() > 0) {\n        Iterator iter = getRequiredOptions().iterator();\n        StringBuffer buff = new StringBuffer(\"Missing required option\");\n        buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n        buff.append(\": \");\n        // loop through the required options\n        while (iter.hasNext()) {\n            buff.append(iter.next());\n        }\n        throw new MissingOptionException(buff.toString());\n    }\n}", "code_comment": "/**\n * <p>Throws a {@link MissingOptionException} if all of the\n * required options are no present.</p>\n *\n * @throws MissingOptionException if any of the required Options\n * are not present.\n */\n", "code_no_comment": "protected void checkRequiredOptions() throws MissingOptionException {\n        if (getRequiredOptions().size() > 0) {\n        Iterator iter = getRequiredOptions().iterator();\n        StringBuffer buff = new StringBuffer(\"Missing required option\");\n        buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n        buff.append(\": \");\n                while (iter.hasNext()) {\n            buff.append(iter.next());\n        }\n        throw new MissingOptionException(buff.toString());\n    }\n}", "lc": -0.09090909090909091, "pi": 0.2193877551020409, "ma": 0.16666666666666666, "nbd": 0.0, "ml": 0.0, "d": -0.054374691052891735, "mi": 0.07628333811299104, "fo": 0.5, "r": 1.3714285714285714, "e": -0.04594806429645238}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-177_f91ce934", "label": 1, "code": "protected void setOutputStream(final OutputStream os) {\n    this.os = os;\n}", "code_comment": NaN, "code_no_comment": "protected void setOutputStream(final OutputStream os) {\n    this.os = os;\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 1.0943504445081733, "fo": -0.5, "r": 2.085714285714286, "e": -0.16422749602751402}
{"project_name": "Math", "project_version": 5, "label": 3, "code": "/**\n * {@inheritDoc}\n */\npublic Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    if (isInfinite) {\n        return ZERO;\n    }\n    if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n        double q = real / imaginary;\n        double scale = 1. / (real * q + imaginary);\n        return createComplex(scale * q, -scale);\n    } else {\n        double q = imaginary / real;\n        double scale = 1. / (imaginary * q + real);\n        return createComplex(scale, -scale * q);\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    if (isInfinite) {\n        return ZERO;\n    }\n    if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n        double q = real / imaginary;\n        double scale = 1. / (real * q + imaginary);\n        return createComplex(scale * q, -scale);\n    } else {\n        double q = imaginary / real;\n        double scale = 1. / (imaginary * q + real);\n        return createComplex(scale, -scale * q);\n    }\n}", "lc": 0.2727272727272727, "pi": -0.20408163265306117, "ma": 0.16666666666666666, "nbd": -0.5, "ml": 0.5, "d": 1.6955017301038064, "mi": -0.24003441353599103, "fo": -0.16666666666666666, "r": 0.4857142857142857, "e": 1.114167748125115}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3618_fbfd17e6", "label": 1, "code": "/**\n *  Writes the content of the buffer to the specified response. Also sets the properties and and\n *  headers.\n *\n *  @param response\n */\npublic void writeTo(final WebResponse response) {\n    Args.notNull(response, \"response\");\n    for (Action action : actions) {\n        action.invoke(response);\n    }\n}", "code_comment": "/**\n *  Writes the content of the buffer to the specified response. Also sets the properties and and\n *  headers.\n *\n *  @param response\n */\n", "code_no_comment": "public void writeTo(final WebResponse response) {\n    Args.notNull(response, \"response\");\n    for (Action action : actions) {\n        action.invoke(response);\n    }\n}", "lc": -0.36363636363636365, "pi": -0.13775510204081634, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.6091195870375681, "fo": -0.3333333333333333, "r": 2.1142857142857143, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4309_b4274415", "label": 1, "code": "/**\n *  Convert to object types, returning null if text is null.\n *\n *  @return converted\n *  @throws StringValueConversionException\n */\npublic final Duration toOptionalDuration() throws StringValueConversionException {\n    return (text == null) ? null : toDuration();\n}", "code_comment": "/**\n *  Convert to object types, returning null if text is null.\n *\n *  @return converted\n *  @throws StringValueConversionException\n */\n", "code_no_comment": "public final Duration toOptionalDuration() throws StringValueConversionException {\n    return (text == null) ? null : toDuration();\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.3333333333333333, "nbd": -1.0, "ml": -0.25, "d": -0.3806228373702422, "mi": 1.012044737596788, "fo": -0.4166666666666667, "r": 2.8285714285714287, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3549_9772f5b2", "label": 1, "code": "/**\n * OAK-2624 : background read operations are split from background update ops\n */\nprivate void internalRunBackgroundReadOperations() {\n    synchronized (backgroundReadMonitor) {\n        long start = clock.getTime();\n        // pull in changes from other cluster nodes\n        BackgroundReadStats readStats = backgroundRead(true);\n        long readTime = clock.getTime() - start;\n        String msg = \"Background read operations stats (read:{} {})\";\n        if (clock.getTime() - start > TimeUnit.SECONDS.toMillis(10)) {\n            // log as info if it took more than 10 seconds\n            LOG.info(msg, readTime, readStats);\n        } else {\n            LOG.debug(msg, readTime, readStats);\n        }\n    }\n}", "code_comment": "/**\n * OAK-2624 : background read operations are split from background update ops\n */\n", "code_no_comment": "private void internalRunBackgroundReadOperations() {\n    synchronized (backgroundReadMonitor) {\n        long start = clock.getTime();\n                BackgroundReadStats readStats = backgroundRead(true);\n        long readTime = clock.getTime() - start;\n        String msg = \"Background read operations stats (read:{} {})\";\n        if (clock.getTime() - start > TimeUnit.SECONDS.toMillis(10)) {\n                        LOG.info(msg, readTime, readStats);\n        } else {\n            LOG.debug(msg, readTime, readStats);\n        }\n    }\n}", "lc": -0.045454545454545456, "pi": 0.31632653061224497, "ma": -0.3333333333333333, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.06030647553138898, "mi": 0.04158302265557795, "fo": 0.08333333333333333, "r": 1.885714285714286, "e": -0.03387427670774066}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-3789_9319e139", "label": 1, "code": "@Override\npublic boolean begin(GenericFileOperations<T> operations, GenericFileEndpoint<T> endpoint, Exchange exchange, GenericFile<T> file) throws Exception {\n    // must invoke super\n    boolean result = super.begin(operations, endpoint, exchange, file);\n    if (!result) {\n        return false;\n    }\n    if (beginRenamer != null) {\n        GenericFile<T> newName = beginRenamer.renameFile(exchange, file);\n        GenericFile<T> to = renameFile(operations, file, newName);\n        if (to != null) {\n            to.bindToExchange(exchange);\n        }\n    }\n    return true;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean begin(GenericFileOperations<T> operations, GenericFileEndpoint<T> endpoint, Exchange exchange, GenericFile<T> file) throws Exception {\n        boolean result = super.begin(operations, endpoint, exchange, file);\n    if (!result) {\n        return false;\n    }\n    if (beginRenamer != null) {\n        GenericFile<T> newName = beginRenamer.renameFile(exchange, file);\n        GenericFile<T> to = renameFile(operations, file, newName);\n        if (to != null) {\n            to.bindToExchange(exchange);\n        }\n    }\n    return true;\n}", "lc": 0.045454545454545456, "pi": 0.19897959183673475, "ma": 0.0, "nbd": 0.0, "ml": 0.08333333333333333, "d": 0.024715768660405344, "mi": -0.07255520504731866, "fo": -0.16666666666666666, "r": -0.028571428571428574, "e": 0.04325833793756237}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3396_c83755c3", "label": 0, "code": "@Nonnull\nprivate ExternalGroup createGroup(@Nonnull Entry entry, @CheckForNull String name) throws LdapInvalidAttributeValueException {\n    ExternalIdentityRef ref = new ExternalIdentityRef(entry.getDn().getName(), this.getName());\n    if (name == null) {\n        name = entry.get(config.getGroupConfig().getIdAttribute()).getString();\n    }\n    String path = config.getGroupConfig().makeDnPath() ? createDNPath(entry.getDn()) : null;\n    LdapGroup group = new LdapGroup(this, ref, name, path);\n    Map<String, Object> props = group.getProperties();\n    applyAttributes(props, entry);\n    return group;\n}", "code_comment": NaN, "code_no_comment": "@Nonnull\nprivate ExternalGroup createGroup(@Nonnull Entry entry, @CheckForNull String name) throws LdapInvalidAttributeValueException {\n    ExternalIdentityRef ref = new ExternalIdentityRef(entry.getDn().getName(), this.getName());\n    if (name == null) {\n        name = entry.get(config.getGroupConfig().getIdAttribute()).getString();\n    }\n    String path = config.getGroupConfig().makeDnPath() ? createDNPath(entry.getDn()) : null;\n    LdapGroup group = new LdapGroup(this, ref, name, path);\n    Map<String, Object> props = group.getProperties();\n    applyAttributes(props, entry);\n    return group;\n}", "lc": -0.09090909090909091, "pi": -0.413265306122449, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.0385565991102323, "mi": 0.007456266131344737, "fo": 0.5833333333333334, "r": -0.028571428571428574, "e": 0.05106625378510458}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2624_ef880545", "label": 1, "code": "/**\n *  @param object\n *  @param value\n *  @param converter\n */\npublic final void setValue(final Object object, final Object value, PropertyResolverConverter converter) {\n    Class type = null;\n    if (setMethod != null) {\n        type = getMethod.getReturnType();\n    } else if (field != null) {\n        type = field.getType();\n    }\n    Object converted = null;\n    if (type != null) {\n        converted = converter.convert(value, getMethod.getReturnType());\n        if (converted == null) {\n            if (value != null) {\n                throw new ConversionException(\"Can't convert value: \" + value + \" to class: \" + getMethod.getReturnType() + \" for setting it on \" + object);\n            } else if (getMethod.getReturnType().isPrimitive()) {\n                throw new ConversionException(\"Can't convert null value to a primitive class: \" + getMethod.getReturnType() + \" for setting it on \" + object);\n            }\n        }\n    }\n    if (setMethod != null) {\n        try {\n            setMethod.invoke(object, new Object[] { converted });\n        } catch (InvocationTargetException ex) {\n            throw new WicketRuntimeException(\"Error calling method: \" + setMethod + \" on object: \" + object, ex.getCause());\n        } catch (Exception ex) {\n            throw new WicketRuntimeException(\"Error calling method: \" + setMethod + \" on object: \" + object, ex);\n        }\n    } else if (field != null) {\n        try {\n            field.set(object, converted);\n        } catch (Exception ex) {\n            throw new WicketRuntimeException(\"Error setting field: \" + field + \" on object: \" + object, ex);\n        }\n    } else {\n        throw new WicketRuntimeException(\"no set method defined for value: \" + value + \" on object: \" + object + \" while respective getMethod being \" + getMethod.getName());\n    }\n}", "code_comment": "/**\n *  @param object\n *  @param value\n *  @param converter\n */\n", "code_no_comment": "public final void setValue(final Object object, final Object value, PropertyResolverConverter converter) {\n    Class type = null;\n    if (setMethod != null) {\n        type = getMethod.getReturnType();\n    } else if (field != null) {\n        type = field.getType();\n    }\n    Object converted = null;\n    if (type != null) {\n        converted = converter.convert(value, getMethod.getReturnType());\n        if (converted == null) {\n            if (value != null) {\n                throw new ConversionException(\"Can't convert value: \" + value + \" to class: \" + getMethod.getReturnType() + \" for setting it on \" + object);\n            } else if (getMethod.getReturnType().isPrimitive()) {\n                throw new ConversionException(\"Can't convert null value to a primitive class: \" + getMethod.getReturnType() + \" for setting it on \" + object);\n            }\n        }\n    }\n    if (setMethod != null) {\n        try {\n            setMethod.invoke(object, new Object[] { converted });\n        } catch (InvocationTargetException ex) {\n            throw new WicketRuntimeException(\"Error calling method: \" + setMethod + \" on object: \" + object, ex.getCause());\n        } catch (Exception ex) {\n            throw new WicketRuntimeException(\"Error calling method: \" + setMethod + \" on object: \" + object, ex);\n        }\n    } else if (field != null) {\n        try {\n            field.set(object, converted);\n        } catch (Exception ex) {\n            throw new WicketRuntimeException(\"Error setting field: \" + field + \" on object: \" + object, ex);\n        }\n    } else {\n        throw new WicketRuntimeException(\"no set method defined for value: \" + value + \" on object: \" + object + \" while respective getMethod being \" + getMethod.getName());\n    }\n}", "lc": 1.0, "pi": 0.46428571428571436, "ma": 2.3333333333333335, "nbd": 1.0, "ml": 0.75, "d": 0.7068709836875928, "mi": -0.71580154860912, "fo": 0.5, "r": -0.028571428571428574, "e": 1.302555668341321}
{"project_name": "Math", "project_version": 29, "label": 1, "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic OpenMapRealVector ebeDivide(RealVector v) {\n    checkVectorDimensions(v.getDimension());\n    OpenMapRealVector res = new OpenMapRealVector(this);\n    /*\n         * MATH-803: it is not sufficient to loop through non zero entries of\n         * this only. Indeed, if this[i] = 0d and v[i] = 0d, then\n         * this[i] / v[i] = NaN, and not 0d.\n         */\n    Iterator iter = entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n    }\n    return res;\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\npublic OpenMapRealVector ebeDivide(RealVector v) {\n    checkVectorDimensions(v.getDimension());\n    OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n    }\n    return res;\n}", "lc": -0.13636363636363635, "pi": -0.17857142857142863, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.05832921403855659, "mi": 0.15342701462575267, "fo": 0.3333333333333333, "r": 0.5428571428571429, "e": -0.05986782650408384}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4398_f88721fd", "label": 1, "code": "/**\n *  @param qp\n *  @param charset\n *  @return query parameters\n */\nprivate static QueryParameter parseQueryParameter(final String qp, final Charset charset) {\n    if (qp.indexOf('=') == -1) {\n        return new QueryParameter(decodeParameter(qp, charset), \"\");\n    }\n    String[] parts = Strings.split(qp, '=');\n    if (parts.length == 0) {\n        return new QueryParameter(\"\", \"\");\n    } else if (parts.length == 1) {\n        return new QueryParameter(\"\", decodeParameter(parts[0], charset));\n    } else {\n        return new QueryParameter(decodeParameter(parts[0], charset), decodeParameter(parts[1], charset));\n    }\n}", "code_comment": "/**\n *  @param qp\n *  @param charset\n *  @return query parameters\n */\n", "code_no_comment": "private static QueryParameter parseQueryParameter(final String qp, final Charset charset) {\n    if (qp.indexOf('=') == -1) {\n        return new QueryParameter(decodeParameter(qp, charset), \"\");\n    }\n    String[] parts = Strings.split(qp, '=');\n    if (parts.length == 0) {\n        return new QueryParameter(\"\", \"\");\n    } else if (parts.length == 1) {\n        return new QueryParameter(\"\", decodeParameter(parts[0], charset));\n    } else {\n        return new QueryParameter(decodeParameter(parts[0], charset), decodeParameter(parts[1], charset));\n    }\n}", "lc": -0.045454545454545456, "pi": -0.1887755102040817, "ma": 0.0, "nbd": 0.0, "ml": 0.0, "d": 0.1552150271873456, "mi": 0.004588471465442978, "fo": 0.0, "r": 0.028571428571428574, "e": 0.09122369700318225}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-5701_087c0a26", "label": 1, "code": "@Override\npublic void run() {\n    if (pageId != NO_PAGE_ID) {\n        page.send(application, Broadcast.BREADTH, payload);\n    } else {\n        ResourceReference reference = new SharedResourceReference(resourceName);\n        IResource resource = reference.getResource();\n        if (resource instanceof WebSocketResource) {\n            WebSocketResource wsResource = (WebSocketResource) resource;\n            wsResource.onPayload(payload);\n        } else {\n            throw new IllegalStateException(String.format(\"Shared resource with name '%s' is not a %s but %s\", resourceName, WebSocketResource.class.getSimpleName(), Classes.name(resource.getClass())));\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void run() {\n    if (pageId != NO_PAGE_ID) {\n        page.send(application, Broadcast.BREADTH, payload);\n    } else {\n        ResourceReference reference = new SharedResourceReference(resourceName);\n        IResource resource = reference.getResource();\n        if (resource instanceof WebSocketResource) {\n            WebSocketResource wsResource = (WebSocketResource) resource;\n            wsResource.onPayload(payload);\n        } else {\n            throw new IllegalStateException(String.format(\"Shared resource with name '%s' is not a %s but %s\", resourceName, WebSocketResource.class.getSimpleName(), Classes.name(resource.getClass())));\n        }\n    }\n}", "lc": 0.045454545454545456, "pi": 0.5408163265306123, "ma": 0.0, "nbd": 0.0, "ml": -0.08333333333333333, "d": -0.11566979733069695, "mi": -0.05678233438485818, "fo": 0.08333333333333333, "r": -0.028571428571428574, "e": -0.04152372141630368}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5515_b3bb8670", "label": 1, "code": "/**\n * Continues processing the {@link org.apache.camel.Exchange} using asynchronous routing engine.\n *\n * @param poolSize    the core pool size\n * @param maxPoolSize the maximum pool size\n * @param threadName the thread pool name\n * @return the builder\n */\npublic ThreadsDefinition threads(int poolSize, int maxPoolSize, String threadName) {\n    ThreadsDefinition answer = threads();\n    answer.setPoolSize(poolSize);\n    answer.setMaxPoolSize(maxPoolSize);\n    answer.setThreadName(threadName);\n    addOutput(answer);\n    return answer;\n}", "code_comment": "/**\n * Continues processing the {@link org.apache.camel.Exchange} using asynchronous routing engine.\n *\n * @param poolSize    the core pool size\n * @param maxPoolSize the maximum pool size\n * @param threadName the thread pool name\n * @return the builder\n */\n", "code_no_comment": "public ThreadsDefinition threads(int poolSize, int maxPoolSize, String threadName) {\n    ThreadsDefinition answer = threads();\n    answer.setPoolSize(poolSize);\n    answer.setMaxPoolSize(maxPoolSize);\n    answer.setThreadName(threadName);\n    addOutput(answer);\n    return answer;\n}", "lc": -0.2727272727272727, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.3917407513622025, "fo": -0.08333333333333333, "r": 1.6285714285714286, "e": -0.16422749602751402}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2294_fef9f115", "label": 0, "code": "@Override\npublic void collect(T record) {\n    try {\n        operator.processElement(serializer.copy(record));\n    } catch (Exception e) {\n        if (LOG.isErrorEnabled()) {\n            LOG.error(\"Could not forward element to operator.\", e);\n        }\n        throw new RuntimeException(e);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void collect(T record) {\n    try {\n        operator.processElement(serializer.copy(record));\n    } catch (Exception e) {\n        if (LOG.isErrorEnabled()) {\n            LOG.error(\"Could not forward element to operator.\", e);\n        }\n        throw new RuntimeException(e);\n    }\n}", "lc": -0.13636363636363635, "pi": 0.42346938775510207, "ma": 0.0, "nbd": 0.0, "ml": -0.25, "d": -0.3806228373702422, "mi": 0.23343848580441648, "fo": -0.16666666666666666, "r": 0.4857142857142857, "e": -0.16422749602751402}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-6447_020c451a", "label": 1, "code": "public void done(boolean doneSync) {\n    // we only have to handle async completion of the pipeline\n    if (doneSync) {\n        return;\n    }\n    // continue processing the pipeline asynchronously\n    while (continueRouting(processors, exchange)) {\n        AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());\n        // check for error if so we should break out\n        if (!continueProcessing(exchange, \"so breaking out of pipeline\", LOG)) {\n            break;\n        }\n        doneSync = process(exchange, callback, processors, processor);\n        if (!doneSync) {\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n            return;\n        }\n    }\n    LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n    callback.done(false);\n}", "code_comment": NaN, "code_no_comment": "public void done(boolean doneSync) {\n        if (doneSync) {\n        return;\n    }\n        while (continueRouting(processors, exchange)) {\n        AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());\n                if (!continueProcessing(exchange, \"so breaking out of pipeline\", LOG)) {\n            break;\n        }\n        doneSync = process(exchange, callback, processors, processor);\n        if (!doneSync) {\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n            return;\n        }\n    }\n    LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n    callback.done(false);\n}", "lc": 0.18181818181818182, "pi": 0.2755102040816327, "ma": 0.3333333333333333, "nbd": 0.0, "ml": 0.3333333333333333, "d": -0.02273850716757287, "mi": -0.13765414396329217, "fo": 0.3333333333333333, "r": -0.028571428571428574, "e": -0.01698210989331037}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3530_4d231938", "label": 1, "code": "public int getType(Tree tree) {\n    if (tree.isRoot()) {\n        return TYPE_DEFAULT;\n    } else {\n        return getType(tree, getType(tree.getParent()));\n    }\n}", "code_comment": NaN, "code_no_comment": "public int getType(Tree tree) {\n    if (tree.isRoot()) {\n        return TYPE_DEFAULT;\n    } else {\n        return getType(tree, getType(tree.getParent()));\n    }\n}", "lc": -0.3181818181818182, "pi": 0.0, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.3806228373702422, "mi": 0.5856036707771726, "fo": -0.16666666666666666, "r": 0.4285714285714286, "e": -0.16422749602751402}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-1025_a96b455c", "label": 1, "code": "/*\n     * TODO consider making public.\n     */\nprivate void mapJulToLog4j(java.util.logging.Level julLevel, Level level) {\n    julToLog4j.put(julLevel, level);\n}", "code_comment": NaN, "code_no_comment": "private void mapJulToLog4j(java.util.logging.Level julLevel, Level level) {\n    julToLog4j.put(julLevel, level);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9486664754803554, "fo": -0.4166666666666667, "r": 2.4, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-349_4cc9a49d", "label": 3, "code": "/**\n * Set the Poisson mean for the distribution. The mean value must be\n * positive; otherwise an <code>IllegalArgument</code> is thrown.\n *\n * @param p the Poisson mean value\n * @throws IllegalArgumentException if p &le; 0\n * @deprecated as of 2.1 (class will become immutable in 3.0)\n */\n@Deprecated\npublic void setMean(double p) {\n    setNormalAndMeanInternal(normal, p);\n}", "code_comment": "/**\n * Set the Poisson mean for the distribution. The mean value must be\n * positive; otherwise an <code>IllegalArgument</code> is thrown.\n *\n * @param p the Poisson mean value\n * @throws IllegalArgumentException if p &le; 0\n * @deprecated as of 2.1 (class will become immutable in 3.0)\n */\n", "code_no_comment": "@Deprecated\npublic void setMean(double p) {\n    setNormalAndMeanInternal(normal, p);\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9446515629480932, "fo": -0.4166666666666667, "r": 2.685714285714286, "e": -0.16422749602751402}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2528_239de7b8", "label": 1, "code": "private List<UpdateOp> create() {\n    if (!considerSplit()) {\n        return Collections.emptyList();\n    }\n    splitOps = Lists.newArrayList();\n    mostRecentRevs = Sets.newHashSet();\n    splitRevs = Sets.newHashSet();\n    garbage = Maps.newHashMap();\n    committedChanges = getCommittedLocalChanges();\n    // revisions of the most recent committed changes on this document\n    // these are kept in the main document. _revisions and _commitRoot\n    // entries with these revisions are retained in the main document\n    populateSplitRevs();\n    // collect _revisions and _commitRoot entries for split document\n    collectRevisionsAndCommitRoot();\n    // create split ops out of the split values\n    main = createSplitOps();\n    // create intermediate docs if needed\n    createIntermediateDocs();\n    // remove stale references to previous docs\n    disconnectStalePrevDocs();\n    // remove garbage\n    removeGarbage();\n    // main document must be updated last\n    if (main != null) {\n        splitOps.add(main);\n    }\n    return splitOps;\n}", "code_comment": NaN, "code_no_comment": "private List<UpdateOp> create() {\n    if (!considerSplit()) {\n        return Collections.emptyList();\n    }\n    splitOps = Lists.newArrayList();\n    mostRecentRevs = Sets.newHashSet();\n    splitRevs = Sets.newHashSet();\n    garbage = Maps.newHashMap();\n    committedChanges = getCommittedLocalChanges();\n                populateSplitRevs();\n        collectRevisionsAndCommitRoot();\n        main = createSplitOps();\n        createIntermediateDocs();\n        disconnectStalePrevDocs();\n        removeGarbage();\n        if (main != null) {\n        splitOps.add(main);\n    }\n    return splitOps;\n}", "lc": 0.2727272727272727, "pi": -0.6275510204081632, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.08333333333333333, "d": -0.14137419673751853, "mi": -0.18038428448523108, "fo": 0.6666666666666666, "r": 0.20000000000000004, "e": -0.05601312312350898}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3620_1a2bc1bc", "label": 1, "code": "@Override\nprotected void invoke(WebResponse response) {\n    AppendingStringBuffer responseBuffer = new AppendingStringBuffer(builder);\n    List<IResponseFilter> responseFilters = Application.get().getRequestCycleSettings().getResponseFilters();\n    if (responseFilters != null) {\n        for (IResponseFilter filter : responseFilters) {\n            filter.filter(responseBuffer);\n        }\n    }\n    response.write(builder);\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected void invoke(WebResponse response) {\n    AppendingStringBuffer responseBuffer = new AppendingStringBuffer(builder);\n    List<IResponseFilter> responseFilters = Application.get().getRequestCycleSettings().getResponseFilters();\n    if (responseFilters != null) {\n        for (IResponseFilter filter : responseFilters) {\n            filter.filter(responseBuffer);\n        }\n    }\n    response.write(builder);\n}", "lc": -0.13636363636363635, "pi": 0.2959183673469388, "ma": -0.16666666666666666, "nbd": 0.0, "ml": -0.25, "d": -0.08403361344537813, "mi": 0.16805276742185263, "fo": -0.08333333333333333, "r": 0.1142857142857143, "e": -0.08092735597329119}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7", "label": 3, "code": "@Override\npublic void write(org.apache.thrift.protocol.TProtocol prot, removeConstraint_result struct) throws org.apache.thrift.TException {\n    TTupleProtocol oprot = (TTupleProtocol) prot;\n    BitSet optionals = new BitSet();\n    if (struct.isSetOuch1()) {\n        optionals.set(0);\n    }\n    if (struct.isSetOuch2()) {\n        optionals.set(1);\n    }\n    oprot.writeBitSet(optionals, 2);\n    if (struct.isSetOuch1()) {\n        struct.ouch1.write(oprot);\n    }\n    if (struct.isSetOuch2()) {\n        struct.ouch2.write(oprot);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void write(org.apache.thrift.protocol.TProtocol prot, removeConstraint_result struct) throws org.apache.thrift.TException {\n    TTupleProtocol oprot = (TTupleProtocol) prot;\n    BitSet optionals = new BitSet();\n    if (struct.isSetOuch1()) {\n        optionals.set(0);\n    }\n    if (struct.isSetOuch2()) {\n        optionals.set(1);\n    }\n    oprot.writeBitSet(optionals, 2);\n    if (struct.isSetOuch1()) {\n        struct.ouch1.write(oprot);\n    }\n    if (struct.isSetOuch2()) {\n        struct.ouch2.write(oprot);\n    }\n}", "lc": 0.18181818181818182, "pi": -0.2755102040816327, "ma": 0.16666666666666666, "nbd": -0.5, "ml": 0.08333333333333333, "d": -0.3806228373702422, "mi": -0.16260395755663903, "fo": 0.25, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4173_84bbbf68", "label": 1, "code": "/*\n\t * TODO: simplify the code below. See WICKET-3347\n\t */\n@Override\npublic void respond(RequestCycle requestCycle) {\n    Url currentUrl = requestCycle.getUrlRenderer().getBaseUrl();\n    Url targetUrl = requestCycle.mapUrlFor(getRenderPageRequestHandler());\n    // \n    // the code below is little hairy but we have to handle 3 redirect policies,\n    // 3 rendering strategies and two kind of requests (ajax and normal)\n    // \n    // try to get an already rendered buffered response for current URL\n    BufferedWebResponse bufferedResponse = getAndRemoveBufferedResponse(currentUrl);\n    boolean isAjax = isAjax(requestCycle);\n    boolean shouldPreserveClientUrl = ((WebRequest) requestCycle.getRequest()).shouldPreserveClientUrl();\n    if (bufferedResponse != null) {\n        logger.warn(\"The Buffered response should be handled by BufferedResponseRequestHandler\");\n        // if there is saved response for this URL render it\n        bufferedResponse.writeTo((WebResponse) requestCycle.getResponse());\n    } else if (getRedirectPolicy() == RedirectPolicy.NEVER_REDIRECT || // \n    (isOnePassRender() && isAjax == false) || (// \n    !isAjax && // \n    (targetUrl.equals(currentUrl) && !getPageProvider().isNewPageInstance() && !getPage().isPageStateless()) || // \n    (targetUrl.equals(currentUrl) && isRedirectToRender())) || // \n    shouldPreserveClientUrl) {\n        // if the policy is never to redirect\n        // or one pass render mode is on\n        // or the targetUrl matches current url and the page is not stateless\n        // or the targetUrl matches current url, page is stateless but it's redirect-to-render\n        // or the request determines that the current url should be preserved\n        // just render the page\n        BufferedWebResponse response = renderPage(currentUrl, requestCycle);\n        if (response != null) {\n            response.writeTo((WebResponse) requestCycle.getResponse());\n        }\n    } else if (// \n    getRedirectPolicy() == RedirectPolicy.ALWAYS_REDIRECT || // \n    isRedirectToRender() || (isAjax && targetUrl.equals(currentUrl))) {\n        // if target URL is different\n        // and render policy is always-redirect or it's redirect-to-render\n        redirectTo(targetUrl, requestCycle);\n    } else if (// \n    !targetUrl.equals(currentUrl) && (getPageProvider().isNewPageInstance() || (isSessionTemporary() && getPage().isPageStateless()))) {\n        // if target URL is different and session is temporary and page is stateless\n        // this is special case when page is stateless but there is no session so we can't\n        // render it to buffer\n        // alternatively if URLs are different and we have a page class and not an instance we\n        // can redirect to the url which will instantiate the instance of us\n        // note: if we had session here we would render the page to buffer and then redirect to\n        // URL generated *after* page has been rendered (the statelessness may change during\n        // render). this would save one redirect because now we have to render to URL generated\n        // *before* page is rendered, render the page, get URL after render and if the URL is\n        // different (meaning page is not stateless), save the buffer and redirect again (which\n        // is pretty much what the next step does)\n        redirectTo(targetUrl, requestCycle);\n    } else {\n        if (isRedirectToBuffer() == false && logger.isWarnEnabled()) {\n            logger.warn(\"Falling back to Redirect_To_Buffer render strategy because none of the conditions matched.\");\n        }\n        // redirect to buffer\n        BufferedWebResponse response = renderPage(targetUrl, requestCycle);\n        if (response == null) {\n            return;\n        }\n        // check if the url hasn't changed after page has been rendered\n        // (i.e. the stateless flag might have changed which could result in different page url)\n        Url targetUrl2 = requestCycle.mapUrlFor(getRenderPageRequestHandler());\n        if (targetUrl.getSegments().equals(targetUrl2.getSegments()) == false) {\n            // the amount of segments is different - generated relative URLs will not work, we\n            // need to rerender the page. This shouldn't happen, but in theory it can - with\n            // RequestHandlerEncoders that produce different URLs with different amount of\n            // segments for stateless and stateful pages\n            response = renderPage(targetUrl2, requestCycle);\n        }\n        if (currentUrl.equals(targetUrl2)) {\n            // no need to redirect when both urls are exactly the same\n            response.writeTo((WebResponse) requestCycle.getResponse());\n        } else // if page is still stateless after render\n        if (getPage().isPageStateless() && !enableRedirectForStatelessPage()) {\n            // we don't want the redirect to happen for stateless page\n            // example:\n            // when a normal mounted stateful page is hit at /mount/point\n            // wicket renders the page to buffer and redirects to /mount/point?12\n            // but for stateless page the redirect is not necessary\n            // also for listener interface on stateful page we want to redirect\n            // after the listener is invoked, but on stateless page the user\n            // must ask for redirect explicitly\n            response.writeTo((WebResponse) requestCycle.getResponse());\n        } else {\n            storeBufferedResponse(targetUrl2, response);\n            redirectTo(targetUrl2, requestCycle);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void respond(RequestCycle requestCycle) {\n    Url currentUrl = requestCycle.getUrlRenderer().getBaseUrl();\n    Url targetUrl = requestCycle.mapUrlFor(getRenderPageRequestHandler());\n                        BufferedWebResponse bufferedResponse = getAndRemoveBufferedResponse(currentUrl);\n    boolean isAjax = isAjax(requestCycle);\n    boolean shouldPreserveClientUrl = ((WebRequest) requestCycle.getRequest()).shouldPreserveClientUrl();\n    if (bufferedResponse != null) {\n        logger.warn(\"The Buffered response should be handled by BufferedResponseRequestHandler\");\n                bufferedResponse.writeTo((WebResponse) requestCycle.getResponse());\n    } else if (getRedirectPolicy() == RedirectPolicy.NEVER_REDIRECT ||     (isOnePassRender() && isAjax == false) || (    !isAjax &&     (targetUrl.equals(currentUrl) && !getPageProvider().isNewPageInstance() && !getPage().isPageStateless()) ||     (targetUrl.equals(currentUrl) && isRedirectToRender())) ||     shouldPreserveClientUrl) {\n                                                        BufferedWebResponse response = renderPage(currentUrl, requestCycle);\n        if (response != null) {\n            response.writeTo((WebResponse) requestCycle.getResponse());\n        }\n    } else if (    getRedirectPolicy() == RedirectPolicy.ALWAYS_REDIRECT ||     isRedirectToRender() || (isAjax && targetUrl.equals(currentUrl))) {\n                        redirectTo(targetUrl, requestCycle);\n    } else if (    !targetUrl.equals(currentUrl) && (getPageProvider().isNewPageInstance() || (isSessionTemporary() && getPage().isPageStateless()))) {\n                                                                                                redirectTo(targetUrl, requestCycle);\n    } else {\n        if (isRedirectToBuffer() == false && logger.isWarnEnabled()) {\n            logger.warn(\"Falling back to Redirect_To_Buffer render strategy because none of the conditions matched.\");\n        }\n                BufferedWebResponse response = renderPage(targetUrl, requestCycle);\n        if (response == null) {\n            return;\n        }\n                        Url targetUrl2 = requestCycle.mapUrlFor(getRenderPageRequestHandler());\n        if (targetUrl.getSegments().equals(targetUrl2.getSegments()) == false) {\n                                                            response = renderPage(targetUrl2, requestCycle);\n        }\n        if (currentUrl.equals(targetUrl2)) {\n                        response.writeTo((WebResponse) requestCycle.getResponse());\n        } else         if (getPage().isPageStateless() && !enableRedirectForStatelessPage()) {\n                                                                                                            response.writeTo((WebResponse) requestCycle.getResponse());\n        } else {\n            storeBufferedResponse(targetUrl2, response);\n            redirectTo(targetUrl2, requestCycle);\n        }\n    }\n}", "lc": 1.6363636363636365, "pi": 0.12244897959183662, "ma": 1.1666666666666667, "nbd": 2.0, "ml": 3.4166666666666665, "d": 1.3257538309441428, "mi": -0.8979065098938919, "fo": 4.0, "r": -0.028571428571428574, "e": 3.6620453056137334}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2336_d0f6715d", "label": 1, "code": "/**\n * Returns a {@link DocumentNodeState} as seen at the given\n * <code>readRevision</code>.\n *\n * @param nodeStore    the node store.\n * @param readRevision the read revision.\n * @param lastModified the revision when this node was last modified, but\n *                     the value is potentially not yet reflected in this\n *                     document.\n *                     See {@link RevisionContext#getPendingModifications()}.\n * @return the node or <code>null</code> if the node doesn't exist at the\n *         given read revision.\n */\n@CheckForNull\npublic DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore, @Nonnull Revision readRevision, @Nullable Revision lastModified) {\n    Map<Revision, String> validRevisions = Maps.newHashMap();\n    Branch branch = nodeStore.getBranches().getBranch(readRevision);\n    LastRevs lastRevs = new LastRevs(getLastRev(), readRevision, branch);\n    // overlay with unsaved last modified from this instance\n    lastRevs.update(lastModified);\n    Revision min = getLiveRevision(nodeStore, readRevision, validRevisions, lastRevs);\n    if (min == null) {\n        // deleted\n        return null;\n    }\n    String path = getPath();\n    DocumentNodeState n = new DocumentNodeState(nodeStore, path, readRevision, hasChildren());\n    Revision lastRevision = min;\n    for (String key : keySet()) {\n        if (!Utils.isPropertyName(key)) {\n            continue;\n        }\n        // first check local map, which contains most recent values\n        Value value = getLatestValue(nodeStore, getLocalMap(key), min, readRevision, validRevisions, lastRevs);\n        // check if there may be more recent values in a previous document\n        if (value != null && !getPreviousRanges().isEmpty()) {\n            Revision newest = getLocalMap(key).firstKey();\n            if (!value.revision.equals(newest)) {\n                // not reading the most recent value, we may need to\n                // consider previous documents as well\n                Revision newestPrev = getPreviousRanges().firstKey();\n                if (isRevisionNewer(nodeStore, newestPrev, value.revision)) {\n                    // a previous document has more recent changes\n                    // than value.revision\n                    value = null;\n                }\n            }\n        }\n        if (value == null && !getPreviousRanges().isEmpty()) {\n            // check complete revision history\n            value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions, lastRevs);\n        }\n        String propertyName = Utils.unescapePropertyName(key);\n        String v = value != null ? value.value : null;\n        n.setProperty(propertyName, v);\n        // keep track of when this node was last modified\n        if (value != null && isRevisionNewer(nodeStore, value.revision, lastRevision)) {\n            lastRevision = value.revision;\n        }\n    }\n    // lastRevision now points to the revision when this node was\n    // last modified directly. but it may also have been 'modified'\n    // by an operation on a descendant node, which is tracked in\n    // _lastRev.\n    // when was this node last modified?\n    Revision branchBase = null;\n    if (branch != null) {\n        branchBase = branch.getBase(readRevision);\n    }\n    for (Revision r : lastRevs.get().values()) {\n        // ignore if newer than readRevision\n        if (isRevisionNewer(nodeStore, r, readRevision)) {\n            // the node has a _lastRev which is newer than readRevision\n            // this means we don't know when this node was\n            // modified by an operation on a descendant node between\n            // current lastRevision and readRevision. therefore we have\n            // to stay on the safe side and use readRevision\n            lastRevision = readRevision;\n            continue;\n        } else if (branchBase != null && isRevisionNewer(nodeStore, r, branchBase)) {\n            // readRevision is on a branch and the node has a\n            // _lastRev which is newer than the base of the branch\n            // we cannot use this _lastRev because it is not visible\n            // from this branch. highest possible revision of visible\n            // changes is the base of the branch\n            r = branchBase;\n        }\n        if (revisionAreAmbiguous(nodeStore, r, lastRevision)) {\n            // _lastRev entries from multiple cluster nodes are ambiguous\n            // use readRevision to make sure read is consistent\n            lastRevision = readRevision;\n        } else if (isRevisionNewer(nodeStore, r, lastRevision)) {\n            lastRevision = r;\n        }\n    }\n    if (branch != null) {\n        // read from a branch\n        // -> possibly overlay with unsaved last revs from branch\n        lastRevs.updateBranch(branch.getUnsavedLastRevision(path, readRevision));\n        Revision r = lastRevs.getBranchRevision();\n        if (r != null) {\n            lastRevision = r;\n        }\n    }\n    n.setLastRevision(lastRevision);\n    return n;\n}", "code_comment": "/**\n * Returns a {@link DocumentNodeState} as seen at the given\n * <code>readRevision</code>.\n *\n * @param nodeStore    the node store.\n * @param readRevision the read revision.\n * @param lastModified the revision when this node was last modified, but\n *                     the value is potentially not yet reflected in this\n *                     document.\n *                     See {@link RevisionContext#getPendingModifications()}.\n * @return the node or <code>null</code> if the node doesn't exist at the\n *         given read revision.\n */\n", "code_no_comment": "@CheckForNull\npublic DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore, @Nonnull Revision readRevision, @Nullable Revision lastModified) {\n    Map<Revision, String> validRevisions = Maps.newHashMap();\n    Branch branch = nodeStore.getBranches().getBranch(readRevision);\n    LastRevs lastRevs = new LastRevs(getLastRev(), readRevision, branch);\n        lastRevs.update(lastModified);\n    Revision min = getLiveRevision(nodeStore, readRevision, validRevisions, lastRevs);\n    if (min == null) {\n                return null;\n    }\n    String path = getPath();\n    DocumentNodeState n = new DocumentNodeState(nodeStore, path, readRevision, hasChildren());\n    Revision lastRevision = min;\n    for (String key : keySet()) {\n        if (!Utils.isPropertyName(key)) {\n            continue;\n        }\n                Value value = getLatestValue(nodeStore, getLocalMap(key), min, readRevision, validRevisions, lastRevs);\n                if (value != null && !getPreviousRanges().isEmpty()) {\n            Revision newest = getLocalMap(key).firstKey();\n            if (!value.revision.equals(newest)) {\n                                                Revision newestPrev = getPreviousRanges().firstKey();\n                if (isRevisionNewer(nodeStore, newestPrev, value.revision)) {\n                                                            value = null;\n                }\n            }\n        }\n        if (value == null && !getPreviousRanges().isEmpty()) {\n                        value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions, lastRevs);\n        }\n        String propertyName = Utils.unescapePropertyName(key);\n        String v = value != null ? value.value : null;\n        n.setProperty(propertyName, v);\n                if (value != null && isRevisionNewer(nodeStore, value.revision, lastRevision)) {\n            lastRevision = value.revision;\n        }\n    }\n                        Revision branchBase = null;\n    if (branch != null) {\n        branchBase = branch.getBase(readRevision);\n    }\n    for (Revision r : lastRevs.get().values()) {\n                if (isRevisionNewer(nodeStore, r, readRevision)) {\n                                                                        lastRevision = readRevision;\n            continue;\n        } else if (branchBase != null && isRevisionNewer(nodeStore, r, branchBase)) {\n                                                                        r = branchBase;\n        }\n        if (revisionAreAmbiguous(nodeStore, r, lastRevision)) {\n                                    lastRevision = readRevision;\n        } else if (isRevisionNewer(nodeStore, r, lastRevision)) {\n            lastRevision = r;\n        }\n    }\n    if (branch != null) {\n                        lastRevs.updateBranch(branch.getUnsavedLastRevision(path, readRevision));\n        Revision r = lastRevs.getBranchRevision();\n        if (r != null) {\n            lastRevision = r;\n        }\n    }\n    n.setLastRevision(lastRevision);\n    return n;\n}", "lc": 2.272727272727273, "pi": 0.5204081632653061, "ma": 2.6666666666666665, "nbd": 1.0, "ml": 2.9166666666666665, "d": 0.8492338111715275, "mi": -1.1210209349010616, "fo": 2.6666666666666665, "r": -0.028571428571428574, "e": 3.6643923916721275}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-5003_a7d9b689", "label": 1, "code": "public synchronized void setupPluginRealm(PluginDescriptor pluginDescriptor, MavenSession session, ClassLoader parent, List<String> imports, DependencyFilter filter) throws PluginResolutionException, PluginContainerException {\n    Plugin plugin = pluginDescriptor.getPlugin();\n    MavenProject project = session.getCurrentProject();\n    Map<String, ClassLoader> foreignImports = calcImports(project, parent, imports);\n    PluginRealmCache.Key cacheKey = pluginRealmCache.createKey(plugin, parent, foreignImports, filter, project.getRemotePluginRepositories(), session.getRepositorySession());\n    PluginRealmCache.CacheRecord cacheRecord = pluginRealmCache.get(cacheKey);\n    if (cacheRecord != null) {\n        pluginDescriptor.setClassRealm(cacheRecord.realm);\n        pluginDescriptor.setArtifacts(new ArrayList<Artifact>(cacheRecord.artifacts));\n    } else {\n        createPluginRealm(pluginDescriptor, session, parent, foreignImports, filter);\n        cacheRecord = pluginRealmCache.put(cacheKey, pluginDescriptor.getClassRealm(), pluginDescriptor.getArtifacts());\n    }\n    pluginRealmCache.register(project, cacheRecord);\n}", "code_comment": NaN, "code_no_comment": "public synchronized void setupPluginRealm(PluginDescriptor pluginDescriptor, MavenSession session, ClassLoader parent, List<String> imports, DependencyFilter filter) throws PluginResolutionException, PluginContainerException {\n    Plugin plugin = pluginDescriptor.getPlugin();\n    MavenProject project = session.getCurrentProject();\n    Map<String, ClassLoader> foreignImports = calcImports(project, parent, imports);\n    PluginRealmCache.Key cacheKey = pluginRealmCache.createKey(plugin, parent, foreignImports, filter, project.getRemotePluginRepositories(), session.getRepositorySession());\n    PluginRealmCache.CacheRecord cacheRecord = pluginRealmCache.get(cacheKey);\n    if (cacheRecord != null) {\n        pluginDescriptor.setClassRealm(cacheRecord.realm);\n        pluginDescriptor.setArtifacts(new ArrayList<Artifact>(cacheRecord.artifacts));\n    } else {\n        createPluginRealm(pluginDescriptor, session, parent, foreignImports, filter);\n        cacheRecord = pluginRealmCache.put(cacheKey, pluginDescriptor.getClassRealm(), pluginDescriptor.getArtifacts());\n    }\n    pluginRealmCache.register(project, cacheRecord);\n}", "lc": 0.045454545454545456, "pi": -0.2806122448979591, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.03657933761739987, "mi": -0.16661887008890175, "fo": 0.6666666666666666, "r": -0.028571428571428574, "e": 0.1976991703821724}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-621_00b4b8a0", "label": 1, "code": "@Override\npublic Iterable<Tree> getChildren() {\n    root.checkLive();\n    Iterable<String> childNames;\n    if (hasOrderableChildren()) {\n        childNames = getOrderedChildNames();\n    } else {\n        childNames = getNodeBuilder().getChildNodeNames();\n    }\n    return Iterables.filter(Iterables.transform(childNames, new Function<String, Tree>() {\n\n        @Override\n        public Tree apply(String input) {\n            return new TreeImpl(root, TreeImpl.this, input);\n        }\n    }), new Predicate<Tree>() {\n\n        @Override\n        public boolean apply(Tree tree) {\n            return tree != null && canRead(tree);\n        }\n    });\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Iterable<Tree> getChildren() {\n    root.checkLive();\n    Iterable<String> childNames;\n    if (hasOrderableChildren()) {\n        childNames = getOrderedChildNames();\n    } else {\n        childNames = getNodeBuilder().getChildNodeNames();\n    }\n    return Iterables.filter(Iterables.transform(childNames, new Function<String, Tree>() {\n\n        @Override\n        public Tree apply(String input) {\n            return new TreeImpl(root, TreeImpl.this, input);\n        }\n    }), new Predicate<Tree>() {\n\n        @Override\n        public boolean apply(Tree tree) {\n            return tree != null && canRead(tree);\n        }\n    });\n}", "lc": 0.3181818181818182, "pi": 0.1938775510204081, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.026693030153237728, "mi": -0.20705477487811874, "fo": 0.16666666666666666, "r": 0.0, "e": 0.007263974370505515}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-3740_f2f5bd5b", "label": 1, "code": "@Override\npublic final void trigger(long time) throws Exception {\n    boolean fire;\n    do {\n        Timer<K, W> timer = processingTimeTimersQueue.peek();\n        if (timer != null && timer.timestamp <= time) {\n            fire = true;\n            processingTimeTimers.remove(timer);\n            processingTimeTimersQueue.remove();\n            context.key = timer.key;\n            context.window = timer.window;\n            setKeyContext(timer.key);\n            TriggerResult triggerResult = context.onProcessingTime(timer.timestamp);\n            processTriggerResult(triggerResult, context.key, context.window);\n        } else {\n            fire = false;\n        }\n    } while (fire);\n    // Also check any watermark timers. We might have some in here since\n    // Context.registerEventTimeTimer sets a trigger if an event-time trigger is registered\n    // that is already behind the watermark.\n    processTriggersFor(new Watermark(currentWatermark));\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic final void trigger(long time) throws Exception {\n    boolean fire;\n    do {\n        Timer<K, W> timer = processingTimeTimersQueue.peek();\n        if (timer != null && timer.timestamp <= time) {\n            fire = true;\n            processingTimeTimers.remove(timer);\n            processingTimeTimersQueue.remove();\n            context.key = timer.key;\n            context.window = timer.window;\n            setKeyContext(timer.key);\n            TriggerResult triggerResult = context.onProcessingTime(timer.timestamp);\n            processTriggerResult(triggerResult, context.key, context.window);\n        } else {\n            fire = false;\n        }\n    } while (fire);\n                processTriggersFor(new Watermark(currentWatermark));\n}", "lc": 0.2727272727272727, "pi": 0.7397959183673468, "ma": -0.16666666666666666, "nbd": 0.0, "ml": 0.16666666666666666, "d": 0.34305486900642623, "mi": -0.24118153140235157, "fo": 0.08333333333333333, "r": -0.028571428571428574, "e": 0.32538836136559296}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-359_296ea4a5", "label": 1, "code": "@Override\npublic void onStartup(final Set<Class<?>> classes, final ServletContext servletContext) throws ServletException {\n    if (servletContext.getMajorVersion() > 2) {\n        servletContext.log(\"Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment.\");\n        final Log4jWebInitializer initializer = Log4jWebInitializerImpl.getLog4jWebInitializer(servletContext);\n        initializer.initialize();\n        // the application is just now starting to start up\n        initializer.setLoggerContext();\n        servletContext.addListener(new Log4jServletContextListener());\n        final FilterRegistration.Dynamic filter = servletContext.addFilter(\"log4jServletFilter\", new Log4jServletFilter());\n        if (filter == null) {\n            throw new UnavailableException(\"In a Servlet 3.0+ application, you must not define a \" + \"log4jServletFilter in web.xml. Log4j 2 defines this for you automatically.\");\n        }\n        filter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, \"/*\");\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void onStartup(final Set<Class<?>> classes, final ServletContext servletContext) throws ServletException {\n    if (servletContext.getMajorVersion() > 2) {\n        servletContext.log(\"Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment.\");\n        final Log4jWebInitializer initializer = Log4jWebInitializerImpl.getLog4jWebInitializer(servletContext);\n        initializer.initialize();\n                initializer.setLoggerContext();\n        servletContext.addListener(new Log4jServletContextListener());\n        final FilterRegistration.Dynamic filter = servletContext.addFilter(\"log4jServletFilter\", new Log4jServletFilter());\n        if (filter == null) {\n            throw new UnavailableException(\"In a Servlet 3.0+ application, you must not define a \" + \"log4jServletFilter in web.xml. Log4j 2 defines this for you automatically.\");\n        }\n        filter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, \"/*\");\n    }\n}", "lc": 0.045454545454545456, "pi": 0.2653061224489796, "ma": 0.0, "nbd": 0.0, "ml": -0.08333333333333333, "d": 0.11171527434503223, "mi": -0.09377688557499274, "fo": 0.25, "r": -0.028571428571428574, "e": 0.12675977916832631}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-554_3f51fb09", "label": 1, "code": "@Override\npublic String toString() {\n    return propertyState.getValue(Type.STRING, index);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic String toString() {\n    return propertyState.getValue(Type.STRING, index);\n}", "lc": -0.45454545454545453, "pi": -0.6581632653061225, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8769716088328073, "fo": -0.4166666666666667, "r": 0.9142857142857144, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2337_36a41358", "label": 1, "code": "private static ObjectAndGetSetter getObjectAndGetSetter(final String expression, final Object object, int tryToCreateNull) {\n    final String expressionBracketsSeperated = Strings.replaceAll(expression, \"[\", \".[\").toString();\n    int index = getNextDotIndex(expressionBracketsSeperated, 0);\n    int lastIndex = 0;\n    Object value = object;\n    Class<?> clz = value.getClass();\n    String exp = expressionBracketsSeperated;\n    while (index != -1) {\n        exp = expressionBracketsSeperated.substring(lastIndex, index);\n        IGetAndSet getAndSetter = null;\n        try {\n            getAndSetter = getGetAndSetter(exp, clz);\n        } catch (WicketRuntimeException ex) {\n            // expression by it self can't be found. try to find a\n            // setPropertyByIndex(int,value) method\n            index = getNextDotIndex(expressionBracketsSeperated, index + 1);\n            if (index != -1) {\n                String indexExpression = expressionBracketsSeperated.substring(lastIndex, index);\n                getAndSetter = getGetAndSetter(indexExpression, clz);\n            } else {\n                exp = expressionBracketsSeperated.substring(lastIndex);\n                break;\n            }\n        }\n        Object newValue = null;\n        if (value != null) {\n            newValue = getAndSetter.getValue(value);\n        }\n        if (newValue == null) {\n            if (tryToCreateNull == CREATE_NEW_VALUE) {\n                newValue = getAndSetter.newValue(value);\n                if (newValue == null) {\n                    return null;\n                }\n            } else if (tryToCreateNull == RESOLVE_CLASS) {\n                clz = getAndSetter.getTargetClass();\n            } else {\n                return null;\n            }\n        }\n        value = newValue;\n        if (value != null) {\n            // value can be null if we are in the RESOLVE_CLASS\n            clz = value.getClass();\n        }\n        lastIndex = index + 1;\n        index = getNextDotIndex(expressionBracketsSeperated, lastIndex);\n        if (index == -1) {\n            exp = expressionBracketsSeperated.substring(lastIndex);\n            break;\n        }\n    }\n    IGetAndSet getAndSetter = getGetAndSetter(exp, clz);\n    return new ObjectAndGetSetter(getAndSetter, value);\n}", "code_comment": NaN, "code_no_comment": "private static ObjectAndGetSetter getObjectAndGetSetter(final String expression, final Object object, int tryToCreateNull) {\n    final String expressionBracketsSeperated = Strings.replaceAll(expression, \"[\", \".[\").toString();\n    int index = getNextDotIndex(expressionBracketsSeperated, 0);\n    int lastIndex = 0;\n    Object value = object;\n    Class<?> clz = value.getClass();\n    String exp = expressionBracketsSeperated;\n    while (index != -1) {\n        exp = expressionBracketsSeperated.substring(lastIndex, index);\n        IGetAndSet getAndSetter = null;\n        try {\n            getAndSetter = getGetAndSetter(exp, clz);\n        } catch (WicketRuntimeException ex) {\n                                    index = getNextDotIndex(expressionBracketsSeperated, index + 1);\n            if (index != -1) {\n                String indexExpression = expressionBracketsSeperated.substring(lastIndex, index);\n                getAndSetter = getGetAndSetter(indexExpression, clz);\n            } else {\n                exp = expressionBracketsSeperated.substring(lastIndex);\n                break;\n            }\n        }\n        Object newValue = null;\n        if (value != null) {\n            newValue = getAndSetter.getValue(value);\n        }\n        if (newValue == null) {\n            if (tryToCreateNull == CREATE_NEW_VALUE) {\n                newValue = getAndSetter.newValue(value);\n                if (newValue == null) {\n                    return null;\n                }\n            } else if (tryToCreateNull == RESOLVE_CLASS) {\n                clz = getAndSetter.getTargetClass();\n            } else {\n                return null;\n            }\n        }\n        value = newValue;\n        if (value != null) {\n                        clz = value.getClass();\n        }\n        lastIndex = index + 1;\n        index = getNextDotIndex(expressionBracketsSeperated, lastIndex);\n        if (index == -1) {\n            exp = expressionBracketsSeperated.substring(lastIndex);\n            break;\n        }\n    }\n    IGetAndSet getAndSetter = getGetAndSetter(exp, clz);\n    return new ObjectAndGetSetter(getAndSetter, value);\n}", "lc": 1.7272727272727273, "pi": 0.7959183673469388, "ma": 1.5, "nbd": 1.0, "ml": 0.6666666666666666, "d": 0.934256055363322, "mi": -0.902208201892745, "fo": 0.9166666666666666, "r": -0.028571428571428574, "e": 2.2926148166231943}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3510_01f5a26f", "label": 1, "code": "/**\n * Tests if the given object is an external identity reference and if it's getString() is equal to this.\n */\n@Override\npublic boolean equals(Object o) {\n    try {\n        // assuming that we never compare other types of classes\n        return this == o || string.equals(((ExternalIdentityRef) o).string);\n    } catch (Exception e) {\n        return false;\n    }\n}", "code_comment": "/**\n * Tests if the given object is an external identity reference and if it's getString() is equal to this.\n */\n", "code_no_comment": "@Override\npublic boolean equals(Object o) {\n    try {\n                return this == o || string.equals(((ExternalIdentityRef) o).string);\n    } catch (Exception e) {\n        return false;\n    }\n}", "lc": -0.2727272727272727, "pi": 0.051020408163265356, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.10380622837370242, "mi": 0.4442213937482076, "fo": -0.4166666666666667, "r": 2.7142857142857144, "e": -0.12983497586527384}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4757_fd910746", "label": 1, "code": "@Override\npublic void component(final FormComponent<?> formComponent, final IVisit<Void> visit) {\n    Form<?> form = formComponent.getForm();\n    if (!form.isVisibleInHierarchy() || !form.isEnabledInHierarchy()) {\n        // do not validate formComponent or any of formComponent's children\n        visit.dontGoDeeper();\n        return;\n    }\n    if (formComponent.isVisibleInHierarchy() && formComponent.isValid() && formComponent.isEnabledInHierarchy()) {\n        validate(formComponent);\n    }\n    if (formComponent.processChildren() == false) {\n        visit.dontGoDeeper();\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void component(final FormComponent<?> formComponent, final IVisit<Void> visit) {\n    Form<?> form = formComponent.getForm();\n    if (!form.isVisibleInHierarchy() || !form.isEnabledInHierarchy()) {\n                visit.dontGoDeeper();\n        return;\n    }\n    if (formComponent.isVisibleInHierarchy() && formComponent.isValid() && formComponent.isEnabledInHierarchy()) {\n        validate(formComponent);\n    }\n    if (formComponent.processChildren() == false) {\n        visit.dontGoDeeper();\n    }\n}", "lc": 0.0, "pi": -0.10714285714285712, "ma": 0.0, "nbd": -0.5, "ml": 0.5833333333333334, "d": 0.2995551161641128, "mi": 0.011184399197017513, "fo": 0.3333333333333333, "r": -0.028571428571428574, "e": 0.08268767051708704}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-2172_ea4a3f8a", "label": 3, "code": "/**\n *  @see IValueMap#getAsEnum(String, Class<T>, T)\n */\npublic <T extends Enum<T>> T getAsEnum(String key, Class<T> eClass, T defaultValue) {\n    return getEnumImpl(key, eClass, defaultValue);\n}", "code_comment": "/**\n *  @see IValueMap#getAsEnum(String, Class<T>, T)\n */\n", "code_no_comment": "public <T extends Enum<T>> T getAsEnum(String key, Class<T> eClass, T defaultValue) {\n    return getEnumImpl(key, eClass, defaultValue);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.9088041296243191, "fo": -0.4166666666666667, "r": 0.5714285714285714, "e": -0.16422749602751402}
{"project_name": "Compress", "project_version": 32, "label": 3, "code": "private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n    /*\n         * The following headers are defined for Pax.\n         * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields\n         * mtime\n         * comment\n         * gid, gname\n         * linkpath\n         * size\n         * uid,uname\n         * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those\n         */\n    for (Entry<String, String> ent : headers.entrySet()) {\n        String key = ent.getKey();\n        String val = ent.getValue();\n        if (\"path\".equals(key)) {\n            currEntry.setName(val);\n        } else if (\"linkpath\".equals(key)) {\n            currEntry.setLinkName(val);\n        } else if (\"gid\".equals(key)) {\n            currEntry.setGroupId(Integer.parseInt(val));\n        } else if (\"gname\".equals(key)) {\n            currEntry.setGroupName(val);\n        } else if (\"uid\".equals(key)) {\n            currEntry.setUserId(Integer.parseInt(val));\n        } else if (\"uname\".equals(key)) {\n            currEntry.setUserName(val);\n        } else if (\"size\".equals(key)) {\n            currEntry.setSize(Long.parseLong(val));\n        } else if (\"mtime\".equals(key)) {\n            currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n        } else if (\"SCHILY.devminor\".equals(key)) {\n            currEntry.setDevMinor(Integer.parseInt(val));\n        } else if (\"SCHILY.devmajor\".equals(key)) {\n            currEntry.setDevMajor(Integer.parseInt(val));\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n        for (Entry<String, String> ent : headers.entrySet()) {\n        String key = ent.getKey();\n        String val = ent.getValue();\n        if (\"path\".equals(key)) {\n            currEntry.setName(val);\n        } else if (\"linkpath\".equals(key)) {\n            currEntry.setLinkName(val);\n        } else if (\"gid\".equals(key)) {\n            currEntry.setGroupId(Integer.parseInt(val));\n        } else if (\"gname\".equals(key)) {\n            currEntry.setGroupName(val);\n        } else if (\"uid\".equals(key)) {\n            currEntry.setUserId(Integer.parseInt(val));\n        } else if (\"uname\".equals(key)) {\n            currEntry.setUserName(val);\n        } else if (\"size\".equals(key)) {\n            currEntry.setSize(Long.parseLong(val));\n        } else if (\"mtime\".equals(key)) {\n            currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n        } else if (\"SCHILY.devminor\".equals(key)) {\n            currEntry.setDevMinor(Integer.parseInt(val));\n        } else if (\"SCHILY.devmajor\".equals(key)) {\n            currEntry.setDevMajor(Integer.parseInt(val));\n        }\n    }\n}", "lc": 0.5909090909090909, "pi": 0.1887755102040817, "ma": 1.3333333333333333, "nbd": 4.5, "ml": 1.3333333333333333, "d": 0.06821552150271878, "mi": -0.5159162603957561, "fo": 1.9166666666666667, "r": -0.028571428571428574, "e": 0.3418522278044037}
{"project_name": "maven", "project_version": "remotes/origin/bugs-dot-jar_MNG-3131_56cd921f", "label": 1, "code": "private static void decomposeParameterIntoUserInstructions(MojoDescriptor mojo, Parameter param, StringBuilder messageBuffer) {\n    String expression = param.getExpression();\n    if (param.isEditable()) {\n        messageBuffer.append(\"Inside the definition for plugin \\'\" + mojo.getPluginDescriptor().getArtifactId() + \"\\', specify the following:\\n\\n<configuration>\\n  ...\\n  <\" + param.getName() + \">VALUE</\" + param.getName() + \">\\n</configuration>\");\n        String alias = param.getAlias();\n        if (StringUtils.isNotEmpty(alias) && !alias.equals(param.getName())) {\n            messageBuffer.append(\"\\n\\n-OR-\\n\\n<configuration>\\n  ...\\n  <\" + alias + \">VALUE</\" + alias + \">\\n</configuration>\\n\");\n        }\n    }\n    if (StringUtils.isEmpty(expression)) {\n        messageBuffer.append(\".\");\n    } else {\n        if (param.isEditable()) {\n            messageBuffer.append(\"\\n\\n-OR-\\n\\n\");\n        }\n    // addParameterUsageInfo( expression, messageBuffer );\n    }\n}", "code_comment": NaN, "code_no_comment": "private static void decomposeParameterIntoUserInstructions(MojoDescriptor mojo, Parameter param, StringBuilder messageBuffer) {\n    String expression = param.getExpression();\n    if (param.isEditable()) {\n        messageBuffer.append(\"Inside the definition for plugin \\'\" + mojo.getPluginDescriptor().getArtifactId() + \"\\', specify the following:\\n\\n<configuration>\\n  ...\\n  <\" + param.getName() + \">VALUE</\" + param.getName() + \">\\n</configuration>\");\n        String alias = param.getAlias();\n        if (StringUtils.isNotEmpty(alias) && !alias.equals(param.getName())) {\n            messageBuffer.append(\"\\n\\n-OR-\\n\\n<configuration>\\n  ...\\n  <\" + alias + \">VALUE</\" + alias + \">\\n</configuration>\\n\");\n        }\n    }\n    if (StringUtils.isEmpty(expression)) {\n        messageBuffer.append(\".\");\n    } else {\n        if (param.isEditable()) {\n            messageBuffer.append(\"\\n\\n-OR-\\n\\n\");\n        }\n        }\n}", "lc": 0.13636363636363635, "pi": 0.1887755102040817, "ma": 0.16666666666666666, "nbd": 0.0, "ml": 0.5833333333333334, "d": 0.35689569945625316, "mi": -0.18009750501864075, "fo": 0.8333333333333334, "r": -0.028571428571428574, "e": 0.34013046029441363}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-344_a0b4b4b7", "label": 0, "code": "/**\n * Find a zero in the given interval with an initial guess.\n * <p>Throws <code>IllegalArgumentException</code> if the values of the\n * function at the three points have the same sign (note that it is\n * allowed to have endpoints with the same sign if the initial point has\n * opposite sign function-wise).</p>\n *\n * @param f function to solve.\n * @param min the lower bound for the interval.\n * @param max the upper bound for the interval.\n * @param initial the start value to use (must be set to min if no\n * initial point is known).\n * @return the value where the function is zero\n * @throws MaxIterationsExceededException the maximum iteration count\n * is exceeded\n * @throws FunctionEvaluationException if an error occurs evaluating\n *  the function\n * @throws IllegalArgumentException if initial is not between min and max\n * (even if it <em>is</em> a root)\n */\npublic double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    // return the initial guess if it is good enough\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    // return the first endpoint if it is good enough\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    // reduce interval if min and initial bracket the root\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    // return the second endpoint if it is good enough\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    // reduce interval if initial and max bracket the root\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    if (yMin * yMax > 0) {\n        throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n    }\n    // full Brent algorithm starting with provided initial guess\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}", "code_comment": "/**\n * Find a zero in the given interval with an initial guess.\n * <p>Throws <code>IllegalArgumentException</code> if the values of the\n * function at the three points have the same sign (note that it is\n * allowed to have endpoints with the same sign if the initial point has\n * opposite sign function-wise).</p>\n *\n * @param f function to solve.\n * @param min the lower bound for the interval.\n * @param max the upper bound for the interval.\n * @param initial the start value to use (must be set to min if no\n * initial point is known).\n * @return the value where the function is zero\n * @throws MaxIterationsExceededException the maximum iteration count\n * is exceeded\n * @throws FunctionEvaluationException if an error occurs evaluating\n *  the function\n * @throws IllegalArgumentException if initial is not between min and max\n * (even if it <em>is</em> a root)\n */\n", "code_no_comment": "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n        double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n        double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n        if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n        double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n        if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    if (yMin * yMax > 0) {\n        throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n    }\n        return solve(f, min, yMin, max, yMax, initial, yInitial);\n}", "lc": 0.6818181818181818, "pi": -0.3826530612244898, "ma": 0.6666666666666666, "nbd": -0.5, "ml": 0.6666666666666666, "d": 1.1023232822540783, "mi": -0.5153427014625754, "fo": 0.75, "r": -0.028571428571428574, "e": 1.4274908879095087}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-2734_8b40bb7a", "label": 0, "code": "// TODO:fix cluster default parallelism\n/**\n *  Creates a {@link RemoteStreamEnvironment}. The remote environment sends\n *  (parts of) the program to a cluster for execution. Note that all file\n *  paths used in the program must be accessible from the cluster. The\n *  execution will use no parallelism, unless the parallelism is set\n *  explicitly via {@link #setParallelism}.\n *\n *  @param host\n *  \t\tThe host name or address of the master (JobManager), where the\n *  \t\tprogram should be executed.\n *  @param port\n *  \t\tThe port of the master (JobManager), where the program should\n *  \t\tbe executed.\n *  @param jarFiles\n *  \t\tThe JAR files with code that needs to be shipped to the\n *  \t\tcluster. If the program uses user-defined functions,\n *  \t\tuser-defined input formats, or any libraries, those must be\n *  \t\tprovided in the JAR files.\n *  @return A remote environment that executes the program on a cluster.\n */\npublic static StreamExecutionEnvironment createRemoteEnvironment(String host, int port, String... jarFiles) {\n    RemoteStreamEnvironment env = new RemoteStreamEnvironment(host, port, jarFiles);\n    return env;\n}", "code_comment": "/**\n *  Creates a {@link RemoteStreamEnvironment}. The remote environment sends\n *  (parts of) the program to a cluster for execution. Note that all file\n *  paths used in the program must be accessible from the cluster. The\n *  execution will use no parallelism, unless the parallelism is set\n *  explicitly via {@link #setParallelism}.\n *\n *  @param host\n *  \t\tThe host name or address of the master (JobManager), where the\n *  \t\tprogram should be executed.\n *  @param port\n *  \t\tThe port of the master (JobManager), where the program should\n *  \t\tbe executed.\n *  @param jarFiles\n *  \t\tThe JAR files with code that needs to be shipped to the\n *  \t\tcluster. If the program uses user-defined functions,\n *  \t\tuser-defined input formats, or any libraries, those must be\n *  \t\tprovided in the JAR files.\n *  @return A remote environment that executes the program on a cluster.\n */\n", "code_no_comment": "public static StreamExecutionEnvironment createRemoteEnvironment(String host, int port, String... jarFiles) {\n    RemoteStreamEnvironment env = new RemoteStreamEnvironment(host, port, jarFiles);\n    return env;\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7840550616575857, "fo": -0.5, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-218_15476a0d", "label": 1, "code": "@Override\npublic int compareTo(Key o) {\n    int compare = super.compareTo(o);\n    if (compare != 0)\n        return compare;\n    if (o instanceof MockMemKey) {\n        MockMemKey other = (MockMemKey) o;\n        if (count < other.count)\n            return -1;\n        if (count > other.count)\n            return 1;\n    } else {\n        return 1;\n    }\n    return 0;\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic int compareTo(Key o) {\n    int compare = super.compareTo(o);\n    if (compare != 0)\n        return compare;\n    if (o instanceof MockMemKey) {\n        MockMemKey other = (MockMemKey) o;\n        if (count < other.count)\n            return -1;\n        if (count > other.count)\n            return 1;\n    } else {\n        return 1;\n    }\n    return 0;\n}", "lc": 0.09090909090909091, "pi": 0.3520408163265306, "ma": 0.16666666666666666, "nbd": -0.5, "ml": 0.25, "d": 0.5902125556104797, "mi": -0.022082018927444685, "fo": -0.4166666666666667, "r": 0.3428571428571429, "e": 0.11331114737387625}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-93_0be7e8f0", "label": 1, "code": "@Override\npublic Iterable<Tree> getChildren() {\n    return new Iterable<Tree>() {\n\n        @Override\n        public Iterator<Tree> iterator() {\n            Iterator<? extends ChildNodeEntry> childEntries = getNodeState().getChildNodeEntries().iterator();\n            return Iterators.map(childEntries, new Function1<ChildNodeEntry, Tree>() {\n\n                @Override\n                public Tree apply(ChildNodeEntry entry) {\n                    NodeStateBuilder childBuilder = builder.getChildBuilder(entry.getName());\n                    return new TreeImpl(store, childBuilder.getNodeState(), childBuilder, TreeImpl.this, entry.getName(), listener);\n                }\n            });\n        }\n    };\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic Iterable<Tree> getChildren() {\n    return new Iterable<Tree>() {\n\n        @Override\n        public Iterator<Tree> iterator() {\n            Iterator<? extends ChildNodeEntry> childEntries = getNodeState().getChildNodeEntries().iterator();\n            return Iterators.map(childEntries, new Function1<ChildNodeEntry, Tree>() {\n\n                @Override\n                public Tree apply(ChildNodeEntry entry) {\n                    NodeStateBuilder childBuilder = builder.getChildBuilder(entry.getName());\n                    return new TreeImpl(store, childBuilder.getNodeState(), childBuilder, TreeImpl.this, entry.getName(), listener);\n                }\n            });\n        }\n    };\n}", "lc": 0.09090909090909091, "pi": 1.8418367346938775, "ma": -0.5, "nbd": 0.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": -0.06423860051620332, "fo": 0.16666666666666666, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "flink", "project_version": "remotes/origin/bugs-dot-jar_FLINK-1133_27e40205", "label": 1, "code": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\nprivate <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoWithTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\n    // check if type is a subclass of tuple\n    if ((t instanceof Class<?> && Tuple.class.isAssignableFrom((Class<?>) t)) || (t instanceof ParameterizedType && Tuple.class.isAssignableFrom((Class<?>) ((ParameterizedType) t).getRawType()))) {\n        Type curT = t;\n        // do not allow usage of Tuple as type\n        if (curT instanceof Class<?> && ((Class<?>) curT).equals(Tuple.class)) {\n            throw new InvalidTypesException(\"Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead.\");\n        }\n        // collect the types while moving up for a later top-down\n        while (!(curT instanceof ParameterizedType && ((Class<?>) ((ParameterizedType) curT).getRawType()).getSuperclass().equals(Tuple.class)) && !(curT instanceof Class<?> && ((Class<?>) curT).getSuperclass().equals(Tuple.class))) {\n            typeHierarchy.add(curT);\n            // parameterized type\n            if (curT instanceof ParameterizedType) {\n                curT = ((Class<?>) ((ParameterizedType) curT).getRawType()).getGenericSuperclass();\n            } else // class\n            {\n                curT = ((Class<?>) curT).getGenericSuperclass();\n            }\n        }\n        // check if immediate child of Tuple has generics\n        if (curT instanceof Class<?>) {\n            throw new InvalidTypesException(\"Tuple needs to be parameterized by using generics.\");\n        }\n        ParameterizedType tupleChild = (ParameterizedType) curT;\n        Type[] subtypes = new Type[tupleChild.getActualTypeArguments().length];\n        // materialize possible type variables\n        for (int i = 0; i < subtypes.length; i++) {\n            // materialize immediate TypeVariables\n            if (tupleChild.getActualTypeArguments()[i] instanceof TypeVariable<?>) {\n                subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) tupleChild.getActualTypeArguments()[i]);\n            } else // class or parameterized type\n            {\n                subtypes[i] = tupleChild.getActualTypeArguments()[i];\n            }\n        }\n        TypeInformation<?>[] tupleSubTypes = new TypeInformation<?>[subtypes.length];\n        for (int i = 0; i < subtypes.length; i++) {\n            // try to derive the type info of the TypeVariable from the immediate base child input as a last attempt\n            if (subtypes[i] instanceof TypeVariable<?>) {\n                tupleSubTypes[i] = createTypeInfoFromInput((TypeVariable<?>) subtypes[i], typeHierarchy, in1Type, in2Type);\n                // variable could not be determined\n                if (tupleSubTypes[i] == null) {\n                    throw new InvalidTypesException(\"Type of TypeVariable '\" + ((TypeVariable<?>) subtypes[i]).getName() + \"' in '\" + ((TypeVariable<?>) subtypes[i]).getGenericDeclaration() + \"' could not be determined. This is most likely a type erasure problem. \" + \"The type extraction currently supports types with generic variables only in cases where \" + \"all variables in the return type can be deduced from the input type(s).\");\n                }\n            } else {\n                tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new ArrayList<Type>(typeHierarchy), subtypes[i], in1Type, in2Type);\n            }\n        }\n        if (t instanceof Class<?>) {\n            return new TupleTypeInfo(((Class<? extends Tuple>) t), tupleSubTypes);\n        } else if (t instanceof ParameterizedType) {\n            return new TupleTypeInfo(((Class<? extends Tuple>) ((ParameterizedType) t).getRawType()), tupleSubTypes);\n        }\n    } else // e.g. class MyMapper<E> extends MapFunction<String, E>\n    if (t instanceof TypeVariable) {\n        Type typeVar = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) t);\n        if (!(typeVar instanceof TypeVariable)) {\n            return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);\n        } else // try to derive the type info of the TypeVariable from the immediate base child input as a last attempt\n        {\n            TypeInformation<OUT> typeInfo = (TypeInformation<OUT>) createTypeInfoFromInput((TypeVariable<?>) t, typeHierarchy, in1Type, in2Type);\n            if (typeInfo != null) {\n                return typeInfo;\n            } else {\n                throw new InvalidTypesException(\"Type of TypeVariable '\" + ((TypeVariable<?>) t).getName() + \"' in '\" + ((TypeVariable<?>) t).getGenericDeclaration() + \"' could not be determined. This is most likely a type erasure problem. \" + \"The type extraction currently supports types with generic variables only in cases where \" + \"all variables in the return type can be deduced from the input type(s).\");\n            }\n        }\n    } else // arrays with generics\n    if (t instanceof GenericArrayType) {\n        GenericArrayType genericArray = (GenericArrayType) t;\n        Type componentType = genericArray.getGenericComponentType();\n        // due to a Java 6 bug, it is possible that the JVM classifies e.g. String[] or int[] as GenericArrayType instead of Class\n        if (componentType instanceof Class) {\n            Class<?> componentClass = (Class<?>) componentType;\n            String className;\n            // for int[], double[] etc.\n            if (componentClass.isPrimitive()) {\n                className = encodePrimitiveClass(componentClass);\n            } else // for String[], Integer[] etc.\n            {\n                className = \"L\" + componentClass.getName() + \";\";\n            }\n            Class<OUT> classArray = null;\n            try {\n                classArray = (Class<OUT>) Class.forName(\"[\" + className);\n            } catch (ClassNotFoundException e) {\n                throw new InvalidTypesException(\"Could not convert GenericArrayType to Class.\");\n            }\n            return getForClass(classArray);\n        }\n        TypeInformation<?> componentInfo = createTypeInfoWithTypeHierarchy(typeHierarchy, genericArray.getGenericComponentType(), in1Type, in2Type);\n        return ObjectArrayTypeInfo.getInfoFor(t, componentInfo);\n    } else // objects with generics are treated as raw type\n    if (t instanceof ParameterizedType) {\n        return privateGetForClass((Class<OUT>) ((ParameterizedType) t).getRawType());\n    } else // no tuple, no TypeVariable, no generic type\n    if (t instanceof Class) {\n        return privateGetForClass((Class<OUT>) t);\n    }\n    throw new InvalidTypesException(\"Type Information could not be created.\");\n}", "code_comment": NaN, "code_no_comment": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\nprivate <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoWithTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\n        if ((t instanceof Class<?> && Tuple.class.isAssignableFrom((Class<?>) t)) || (t instanceof ParameterizedType && Tuple.class.isAssignableFrom((Class<?>) ((ParameterizedType) t).getRawType()))) {\n        Type curT = t;\n                if (curT instanceof Class<?> && ((Class<?>) curT).equals(Tuple.class)) {\n            throw new InvalidTypesException(\"Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead.\");\n        }\n                while (!(curT instanceof ParameterizedType && ((Class<?>) ((ParameterizedType) curT).getRawType()).getSuperclass().equals(Tuple.class)) && !(curT instanceof Class<?> && ((Class<?>) curT).getSuperclass().equals(Tuple.class))) {\n            typeHierarchy.add(curT);\n                        if (curT instanceof ParameterizedType) {\n                curT = ((Class<?>) ((ParameterizedType) curT).getRawType()).getGenericSuperclass();\n            } else             {\n                curT = ((Class<?>) curT).getGenericSuperclass();\n            }\n        }\n                if (curT instanceof Class<?>) {\n            throw new InvalidTypesException(\"Tuple needs to be parameterized by using generics.\");\n        }\n        ParameterizedType tupleChild = (ParameterizedType) curT;\n        Type[] subtypes = new Type[tupleChild.getActualTypeArguments().length];\n                for (int i = 0; i < subtypes.length; i++) {\n                        if (tupleChild.getActualTypeArguments()[i] instanceof TypeVariable<?>) {\n                subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) tupleChild.getActualTypeArguments()[i]);\n            } else             {\n                subtypes[i] = tupleChild.getActualTypeArguments()[i];\n            }\n        }\n        TypeInformation<?>[] tupleSubTypes = new TypeInformation<?>[subtypes.length];\n        for (int i = 0; i < subtypes.length; i++) {\n                        if (subtypes[i] instanceof TypeVariable<?>) {\n                tupleSubTypes[i] = createTypeInfoFromInput((TypeVariable<?>) subtypes[i], typeHierarchy, in1Type, in2Type);\n                                if (tupleSubTypes[i] == null) {\n                    throw new InvalidTypesException(\"Type of TypeVariable '\" + ((TypeVariable<?>) subtypes[i]).getName() + \"' in '\" + ((TypeVariable<?>) subtypes[i]).getGenericDeclaration() + \"' could not be determined. This is most likely a type erasure problem. \" + \"The type extraction currently supports types with generic variables only in cases where \" + \"all variables in the return type can be deduced from the input type(s).\");\n                }\n            } else {\n                tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new ArrayList<Type>(typeHierarchy), subtypes[i], in1Type, in2Type);\n            }\n        }\n        if (t instanceof Class<?>) {\n            return new TupleTypeInfo(((Class<? extends Tuple>) t), tupleSubTypes);\n        } else if (t instanceof ParameterizedType) {\n            return new TupleTypeInfo(((Class<? extends Tuple>) ((ParameterizedType) t).getRawType()), tupleSubTypes);\n        }\n    } else     if (t instanceof TypeVariable) {\n        Type typeVar = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) t);\n        if (!(typeVar instanceof TypeVariable)) {\n            return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);\n        } else         {\n            TypeInformation<OUT> typeInfo = (TypeInformation<OUT>) createTypeInfoFromInput((TypeVariable<?>) t, typeHierarchy, in1Type, in2Type);\n            if (typeInfo != null) {\n                return typeInfo;\n            } else {\n                throw new InvalidTypesException(\"Type of TypeVariable '\" + ((TypeVariable<?>) t).getName() + \"' in '\" + ((TypeVariable<?>) t).getGenericDeclaration() + \"' could not be determined. This is most likely a type erasure problem. \" + \"The type extraction currently supports types with generic variables only in cases where \" + \"all variables in the return type can be deduced from the input type(s).\");\n            }\n        }\n    } else     if (t instanceof GenericArrayType) {\n        GenericArrayType genericArray = (GenericArrayType) t;\n        Type componentType = genericArray.getGenericComponentType();\n                if (componentType instanceof Class) {\n            Class<?> componentClass = (Class<?>) componentType;\n            String className;\n                        if (componentClass.isPrimitive()) {\n                className = encodePrimitiveClass(componentClass);\n            } else             {\n                className = \"L\" + componentClass.getName() + \";\";\n            }\n            Class<OUT> classArray = null;\n            try {\n                classArray = (Class<OUT>) Class.forName(\"[\" + className);\n            } catch (ClassNotFoundException e) {\n                throw new InvalidTypesException(\"Could not convert GenericArrayType to Class.\");\n            }\n            return getForClass(classArray);\n        }\n        TypeInformation<?> componentInfo = createTypeInfoWithTypeHierarchy(typeHierarchy, genericArray.getGenericComponentType(), in1Type, in2Type);\n        return ObjectArrayTypeInfo.getInfoFor(t, componentInfo);\n    } else     if (t instanceof ParameterizedType) {\n        return privateGetForClass((Class<OUT>) ((ParameterizedType) t).getRawType());\n    } else     if (t instanceof Class) {\n        return privateGetForClass((Class<OUT>) t);\n    }\n    throw new InvalidTypesException(\"Type Information could not be created.\");\n}", "lc": 3.5, "pi": 0.5612244897959184, "ma": 4.0, "nbd": 1.5, "ml": 2.9166666666666665, "d": 2.848245180425111, "mi": -1.3960424433610557, "fo": 2.8333333333333335, "r": -0.028571428571428574, "e": 14.737670302936854}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3733_a5ff019e", "label": 1, "code": "/**\n * Checks if the update operation introduced any conflicts on the given\n * document. The document shows the state right before the operation was\n * applied.\n *\n * @param op the update operation.\n * @param before how the document looked before the update was applied or\n *               {@code null} if it didn't exist before.\n * @throws ConflictException if there was a conflict introduced by the\n *          given update operation.\n */\nprivate void checkConflicts(@Nonnull UpdateOp op, @Nullable NodeDocument before) throws ConflictException {\n    DocumentStore store = nodeStore.getDocumentStore();\n    collisions.clear();\n    if (baseRevision != null) {\n        Revision newestRev = null;\n        if (before != null) {\n            Revision base = baseRevision;\n            if (nodeStore.isDisableBranches()) {\n                base = base.asTrunkRevision();\n            }\n            newestRev = before.getNewestRevision(nodeStore, base, revision, getBranch(), collisions);\n        }\n        String conflictMessage = null;\n        Revision conflictRevision = newestRev;\n        if (newestRev == null) {\n            if ((op.isDelete() || !op.isNew()) && isConflicting(before, op)) {\n                conflictMessage = \"The node \" + op.getId() + \" does not exist or is already deleted\";\n                if (before != null && !before.getLocalDeleted().isEmpty()) {\n                    conflictRevision = before.getLocalDeleted().firstKey();\n                }\n            }\n        } else {\n            if (op.isNew() && isConflicting(before, op)) {\n                conflictMessage = \"The node \" + op.getId() + \" was already added in revision\\n\" + formatConflictRevision(newestRev);\n            } else if (nodeStore.isRevisionNewer(newestRev, baseRevision) && (op.isDelete() || isConflicting(before, op))) {\n                conflictMessage = \"The node \" + op.getId() + \" was changed in revision\\n\" + formatConflictRevision(newestRev) + \", which was applied after the base revision\\n\" + baseRevision;\n            }\n        }\n        if (conflictMessage == null) {\n            // TODO: unify above conflict detection and isConflicting()\n            if (!collisions.isEmpty() && isConflicting(before, op)) {\n                for (Revision r : collisions) {\n                    // mark collisions on commit root\n                    Collision c = new Collision(before, r, op, revision);\n                    if (c.mark(store).equals(revision)) {\n                        // our revision was marked\n                        if (baseRevision.isBranch()) {\n                        // this is a branch commit. do not fail immediately\n                        // merging this branch will fail later.\n                        } else {\n                            // fail immediately\n                            conflictMessage = \"The node \" + op.getId() + \" was changed in revision\\n\" + formatConflictRevision(r) + \", which was applied after the base revision\\n\" + baseRevision;\n                            conflictRevision = r;\n                        }\n                    }\n                }\n            }\n        }\n        if (conflictMessage != null) {\n            conflictMessage += \", before\\n\" + revision;\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(conflictMessage + \"; document:\\n\" + (before == null ? \"\" : before.format()) + \",\\nrevision order:\\n\" + nodeStore.getRevisionComparator());\n            }\n            throw new ConflictException(conflictMessage, conflictRevision);\n        }\n    }\n}", "code_comment": "/**\n * Checks if the update operation introduced any conflicts on the given\n * document. The document shows the state right before the operation was\n * applied.\n *\n * @param op the update operation.\n * @param before how the document looked before the update was applied or\n *               {@code null} if it didn't exist before.\n * @throws ConflictException if there was a conflict introduced by the\n *          given update operation.\n */\n", "code_no_comment": "private void checkConflicts(@Nonnull UpdateOp op, @Nullable NodeDocument before) throws ConflictException {\n    DocumentStore store = nodeStore.getDocumentStore();\n    collisions.clear();\n    if (baseRevision != null) {\n        Revision newestRev = null;\n        if (before != null) {\n            Revision base = baseRevision;\n            if (nodeStore.isDisableBranches()) {\n                base = base.asTrunkRevision();\n            }\n            newestRev = before.getNewestRevision(nodeStore, base, revision, getBranch(), collisions);\n        }\n        String conflictMessage = null;\n        Revision conflictRevision = newestRev;\n        if (newestRev == null) {\n            if ((op.isDelete() || !op.isNew()) && isConflicting(before, op)) {\n                conflictMessage = \"The node \" + op.getId() + \" does not exist or is already deleted\";\n                if (before != null && !before.getLocalDeleted().isEmpty()) {\n                    conflictRevision = before.getLocalDeleted().firstKey();\n                }\n            }\n        } else {\n            if (op.isNew() && isConflicting(before, op)) {\n                conflictMessage = \"The node \" + op.getId() + \" was already added in revision\\n\" + formatConflictRevision(newestRev);\n            } else if (nodeStore.isRevisionNewer(newestRev, baseRevision) && (op.isDelete() || isConflicting(before, op))) {\n                conflictMessage = \"The node \" + op.getId() + \" was changed in revision\\n\" + formatConflictRevision(newestRev) + \", which was applied after the base revision\\n\" + baseRevision;\n            }\n        }\n        if (conflictMessage == null) {\n                        if (!collisions.isEmpty() && isConflicting(before, op)) {\n                for (Revision r : collisions) {\n                                        Collision c = new Collision(before, r, op, revision);\n                    if (c.mark(store).equals(revision)) {\n                                                if (baseRevision.isBranch()) {\n                                                                        } else {\n                                                        conflictMessage = \"The node \" + op.getId() + \" was changed in revision\\n\" + formatConflictRevision(r) + \", which was applied after the base revision\\n\" + baseRevision;\n                            conflictRevision = r;\n                        }\n                    }\n                }\n            }\n        }\n        if (conflictMessage != null) {\n            conflictMessage += \", before\\n\" + revision;\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(conflictMessage + \"; document:\\n\" + (before == null ? \"\" : before.format()) + \",\\nrevision order:\\n\" + nodeStore.getRevisionComparator());\n            }\n            throw new ConflictException(conflictMessage, conflictRevision);\n        }\n    }\n}", "lc": 1.6818181818181819, "pi": 1.7040816326530615, "ma": 2.3333333333333335, "nbd": 2.0, "ml": 2.75, "d": 1.756796836381612, "mi": -0.9698881560080304, "fo": 2.3333333333333335, "r": -0.028571428571428574, "e": 5.187856827750438}
{"project_name": "Closure", "project_version": 108, "label": 2, "code": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n    // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n        if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n        if (t.getScopeDepth() >= 2) {\n                if (aliasVar != null) {\n                                                                                    aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n                        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        }\n}", "lc": 1.4545454545454546, "pi": 0.586734693877551, "ma": 1.8333333333333333, "nbd": 1.0, "ml": 1.75, "d": 0.9500741473059815, "mi": -0.8391167192429025, "fo": 1.5, "r": -0.028571428571428574, "e": 2.0203528338494356}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-3019_5135cf4b", "label": 1, "code": "@Override\npublic boolean childNodeChanged(String name, NodeState before, NodeState after) {\n    Node node = new Node(nodeAfter, name);\n    return after.compareAgainstBaseState(before, new Diff(versionManager, node, exceptions));\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean childNodeChanged(String name, NodeState before, NodeState after) {\n    Node node = new Node(nodeAfter, name);\n    return after.compareAgainstBaseState(before, new Diff(versionManager, node, exceptions));\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.6051046745053055, "fo": -0.4166666666666667, "r": -0.028571428571428574, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-554_fbbb96eb", "label": 1, "code": "/**\n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @return the cross product v1 ^ v2 as a new Vector\n */\npublic static Vector3D crossProduct(Vector3D v1, Vector3D v2) {\n    return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n}", "code_comment": "/**\n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @return the cross product v1 ^ v2 as a new Vector\n */\n", "code_no_comment": "public static Vector3D crossProduct(Vector3D v1, Vector3D v2) {\n    return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n}", "lc": -0.5, "pi": -0.576530612244898, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": 0.41028175976272874, "mi": 0.7774591339260111, "fo": -0.5, "r": 0.05714285714285714, "e": 0.06911054860995111}
{"project_name": "Math", "project_version": 24, "label": 3, "code": "/**\n * {@inheritDoc}\n */\n@Override\nprotected UnivariatePointValuePair doOptimize() {\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n    final double lo = getMin();\n    final double mid = getStartValue();\n    final double hi = getMax();\n    // Optional additional convergence criteria.\n    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\n    double a;\n    double b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(x);\n    if (!isMinim) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n    UnivariatePointValuePair previous = null;\n    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n    int iter = 0;\n    while (true) {\n        final double m = 0.5 * (a + b);\n        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 = 2 * tol1;\n        // Default stopping criterion.\n        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n            if (FastMath.abs(e) > tol1) {\n                // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n            // Update by at least \"tol1\".\n            if (FastMath.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                u = x + d;\n            }\n            double fu = computeObjectiveValue(u);\n            if (!isMinim) {\n                fu = -fu;\n            }\n            // User-defined convergence checker.\n            previous = current;\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n            if (checker != null) {\n                if (checker.converged(iter, previous, current)) {\n                    return current;\n                }\n            }\n            // Update a, b, v, w and x.\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw || Precision.equals(w, x)) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else {\n            // Default termination (Brent's criterion).\n            return current;\n        }\n        ++iter;\n    }\n}", "code_comment": "/**\n * {@inheritDoc}\n */\n", "code_no_comment": "@Override\nprotected UnivariatePointValuePair doOptimize() {\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n    final double lo = getMin();\n    final double mid = getStartValue();\n    final double hi = getMax();\n        final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\n    double a;\n    double b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(x);\n    if (!isMinim) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n    UnivariatePointValuePair previous = null;\n    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n    int iter = 0;\n    while (true) {\n        final double m = 0.5 * (a + b);\n        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 = 2 * tol1;\n                final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n            if (FastMath.abs(e) > tol1) {\n                                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                                        d = p / q;\n                    u = x + d;\n                                        if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                    }\n                } else {\n                                        if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n                        if (FastMath.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                u = x + d;\n            }\n            double fu = computeObjectiveValue(u);\n            if (!isMinim) {\n                fu = -fu;\n            }\n                        previous = current;\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n            if (checker != null) {\n                if (checker.converged(iter, previous, current)) {\n                    return current;\n                }\n            }\n                        if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw || Precision.equals(w, x)) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else {\n                        return current;\n        }\n        ++iter;\n    }\n}", "lc": 5.363636363636363, "pi": 1.7500000000000002, "ma": 3.3333333333333335, "nbd": 2.0, "ml": 4.833333333333333, "d": 6.879881364310432, "mi": -1.5718382563808437, "fo": 0.9166666666666666, "r": -0.028571428571428574, "e": 40.61709946419623}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-2430_be3a9114", "label": 1, "code": "@Override\npublic boolean childNodeChanged(String name, NodeState before, NodeState after) {\n    if (!loader.isRunning()) {\n        return false;\n    }\n    return after.compareAgainstBaseState(before, new StandbyApplyDiff(builder.getChildNode(name), store, loader, path + name + \"/\"));\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic boolean childNodeChanged(String name, NodeState before, NodeState after) {\n    if (!loader.isRunning()) {\n        return false;\n    }\n    return after.compareAgainstBaseState(before, new StandbyApplyDiff(builder.getChildNode(name), store, loader, path + name + \"/\"));\n}", "lc": -0.3181818181818182, "pi": -0.11224489795918377, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.25, "d": -0.11764705882352938, "mi": 0.40579294522512177, "fo": -0.25, "r": -0.028571428571428574, "e": -0.10005525074845491}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4927_8c827e33", "label": 1, "code": "@Override\npublic void setContentLength(long length) {\n    checkHeader();\n    bufferedResponse.setContentLength(length);\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void setContentLength(long length) {\n    checkHeader();\n    bufferedResponse.setContentLength(length);\n}", "lc": -0.4090909090909091, "pi": -0.5408163265306123, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.8213363923143101, "fo": -0.3333333333333333, "r": 1.2285714285714286, "e": -0.16422749602751402}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-657_32b0f733", "label": 3, "code": "/**\n * Returns a {@code Complex} whose value is\n * {@code (this / divisor)}.\n * Implements the definitional formula\n * <pre>\n *  <code>\n *    a + bi          ac + bd + (bc - ad)i\n *    ----------- = -------------------------\n *    c + di         c<sup>2</sup> + d<sup>2</sup>\n *  </code>\n * </pre>\n * but uses\n * <a href=\"http://doi.acm.org/10.1145/1039813.1039814\">\n * prescaling of operands</a> to limit the effects of overflows and\n * underflows in the computation.\n * <br/>\n * {@code Infinite} and {@code NaN} values are handled according to the\n * following rules, applied in the order presented:\n * <ul>\n *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value\n *   in either part, {@link #NaN} is returned.\n *  </li>\n *  <li>If {@code divisor} equals {@link #ZERO}, {@link #NaN} is returned.\n *  </li>\n *  <li>If {@code this} and {@code divisor} are both infinite,\n *   {@link #NaN} is returned.\n *  </li>\n *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or\n *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts\n *   infinite), {@link #ZERO} is returned.\n *  </li>\n *  <li>If {@code this} is infinite and {@code divisor} is finite,\n *   {@code NaN} values are returned in the parts of the result if the\n *   {@link java.lang.Double} rules applied to the definitional formula\n *   force {@code NaN} results.\n *  </li>\n * </ul>\n *\n * @param divisor Value by which this {@code Complex} is to be divided.\n * @return {@code this / divisor}.\n * @throws NullArgumentException if {@code divisor} is {@code null}.\n */\npublic Complex divide(Complex divisor) throws NullArgumentException {\n    MathUtils.checkNotNull(divisor);\n    if (isNaN || divisor.isNaN) {\n        return NaN;\n    }\n    final double c = divisor.getReal();\n    final double d = divisor.getImaginary();\n    if (c == 0.0 && d == 0.0) {\n        return NaN;\n    }\n    if (divisor.isInfinite() && !isInfinite()) {\n        return ZERO;\n    }\n    if (FastMath.abs(c) < FastMath.abs(d)) {\n        double q = c / d;\n        double denominator = c * q + d;\n        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);\n    } else {\n        double q = d / c;\n        double denominator = d * q + c;\n        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);\n    }\n}", "code_comment": "/**\n * Returns a {@code Complex} whose value is\n * {@code (this / divisor)}.\n * Implements the definitional formula\n * <pre>\n *  <code>\n *    a + bi          ac + bd + (bc - ad)i\n *    ----------- = -------------------------\n *    c + di         c<sup>2</sup> + d<sup>2</sup>\n *  </code>\n * </pre>\n * but uses\n * <a href=\"http://doi.acm.org/10.1145/1039813.1039814\">\n * prescaling of operands</a> to limit the effects of overflows and\n * underflows in the computation.\n * <br/>\n * {@code Infinite} and {@code NaN} values are handled according to the\n * following rules, applied in the order presented:\n * <ul>\n *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value\n *   in either part, {@link #NaN} is returned.\n *  </li>\n *  <li>If {@code divisor} equals {@link #ZERO}, {@link #NaN} is returned.\n *  </li>\n *  <li>If {@code this} and {@code divisor} are both infinite,\n *   {@link #NaN} is returned.\n *  </li>\n *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or\n *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts\n *   infinite), {@link #ZERO} is returned.\n *  </li>\n *  <li>If {@code this} is infinite and {@code divisor} is finite,\n *   {@code NaN} values are returned in the parts of the result if the\n *   {@link java.lang.Double} rules applied to the definitional formula\n *   force {@code NaN} results.\n *  </li>\n * </ul>\n *\n * @param divisor Value by which this {@code Complex} is to be divided.\n * @return {@code this / divisor}.\n * @throws NullArgumentException if {@code divisor} is {@code null}.\n */\n", "code_no_comment": "public Complex divide(Complex divisor) throws NullArgumentException {\n    MathUtils.checkNotNull(divisor);\n    if (isNaN || divisor.isNaN) {\n        return NaN;\n    }\n    final double c = divisor.getReal();\n    final double d = divisor.getImaginary();\n    if (c == 0.0 && d == 0.0) {\n        return NaN;\n    }\n    if (divisor.isInfinite() && !isInfinite()) {\n        return ZERO;\n    }\n    if (FastMath.abs(c) < FastMath.abs(d)) {\n        double q = c / d;\n        double denominator = c * q + d;\n        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);\n    } else {\n        double q = d / c;\n        double denominator = d * q + c;\n        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);\n    }\n}", "lc": 0.4090909090909091, "pi": -0.2755102040816327, "ma": 0.16666666666666666, "nbd": -0.5, "ml": 0.8333333333333334, "d": 2.456747404844291, "mi": -0.386005162030399, "fo": 0.25, "r": -0.028571428571428574, "e": 2.842646725001178}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1668_63070cf9", "label": 1, "code": "private static void addNonFullTextConstraints(List<Query> qs, Filter filter, IndexReader reader, Analyzer analyzer) {\n    if (!filter.matchesAllTypes()) {\n        addNodeTypeConstraints(qs, filter);\n    }\n    String path = filter.getPath();\n    switch(filter.getPathRestriction()) {\n        case ALL_CHILDREN:\n            if (\"/\".equals(path)) {\n                break;\n            }\n            if (!path.endsWith(\"/\")) {\n                path += \"/\";\n            }\n            qs.add(new PrefixQuery(newPathTerm(path)));\n            break;\n        case DIRECT_CHILDREN:\n            if (!path.endsWith(\"/\")) {\n                path += \"/\";\n            }\n            qs.add(new PrefixQuery(newPathTerm(path)));\n            break;\n        case EXACT:\n            qs.add(new TermQuery(newPathTerm(path)));\n            break;\n        case PARENT:\n            if (denotesRoot(path)) {\n                // there's no parent of the root node\n                // we add a path that can not possibly occur because there\n                // is no way to say \"match no documents\" in Lucene\n                qs.add(new TermQuery(new Term(FieldNames.PATH, \"///\")));\n            } else {\n                qs.add(new TermQuery(newPathTerm(getParentPath(path))));\n            }\n            break;\n        case NO_RESTRICTION:\n            break;\n    }\n    for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n        if (pr.first == null && pr.last == null) {\n            // is not null' queries (OAK-1208)\n            continue;\n        }\n        String name = pr.propertyName;\n        if (name.contains(\"/\")) {\n            // lucene cannot handle child-level property restrictions\n            continue;\n        }\n        if (\"rep:excerpt\".equals(name)) {\n            continue;\n        }\n        if (JCR_PRIMARYTYPE.equals(name)) {\n            continue;\n        }\n        if (skipTokenization(name)) {\n            qs.add(new TermQuery(new Term(name, pr.first.getValue(STRING))));\n            continue;\n        }\n        String first = null;\n        String last = null;\n        boolean isLike = pr.isLike;\n        // TODO what to do with escaped tokens?\n        if (pr.first != null) {\n            first = pr.first.getValue(STRING);\n            first = first.replace(\"\\\\\", \"\");\n        }\n        if (pr.last != null) {\n            last = pr.last.getValue(STRING);\n            last = last.replace(\"\\\\\", \"\");\n        }\n        if (isLike) {\n            first = first.replace('%', WildcardQuery.WILDCARD_STRING);\n            first = first.replace('_', WildcardQuery.WILDCARD_CHAR);\n            int indexOfWS = first.indexOf(WildcardQuery.WILDCARD_STRING);\n            int indexOfWC = first.indexOf(WildcardQuery.WILDCARD_CHAR);\n            int len = first.length();\n            if (indexOfWS == len || indexOfWC == len) {\n                // remove trailing \"*\" for prefixquery\n                first = first.substring(0, first.length() - 1);\n                if (JCR_PATH.equals(name)) {\n                    qs.add(new PrefixQuery(newPathTerm(first)));\n                } else {\n                    qs.add(new PrefixQuery(new Term(name, first)));\n                }\n            } else {\n                if (JCR_PATH.equals(name)) {\n                    qs.add(new WildcardQuery(newPathTerm(first)));\n                } else {\n                    qs.add(new WildcardQuery(new Term(name, first)));\n                }\n            }\n            continue;\n        }\n        if (first != null && first.equals(last) && pr.firstIncluding && pr.lastIncluding) {\n            if (JCR_PATH.equals(name)) {\n                qs.add(new TermQuery(newPathTerm(first)));\n            } else {\n                if (\"*\".equals(name)) {\n                    addReferenceConstraint(first, qs, reader);\n                } else {\n                    for (String t : tokenize(first, analyzer)) {\n                        qs.add(new TermQuery(new Term(name, t)));\n                    }\n                }\n            }\n            continue;\n        }\n        first = tokenizeAndPoll(first, analyzer);\n        last = tokenizeAndPoll(last, analyzer);\n        qs.add(TermRangeQuery.newStringRange(name, first, last, pr.firstIncluding, pr.lastIncluding));\n    }\n}", "code_comment": NaN, "code_no_comment": "private static void addNonFullTextConstraints(List<Query> qs, Filter filter, IndexReader reader, Analyzer analyzer) {\n    if (!filter.matchesAllTypes()) {\n        addNodeTypeConstraints(qs, filter);\n    }\n    String path = filter.getPath();\n    switch(filter.getPathRestriction()) {\n        case ALL_CHILDREN:\n            if (\"/\".equals(path)) {\n                break;\n            }\n            if (!path.endsWith(\"/\")) {\n                path += \"/\";\n            }\n            qs.add(new PrefixQuery(newPathTerm(path)));\n            break;\n        case DIRECT_CHILDREN:\n            if (!path.endsWith(\"/\")) {\n                path += \"/\";\n            }\n            qs.add(new PrefixQuery(newPathTerm(path)));\n            break;\n        case EXACT:\n            qs.add(new TermQuery(newPathTerm(path)));\n            break;\n        case PARENT:\n            if (denotesRoot(path)) {\n                                                                qs.add(new TermQuery(new Term(FieldNames.PATH, \"///\")));\n            } else {\n                qs.add(new TermQuery(newPathTerm(getParentPath(path))));\n            }\n            break;\n        case NO_RESTRICTION:\n            break;\n    }\n    for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n        if (pr.first == null && pr.last == null) {\n                        continue;\n        }\n        String name = pr.propertyName;\n        if (name.contains(\"/\")) {\n                        continue;\n        }\n        if (\"rep:excerpt\".equals(name)) {\n            continue;\n        }\n        if (JCR_PRIMARYTYPE.equals(name)) {\n            continue;\n        }\n        if (skipTokenization(name)) {\n            qs.add(new TermQuery(new Term(name, pr.first.getValue(STRING))));\n            continue;\n        }\n        String first = null;\n        String last = null;\n        boolean isLike = pr.isLike;\n                if (pr.first != null) {\n            first = pr.first.getValue(STRING);\n            first = first.replace(\"\\\\\", \"\");\n        }\n        if (pr.last != null) {\n            last = pr.last.getValue(STRING);\n            last = last.replace(\"\\\\\", \"\");\n        }\n        if (isLike) {\n            first = first.replace('%', WildcardQuery.WILDCARD_STRING);\n            first = first.replace('_', WildcardQuery.WILDCARD_CHAR);\n            int indexOfWS = first.indexOf(WildcardQuery.WILDCARD_STRING);\n            int indexOfWC = first.indexOf(WildcardQuery.WILDCARD_CHAR);\n            int len = first.length();\n            if (indexOfWS == len || indexOfWC == len) {\n                                first = first.substring(0, first.length() - 1);\n                if (JCR_PATH.equals(name)) {\n                    qs.add(new PrefixQuery(newPathTerm(first)));\n                } else {\n                    qs.add(new PrefixQuery(new Term(name, first)));\n                }\n            } else {\n                if (JCR_PATH.equals(name)) {\n                    qs.add(new WildcardQuery(newPathTerm(first)));\n                } else {\n                    qs.add(new WildcardQuery(new Term(name, first)));\n                }\n            }\n            continue;\n        }\n        if (first != null && first.equals(last) && pr.firstIncluding && pr.lastIncluding) {\n            if (JCR_PATH.equals(name)) {\n                qs.add(new TermQuery(newPathTerm(first)));\n            } else {\n                if (\"*\".equals(name)) {\n                    addReferenceConstraint(first, qs, reader);\n                } else {\n                    for (String t : tokenize(first, analyzer)) {\n                        qs.add(new TermQuery(new Term(name, t)));\n                    }\n                }\n            }\n            continue;\n        }\n        first = tokenizeAndPoll(first, analyzer);\n        last = tokenizeAndPoll(last, analyzer);\n        qs.add(TermRangeQuery.newStringRange(name, first, last, pr.firstIncluding, pr.lastIncluding));\n    }\n}", "lc": 4.090909090909091, "pi": 0.7142857142857143, "ma": 6.0, "nbd": 1.5, "ml": 4.0, "d": 2.3044982698961944, "mi": -1.5179237166618875, "fo": 4.166666666666667, "r": -0.028571428571428574, "e": 10.728598900981238}
{"project_name": "camel", "project_version": "remotes/origin/bugs-dot-jar_CAMEL-5261_55c2e2d8", "label": 1, "code": "@Override\nprotected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n    int consumers = getAndRemoveParameter(parameters, \"concurrentConsumers\", Integer.class, defaultConcurrentConsumers);\n    boolean limitConcurrentConsumers = getAndRemoveParameter(parameters, \"limitConcurrentConsumers\", Boolean.class, true);\n    if (limitConcurrentConsumers && consumers > maxConcurrentConsumers) {\n        throw new IllegalArgumentException(\"The limitConcurrentConsumers flag in set to true. ConcurrentConsumers cannot be set at a value greater than \" + maxConcurrentConsumers + \" was \" + consumers);\n    }\n    SedaEndpoint answer = new SedaEndpoint(uri, this, createQueue(uri, parameters), consumers);\n    answer.configureProperties(parameters);\n    return answer;\n}", "code_comment": NaN, "code_no_comment": "@Override\nprotected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n    int consumers = getAndRemoveParameter(parameters, \"concurrentConsumers\", Integer.class, defaultConcurrentConsumers);\n    boolean limitConcurrentConsumers = getAndRemoveParameter(parameters, \"limitConcurrentConsumers\", Boolean.class, true);\n    if (limitConcurrentConsumers && consumers > maxConcurrentConsumers) {\n        throw new IllegalArgumentException(\"The limitConcurrentConsumers flag in set to true. ConcurrentConsumers cannot be set at a value greater than \" + maxConcurrentConsumers + \" was \" + consumers);\n    }\n    SedaEndpoint answer = new SedaEndpoint(uri, this, createQueue(uri, parameters), consumers);\n    answer.configureProperties(parameters);\n    return answer;\n}", "lc": -0.13636363636363635, "pi": -0.36734693877551033, "ma": -0.16666666666666666, "nbd": -0.5, "ml": 0.0, "d": 0.2778052397429561, "mi": 0.06854029251505596, "fo": -0.16666666666666666, "r": -0.028571428571428574, "e": 0.19649136332292566}
{"project_name": "Lang", "project_version": 41, "label": 3, "code": "/**\n * <p>Gets the class name minus the package name from a String.</p>\n *\n * <p>The string passed in is assumed to be a class name - it is not checked.</p>\n *\n * @param className  the className to get the short name for\n * @return the class name of the class without the package name or an empty string\n */\npublic static String getShortClassName(String className) {\n    if (className == null) {\n        return StringUtils.EMPTY;\n    }\n    if (className.length() == 0) {\n        return StringUtils.EMPTY;\n    }\n    // Handle array encoding\n    // Strip Object type encoding\n    int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n    int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\n    String out = className.substring(lastDotIdx + 1);\n    if (innerIdx != -1) {\n        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n    }\n    return out;\n}", "code_comment": "/**\n * <p>Gets the class name minus the package name from a String.</p>\n *\n * <p>The string passed in is assumed to be a class name - it is not checked.</p>\n *\n * @param className  the className to get the short name for\n * @return the class name of the class without the package name or an empty string\n */\n", "code_no_comment": "public static String getShortClassName(String className) {\n    if (className == null) {\n        return StringUtils.EMPTY;\n    }\n    if (className.length() == 0) {\n        return StringUtils.EMPTY;\n    }\n            int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n    int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\n    String out = className.substring(lastDotIdx + 1);\n    if (innerIdx != -1) {\n        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n    }\n    return out;\n}", "lc": 0.045454545454545456, "pi": -0.37244897959183676, "ma": 0.16666666666666666, "nbd": -0.5, "ml": 0.25, "d": 0.47355412753336645, "mi": -0.08287926584456556, "fo": -0.08333333333333333, "r": 0.28571428571428575, "e": 0.2849525229033626}
{"project_name": "logging-log4j2", "project_version": "remotes/origin/bugs-dot-jar_LOG4J2-964_16ad8763", "label": 1, "code": "private void writeObject(final ObjectOutputStream out) throws IOException {\n    out.defaultWriteObject();\n    getFormattedMessage();\n    out.writeUTF(formattedMessage);\n    out.writeUTF(messagePattern);\n    out.writeInt(argArray.length);\n    stringArgs = new String[argArray.length];\n    int i = 0;\n    for (final Object obj : argArray) {\n        stringArgs[i] = obj.toString();\n        ++i;\n    }\n}", "code_comment": NaN, "code_no_comment": "private void writeObject(final ObjectOutputStream out) throws IOException {\n    out.defaultWriteObject();\n    getFormattedMessage();\n    out.writeUTF(formattedMessage);\n    out.writeUTF(messagePattern);\n    out.writeInt(argArray.length);\n    stringArgs = new String[argArray.length];\n    int i = 0;\n    for (final Object obj : argArray) {\n        stringArgs[i] = obj.toString();\n        ++i;\n    }\n}", "lc": -0.045454545454545456, "pi": -0.40816326530612235, "ma": -0.3333333333333333, "nbd": -0.5, "ml": -0.4166666666666667, "d": -0.06426099851705384, "mi": 0.06509893891597351, "fo": 0.0, "r": 0.05714285714285714, "e": -0.05421426154590737}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-4441_54c86ebb", "label": 1, "code": "/**\n *  Looks up a page by id from the {@link IPageStore}. <br/>\n *  If {@linkplain #pageClass} is specified then compares it against the stored instance class\n *  and returns the found instance only if they match.\n *\n *  @param pageId\n *             the id of the page to look for.\n *  @return the found page instance by id.\n */\nprivate IRequestablePage getStoredPage(final int pageId) {\n    IRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);\n    if (storedPageInstance != null) {\n        if (pageClass == null || pageClass.equals(storedPageInstance.getClass())) {\n            pageInstance = storedPageInstance;\n            pageInstanceIsFresh = false;\n            if (renderCount != null && pageInstance.getRenderCount() != renderCount) {\n                throw new StalePageException(pageInstance);\n            }\n        } else {\n            // the found page class doesn't match the requested one\n            storedPageInstance = null;\n        }\n    }\n    return storedPageInstance;\n}", "code_comment": "/**\n *  Looks up a page by id from the {@link IPageStore}. <br/>\n *  If {@linkplain #pageClass} is specified then compares it against the stored instance class\n *  and returns the found instance only if they match.\n *\n *  @param pageId\n *             the id of the page to look for.\n *  @return the found page instance by id.\n */\n", "code_no_comment": "private IRequestablePage getStoredPage(final int pageId) {\n    IRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);\n    if (storedPageInstance != null) {\n        if (pageClass == null || pageClass.equals(storedPageInstance.getClass())) {\n            pageInstance = storedPageInstance;\n            pageInstanceIsFresh = false;\n            if (renderCount != null && pageInstance.getRenderCount() != renderCount) {\n                throw new StalePageException(pageInstance);\n            }\n        } else {\n                        storedPageInstance = null;\n        }\n    }\n    return storedPageInstance;\n}", "lc": 0.045454545454545456, "pi": 0.872448979591837, "ma": 0.16666666666666666, "nbd": 0.5, "ml": 0.5, "d": 0.34107760751359373, "mi": -0.04072268425580734, "fo": -0.08333333333333333, "r": 0.1142857142857143, "e": 0.12137176044303394}
{"project_name": "jackrabbit-oak", "project_version": "remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd", "label": 1, "code": "/**\n * Creates a cursor which wraps another cursor and adds a path prefix to\n * each of row of the wrapped cursor. This method will return the passed\n * cursor as is if {@code path} is the empty string or the root path (\"/\").\n *\n * @param c    the cursor to wrap.\n * @param path the path prefix.\n * @return the cursor.\n */\npublic static Cursor newPrefixCursor(Cursor c, String path) {\n    if (path.isEmpty() || PathUtils.denotesRoot(path)) {\n        // no need to wrap\n        return c;\n    }\n    return new PrefixCursor(c, path);\n}", "code_comment": "/**\n * Creates a cursor which wraps another cursor and adds a path prefix to\n * each of row of the wrapped cursor. This method will return the passed\n * cursor as is if {@code path} is the empty string or the root path (\"/\").\n *\n * @param c    the cursor to wrap.\n * @param path the path prefix.\n * @return the cursor.\n */\n", "code_no_comment": "public static Cursor newPrefixCursor(Cursor c, String path) {\n    if (path.isEmpty() || PathUtils.denotesRoot(path)) {\n                return c;\n    }\n    return new PrefixCursor(c, path);\n}", "lc": -0.36363636363636365, "pi": -0.13775510204081634, "ma": -0.3333333333333333, "nbd": -0.5, "ml": 0.0, "d": -0.3806228373702422, "mi": 0.5741324921135648, "fo": -0.3333333333333333, "r": 1.1428571428571428, "e": -0.16422749602751402}
{"project_name": "wicket", "project_version": "remotes/origin/bugs-dot-jar_WICKET-3603_aa1d177a", "label": 1, "code": "private void addToolbar(final AbstractToolbar toolbar, final RepeatingView container) {\n    if (toolbar == null) {\n        throw new IllegalArgumentException(\"argument [toolbar] cannot be null\");\n    }\n    container.add(toolbar);\n}", "code_comment": NaN, "code_no_comment": "private void addToolbar(final AbstractToolbar toolbar, final RepeatingView container) {\n    if (toolbar == null) {\n        throw new IllegalArgumentException(\"argument [toolbar] cannot be null\");\n    }\n    container.add(toolbar);\n}", "lc": -0.36363636363636365, "pi": -0.13775510204081634, "ma": -0.16666666666666666, "nbd": -0.5, "ml": -0.25, "d": -0.3806228373702422, "mi": 0.5965012905075997, "fo": -0.4166666666666667, "r": 1.0857142857142859, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-776_dc9f23d9", "label": 3, "code": "/**\n * A convenience method for setting the end timestamp accepted by the timestamp filter.\n *\n * @param is\n *          the iterator setting object to configure\n * @param end\n *          the end timestamp (yyyyMMddHHmmssz)\n * @param endInclusive\n *          boolean indicating whether the end is inclusive\n */\npublic static void setEnd(IteratorSetting is, String end, boolean endInclusive) {\n    is.addOption(END, end);\n    is.addOption(END_INCL, Boolean.toString(endInclusive));\n}", "code_comment": "/**\n * A convenience method for setting the end timestamp accepted by the timestamp filter.\n *\n * @param is\n *          the iterator setting object to configure\n * @param end\n *          the end timestamp (yyyyMMddHHmmssz)\n * @param endInclusive\n *          boolean indicating whether the end is inclusive\n */\n", "code_no_comment": "public static void setEnd(IteratorSetting is, String end, boolean endInclusive) {\n    is.addOption(END, end);\n    is.addOption(END_INCL, Boolean.toString(endInclusive));\n}", "lc": -0.45454545454545453, "pi": -0.5204081632653061, "ma": -0.5, "nbd": -1.0, "ml": -0.4166666666666667, "d": -0.3806228373702422, "mi": 0.7636937195296818, "fo": -0.25, "r": 2.5142857142857147, "e": -0.16422749602751402}
{"project_name": "accumulo", "project_version": "remotes/origin/bugs-dot-jar_ACCUMULO-217_add180fb", "label": 1, "code": "@Override\npublic void checkIteratorConflicts(String tableName, IteratorSetting setting) throws AccumuloException, TableNotFoundException {\n    for (IteratorScope scope : setting.getScopes()) {\n        String scopeStr = String.format(\"%s%s\", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase());\n        String nameStr = String.format(\"%s.%s\", scopeStr, setting.getName());\n        String optStr = String.format(\"%s.opt.\", nameStr);\n        Map<String, String> optionConflicts = new TreeMap<String, String>();\n        for (Entry<String, String> property : this.getProperties(tableName)) {\n            if (property.getKey().startsWith(scopeStr)) {\n                if (property.getKey().equals(nameStr))\n                    throw new IllegalArgumentException(\"iterator name conflict for \" + setting.getName() + \": \" + property.getKey() + \"=\" + property.getValue());\n                if (property.getKey().startsWith(optStr))\n                    optionConflicts.put(property.getKey(), property.getValue());\n                if (property.getKey().contains(\".opt.\"))\n                    continue;\n                String[] parts = property.getValue().split(\",\");\n                if (parts.length != 2)\n                    throw new AccumuloException(\"Bad value for existing iterator setting: \" + property.getKey() + \"=\" + property.getValue());\n                try {\n                    if (Integer.parseInt(parts[0]) == setting.getPriority())\n                        throw new IllegalArgumentException(\"iterator priority conflict: \" + property.getKey() + \"=\" + property.getValue());\n                } catch (NumberFormatException e) {\n                    throw new AccumuloException(\"Bad value for existing iterator setting: \" + property.getKey() + \"=\" + property.getValue());\n                }\n            }\n        }\n        if (optionConflicts.size() > 0)\n            throw new IllegalArgumentException(\"iterator options conflict for \" + setting.getName() + \": \" + optionConflicts);\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void checkIteratorConflicts(String tableName, IteratorSetting setting) throws AccumuloException, TableNotFoundException {\n    for (IteratorScope scope : setting.getScopes()) {\n        String scopeStr = String.format(\"%s%s\", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase());\n        String nameStr = String.format(\"%s.%s\", scopeStr, setting.getName());\n        String optStr = String.format(\"%s.opt.\", nameStr);\n        Map<String, String> optionConflicts = new TreeMap<String, String>();\n        for (Entry<String, String> property : this.getProperties(tableName)) {\n            if (property.getKey().startsWith(scopeStr)) {\n                if (property.getKey().equals(nameStr))\n                    throw new IllegalArgumentException(\"iterator name conflict for \" + setting.getName() + \": \" + property.getKey() + \"=\" + property.getValue());\n                if (property.getKey().startsWith(optStr))\n                    optionConflicts.put(property.getKey(), property.getValue());\n                if (property.getKey().contains(\".opt.\"))\n                    continue;\n                String[] parts = property.getValue().split(\",\");\n                if (parts.length != 2)\n                    throw new AccumuloException(\"Bad value for existing iterator setting: \" + property.getKey() + \"=\" + property.getValue());\n                try {\n                    if (Integer.parseInt(parts[0]) == setting.getPriority())\n                        throw new IllegalArgumentException(\"iterator priority conflict: \" + property.getKey() + \"=\" + property.getValue());\n                } catch (NumberFormatException e) {\n                    throw new AccumuloException(\"Bad value for existing iterator setting: \" + property.getKey() + \"=\" + property.getValue());\n                }\n            }\n        }\n        if (optionConflicts.size() > 0)\n            throw new IllegalArgumentException(\"iterator options conflict for \" + setting.getName() + \": \" + optionConflicts);\n    }\n}", "lc": 0.7272727272727273, "pi": 1.846938775510204, "ma": 2.1666666666666665, "nbd": 1.0, "ml": 1.0833333333333333, "d": 0.5308947108255069, "mi": -0.6696300544880991, "fo": 2.3333333333333335, "r": -0.028571428571428574, "e": 1.4975651123646034}
{"project_name": "Closure", "project_version": 22, "label": 2, "code": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    // so we'll allow it.\n    if (n.isEmpty() || n.isComma()) {\n        return;\n    }\n    if (parent == null) {\n        return;\n    }\n    // fix up the tree in more clever ways when these are removed.\n    if (parent.getType() == Token.COMMA) {\n        Node gramps = parent.getParent();\n        if (gramps.isCall() && parent == gramps.getFirstChild()) {\n            if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n                return;\n            }\n        }\n        // be attached to the name. This check should not complain about it.\n        if (n == parent.getLastChild()) {\n            for (Node an : parent.getAncestors()) {\n                int ancestorType = an.getType();\n                if (ancestorType == Token.COMMA)\n                    continue;\n                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n                    return;\n                else\n                    break;\n            }\n        }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n        if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n        } else {\n            return;\n        }\n    }\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n        if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n            return;\n        } else if (n.isExprResult()) {\n            return;\n        }\n        String msg = \"This code lacks side-effects. Is there a bug?\";\n        if (n.isString()) {\n            msg = \"Is there a missing '+' on the previous line?\";\n        } else if (isSimpleOp) {\n            msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";\n        }\n        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n        // try to protect side-effect free statements as well.\n        if (!NodeUtil.isStatement(n)) {\n            problemNodes.add(n);\n        }\n    }\n}", "code_comment": NaN, "code_no_comment": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n        if (n.isEmpty() || n.isComma()) {\n        return;\n    }\n    if (parent == null) {\n        return;\n    }\n        if (parent.getType() == Token.COMMA) {\n        Node gramps = parent.getParent();\n        if (gramps.isCall() && parent == gramps.getFirstChild()) {\n            if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n                return;\n            }\n        }\n                if (n == parent.getLastChild()) {\n            for (Node an : parent.getAncestors()) {\n                int ancestorType = an.getType();\n                if (ancestorType == Token.COMMA)\n                    continue;\n                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n                    return;\n                else\n                    break;\n            }\n        }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n        if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n        } else {\n            return;\n        }\n    }\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n        if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n            return;\n        } else if (n.isExprResult()) {\n            return;\n        }\n        String msg = \"This code lacks side-effects. Is there a bug?\";\n        if (n.isString()) {\n            msg = \"Is there a missing '+' on the previous line?\";\n        } else if (isSimpleOp) {\n            msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";\n        }\n        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n                if (!NodeUtil.isStatement(n)) {\n            problemNodes.add(n);\n        }\n    }\n}", "lc": 1.7272727272727273, "pi": 0.9438775510204083, "ma": 2.6666666666666665, "nbd": 0.5, "ml": 4.0, "d": 1.0074147305981218, "mi": -0.9813593346716377, "fo": 2.9166666666666665, "r": -0.028571428571428574, "e": 3.06924760473015}
{"project_name": "commons-math", "project_version": "remotes/origin/bugs-dot-jar_MATH-1300_1d635088", "label": 1, "code": "/**\n * Generates random bytes and places them into a user-supplied\n * byte array.  The number of random bytes produced is equal to\n * the length of the byte array.\n * <p>\n * The default implementation fills the array with bytes extracted from\n * random integers generated using {@link #nextInt}.</p>\n *\n * @param bytes the non-null byte array in which to put the\n * random bytes\n */\n@Override\npublic void nextBytes(byte[] bytes) {\n    int bytesOut = 0;\n    while (bytesOut < bytes.length) {\n        int randInt = nextInt();\n        for (int i = 0; i < 3; i++) {\n            if (i > 0) {\n                randInt >>= 8;\n            }\n            bytes[bytesOut++] = (byte) randInt;\n            if (bytesOut == bytes.length) {\n                return;\n            }\n        }\n    }\n}", "code_comment": "/**\n * Generates random bytes and places them into a user-supplied\n * byte array.  The number of random bytes produced is equal to\n * the length of the byte array.\n * <p>\n * The default implementation fills the array with bytes extracted from\n * random integers generated using {@link #nextInt}.</p>\n *\n * @param bytes the non-null byte array in which to put the\n * random bytes\n */\n", "code_no_comment": "@Override\npublic void nextBytes(byte[] bytes) {\n    int bytesOut = 0;\n    while (bytesOut < bytes.length) {\n        int randInt = nextInt();\n        for (int i = 0; i < 3; i++) {\n            if (i > 0) {\n                randInt >>= 8;\n            }\n            bytes[bytesOut++] = (byte) randInt;\n            if (bytesOut == bytes.length) {\n                return;\n            }\n        }\n    }\n}", "lc": 0.09090909090909091, "pi": 1.1581632653061225, "ma": 0.16666666666666666, "nbd": 0.5, "ml": 0.16666666666666666, "d": 0.9045971329708355, "mi": -0.04531115572125032, "fo": -0.4166666666666667, "r": 0.2571428571428572, "e": 0.2653021016699432}
