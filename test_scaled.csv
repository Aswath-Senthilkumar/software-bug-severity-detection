project_name,project_version,label,code,code_comment,code_no_comment,lc,pi,ma,nbd,ml,d,mi,fo,r,e
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2249_6dde8e9d,1,"@Override
public void restrict(FilterImpl f) {
    if (propertyName != null) {
        if (f.getSelector().equals(selector)) {
            String pn = normalizePropertyName(propertyName);
            f.restrictProperty(pn, Operator.NOT_EQUAL, null);
        }
    }
    f.restrictFulltextCondition(fullTextSearchExpression.currentValue().getValue(Type.STRING));
}",,"@Override
public void restrict(FilterImpl f) {
    if (propertyName != null) {
        if (f.getSelector().equals(selector)) {
            String pn = normalizePropertyName(propertyName);
            f.restrictProperty(pn, Operator.NOT_EQUAL, null);
        }
    }
    f.restrictFulltextCondition(fullTextSearchExpression.currentValue().getValue(Type.STRING));
}",-0.18181818181818182,0.7040816326530615,-0.16666666666666666,0.0,0.0,-0.12951062778052397,0.2033266418124464,0.08333333333333333,0.20000000000000004,-0.0892492322715767
Compress,24,0,"/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */
public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
    // Skip leading spaces
    while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
    // Trim all trailing NULs and spaces.
    // The ustar and POSIX tar specs require a trailing NUL or
    // space but some implementations use the extra digit for big
    // sizes/uids/gids ...
    byte trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    trailer = buffer[end - 1];
    while (start < end - 1 && (trailer == 0 || trailer == ' ')) {
        end--;
        trailer = buffer[end - 1];
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
        // CheckStyle:MagicNumber OFF
        if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
        // convert from ASCII
        result = (result << 3) + (currentByte - '0');
    // CheckStyle:MagicNumber ON
    }
    return result;
}","/**
 * Parse an octal string from a buffer.
 *
 * <p>Leading spaces are ignored.
 * The buffer must contain a trailing space or NUL,
 * and may contain an additional trailing space or NUL.</p>
 *
 * <p>The input buffer is allowed to contain all NULs,
 * in which case the method returns 0L
 * (this allows for missing fields).</p>
 *
 * <p>To work-around some tar implementations that insert a
 * leading NUL this method returns 0 if it detects a leading NUL
 * since Commons Compress 1.4.</p>
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse - must be at least 2 bytes.
 * @return The long value of the octal string.
 * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
 */
","public static long parseOctal(final byte[] buffer, final int offset, final int length) {
    long result = 0;
    int end = offset + length;
    int start = offset;
    if (length < 2) {
        throw new IllegalArgumentException(""Length "" + length + "" must be at least 2"");
    }
    if (buffer[start] == 0) {
        return 0L;
    }
        while (start < end) {
        if (buffer[start] == ' ') {
            start++;
        } else {
            break;
        }
    }
                    byte trailer = buffer[end - 1];
    if (trailer == 0 || trailer == ' ') {
        end--;
    } else {
        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));
    }
    trailer = buffer[end - 1];
    while (start < end - 1 && (trailer == 0 || trailer == ' ')) {
        end--;
        trailer = buffer[end - 1];
    }
    for (; start < end; start++) {
        final byte currentByte = buffer[start];
                if (currentByte < '0' || currentByte > '7') {
            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));
        }
                result = (result << 3) + (currentByte - '0');
        }
    return result;
}",1.0454545454545454,-0.0714285714285715,1.5,0.0,1.0,3.5739001482946122,-0.6925724118153144,-0.3333333333333333,-0.028571428571428574,5.061037086529525
Closure,43,2,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    inputId = t.getInputId();
    attachLiteralTypes(t, n);
    switch(n.getType()) {
        case Token.CALL:
            checkForClassDefiningCalls(t, n, parent);
            checkForCallingConventionDefiningCalls(n, delegateCallingConventions);
            break;
        case Token.FUNCTION:
            if (t.getInput() == null || !t.getInput().isExtern()) {
                nonExternFunctions.add(n);
            }
            // Hoisted functions are handled during pre-traversal.
            if (!NodeUtil.isHoistedFunctionDeclaration(n)) {
                defineFunctionLiteral(n, parent);
            }
            break;
        case Token.ASSIGN:
            // Handle initialization of properties.
            Node firstChild = n.getFirstChild();
            if (firstChild.isGetProp() && firstChild.isQualifiedName()) {
                maybeDeclareQualifiedName(t, n.getJSDocInfo(), firstChild, n, firstChild.getNext());
            }
            break;
        case Token.CATCH:
            defineCatch(n, parent);
            break;
        case Token.VAR:
            defineVar(n, parent);
            break;
        case Token.GETPROP:
            // Handle stubbed properties.
            if (parent.isExprResult() && n.isQualifiedName()) {
                maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);
            }
            break;
    }
// Analyze any @lends object literals in this statement.
}",,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    inputId = t.getInputId();
    attachLiteralTypes(t, n);
    switch(n.getType()) {
        case Token.CALL:
            checkForClassDefiningCalls(t, n, parent);
            checkForCallingConventionDefiningCalls(n, delegateCallingConventions);
            break;
        case Token.FUNCTION:
            if (t.getInput() == null || !t.getInput().isExtern()) {
                nonExternFunctions.add(n);
            }
                        if (!NodeUtil.isHoistedFunctionDeclaration(n)) {
                defineFunctionLiteral(n, parent);
            }
            break;
        case Token.ASSIGN:
                        Node firstChild = n.getFirstChild();
            if (firstChild.isGetProp() && firstChild.isQualifiedName()) {
                maybeDeclareQualifiedName(t, n.getJSDocInfo(), firstChild, n, firstChild.getNext());
            }
            break;
        case Token.CATCH:
            defineCatch(n, parent);
            break;
        case Token.VAR:
            defineVar(n, parent);
            break;
        case Token.GETPROP:
                        if (parent.isExprResult() && n.isQualifiedName()) {
                maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);
            }
            break;
    }
}",1.0,0.6887755102040817,2.1666666666666665,0.5,1.4166666666666667,0.4498269896193773,-0.6779466590192145,1.4166666666666667,-0.028571428571428574,0.7446473160556962
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2494_0dc92ca1,1,"public void clear() {
    sum = 0;
    count = 0;
    partialStdDev = 0;
}",,"public void clear() {
    sum = 0;
    count = 0;
    partialStdDev = 0;
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7613994837969603,-0.5,2.6,-0.16422749602751402
Math,90,1,"/**
 * Adds 1 to the frequency count for v.
 * <p>
 * If other objects have already been added to this Frequency, v must
 * be comparable to those that have already been added.
 * </p>
 *
 * @param v the value to add.
 * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries
 * @throws ClassCastException if <code>v</code> is not Comparable
 * @deprecated use {@link #addValue(Comparable)} instead
 */
@Deprecated
public void addValue(Object v) {
    /**
     * Adds 1 to the frequency count for v.
     * <p>
     * If other objects have already been added to this Frequency, v must
     * be comparable to those that have already been added.
     * </p>
     *
     * @param v the value to add.
     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries
     */
    Object obj = v;
    if (v instanceof Integer) {
        obj = Long.valueOf(((Integer) v).longValue());
    }
    try {
        Long count = (Long) freqTable.get(obj);
        if (count == null) {
            freqTable.put(obj, Long.valueOf(1));
        } else {
            freqTable.put(obj, Long.valueOf(count.longValue() + 1));
        }
    } catch (ClassCastException ex) {
        // TreeMap will throw ClassCastException if v is not comparable
        throw new IllegalArgumentException(""Value not comparable to existing values."");
    }
}","/**
 * Adds 1 to the frequency count for v.
 * <p>
 * If other objects have already been added to this Frequency, v must
 * be comparable to those that have already been added.
 * </p>
 *
 * @param v the value to add.
 * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries
 * @throws ClassCastException if <code>v</code> is not Comparable
 * @deprecated use {@link #addValue(Comparable)} instead
 */
/**
 * Adds 1 to the frequency count for v.
 * <p>
 * If other objects have already been added to this Frequency, v must
 * be comparable to those that have already been added.
 * </p>
 *
 * @param v the value to add.
 * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries
 */
","@Deprecated
public void addValue(Object v) {
    /**
     * Adds 1 to the frequency count for v.
     * <p>
     * If other objects have already been added to this Frequency, v must
     * be comparable to those that have already been added.
     * </p>
     *
     * @param v the value to add.
     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries
     */
    Object obj = v;
    if (v instanceof Integer) {
        obj = Long.valueOf(((Integer) v).longValue());
    }
    try {
        Long count = (Long) freqTable.get(obj);
        if (count == null) {
            freqTable.put(obj, Long.valueOf(1));
        } else {
            freqTable.put(obj, Long.valueOf(count.longValue() + 1));
        }
    } catch (ClassCastException ex) {
                throw new IllegalArgumentException(""Value not comparable to existing values."");
    }
}",0.5909090909090909,-0.051020408163265356,0.16666666666666666,0.0,-0.08333333333333333,0.03460207612456753,-0.33610553484370526,0.16666666666666666,0.0,0.02700005567904884
Cli,13,1,"public void processValues(final WriteableCommandLine commandLine, final ListIterator arguments, final Option option) throws OptionException {
    // count of arguments processed for this option.
    int argumentCount = 0;
    while (arguments.hasNext() && (argumentCount < maximum)) {
        final String allValuesQuoted = (String) arguments.next();
        final String allValues = stripBoundaryQuotes(allValuesQuoted);
        // should we ignore things that look like options?
        if (allValuesQuoted.equals(consumeRemaining)) {
            while (arguments.hasNext() && (argumentCount < maximum)) {
                ++argumentCount;
                commandLine.addValue(option, arguments.next());
            }
        } else // does it look like an option?
        if (commandLine.looksLikeOption(allValuesQuoted)) {
            arguments.previous();
            break;
        } else // should we split the string up?
        if (subsequentSplit) {
            final StringTokenizer values = new StringTokenizer(allValues, String.valueOf(subsequentSeparator));
            arguments.remove();
            while (values.hasMoreTokens() && (argumentCount < maximum)) {
                ++argumentCount;
                final String token = values.nextToken();
                commandLine.addValue(option, token);
                arguments.add(token);
            }
            if (values.hasMoreTokens()) {
                throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE, values.nextToken());
            }
        } else // it must be a value as it is
        {
            ++argumentCount;
            commandLine.addValue(option, allValues);
        }
    }
}",,"public void processValues(final WriteableCommandLine commandLine, final ListIterator arguments, final Option option) throws OptionException {
        int argumentCount = 0;
    while (arguments.hasNext() && (argumentCount < maximum)) {
        final String allValuesQuoted = (String) arguments.next();
        final String allValues = stripBoundaryQuotes(allValuesQuoted);
                if (allValuesQuoted.equals(consumeRemaining)) {
            while (arguments.hasNext() && (argumentCount < maximum)) {
                ++argumentCount;
                commandLine.addValue(option, arguments.next());
            }
        } else         if (commandLine.looksLikeOption(allValuesQuoted)) {
            arguments.previous();
            break;
        } else         if (subsequentSplit) {
            final StringTokenizer values = new StringTokenizer(allValues, String.valueOf(subsequentSeparator));
            arguments.remove();
            while (values.hasMoreTokens() && (argumentCount < maximum)) {
                ++argumentCount;
                final String token = values.nextToken();
                commandLine.addValue(option, token);
                arguments.add(token);
            }
            if (values.hasMoreTokens()) {
                throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE, values.nextToken());
            }
        } else         {
            ++argumentCount;
            commandLine.addValue(option, allValues);
        }
    }
}",0.9090909090909091,0.6836734693877553,1.0,1.5,1.1666666666666667,0.5348492338111717,-0.6042443361055352,1.0,-0.028571428571428574,0.8311725579383333
Lang,7,1,"// -----------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
// BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// Float.valueOf(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// Integer.valueOf(String)
// Double.valueOf(String)
// new Byte(String)
// Long.valueOf(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// Short.valueOf(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it
 * will be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x
 * prefix is more than 8.
 * Values with leading <code>0</code>'s will not be interpreted as octal.</p>
 *
 * <p>Then, the value is examined for a type qualifier on the end, i.e. one of
 * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can represent the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * <p>This method does not trim the input string, i.e., strings with leading
 * or trailing spaces will generate NumberFormatExceptions.</p>
 *
 * @param str  String containing a number, may be null
 * @return Number created from the string (or null if the input is null)
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
        // drop 0x
        int hexDigits = str.length() - 2;
        if (str.startsWith(""-"")) {
            // drop -
            hexDigits--;
        }
        if (hexDigits > 8) {
            // too many for an int
            return createLong(str);
        }
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = str.indexOf('e') + str.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos || expPos > str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            if (expPos > str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        // Requesting a specific type..
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                    // NOPMD
                    // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        // has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                // NOPMD
                // ignore the bad number
                }
            // $FALL-THROUGH$
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                // NOPMD
                // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                // NOPMD
                // ignore the bad number
                }
            // $FALL-THROUGH$
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        // small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            // Must be an int,long,bigint
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
            // NOPMD
            // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (NumberFormatException nfe) {
            // NOPMD
            // ignore the bad number
            }
            return createBigInteger(str);
        } else {
            // Must be a float,double,BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
            // NOPMD
            // ignore the bad number
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
            // NOPMD
            // ignore the bad number
            }
            return createBigDecimal(str);
        }
    }
}","/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it
 * will be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x
 * prefix is more than 8.
 * Values with leading <code>0</code>'s will not be interpreted as octal.</p>
 *
 * <p>Then, the value is examined for a type qualifier on the end, i.e. one of
 * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can represent the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * <p>This method does not trim the input string, i.e., strings with leading
 * or trailing spaces will generate NumberFormatExceptions.</p>
 *
 * @param str  String containing a number, may be null
 * @return Number created from the string (or null if the input is null)
 * @throws NumberFormatException if the value cannot be converted
 */
","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
                int hexDigits = str.length() - 2;
        if (str.startsWith(""-"")) {
                        hexDigits--;
        }
        if (hexDigits > 8) {
                        return createLong(str);
        }
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = str.indexOf('e') + str.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos || expPos > str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            if (expPos > str.length()) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar) && lastChar != '.') {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
                String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                                                            }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                                                return f;
                    }
                } catch (NumberFormatException nfe) {
                                                }
                        case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                                                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                                                }
                        default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
                if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
                        try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
                                    }
            try {
                return createLong(str);
            } catch (NumberFormatException nfe) {
                                    }
            return createBigInteger(str);
        } else {
                        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                                    }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
                                    }
            return createBigDecimal(str);
        }
    }
}",5.136363636363637,1.1887755102040816,6.166666666666667,1.5,5.666666666666667,3.9199209095402874,-1.6466876971608837,4.25,-0.028571428571428574,21.06078438930791
wicket,remotes/origin/bugs-dot-jar_WICKET-5965_31c88569,1,"/**
 *  Insert &lt;head&gt; open and close tag (with empty body) to the current position.
 */
private void insertHeadTag() {
    // Note: only the open-tag must be a AutoComponentTag
    final ComponentTag openTag = new ComponentTag(HEAD, TagType.OPEN);
    openTag.setId(HEADER_ID);
    openTag.setAutoComponentTag(true);
    openTag.setModified(true);
    final ComponentTag closeTag = new ComponentTag(HEAD, TagType.CLOSE);
    closeTag.setOpenTag(openTag);
    closeTag.setModified(true);
    // insert the tags into the markup stream
    markup.addMarkupElement(openTag);
    markup.addMarkupElement(closeTag);
}","/**
 *  Insert &lt;head&gt; open and close tag (with empty body) to the current position.
 */
","private void insertHeadTag() {
        final ComponentTag openTag = new ComponentTag(HEAD, TagType.OPEN);
    openTag.setId(HEADER_ID);
    openTag.setAutoComponentTag(true);
    openTag.setModified(true);
    final ComponentTag closeTag = new ComponentTag(HEAD, TagType.CLOSE);
    closeTag.setOpenTag(openTag);
    closeTag.setModified(true);
        markup.addMarkupElement(openTag);
    markup.addMarkupElement(closeTag);
}",-0.13636363636363635,-0.7551020408163265,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.1551476914252939,0.08333333333333333,0.3428571428571429,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-5319_c863b032,3,"/**
 *  Generate the next segment
 *
 *  @return segment
 */
public String next() {
    char a = characters[Math.abs(hash % characters.length)];
    hash++;
    char b = characters[Math.abs(hash % characters.length)];
    hash++;
    char c = characters[Math.abs(hash % characters.length)];
    String segment = """" + a + b + c;
    hash = hashString(segment);
    segment += String.format(""%02x"", Math.abs(hash % 256));
    hash = hashString(segment);
    return segment;
}","/**
 *  Generate the next segment
 *
 *  @return segment
 */
","public String next() {
    char a = characters[Math.abs(hash % characters.length)];
    hash++;
    char b = characters[Math.abs(hash % characters.length)];
    hash++;
    char c = characters[Math.abs(hash % characters.length)];
    String segment = """" + a + b + c;
    hash = hashString(segment);
    segment += String.format(""%02x"", Math.abs(hash % 256));
    hash = hashString(segment);
    return segment;
}",-0.09090909090909091,-0.7806122448979592,-0.5,-1.0,-0.4166666666666667,0.7128027681660901,0.030111843991970103,0.08333333333333333,0.6285714285714287,0.4799962309566946
commons-math,remotes/origin/bugs-dot-jar_MATH-358_061f5017,0,"/**
 * {@inheritDoc}
 */
@Override
public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {
    final int n = y0.length;
    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;
    // initialize working arrays
    if (y != y0) {
        System.arraycopy(y0, 0, y, 0, n);
    }
    final double[] yDot = new double[n];
    final double[] yTmp = new double[y0.length];
    // set up an interpolator sharing the integrator arrays
    final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();
    interpolator.reinitialize(y, forward);
    final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator();
    interpolatorTmp.reinitialize(yTmp, forward);
    // set up integration control objects
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    // compute the initial Nordsieck vector using the configured starter integrator
    start(t0, y, t);
    interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);
    interpolator.storeTime(stepStart);
    final int lastRow = nordsieck.getRowDimension() - 1;
    // reuse the step that was chosen by the starter integrator
    double hNew = stepSize;
    interpolator.rescale(hNew);
    boolean lastStep = false;
    while (!lastStep) {
        // shift all data
        interpolator.shift();
        double error = 0;
        for (boolean loop = true; loop; ) {
            stepSize = hNew;
            // evaluate error using the last term of the Taylor expansion
            error = 0;
            for (int i = 0; i < y0.length; ++i) {
                final double yScale = Math.abs(y[i]);
                final double tol = (vecAbsoluteTolerance == null) ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale) : (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);
                final double ratio = nordsieck.getEntry(lastRow, i) / tol;
                error += ratio * ratio;
            }
            error = Math.sqrt(error / y0.length);
            if (error <= 1.0) {
                // predict a first estimate of the state at step end
                final double stepEnd = stepStart + stepSize;
                interpolator.setInterpolatedTime(stepEnd);
                System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);
                // evaluate the derivative
                computeDerivatives(stepEnd, yTmp, yDot);
                // update Nordsieck vector
                final double[] predictedScaled = new double[y0.length];
                for (int j = 0; j < y0.length; ++j) {
                    predictedScaled[j] = stepSize * yDot[j];
                }
                final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);
                updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);
                // discrete events handling
                interpolatorTmp.reinitialize(stepEnd, stepSize, predictedScaled, nordsieckTmp);
                interpolatorTmp.storeTime(stepStart);
                interpolatorTmp.shift();
                interpolatorTmp.storeTime(stepEnd);
                if (manager.evaluateStep(interpolatorTmp)) {
                    final double dt = manager.getEventTime() - stepStart;
                    if (Math.abs(dt) <= Math.ulp(stepStart)) {
                        // rejecting the step would lead to a too small next step, we accept it
                        loop = false;
                    } else {
                        // reject the step to match exactly the next switch time
                        hNew = dt;
                        interpolator.rescale(hNew);
                    }
                } else {
                    // accept the step
                    scaled = predictedScaled;
                    nordsieck = nordsieckTmp;
                    interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);
                    loop = false;
                }
            } else {
                // reject the step and attempt to reduce error by stepsize control
                final double factor = computeStepGrowShrinkFactor(error);
                hNew = filterStep(stepSize * factor, forward, false);
                interpolator.rescale(hNew);
            }
        }
        // the step has been accepted (may have been truncated)
        final double nextStep = stepStart + stepSize;
        System.arraycopy(yTmp, 0, y, 0, n);
        interpolator.storeTime(nextStep);
        manager.stepAccepted(nextStep, y);
        lastStep = manager.stop();
        // provide the step data to the step handler
        for (StepHandler handler : stepHandlers) {
            interpolator.setInterpolatedTime(nextStep);
            handler.handleStep(interpolator, lastStep);
        }
        stepStart = nextStep;
        if (!lastStep && manager.reset(stepStart, y)) {
            // some events handler has triggered changes that
            // invalidate the derivatives, we need to restart from scratch
            start(stepStart, y, t);
            interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);
        }
        if (!lastStep) {
            // in some rare cases we may get here with stepSize = 0, for example
            // when an event occurs at integration start, reducing the first step
            // to zero; we have to reset the step to some safe non zero value
            stepSize = filterStep(stepSize, forward, true);
            // stepsize control for next step
            final double factor = computeStepGrowShrinkFactor(error);
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
            interpolator.rescale(hNew);
        }
    }
    final double stopTime = stepStart;
    stepStart = Double.NaN;
    stepSize = Double.NaN;
    return stopTime;
}","/**
 * {@inheritDoc}
 */
","@Override
public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {
    final int n = y0.length;
    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;
        if (y != y0) {
        System.arraycopy(y0, 0, y, 0, n);
    }
    final double[] yDot = new double[n];
    final double[] yTmp = new double[y0.length];
        final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();
    interpolator.reinitialize(y, forward);
    final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator();
    interpolatorTmp.reinitialize(yTmp, forward);
        for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
        start(t0, y, t);
    interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);
    interpolator.storeTime(stepStart);
    final int lastRow = nordsieck.getRowDimension() - 1;
        double hNew = stepSize;
    interpolator.rescale(hNew);
    boolean lastStep = false;
    while (!lastStep) {
                interpolator.shift();
        double error = 0;
        for (boolean loop = true; loop; ) {
            stepSize = hNew;
                        error = 0;
            for (int i = 0; i < y0.length; ++i) {
                final double yScale = Math.abs(y[i]);
                final double tol = (vecAbsoluteTolerance == null) ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale) : (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);
                final double ratio = nordsieck.getEntry(lastRow, i) / tol;
                error += ratio * ratio;
            }
            error = Math.sqrt(error / y0.length);
            if (error <= 1.0) {
                                final double stepEnd = stepStart + stepSize;
                interpolator.setInterpolatedTime(stepEnd);
                System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);
                                computeDerivatives(stepEnd, yTmp, yDot);
                                final double[] predictedScaled = new double[y0.length];
                for (int j = 0; j < y0.length; ++j) {
                    predictedScaled[j] = stepSize * yDot[j];
                }
                final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);
                updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);
                                interpolatorTmp.reinitialize(stepEnd, stepSize, predictedScaled, nordsieckTmp);
                interpolatorTmp.storeTime(stepStart);
                interpolatorTmp.shift();
                interpolatorTmp.storeTime(stepEnd);
                if (manager.evaluateStep(interpolatorTmp)) {
                    final double dt = manager.getEventTime() - stepStart;
                    if (Math.abs(dt) <= Math.ulp(stepStart)) {
                                                loop = false;
                    } else {
                                                hNew = dt;
                        interpolator.rescale(hNew);
                    }
                } else {
                                        scaled = predictedScaled;
                    nordsieck = nordsieckTmp;
                    interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);
                    loop = false;
                }
            } else {
                                final double factor = computeStepGrowShrinkFactor(error);
                hNew = filterStep(stepSize * factor, forward, false);
                interpolator.rescale(hNew);
            }
        }
                final double nextStep = stepStart + stepSize;
        System.arraycopy(yTmp, 0, y, 0, n);
        interpolator.storeTime(nextStep);
        manager.stepAccepted(nextStep, y);
        lastStep = manager.stop();
                for (StepHandler handler : stepHandlers) {
            interpolator.setInterpolatedTime(nextStep);
            handler.handleStep(interpolator, lastStep);
        }
        stepStart = nextStep;
        if (!lastStep && manager.reset(stepStart, y)) {
                                    start(stepStart, y, t);
            interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);
        }
        if (!lastStep) {
                                                stepSize = filterStep(stepSize, forward, true);
                        final double factor = computeStepGrowShrinkFactor(error);
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
            interpolator.rescale(hNew);
        }
    }
    final double stopTime = stepStart;
    stepStart = Double.NaN;
    stepSize = Double.NaN;
    return stopTime;
}",4.090909090909091,1.5306122448979589,1.8333333333333333,1.5,2.0833333333333335,4.493326742461691,-1.406940063091483,3.5833333333333335,-0.028571428571428574,28.23659741049593
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1312_d9ab8449,1,"/**
 * Converts the current object to the relevant thrift type. The object returned from this contains a non-destroyable version of the
 * {@link AuthenticationToken}, so this should be used just before placing on the wire, and references to it should be tightly controlled.
 */
public TCredentials toThrift(Instance instance) {
    return new TCredentials(principal, token.getClass().getName(), ByteBuffer.wrap(AuthenticationTokenSerializer.serialize(token)), instance.getInstanceID());
}","/**
 * Converts the current object to the relevant thrift type. The object returned from this contains a non-destroyable version of the
 * {@link AuthenticationToken}, so this should be used just before placing on the wire, and references to it should be tightly controlled.
 */
","public TCredentials toThrift(Instance instance) {
    return new TCredentials(principal, token.getClass().getName(), ByteBuffer.wrap(AuthenticationTokenSerializer.serialize(token)), instance.getInstanceID());
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8884427874964153,-0.08333333333333333,0.1142857142857143,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2246_dcadb0e1,1,"private void collectUUIDs(Tree tree) {
    if (tree == null) {
        return;
    }
    String uuid = TreeUtil.getString(tree, JcrConstants.JCR_UUID);
    if (uuid != null) {
        uuids.add(uuid);
    }
    for (Tree child : tree.getChildren()) {
        collectUUIDs(child);
    }
}",,"private void collectUUIDs(Tree tree) {
    if (tree == null) {
        return;
    }
    String uuid = TreeUtil.getString(tree, JcrConstants.JCR_UUID);
    if (uuid != null) {
        uuids.add(uuid);
    }
    for (Tree child : tree.getChildren()) {
        collectUUIDs(child);
    }
}",-0.09090909090909091,-0.2346938775510204,0.0,-0.5,-0.08333333333333333,-0.06426099851705384,0.14195583596214523,-0.16666666666666666,0.4857142857142857,-0.08707346636343001
commons-math,remotes/origin/bugs-dot-jar_MATH-320_c06cc933,1,"/**
 * {@inheritDoc}
 */
public DecompositionSolver getSolver() {
    return new Solver(singularValues, getUT(), getV(), getRank() == singularValues.length);
}","/**
 * {@inheritDoc}
 */
","public DecompositionSolver getSolver() {
    return new Solver(singularValues, getUT(), getV(), getRank() == singularValues.length);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9736162890737022,-0.25,2.742857142857143,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2117_c7669f31,3,"private void collectIndexEditors(NodeBuilder definitions, NodeState before) throws CommitFailedException {
    for (String name : definitions.getChildNodeNames()) {
        NodeBuilder definition = definitions.getChildNode(name);
        if (Objects.equal(async, definition.getString(ASYNC_PROPERTY_NAME))) {
            String type = definition.getString(TYPE_PROPERTY_NAME);
            boolean shouldReindex = shouldReindex(definition, before, name);
            Editor editor = provider.getIndexEditor(type, definition, root, updateCallback);
            if (editor == null) {
                // trigger reindexing when an indexer becomes available
                definition.setProperty(REINDEX_PROPERTY_NAME, true);
            } else if (shouldReindex) {
                if (definition.getBoolean(REINDEX_ASYNC_PROPERTY_NAME) && definition.getString(ASYNC_PROPERTY_NAME) == null) {
                    // switch index to an async update mode
                    definition.setProperty(ASYNC_PROPERTY_NAME, ASYNC_REINDEX_VALUE);
                } else {
                    definition.setProperty(REINDEX_PROPERTY_NAME, false);
                    // beforehand, we'll remove all child nodes
                    for (String rm : definition.getChildNodeNames()) {
                        definition.getChildNode(rm).remove();
                    }
                    reindex.put(concat(getPath(), INDEX_DEFINITIONS_NAME, name), editor);
                }
            } else {
                editors.add(editor);
            }
        }
    }
}",,"private void collectIndexEditors(NodeBuilder definitions, NodeState before) throws CommitFailedException {
    for (String name : definitions.getChildNodeNames()) {
        NodeBuilder definition = definitions.getChildNode(name);
        if (Objects.equal(async, definition.getString(ASYNC_PROPERTY_NAME))) {
            String type = definition.getString(TYPE_PROPERTY_NAME);
            boolean shouldReindex = shouldReindex(definition, before, name);
            Editor editor = provider.getIndexEditor(type, definition, root, updateCallback);
            if (editor == null) {
                                definition.setProperty(REINDEX_PROPERTY_NAME, true);
            } else if (shouldReindex) {
                if (definition.getBoolean(REINDEX_ASYNC_PROPERTY_NAME) && definition.getString(ASYNC_PROPERTY_NAME) == null) {
                                        definition.setProperty(ASYNC_PROPERTY_NAME, ASYNC_REINDEX_VALUE);
                } else {
                    definition.setProperty(REINDEX_PROPERTY_NAME, false);
                                        for (String rm : definition.getChildNodeNames()) {
                        definition.getChildNode(rm).remove();
                    }
                    reindex.put(concat(getPath(), INDEX_DEFINITIONS_NAME, name), editor);
                }
            } else {
                editors.add(editor);
            }
        }
    }
}",0.5,1.673469387755102,0.5,2.0,0.5,-0.012852199703410724,-0.43533123028391196,1.0833333333333333,-0.028571428571428574,0.21869445479503685
Closure,97,1,"/**
 * Try to fold shift operations
 */
private Node tryFoldShift(Node n, Node left, Node right) {
    if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {
        double result;
        double lval = left.getDouble();
        double rval = right.getDouble();
        // a 32-bit range, since the user likely does not intend that.
        if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {
            error(BITWISE_OPERAND_OUT_OF_RANGE, left);
            return n;
        }
        // if the shift amount is outside [0,32)
        if (!(rval >= 0 && rval < 32)) {
            error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);
            return n;
        }
        // Convert the numbers to ints
        int lvalInt = (int) lval;
        if (lvalInt != lval) {
            error(FRACTIONAL_BITWISE_OPERAND, left);
            return n;
        }
        int rvalInt = (int) rval;
        if (rvalInt != rval) {
            error(FRACTIONAL_BITWISE_OPERAND, right);
            return n;
        }
        switch(n.getType()) {
            case Token.LSH:
                result = lvalInt << rvalInt;
                break;
            case Token.RSH:
                result = lvalInt >> rvalInt;
                break;
            case Token.URSH:
                // JavaScript handles zero shifts on signed numbers differently than
                // Java as an Java int can not represent the unsigned 32-bit number
                // where JavaScript can so use a long here.
                result = lvalInt >>> rvalInt;
                break;
            default:
                throw new AssertionError(""Unknown shift operator: "" + Node.tokenToName(n.getType()));
        }
        Node newNumber = Node.newNumber(result);
        n.getParent().replaceChild(n, newNumber);
        reportCodeChange();
        return newNumber;
    }
    return n;
}","/**
 * Try to fold shift operations
 */
","private Node tryFoldShift(Node n, Node left, Node right) {
    if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {
        double result;
        double lval = left.getDouble();
        double rval = right.getDouble();
                if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {
            error(BITWISE_OPERAND_OUT_OF_RANGE, left);
            return n;
        }
                if (!(rval >= 0 && rval < 32)) {
            error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);
            return n;
        }
                int lvalInt = (int) lval;
        if (lvalInt != lval) {
            error(FRACTIONAL_BITWISE_OPERAND, left);
            return n;
        }
        int rvalInt = (int) rval;
        if (rvalInt != rval) {
            error(FRACTIONAL_BITWISE_OPERAND, right);
            return n;
        }
        switch(n.getType()) {
            case Token.LSH:
                result = lvalInt << rvalInt;
                break;
            case Token.RSH:
                result = lvalInt >> rvalInt;
                break;
            case Token.URSH:
                                                                result = lvalInt >>> rvalInt;
                break;
            default:
                throw new AssertionError(""Unknown shift operator: "" + Node.tokenToName(n.getType()));
        }
        Node newNumber = Node.newNumber(result);
        n.getParent().replaceChild(n, newNumber);
        reportCodeChange();
        return newNumber;
    }
    return n;
}",1.3181818181818181,0.4897959183673469,1.6666666666666667,0.5,1.0833333333333333,2.899653979238755,-0.7800401491253229,0.75,-0.028571428571428574,4.505749932542691
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-3408_81d25bc2,3,"public static String bigNumber(long big, String[] SUFFIXES, long base) {
    return String.format(""%,d"", big);
}",,"public static String bigNumber(long big, String[] SUFFIXES, long base) {
    return String.format(""%,d"", big);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9888156008029825,-0.4166666666666667,-0.028571428571428574,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-1067_aff82362,1,"/**
 * Returns the regularized beta function I(x, a, b).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedBetaFunction.html"">
 * Regularized Beta Function</a>.</li>
 * <li>
 * <a href=""http://functions.wolfram.com/06.21.10.0001.01"">
 * Regularized Beta Function</a>.</li>
 * </ul>
 *
 * @param x the value.
 * @param a Parameter {@code a}.
 * @param b Parameter {@code b}.
 * @param epsilon When the absolute value of the nth item in the
 * series is less than epsilon the approximation ceases to calculate
 * further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized beta function I(x, a, b)
 * @throws org.apache.commons.math3.exception.MaxCountExceededException
 * if the algorithm fails to converge.
 */
public static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations) {
    double ret;
    if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || x < 0 || x > 1 || a <= 0.0 || b <= 0.0) {
        ret = Double.NaN;
    } else if (x > (a + 1.0) / (a + b + 2.0)) {
        ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);
    } else {
        ContinuedFraction fraction = new ContinuedFraction() {

            @Override
            protected double getB(int n, double x) {
                double ret;
                double m;
                if (n % 2 == 0) {
                    // even
                    m = n / 2.0;
                    ret = (m * (b - m) * x) / ((a + (2 * m) - 1) * (a + (2 * m)));
                } else {
                    m = (n - 1.0) / 2.0;
                    ret = -((a + m) * (a + b + m) * x) / ((a + (2 * m)) * (a + (2 * m) + 1.0));
                }
                return ret;
            }

            @Override
            protected double getA(int n, double x) {
                return 1.0;
            }
        };
        ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log1p(-x)) - FastMath.log(a) - logBeta(a, b)) * 1.0 / fraction.evaluate(x, epsilon, maxIterations);
    }
    return ret;
}","/**
 * Returns the regularized beta function I(x, a, b).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedBetaFunction.html"">
 * Regularized Beta Function</a>.</li>
 * <li>
 * <a href=""http://functions.wolfram.com/06.21.10.0001.01"">
 * Regularized Beta Function</a>.</li>
 * </ul>
 *
 * @param x the value.
 * @param a Parameter {@code a}.
 * @param b Parameter {@code b}.
 * @param epsilon When the absolute value of the nth item in the
 * series is less than epsilon the approximation ceases to calculate
 * further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized beta function I(x, a, b)
 * @throws org.apache.commons.math3.exception.MaxCountExceededException
 * if the algorithm fails to converge.
 */
","public static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations) {
    double ret;
    if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || x < 0 || x > 1 || a <= 0.0 || b <= 0.0) {
        ret = Double.NaN;
    } else if (x > (a + 1.0) / (a + b + 2.0)) {
        ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);
    } else {
        ContinuedFraction fraction = new ContinuedFraction() {

            @Override
            protected double getB(int n, double x) {
                double ret;
                double m;
                if (n % 2 == 0) {
                                        m = n / 2.0;
                    ret = (m * (b - m) * x) / ((a + (2 * m) - 1) * (a + (2 * m)));
                } else {
                    m = (n - 1.0) / 2.0;
                    ret = -((a + m) * (a + b + m) * x) / ((a + (2 * m)) * (a + (2 * m) + 1.0));
                }
                return ret;
            }

            @Override
            protected double getA(int n, double x) {
                return 1.0;
            }
        };
        ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log1p(-x)) - FastMath.log(a) - logBeta(a, b)) * 1.0 / fraction.evaluate(x, epsilon, maxIterations);
    }
    return ret;
}",0.7272727272727273,1.5306122448979589,0.0,1.0,0.9166666666666666,3.508650519031143,-0.5970748494407804,0.3333333333333333,-0.028571428571428574,7.597778834252039
wicket,remotes/origin/bugs-dot-jar_WICKET-4116_4624ab3d,1,"/**
 *  @see org.apache.wicket.request.IRequestHandler#respond(org.apache.wicket.request.IRequestCycle)
 */
public void respond(final IRequestCycle requestCycle) {
    final IRequestablePage page = getPage();
    if (getComponent().getPage() == page) {
        boolean isAjax = ((WebRequest) requestCycle.getRequest()).isAjax();
        if (isAjax == false && listenerInterface.isRenderPageAfterInvocation()) {
            // schedule page render after current request handler is done. this can be
            // overridden during invocation of listener
            // method (i.e. by calling RequestCycle#setResponsePage)
            final IPageProvider pageProvider = new PageProvider(page);
            final RedirectPolicy policy = page.isPageStateless() ? RedirectPolicy.NEVER_REDIRECT : RedirectPolicy.AUTO_REDIRECT;
            requestCycle.scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(pageProvider, policy));
        }
        invokeListener();
    } else {
        throw new WicketRuntimeException(""Component "" + getComponent() + "" has been removed from page."");
    }
}","/**
 *  @see org.apache.wicket.request.IRequestHandler#respond(org.apache.wicket.request.IRequestCycle)
 */
","public void respond(final IRequestCycle requestCycle) {
    final IRequestablePage page = getPage();
    if (getComponent().getPage() == page) {
        boolean isAjax = ((WebRequest) requestCycle.getRequest()).isAjax();
        if (isAjax == false && listenerInterface.isRenderPageAfterInvocation()) {
                                                final IPageProvider pageProvider = new PageProvider(page);
            final RedirectPolicy policy = page.isPageStateless() ? RedirectPolicy.NEVER_REDIRECT : RedirectPolicy.AUTO_REDIRECT;
            requestCycle.scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(pageProvider, policy));
        }
        invokeListener();
    } else {
        throw new WicketRuntimeException(""Component "" + getComponent() + "" has been removed from page."");
    }
}",0.0,0.4438775510204082,0.16666666666666666,0.0,0.3333333333333333,0.19871478002965903,-0.0521938629194152,0.3333333333333333,-0.028571428571428574,0.1430780234794266
Codec,15,1,"/**
 * Used internally by the Soundex algorithm.
 *
 * Consonants from the same code group separated by W or H are treated as one.
 *
 * @param str
 *                  the cleaned working string to encode (in upper case).
 * @param index
 *                  the character position to encode
 * @return Mapping code for a particular character
 * @throws IllegalArgumentException
 *                  if the character is not mapped
 */
private char getMappingCode(final String str, final int index) {
    // map() throws IllegalArgumentException
    final char mappedChar = this.map(str.charAt(index));
    // HW rule check
    if (index > 1 && mappedChar != '0') {
        final char hwChar = str.charAt(index - 1);
        if ('H' == hwChar || 'W' == hwChar) {
            final char preHWChar = str.charAt(index - 2);
            final char firstCode = this.map(preHWChar);
            if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {
                return 0;
            }
        }
    }
    return mappedChar;
}","/**
 * Used internally by the Soundex algorithm.
 *
 * Consonants from the same code group separated by W or H are treated as one.
 *
 * @param str
 *                  the cleaned working string to encode (in upper case).
 * @param index
 *                  the character position to encode
 * @return Mapping code for a particular character
 * @throws IllegalArgumentException
 *                  if the character is not mapped
 */
","private char getMappingCode(final String str, final int index) {
        final char mappedChar = this.map(str.charAt(index));
        if (index > 1 && mappedChar != '0') {
        final char hwChar = str.charAt(index - 1);
        if ('H' == hwChar || 'W' == hwChar) {
            final char preHWChar = str.charAt(index - 2);
            final char firstCode = this.map(preHWChar);
            if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {
                return 0;
            }
        }
    }
    return mappedChar;
}",0.0,0.8826530612244898,0.0,0.5,0.5833333333333334,1.0647553138902621,-0.050473186119873975,-0.08333333333333333,2.142857142857143,0.629156119769917
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-776_dc9f23d9,3,"/**
 * A convenience method for setting the start timestamp accepted by the timestamp filter.
 *
 * @param is
 *          the iterator setting object to configure
 * @param start
 *          the start timestamp (yyyyMMddHHmmssz)
 * @param startInclusive
 *          boolean indicating whether the start is inclusive
 */
public static void setStart(IteratorSetting is, String start, boolean startInclusive) {
    is.addOption(START, start);
    is.addOption(START_INCL, Boolean.toString(startInclusive));
}","/**
 * A convenience method for setting the start timestamp accepted by the timestamp filter.
 *
 * @param is
 *          the iterator setting object to configure
 * @param start
 *          the start timestamp (yyyyMMddHHmmssz)
 * @param startInclusive
 *          boolean indicating whether the start is inclusive
 */
","public static void setStart(IteratorSetting is, String start, boolean startInclusive) {
    is.addOption(START, start);
    is.addOption(START_INCL, Boolean.toString(startInclusive));
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7636937195296818,-0.25,2.2571428571428576,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2899_31aea2ad,0,"private Set<String> beginClearingUnusedLogs() {
    Set<String> doomed = new HashSet<String>();
    ArrayList<String> otherLogsCopy = new ArrayList<String>();
    ArrayList<String> currentLogsCopy = new ArrayList<String>();
    // do not hold tablet lock while acquiring the log lock
    logLock.lock();
    synchronized (this) {
        if (removingLogs)
            throw new IllegalStateException(""Attempted to clear logs when removal of logs in progress"");
        for (DfsLogger logger : otherLogs) {
            otherLogsCopy.add(logger.toString());
            doomed.add(logger.toString());
        }
        for (DfsLogger logger : currentLogs) {
            currentLogsCopy.add(logger.toString());
            doomed.remove(logger.toString());
        }
        otherLogs = Collections.emptySet();
        if (doomed.size() > 0)
            removingLogs = true;
    }
    // do debug logging outside tablet lock
    for (String logger : otherLogsCopy) {
        log.debug(""Logs for memory compacted: "" + getExtent() + "" "" + logger.toString());
    }
    for (String logger : currentLogsCopy) {
        log.debug(""Logs for current memory: "" + getExtent() + "" "" + logger);
    }
    return doomed;
}",,"private Set<String> beginClearingUnusedLogs() {
    Set<String> doomed = new HashSet<String>();
    ArrayList<String> otherLogsCopy = new ArrayList<String>();
    ArrayList<String> currentLogsCopy = new ArrayList<String>();
        logLock.lock();
    synchronized (this) {
        if (removingLogs)
            throw new IllegalStateException(""Attempted to clear logs when removal of logs in progress"");
        for (DfsLogger logger : otherLogs) {
            otherLogsCopy.add(logger.toString());
            doomed.add(logger.toString());
        }
        for (DfsLogger logger : currentLogs) {
            currentLogsCopy.add(logger.toString());
            doomed.remove(logger.toString());
        }
        otherLogs = Collections.emptySet();
        if (doomed.size() > 0)
            removingLogs = true;
    }
        for (String logger : otherLogsCopy) {
        log.debug(""Logs for memory compacted: "" + getExtent() + "" "" + logger.toString());
    }
    for (String logger : currentLogsCopy) {
        log.debug(""Logs for current memory: "" + getExtent() + "" "" + logger);
    }
    return doomed;
}",0.6363636363636364,0.27040816326530603,0.6666666666666666,0.0,-0.08333333333333333,0.0761245674740485,-0.47462001720676805,0.8333333333333334,-0.028571428571428574,0.25235458131496785
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1215_a9efe3c4,0,"/**
 * Normalize the property name (including namespace remapping).
 *
 * @param propertyName the property name to normalize
 * @return the normalized property name
 */
protected String normalizePropertyName(String propertyName) {
    // where possible)
    if (query == null) {
        return propertyName;
    }
    if (propertyName == null) {
        return null;
    }
    int slash = propertyName.indexOf('/');
    if (slash < 0) {
        return normalizeNonRelativePropertyName(propertyName);
    }
    // relative properties
    String relativePath = PathUtils.getParentPath(propertyName);
    relativePath = query.getOakPath(relativePath);
    propertyName = PathUtils.getName(propertyName);
    propertyName = normalizeNonRelativePropertyName(propertyName);
    return PathUtils.concat(relativePath, propertyName);
}","/**
 * Normalize the property name (including namespace remapping).
 *
 * @param propertyName the property name to normalize
 * @return the normalized property name
 */
","protected String normalizePropertyName(String propertyName) {
        if (query == null) {
        return propertyName;
    }
    if (propertyName == null) {
        return null;
    }
    int slash = propertyName.indexOf('/');
    if (slash < 0) {
        return normalizeNonRelativePropertyName(propertyName);
    }
        String relativePath = PathUtils.getParentPath(propertyName);
    relativePath = query.getOakPath(relativePath);
    propertyName = PathUtils.getName(propertyName);
    propertyName = normalizeNonRelativePropertyName(propertyName);
    return PathUtils.concat(relativePath, propertyName);
}",0.13636363636363635,-0.43877551020408156,0.0,-0.5,0.08333333333333333,0.07217004448838364,-0.10782907943791242,0.08333333333333333,0.0,0.03536476201489629
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-846_7acb091a,3,"/**
 * Try to create or update the node. If there was a conflict, this method
 * throws an exception, even though the change is still applied.
 *
 * @param store the store
 * @param op the operation
 */
private void createOrUpdateNode(DocumentStore store, UpdateOp op) {
    Map<String, Object> map = store.createOrUpdate(Collection.NODES, op);
    if (baseRevision != null) {
        final AtomicReference<List<Revision>> collisions = new AtomicReference<List<Revision>>();
        Revision newestRev = mk.getNewestRevision(map, revision, new CollisionHandler() {

            @Override
            void uncommittedModification(Revision uncommitted) {
                if (collisions.get() == null) {
                    collisions.set(new ArrayList<Revision>());
                }
                collisions.get().add(uncommitted);
            }
        });
        String conflictMessage = null;
        if (newestRev == null) {
            if (op.isDelete || !op.isNew) {
                conflictMessage = ""The node "" + op.path + "" does not exist or is already deleted"";
            }
        } else {
            if (op.isNew) {
                conflictMessage = ""The node "" + op.path + "" was already added in revision\n"" + newestRev;
            } else if (mk.isRevisionNewer(newestRev, baseRevision) && (op.isDelete || isConflicting(map, op))) {
                conflictMessage = ""The node "" + op.path + "" was changed in revision\n"" + newestRev + "", which was applied after the base revision\n"" + baseRevision;
            }
        }
        if (conflictMessage != null) {
            conflictMessage += "", before\n"" + revision + ""; document:\n"" + map.toString().replaceAll("", _"", "",\n_"").replaceAll(""}, "", ""},\n"") + "",\nrevision order:\n"" + mk.getRevisionComparator();
            throw new MicroKernelException(conflictMessage);
        }
        // on a node are possible if property updates do not overlap)
        if (collisions.get() != null && isConflicting(map, op)) {
            for (Revision r : collisions.get()) {
                // mark collisions on commit root
                Collision c = new Collision(map, r, op, revision);
                boolean success = c.mark(store);
                if (!success) {
                // TODO: fail this commit
                }
            }
        }
    }
    int size = Utils.estimateMemoryUsage(map);
    if (size > MAX_DOCUMENT_SIZE) {
        UpdateOp[] split = splitDocument(map);
        // TODO check if the new main document is actually smaller;
        // otherwise, splitting doesn't make sense
        // the old version
        UpdateOp old = split[0];
        if (old != null) {
            store.createOrUpdate(Collection.NODES, old);
        }
        // the (shrunken) main document
        UpdateOp main = split[1];
        if (main != null) {
            store.createOrUpdate(Collection.NODES, main);
        }
    }
}","/**
 * Try to create or update the node. If there was a conflict, this method
 * throws an exception, even though the change is still applied.
 *
 * @param store the store
 * @param op the operation
 */
","private void createOrUpdateNode(DocumentStore store, UpdateOp op) {
    Map<String, Object> map = store.createOrUpdate(Collection.NODES, op);
    if (baseRevision != null) {
        final AtomicReference<List<Revision>> collisions = new AtomicReference<List<Revision>>();
        Revision newestRev = mk.getNewestRevision(map, revision, new CollisionHandler() {

            @Override
            void uncommittedModification(Revision uncommitted) {
                if (collisions.get() == null) {
                    collisions.set(new ArrayList<Revision>());
                }
                collisions.get().add(uncommitted);
            }
        });
        String conflictMessage = null;
        if (newestRev == null) {
            if (op.isDelete || !op.isNew) {
                conflictMessage = ""The node "" + op.path + "" does not exist or is already deleted"";
            }
        } else {
            if (op.isNew) {
                conflictMessage = ""The node "" + op.path + "" was already added in revision\n"" + newestRev;
            } else if (mk.isRevisionNewer(newestRev, baseRevision) && (op.isDelete || isConflicting(map, op))) {
                conflictMessage = ""The node "" + op.path + "" was changed in revision\n"" + newestRev + "", which was applied after the base revision\n"" + baseRevision;
            }
        }
        if (conflictMessage != null) {
            conflictMessage += "", before\n"" + revision + ""; document:\n"" + map.toString().replaceAll("", _"", "",\n_"").replaceAll(""}, "", ""},\n"") + "",\nrevision order:\n"" + mk.getRevisionComparator();
            throw new MicroKernelException(conflictMessage);
        }
                if (collisions.get() != null && isConflicting(map, op)) {
            for (Revision r : collisions.get()) {
                                Collision c = new Collision(map, r, op, revision);
                boolean success = c.mark(store);
                if (!success) {
                                }
            }
        }
    }
    int size = Utils.estimateMemoryUsage(map);
    if (size > MAX_DOCUMENT_SIZE) {
        UpdateOp[] split = splitDocument(map);
                                UpdateOp old = split[0];
        if (old != null) {
            store.createOrUpdate(Collection.NODES, old);
        }
                UpdateOp main = split[1];
        if (main != null) {
            store.createOrUpdate(Collection.NODES, main);
        }
    }
}",1.6818181818181819,0.7244897959183676,1.8333333333333333,1.0,2.0833333333333335,1.4562530894710826,-0.9544020648121597,1.1666666666666667,-0.028571428571428574,4.575520063731096
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1739_8188ef54,1,"@Override
public boolean evaluate() {
    // JCR 2.0 spec, 6.7.16 Comparison:
    // ""operand1 may evaluate to an array of values""
    PropertyValue p1 = operand1.currentProperty();
    if (p1 == null) {
        return false;
    }
    PropertyValue p2 = operand2.currentValue();
    if (p2 == null) {
        // even for ""null <> 'x'"" (same as in SQL)
        return false;
    }
    // property type of the value of operand1""
    try {
        p2 = convertValueToType(p2, p1);
    } catch (IllegalArgumentException ex) {
        // unable to convert, just skip this node
        return false;
    }
    return evaluate(p1, p2);
}",,"@Override
public boolean evaluate() {
            PropertyValue p1 = operand1.currentProperty();
    if (p1 == null) {
        return false;
    }
    PropertyValue p2 = operand2.currentValue();
    if (p2 == null) {
                return false;
    }
        try {
        p2 = convertValueToType(p2, p1);
    } catch (IllegalArgumentException ex) {
                return false;
    }
    return evaluate(p1, p2);
}",0.13636363636363635,-0.2346938775510204,0.0,-0.5,-0.08333333333333333,-0.0247157686604053,-0.04215658158875822,-0.16666666666666666,0.4857142857142857,-0.06338845559167555
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5,3,"public update_resultStandardScheme getScheme() {
    return new update_resultStandardScheme();
}",,"public update_resultStandardScheme getScheme() {
    return new update_resultStandardScheme();
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.2348723831373678,-0.5,2.142857142857143,-0.16422749602751402
Closure,106,2,"boolean canCollapseUnannotatedChildNames() {
    if (type == Type.OTHER || globalSets != 1 || localSets != 0) {
        return false;
    }
    if (isClassOrEnum) {
        return true;
    }
    return (type == Type.FUNCTION || aliasingGets == 0) && (parent == null || parent.canCollapseUnannotatedChildNames());
}",,"boolean canCollapseUnannotatedChildNames() {
    if (type == Type.OTHER || globalSets != 1 || localSets != 0) {
        return false;
    }
    if (isClassOrEnum) {
        return true;
    }
    return (type == Type.FUNCTION || aliasingGets == 0) && (parent == null || parent.canCollapseUnannotatedChildNames());
}",-0.22727272727272727,-0.17857142857142863,-0.16666666666666666,-0.5,0.25,0.13741967375185377,0.25150559219959845,-0.4166666666666667,1.7428571428571429,-0.00873732766263635
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2999_3bf07779,1,"@Override
public void propertyDeleted(PropertyState before) {
    markPropertyChanged(before.getName());
    checkAggregates(before.getName());
}",,"@Override
public void propertyDeleted(PropertyState before) {
    markPropertyChanged(before.getName());
    checkAggregates(before.getName());
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7516489819328936,-0.16666666666666666,0.0,-0.16422749602751402
Math,50,1,"/**
 * {@inheritDoc}
 */
protected final double doSolve() {
    // Get initial solution
    double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
    // regardless of the allowed solutions.
    if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
    // Verify bracketing of initial solution.
    verifyBracketing(x0, x1);
    // Get accuracies.
    final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
    // Keep track of inverted intervals, meaning that the left bound is
    // larger than the right bound.
    boolean inverted = false;
    // Keep finding better approximations.
    while (true) {
        // Calculate the next approximation.
        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
        // we can return it regardless of the allowed solutions.
        if (fx == 0.0) {
            return x;
        }
        // Update the bounds with the new approximation.
        if (f1 * fx < 0) {
            // The value of x1 has switched to the other bound, thus inverting
            // the interval.
            x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    // Nothing.
                    if (x == x1) {
                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
                        f0 = computeObjectiveValue(x0);
                    }
                    break;
                default:
                    // Should never happen.
                    throw new MathInternalError();
            }
        }
        // Update from [x0, x1] to [x0, x].
        x1 = x;
        f1 = fx;
        // the root than we already are.
        if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
        // are satisfied with the current approximation.
        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}","/**
 * {@inheritDoc}
 */
","protected final double doSolve() {
        double x0 = getMin();
    double x1 = getMax();
    double f0 = computeObjectiveValue(x0);
    double f1 = computeObjectiveValue(x1);
        if (f0 == 0.0) {
        return x0;
    }
    if (f1 == 0.0) {
        return x1;
    }
        verifyBracketing(x0, x1);
        final double ftol = getFunctionValueAccuracy();
    final double atol = getAbsoluteAccuracy();
    final double rtol = getRelativeAccuracy();
            boolean inverted = false;
        while (true) {
                final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
        final double fx = computeObjectiveValue(x);
                if (fx == 0.0) {
            return x;
        }
                if (f1 * fx < 0) {
                                    x0 = x1;
            f0 = f1;
            inverted = !inverted;
        } else {
            switch(method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                                        if (x == x1) {
                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
                        f0 = computeObjectiveValue(x0);
                    }
                    break;
                default:
                                        throw new MathInternalError();
            }
        }
                x1 = x;
        f1 = fx;
                if (FastMath.abs(f1) <= ftol) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
            }
        }
                if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {
            switch(allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
            }
        }
    }
}",3.5454545454545454,1.8775510204081634,6.5,1.5,3.3333333333333335,3.210084033613446,-1.392027530828793,0.8333333333333334,-0.028571428571428574,7.8702763822323885
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7,3,"public void recv_removeTableProperty() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {
    removeTableProperty_result result = new removeTableProperty_result();
    receiveBase(result, ""removeTableProperty"");
    if (result.ouch1 != null) {
        throw result.ouch1;
    }
    if (result.ouch2 != null) {
        throw result.ouch2;
    }
    return;
}",,"public void recv_removeTableProperty() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {
    removeTableProperty_result result = new removeTableProperty_result();
    receiveBase(result, ""removeTableProperty"");
    if (result.ouch1 != null) {
        throw result.ouch1;
    }
    if (result.ouch2 != null) {
        throw result.ouch2;
    }
    return;
}",-0.13636363636363635,-0.3112244897959183,0.16666666666666666,-0.5,-0.08333333333333333,-0.06426099851705384,0.17866360768568987,-0.4166666666666667,-0.028571428571428574,-0.08859821570063517
Closure,17,2,"/**
 * Look for a type declaration on a property assignment
 * (in an ASSIGN or an object literal key).
 *
 * @param info The doc info for this property.
 * @param lValue The l-value node.
 * @param rValue The node that {@code n} is being initialized to,
 *     or {@code null} if this is a stub declaration.
 */
private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {
    if (info != null && info.hasType()) {
        return getDeclaredTypeInAnnotation(sourceName, lValue, info);
    } else if (rValue != null && rValue.isFunction() && shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        return rValue.getJSType();
    } else if (info != null) {
        if (info.hasEnumParameterType()) {
            if (rValue != null && rValue.isObjectLit()) {
                return rValue.getJSType();
            } else {
                return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);
            }
        } else if (info.isConstructor() || info.isInterface()) {
            return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);
        } else {
            // Check if this is constant, and if it has a known type.
            if (info.isConstant()) {
                JSType knownType = null;
                if (rValue != null) {
                    if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
                        // then we can safely use that.
                        return rValue.getJSType();
                    } else if (rValue.isOr()) {
                        // Check for a very specific JS idiom:
                        // var x = x || TYPE;
                        // This is used by Closure's base namespace for esoteric
                        // reasons.
                        Node firstClause = rValue.getFirstChild();
                        Node secondClause = firstClause.getNext();
                        boolean namesMatch = firstClause.isName() && lValue.isName() && firstClause.getString().equals(lValue.getString());
                        if (namesMatch && secondClause.getJSType() != null && !secondClause.getJSType().isUnknownType()) {
                            return secondClause.getJSType();
                        }
                    }
                }
            }
        }
    }
    return getDeclaredTypeInAnnotation(sourceName, lValue, info);
}","/**
 * Look for a type declaration on a property assignment
 * (in an ASSIGN or an object literal key).
 *
 * @param info The doc info for this property.
 * @param lValue The l-value node.
 * @param rValue The node that {@code n} is being initialized to,
 *     or {@code null} if this is a stub declaration.
 */
","private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {
    if (info != null && info.hasType()) {
        return getDeclaredTypeInAnnotation(sourceName, lValue, info);
    } else if (rValue != null && rValue.isFunction() && shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
        return rValue.getJSType();
    } else if (info != null) {
        if (info.hasEnumParameterType()) {
            if (rValue != null && rValue.isObjectLit()) {
                return rValue.getJSType();
            } else {
                return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);
            }
        } else if (info.isConstructor() || info.isInterface()) {
            return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);
        } else {
                        if (info.isConstant()) {
                JSType knownType = null;
                if (rValue != null) {
                    if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
                                                return rValue.getJSType();
                    } else if (rValue.isOr()) {
                                                                                                                        Node firstClause = rValue.getFirstChild();
                        Node secondClause = firstClause.getNext();
                        boolean namesMatch = firstClause.isName() && lValue.isName() && firstClause.getString().equals(lValue.getString());
                        if (namesMatch && secondClause.getJSType() != null && !secondClause.getJSType().isUnknownType()) {
                            return secondClause.getJSType();
                        }
                    }
                }
            }
        }
    }
    return getDeclaredTypeInAnnotation(sourceName, lValue, info);
}",0.9090909090909091,2.408163265306123,1.3333333333333333,4.0,2.6666666666666665,0.7622343054869009,-0.6661887008890166,2.3333333333333335,-0.028571428571428574,1.5589319901833554
wicket,remotes/origin/bugs-dot-jar_WICKET-4664_2fcb3417,1,"/**
 *  Stringizes this url
 *
 *  @param mode
 *             {@link StringMode} that determins how to stringize the url
 *  @param charset
 *             charset
 *  @return sringized version of this url
 */
public String toString(StringMode mode, Charset charset) {
    StringBuilder result = new StringBuilder();
    final String path = getPath(charset);
    if (StringMode.FULL == mode) {
        if (Strings.isEmpty(host)) {
            throw new IllegalStateException(""Cannot render this url in "" + StringMode.FULL.name() + "" mode because it does not have a host set."");
        }
        if (Strings.isEmpty(protocol) == false) {
            result.append(protocol);
            result.append(""://"");
        } else if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false) {
            result.append(""//"");
        }
        result.append(host);
        if (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false) {
            result.append(':');
            result.append(port);
        }
        if (segments.contains("".."")) {
            throw new IllegalStateException(""Cannot render this url in "" + StringMode.FULL.name() + "" mode because it has a `..` segment: "" + toString());
        }
        if (!path.startsWith(""/"")) {
            result.append('/');
        }
    }
    result.append(path);
    result.append(getQueryString(charset));
    return result.toString();
}","/**
 *  Stringizes this url
 *
 *  @param mode
 *             {@link StringMode} that determins how to stringize the url
 *  @param charset
 *             charset
 *  @return sringized version of this url
 */
","public String toString(StringMode mode, Charset charset) {
    StringBuilder result = new StringBuilder();
    final String path = getPath(charset);
    if (StringMode.FULL == mode) {
        if (Strings.isEmpty(host)) {
            throw new IllegalStateException(""Cannot render this url in "" + StringMode.FULL.name() + "" mode because it does not have a host set."");
        }
        if (Strings.isEmpty(protocol) == false) {
            result.append(protocol);
            result.append(""://"");
        } else if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false) {
            result.append(""//"");
        }
        result.append(host);
        if (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false) {
            result.append(':');
            result.append(port);
        }
        if (segments.contains("".."")) {
            throw new IllegalStateException(""Cannot render this url in "" + StringMode.FULL.name() + "" mode because it has a `..` segment: "" + toString());
        }
        if (!path.startsWith(""/"")) {
            result.append('/');
        }
    }
    result.append(path);
    result.append(getQueryString(charset));
    return result.toString();
}",0.6818181818181818,0.2653061224489796,1.0,0.5,1.1666666666666667,1.0528917449332675,-0.539718956122742,1.4166666666666667,-0.028571428571428574,1.4934405797473884
Closure,133,2,"/**
 * Returns the remainder of the line.
 */
private String getRemainingJSDocLine() {
    String result = stream.getRemainingJSDocLine();
    return result;
}","/**
 * Returns the remainder of the line.
 */
","private String getRemainingJSDocLine() {
    String result = stream.getRemainingJSDocLine();
    return result;
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9073702322913678,-0.4166666666666667,2.8000000000000003,-0.16422749602751402
Closure,88,1,"/**
 * Give an expression and a variable. It returns READ, if the first
 * reference of that variable is a read. It returns KILL, if the first
 * reference of that variable is an assignment. It returns MAY_LIVE otherwise.
 */
private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {
    if (NodeUtil.isName(n) && variable.equals(n.getString())) {
        if (NodeUtil.isLhs(n, n.getParent())) {
            // occurs after the RHS is evaluated.
            return VariableLiveness.KILL;
        } else {
            return VariableLiveness.READ;
        }
    }
    // Expressions are evaluated left-right, depth first.
    for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {
            // Not a FUNCTION
            VariableLiveness state = isVariableReadBeforeKill(child, variable);
            if (state != VariableLiveness.MAYBE_LIVE) {
                return state;
            }
        }
    }
    return VariableLiveness.MAYBE_LIVE;
}","/**
 * Give an expression and a variable. It returns READ, if the first
 * reference of that variable is a read. It returns KILL, if the first
 * reference of that variable is an assignment. It returns MAY_LIVE otherwise.
 */
","private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {
    if (NodeUtil.isName(n) && variable.equals(n.getString())) {
        if (NodeUtil.isLhs(n, n.getParent())) {
                        return VariableLiveness.KILL;
        } else {
            return VariableLiveness.READ;
        }
    }
        for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {
                        VariableLiveness state = isVariableReadBeforeKill(child, variable);
            if (state != VariableLiveness.MAYBE_LIVE) {
                return state;
            }
        }
    }
    return VariableLiveness.MAYBE_LIVE;
}",0.18181818181818182,0.7040816326530615,0.3333333333333333,0.5,0.8333333333333334,0.41028175976272874,-0.1798107255520504,0.25,0.0,0.26751641461189557
camel,remotes/origin/bugs-dot-jar_CAMEL-7213_336663c9,1,"@Converter
public static ByteBuffer toByteBuffer(Integer value) {
    ByteBuffer buf = ByteBuffer.allocate(4);
    buf.putInt(value);
    return buf;
}",,"@Converter
public static ByteBuffer toByteBuffer(Integer value) {
    ByteBuffer buf = ByteBuffer.allocate(4);
    buf.putInt(value);
    return buf;
}",-0.36363636363636365,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.5896185833094353,-0.3333333333333333,1.2285714285714286,-0.16422749602751402
Closure,30,2,"@Override
public void process(Node externs, Node root) {
    (new NodeTraversal(compiler, this)).traverse(root);
}",,"@Override
public void process(Node externs, Node root) {
    (new NodeTraversal(compiler, this)).traverse(root);
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8468597648408377,-0.4166666666666667,0.3428571428571429,-0.16422749602751402
Closure,148,2,"private void openLine() throws IOException {
    out.append(""["");
    this.firstChar = true;
}",,"private void openLine() throws IOException {
    out.append(""["");
    this.firstChar = true;
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8769716088328073,-0.4166666666666667,2.2285714285714286,-0.16422749602751402
Closure,137,2,"/**
 * Prepare a set for the new scope.
 */
private static String getNameSuffix(String name, int index) {
    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());
}","/**
 * Prepare a set for the new scope.
 */
","private static String getNameSuffix(String name, int index) {
    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9274447949526817,-0.25,1.657142857142857,-0.16422749602751402
Math,59,1,"/**
 * Compute the maximum of two values
 * @param a first value
 * @param b second value
 * @return b if a is lesser or equal to b, a otherwise
 */
public static float max(final float a, final float b) {
    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);
}","/**
 * Compute the maximum of two values
 * @param a first value
 * @param b second value
 * @return b if a is lesser or equal to b, a otherwise
 */
","public static float max(final float a, final float b) {
    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);
}",-0.5,-0.576530612244898,-0.16666666666666666,-1.0,0.0,0.01482946119624324,0.9116719242902208,-0.4166666666666667,2.8000000000000003,-0.1207807059246791
commons-math,remotes/origin/bugs-dot-jar_MATH-367_3a15d8ce,3,"/**
 * Advance an entry up to the next non null one.
 * @param e entry to advance
 */
protected void advance(EntryImpl e) {
    if (e == null) {
        return;
    }
    do {
        e.setIndex(e.getIndex() + 1);
    } while (e.getIndex() < dim && e.getValue() == 0);
    if (e.getIndex() >= dim) {
        e.setIndex(-1);
    }
}","/**
 * Advance an entry up to the next non null one.
 * @param e entry to advance
 */
","protected void advance(EntryImpl e) {
    if (e == null) {
        return;
    }
    do {
        e.setIndex(e.getIndex() + 1);
    } while (e.getIndex() < dim && e.getValue() == 0);
    if (e.getIndex() >= dim) {
        e.setIndex(-1);
    }
}",-0.13636363636363635,-0.17857142857142863,0.0,-0.5,0.25,0.8591201186356896,0.16977344422139384,0.0,1.7714285714285716,0.16521686989519493
Math,6,1,"/**
 * {@inheritDoc}
 */
@Override
protected PointValuePair doOptimize() {
    // -------------------- Initialization --------------------------------
    isMinimize = getGoalType().equals(GoalType.MINIMIZE);
    final FitnessFunction fitfun = new FitnessFunction();
    final double[] guess = getStartPoint();
    // number of objective variables/problem dimension
    dimension = guess.length;
    initializeCMA(guess);
    iterations = 0;
    double bestValue = fitfun.value(guess);
    push(fitnessHistory, bestValue);
    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);
    PointValuePair lastResult = null;
    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {
        // Generate and evaluate lambda offspring
        final RealMatrix arz = randn1(dimension, lambda);
        final RealMatrix arx = zeros(dimension, lambda);
        final double[] fitness = new double[lambda];
        // generate random offspring
        for (int k = 0; k < lambda; k++) {
            RealMatrix arxk = null;
            for (int i = 0; i < checkFeasableCount + 1; i++) {
                if (diagonalOnly <= 0) {
                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(// m + sig * Normal(0,C)
                    sigma));
                } else {
                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));
                }
                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {
                    break;
                }
                // regenerate random arguments for row
                arz.setColumn(k, randn(dimension));
            }
            copyColumn(arxk, 0, arx, k);
            try {
                // compute fitness
                fitness[k] = fitfun.value(arx.getColumn(k));
            } catch (TooManyEvaluationsException e) {
                break generationLoop;
            }
        }
        // Sort by fitness and compute weighted mean into xmean
        final int[] arindex = sortedIndices(fitness);
        // Calculate new xmean, this is selection and recombination
        // for speed up of Eq. (2) and (3)
        final RealMatrix xold = xmean;
        final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));
        xmean = bestArx.multiply(weights);
        final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));
        final RealMatrix zmean = bestArz.multiply(weights);
        final boolean hsig = updateEvolutionPaths(zmean, xold);
        if (diagonalOnly <= 0) {
            updateCovariance(hsig, bestArx, arz, arindex, xold);
        } else {
            updateCovarianceDiagonalOnly(hsig, bestArz);
        }
        // Adapt step size sigma - Eq. (5)
        sigma *= Math.exp(Math.min(1, (normps / chiN - 1) * cs / damps));
        final double bestFitness = fitness[arindex[0]];
        final double worstFitness = fitness[arindex[arindex.length - 1]];
        if (bestValue > bestFitness) {
            bestValue = bestFitness;
            lastResult = optimum;
            optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);
            if (getConvergenceChecker() != null && lastResult != null) {
                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {
                    break generationLoop;
                }
            }
        }
        // Break, if fitness is good enough
        if (stopFitness != 0) {
            // only if stopFitness is defined
            if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {
                break generationLoop;
            }
        }
        final double[] sqrtDiagC = sqrt(diagC).getColumn(0);
        final double[] pcCol = pc.getColumn(0);
        for (int i = 0; i < dimension; i++) {
            if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {
                break;
            }
            if (i >= dimension - 1) {
                break generationLoop;
            }
        }
        for (int i = 0; i < dimension; i++) {
            if (sigma * sqrtDiagC[i] > stopTolUpX) {
                break generationLoop;
            }
        }
        final double historyBest = min(fitnessHistory);
        final double historyWorst = max(fitnessHistory);
        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {
            break generationLoop;
        }
        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {
            break generationLoop;
        }
        // condition number of the covariance matrix exceeds 1e14
        if (max(diagD) / min(diagD) > 1e7) {
            break generationLoop;
        }
        // user defined termination
        if (getConvergenceChecker() != null) {
            final PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);
            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {
                break generationLoop;
            }
            lastResult = current;
        }
        // Adjust step size in case of equal function values (flat fitness)
        if (bestValue == fitness[arindex[(int) (0.1 + lambda / 4.)]]) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
        // store best in history
        push(fitnessHistory, bestFitness);
        fitfun.setValueRange(worstFitness - bestFitness);
        if (generateStatistics) {
            statisticsSigmaHistory.add(sigma);
            statisticsFitnessHistory.add(bestFitness);
            statisticsMeanHistory.add(xmean.transpose());
            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));
        }
    }
    return optimum;
}","/**
 * {@inheritDoc}
 */
","@Override
protected PointValuePair doOptimize() {
        isMinimize = getGoalType().equals(GoalType.MINIMIZE);
    final FitnessFunction fitfun = new FitnessFunction();
    final double[] guess = getStartPoint();
        dimension = guess.length;
    initializeCMA(guess);
    iterations = 0;
    double bestValue = fitfun.value(guess);
    push(fitnessHistory, bestValue);
    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);
    PointValuePair lastResult = null;
    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {
                final RealMatrix arz = randn1(dimension, lambda);
        final RealMatrix arx = zeros(dimension, lambda);
        final double[] fitness = new double[lambda];
                for (int k = 0; k < lambda; k++) {
            RealMatrix arxk = null;
            for (int i = 0; i < checkFeasableCount + 1; i++) {
                if (diagonalOnly <= 0) {
                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(                    sigma));
                } else {
                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));
                }
                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {
                    break;
                }
                                arz.setColumn(k, randn(dimension));
            }
            copyColumn(arxk, 0, arx, k);
            try {
                                fitness[k] = fitfun.value(arx.getColumn(k));
            } catch (TooManyEvaluationsException e) {
                break generationLoop;
            }
        }
                final int[] arindex = sortedIndices(fitness);
                        final RealMatrix xold = xmean;
        final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));
        xmean = bestArx.multiply(weights);
        final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));
        final RealMatrix zmean = bestArz.multiply(weights);
        final boolean hsig = updateEvolutionPaths(zmean, xold);
        if (diagonalOnly <= 0) {
            updateCovariance(hsig, bestArx, arz, arindex, xold);
        } else {
            updateCovarianceDiagonalOnly(hsig, bestArz);
        }
                sigma *= Math.exp(Math.min(1, (normps / chiN - 1) * cs / damps));
        final double bestFitness = fitness[arindex[0]];
        final double worstFitness = fitness[arindex[arindex.length - 1]];
        if (bestValue > bestFitness) {
            bestValue = bestFitness;
            lastResult = optimum;
            optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);
            if (getConvergenceChecker() != null && lastResult != null) {
                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {
                    break generationLoop;
                }
            }
        }
                if (stopFitness != 0) {
                        if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {
                break generationLoop;
            }
        }
        final double[] sqrtDiagC = sqrt(diagC).getColumn(0);
        final double[] pcCol = pc.getColumn(0);
        for (int i = 0; i < dimension; i++) {
            if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {
                break;
            }
            if (i >= dimension - 1) {
                break generationLoop;
            }
        }
        for (int i = 0; i < dimension; i++) {
            if (sigma * sqrtDiagC[i] > stopTolUpX) {
                break generationLoop;
            }
        }
        final double historyBest = min(fitnessHistory);
        final double historyWorst = max(fitnessHistory);
        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {
            break generationLoop;
        }
        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {
            break generationLoop;
        }
                if (max(diagD) / min(diagD) > 1e7) {
            break generationLoop;
        }
                if (getConvergenceChecker() != null) {
            final PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);
            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {
                break generationLoop;
            }
            lastResult = current;
        }
                if (bestValue == fitness[arindex[(int) (0.1 + lambda / 4.)]]) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
                push(fitnessHistory, bestFitness);
        fitfun.setValueRange(worstFitness - bestFitness);
        if (generateStatistics) {
            statisticsSigmaHistory.add(sigma);
            statisticsFitnessHistory.add(bestFitness);
            statisticsMeanHistory.add(xmean.transpose());
            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));
        }
    }
    return optimum;
}",4.681818181818182,0.6377551020408161,6.166666666666667,1.0,5.583333333333333,4.171033119130005,-1.6624605678233442,5.25,-0.028571428571428574,32.09659030070969
wicket,remotes/origin/bugs-dot-jar_WICKET-2065_9da430fb,1,"protected void appendParameters(AppendingStringBuffer url, Map parameters) {
    int i = 0;
    while (parameters.containsKey(String.valueOf(i))) {
        String value = (String) parameters.get(String.valueOf(i));
        if (!url.endsWith(""/"")) {
            url.append(""/"");
        }
        url.append(urlEncodePathComponent(value)).append(""/"");
        i++;
    }
    String pageMap = (String) parameters.get(WebRequestCodingStrategy.PAGEMAP);
    if (pageMap != null) {
        i++;
        pageMap = WebRequestCodingStrategy.encodePageMapName(pageMap);
        if (!url.endsWith(""/"")) {
            url.append(""/"");
        }
        url.append(WebRequestCodingStrategy.PAGEMAP).append(""/"").append(urlEncodePathComponent(pageMap)).append(""/"");
    }
    if (i != parameters.size()) {
        throw new WicketRuntimeException(""Not all parameters were encoded. Make sure all parameter names are integers in consecutive order starting with zero. Current parameter names are: "" + parameters.keySet().toString());
    }
}",,"protected void appendParameters(AppendingStringBuffer url, Map parameters) {
    int i = 0;
    while (parameters.containsKey(String.valueOf(i))) {
        String value = (String) parameters.get(String.valueOf(i));
        if (!url.endsWith(""/"")) {
            url.append(""/"");
        }
        url.append(urlEncodePathComponent(value)).append(""/"");
        i++;
    }
    String pageMap = (String) parameters.get(WebRequestCodingStrategy.PAGEMAP);
    if (pageMap != null) {
        i++;
        pageMap = WebRequestCodingStrategy.encodePageMapName(pageMap);
        if (!url.endsWith(""/"")) {
            url.append(""/"");
        }
        url.append(WebRequestCodingStrategy.PAGEMAP).append(""/"").append(urlEncodePathComponent(pageMap)).append(""/"");
    }
    if (i != parameters.size()) {
        throw new WicketRuntimeException(""Not all parameters were encoded. Make sure all parameter names are integers in consecutive order starting with zero. Current parameter names are: "" + parameters.keySet().toString());
    }
}",0.4090909090909091,0.03061224489795921,0.5,0.0,0.5,0.6890756302521011,-0.3762546601663323,1.25,-0.028571428571428574,0.8084897700455284
Lang,6,3,"/**
 * Translate an input onto a Writer. This is intentionally final as its algorithm is
 * tightly coupled with the abstract method of this class.
 *
 * @param input CharSequence that is being translated
 * @param out Writer to translate the text to
 * @throws IOException if and only if the Writer produces an IOException
 */
public final void translate(CharSequence input, Writer out) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (input == null) {
        return;
    }
    int pos = 0;
    int len = input.length();
    while (pos < len) {
        int consumed = translate(input, pos, out);
        if (consumed == 0) {
            char[] c = Character.toChars(Character.codePointAt(input, pos));
            out.write(c);
            pos += c.length;
            continue;
        }
        // // and they just took care of a surrogate pair
        for (int pt = 0; pt < consumed; pt++) {
            pos += Character.charCount(Character.codePointAt(input, pos));
        }
    }
}","/**
 * Translate an input onto a Writer. This is intentionally final as its algorithm is
 * tightly coupled with the abstract method of this class.
 *
 * @param input CharSequence that is being translated
 * @param out Writer to translate the text to
 * @throws IOException if and only if the Writer produces an IOException
 */
","public final void translate(CharSequence input, Writer out) throws IOException {
    if (out == null) {
        throw new IllegalArgumentException(""The Writer must not be null"");
    }
    if (input == null) {
        return;
    }
    int pos = 0;
    int len = input.length();
    while (pos < len) {
        int consumed = translate(input, pos, out);
        if (consumed == 0) {
            char[] c = Character.toChars(Character.codePointAt(input, pos));
            out.write(c);
            pos += c.length;
            continue;
        }
                for (int pt = 0; pt < consumed; pt++) {
            pos += Character.charCount(Character.codePointAt(input, pos));
        }
    }
}",0.36363636363636365,0.34183673469387754,0.6666666666666666,0.0,0.5,0.554621848739496,-0.3166045311155724,0.08333333333333333,0.0,0.4615407677712533
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2695_0598498e,0,"@Nonnull
@Override
public NodeState getChildNode(@Nonnull String name) {
    if (!hasChildren) {
        checkValidName(name);
        return EmptyNodeState.MISSING_NODE;
    }
    String p = PathUtils.concat(getPath(), name);
    DocumentNodeState child = store.getNode(p, lastRevision);
    if (child == null) {
        checkValidName(name);
        return EmptyNodeState.MISSING_NODE;
    } else {
        return child;
    }
}",,"@Nonnull
@Override
public NodeState getChildNode(@Nonnull String name) {
    if (!hasChildren) {
        checkValidName(name);
        return EmptyNodeState.MISSING_NODE;
    }
    String p = PathUtils.concat(getPath(), name);
    DocumentNodeState child = store.getNode(p, lastRevision);
    if (child == null) {
        checkValidName(name);
        return EmptyNodeState.MISSING_NODE;
    } else {
        return child;
    }
}",0.09090909090909091,-0.015306122448979493,-0.16666666666666666,-0.5,-0.08333333333333333,-0.08007909045971327,-0.04215658158875822,-0.08333333333333333,0.39999999999999997,-0.056501385551715126
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1183_cfbf5999,3,"@Override
public String createBatchScanner(ByteBuffer login, String tableName, BatchScanOptions opts) throws TException {
    try {
        Connector connector = getConnector(login);
        int threads = 10;
        Authorizations auth;
        if (opts != null && opts.isSetAuthorizations()) {
            auth = getAuthorizations(opts.authorizations);
        } else {
            auth = connector.securityOperations().getUserAuthorizations(connector.whoami());
        }
        if (opts != null && opts.threads > 0)
            threads = opts.threads;
        BatchScanner scanner = connector.createBatchScanner(tableName, auth, threads);
        if (opts != null) {
            if (opts.iterators != null) {
                for (org.apache.accumulo.proxy.thrift.IteratorSetting iter : opts.iterators) {
                    IteratorSetting is = new IteratorSetting(iter.getPriority(), iter.getName(), iter.getIteratorClass(), iter.getProperties());
                    scanner.addScanIterator(is);
                }
            }
            ArrayList<Range> ranges = new ArrayList<Range>();
            if (opts.ranges == null) {
                ranges.add(new Range());
            } else {
                for (org.apache.accumulo.proxy.thrift.Range range : opts.ranges) {
                    Range aRange = new Range(range.getStart() == null ? null : Util.fromThrift(range.getStart()), true, range.getStop() == null ? null : Util.fromThrift(range.getStop()), false);
                    ranges.add(aRange);
                }
            }
            scanner.setRanges(ranges);
        }
        UUID uuid = UUID.randomUUID();
        ScannerPlusIterator spi = new ScannerPlusIterator();
        spi.scanner = scanner;
        spi.iterator = scanner.iterator();
        scannerCache.put(uuid, spi);
        return uuid.toString();
    } catch (Exception e) {
        throw translateException(e);
    }
}",,"@Override
public String createBatchScanner(ByteBuffer login, String tableName, BatchScanOptions opts) throws TException {
    try {
        Connector connector = getConnector(login);
        int threads = 10;
        Authorizations auth;
        if (opts != null && opts.isSetAuthorizations()) {
            auth = getAuthorizations(opts.authorizations);
        } else {
            auth = connector.securityOperations().getUserAuthorizations(connector.whoami());
        }
        if (opts != null && opts.threads > 0)
            threads = opts.threads;
        BatchScanner scanner = connector.createBatchScanner(tableName, auth, threads);
        if (opts != null) {
            if (opts.iterators != null) {
                for (org.apache.accumulo.proxy.thrift.IteratorSetting iter : opts.iterators) {
                    IteratorSetting is = new IteratorSetting(iter.getPriority(), iter.getName(), iter.getIteratorClass(), iter.getProperties());
                    scanner.addScanIterator(is);
                }
            }
            ArrayList<Range> ranges = new ArrayList<Range>();
            if (opts.ranges == null) {
                ranges.add(new Range());
            } else {
                for (org.apache.accumulo.proxy.thrift.Range range : opts.ranges) {
                    Range aRange = new Range(range.getStart() == null ? null : Util.fromThrift(range.getStart()), true, range.getStop() == null ? null : Util.fromThrift(range.getStop()), false);
                    ranges.add(aRange);
                }
            }
            scanner.setRanges(ranges);
        }
        UUID uuid = UUID.randomUUID();
        ScannerPlusIterator spi = new ScannerPlusIterator();
        spi.scanner = scanner;
        spi.iterator = scanner.iterator();
        scannerCache.put(uuid, spi);
        return uuid.toString();
    } catch (Exception e) {
        throw translateException(e);
    }
}",1.2727272727272727,1.0612244897959182,1.3333333333333333,1.0,0.9166666666666666,0.49925852694018796,-0.8250645253799829,1.6666666666666667,-0.028571428571428574,1.8303844852471938
Lang,49,1,"// Calculations
// -------------------------------------------------------------------
/**
 * <p>Reduce the fraction to the smallest values for the numerator and
 * denominator, returning the result.</p>
 *
 * <p>For example, if this fraction represents 2/4, then the result
 * will be 1/2.</p>
 *
 * @return a new reduced fraction instance, or this if no simplification possible
 */
public Fraction reduce() {
    int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
    if (gcd == 1) {
        return this;
    }
    return Fraction.getFraction(numerator / gcd, denominator / gcd);
}","/**
 * <p>Reduce the fraction to the smallest values for the numerator and
 * denominator, returning the result.</p>
 *
 * <p>For example, if this fraction represents 2/4, then the result
 * will be 1/2.</p>
 *
 * @return a new reduced fraction instance, or this if no simplification possible
 */
","public Fraction reduce() {
    int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
    if (gcd == 1) {
        return this;
    }
    return Fraction.getFraction(numerator / gcd, denominator / gcd);
}",-0.3181818181818182,-0.2346938775510204,-0.3333333333333333,-0.5,-0.25,-0.07414730598121598,0.45655291081158605,-0.25,2.1142857142857143,-0.11130241861222112
commons-math,remotes/origin/bugs-dot-jar_MATH-1096_19c1c3bb,0,"/**
 * {@inheritDoc}
 */
public EnclosingBall<Euclidean2D, Vector2D> ballOnSupport(final List<Vector2D> support) {
    if (support.size() < 1) {
        return new EnclosingBall<Euclidean2D, Vector2D>(Vector2D.ZERO, -1.0);
    } else {
        final Vector2D vA = support.get(0);
        if (support.size() < 2) {
            return new EnclosingBall<Euclidean2D, Vector2D>(vA, 0, vA);
        } else {
            final Vector2D vB = support.get(1);
            if (support.size() < 3) {
                return new EnclosingBall<Euclidean2D, Vector2D>(new Vector2D(0.5, vA, 0.5, vB), 0.5 * vA.distance(vB), vA, vB);
            } else {
                final Vector2D vC = support.get(2);
                // a disk is 2D can be defined as:
                // (1)   (x - x_0)^2 + (y - y_0)^2 = r^2
                // which can be written:
                // (2)   (x^2 + y^2) - 2 x_0 x - 2 y_0 y + (x_0^2 + y_0^2 - r^2) = 0
                // or simply:
                // (3)   (x^2 + y^2) + a x + b y + c= 0
                // with disk center coordinates -a/2, -b/2
                // If the sphere exists, a, b and c are a non zero solution to
                // [ (x^2  + y^2 )   x    y   1 ]   [ 1 ]   [ 0 ]
                // [ (xA^2 + yA^2)   xA   yA  1 ]   [ a ]   [ 0 ]
                // [ (xB^2 + yB^2)   xB   yB  1 ] * [ b ] = [ 0 ]
                // [ (xC^2 + yC^2)   xC   yC  1 ]   [ c ]   [ 0 ]
                // So the determinant of the matrix is zero. Computing this determinant
                // by expanding it using the minors m_ij of first row leads to
                // (4)   m_11 (x^2 + y^2) - m_12 x + m_13 y - m_14 = 0
                // So by identifying equations (2) and (4) we get the coordinates
                // of center as:
                // x_0 = +m_12 / (2 m_11)
                // y_0 = -m_13 / (2 m_11)
                // Note that the minors m_11, m_12 and m_13 all have the last column
                // filled with 1.0, hence simplifying the computation
                final double[] c1 = new double[] { vA.getNormSq(), vB.getNormSq(), vC.getNormSq() };
                final double[] c2 = new double[] { vA.getX(), vB.getX(), vC.getX() };
                final double[] c3 = new double[] { vA.getY(), vB.getY(), vC.getY() };
                final double m11 = minor(c2, c3);
                final double m12 = minor(c1, c3);
                final double m13 = minor(c1, c2);
                final Vector2D center = new Vector2D(0.5 * m12 / m11, -0.5 * m13 / m11);
                return new EnclosingBall<Euclidean2D, Vector2D>(center, center.distance(vA), vA, vB, vC);
            }
        }
    }
}","/**
 * {@inheritDoc}
 */
","public EnclosingBall<Euclidean2D, Vector2D> ballOnSupport(final List<Vector2D> support) {
    if (support.size() < 1) {
        return new EnclosingBall<Euclidean2D, Vector2D>(Vector2D.ZERO, -1.0);
    } else {
        final Vector2D vA = support.get(0);
        if (support.size() < 2) {
            return new EnclosingBall<Euclidean2D, Vector2D>(vA, 0, vA);
        } else {
            final Vector2D vB = support.get(1);
            if (support.size() < 3) {
                return new EnclosingBall<Euclidean2D, Vector2D>(new Vector2D(0.5, vA, 0.5, vB), 0.5 * vA.distance(vB), vA, vB);
            } else {
                final Vector2D vC = support.get(2);
                                                                                                                                                                                                                                                                                                                                                                final double[] c1 = new double[] { vA.getNormSq(), vB.getNormSq(), vC.getNormSq() };
                final double[] c2 = new double[] { vA.getX(), vB.getX(), vC.getX() };
                final double[] c3 = new double[] { vA.getY(), vB.getY(), vC.getY() };
                final double m11 = minor(c2, c3);
                final double m12 = minor(c1, c3);
                final double m13 = minor(c1, c2);
                final Vector2D center = new Vector2D(0.5 * m12 / m11, -0.5 * m13 / m11);
                return new EnclosingBall<Euclidean2D, Vector2D>(center, center.distance(vA), vA, vB, vC);
            }
        }
    }
}",0.5,1.1377551020408163,0.0,0.5,-0.08333333333333333,1.0232328225407812,-0.4654430742758821,1.1666666666666667,-0.028571428571428574,1.8786239565532101
wicket,remotes/origin/bugs-dot-jar_WICKET-3514_2b6da516,1,"private Url encryptUrl(final Url url) {
    if (url.getSegments().isEmpty() && url.getQueryParameters().isEmpty()) {
        return url;
    }
    String encryptedUrlString = getCrypt().encryptUrlSafe(url.toString());
    Url encryptedUrl = new Url(url.getCharset());
    encryptedUrl.getSegments().add(encryptedUrlString);
    int numberOfSegments = url.getSegments().size();
    if (numberOfSegments == 0 && !url.getQueryParameters().isEmpty()) {
        numberOfSegments = 1;
    }
    char[] encryptedChars = encryptedUrlString.toCharArray();
    int hash = 0;
    for (int segNo = 0; segNo < numberOfSegments; segNo++) {
        char a = encryptedChars[Math.abs(hash % encryptedChars.length)];
        hash++;
        char b = encryptedChars[Math.abs(hash % encryptedChars.length)];
        hash++;
        char c = encryptedChars[Math.abs(hash % encryptedChars.length)];
        String segment = """" + a + b + c;
        hash = hashString(segment);
        segment += String.format(""%02x"", Math.abs(hash % 256));
        encryptedUrl.getSegments().add(segment);
        hash = hashString(segment);
    }
    return encryptedUrl;
}",,"private Url encryptUrl(final Url url) {
    if (url.getSegments().isEmpty() && url.getQueryParameters().isEmpty()) {
        return url;
    }
    String encryptedUrlString = getCrypt().encryptUrlSafe(url.toString());
    Url encryptedUrl = new Url(url.getCharset());
    encryptedUrl.getSegments().add(encryptedUrlString);
    int numberOfSegments = url.getSegments().size();
    if (numberOfSegments == 0 && !url.getQueryParameters().isEmpty()) {
        numberOfSegments = 1;
    }
    char[] encryptedChars = encryptedUrlString.toCharArray();
    int hash = 0;
    for (int segNo = 0; segNo < numberOfSegments; segNo++) {
        char a = encryptedChars[Math.abs(hash % encryptedChars.length)];
        hash++;
        char b = encryptedChars[Math.abs(hash % encryptedChars.length)];
        hash++;
        char c = encryptedChars[Math.abs(hash % encryptedChars.length)];
        String segment = """" + a + b + c;
        hash = hashString(segment);
        segment += String.format(""%02x"", Math.abs(hash % 256));
        encryptedUrl.getSegments().add(segment);
        hash = hashString(segment);
    }
    return encryptedUrl;
}",0.5909090909090909,-0.2806122448979591,0.0,-0.5,0.3333333333333333,1.788433020266931,-0.5010037281330658,1.5,-0.028571428571428574,2.991241257318583
wicket,remotes/origin/bugs-dot-jar_WICKET-3511_4a875f46,1,"/**
 *  {@inheritDoc}
 *
 *  Checks for {@link IResourceStreamReference} in the cache and returns <code>null</code> if the
 *  result is {@link NullResourceStreamReference#INSTANCE}, or {@link FileResourceStream} /
 *  {@link UrlResourceStream} if there is an entry in the cache. Otherwise asks the delegate to
 *  find one and puts it in the cache.
 */
public IResourceStream locate(Class<?> clazz, String path) {
    Key key = new Key(clazz.getName(), path, null, null, null);
    IResourceStream resourceStream = getCopyFromCache(key);
    if (resourceStream == null) {
        resourceStream = delegate.locate(clazz, path);
        updateCache(key, resourceStream);
    }
    return resourceStream;
}","/**
 *  {@inheritDoc}
 *
 *  Checks for {@link IResourceStreamReference} in the cache and returns <code>null</code> if the
 *  result is {@link NullResourceStreamReference#INSTANCE}, or {@link FileResourceStream} /
 *  {@link UrlResourceStream} if there is an entry in the cache. Otherwise asks the delegate to
 *  find one and puts it in the cache.
 */
","public IResourceStream locate(Class<?> clazz, String path) {
    Key key = new Key(clazz.getName(), path, null, null, null);
    IResourceStream resourceStream = getCopyFromCache(key);
    if (resourceStream == null) {
        resourceStream = delegate.locate(clazz, path);
        updateCache(key, resourceStream);
    }
    return resourceStream;
}",-0.22727272727272727,-0.17857142857142863,-0.3333333333333333,-0.5,-0.25,0.0286702916460702,0.2532262689991397,-0.16666666666666666,0.17142857142857146,-0.037596206971873505
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-843_65390f8c,3,"@Override
public void compact(String tableName, Text start, Text end, List<IteratorSetting> iterators, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException {
    throw new NotImplementedException();
}",,"@Override
public void compact(String tableName, Text start, Text end, List<IteratorSetting> iterators, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException {
    throw new NotImplementedException();
}",-0.45454545454545453,-0.6581632653061225,-0.3333333333333333,-1.0,-0.4166666666666667,-0.3806228373702422,0.7289934040722686,-0.5,-0.028571428571428574,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1899_df59fb45,1,"@Override
void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final String key) {
    for (NodeBuilder node : builders) {
        if (node.hasProperty(""match"") || node.getChildNodeCount(1) > 0) {
            return;
        } else if (node.exists()) {
            if (node.hasProperty(NEXT)) {
                ChildNodeEntry[] walkedLanes = new ChildNodeEntry[OrderedIndex.LANES];
                ChildNodeEntry entry;
                String lane0Next, prevNext, currNext;
                // to keep searching and update
                do {
                    entry = seek(index.getNodeState(), new PredicateEquals(key), walkedLanes);
                    lane0Next = getPropertyNext(walkedLanes[0]);
                    for (int lane = walkedLanes.length - 1; lane >= 0; lane--) {
                        prevNext = getPropertyNext(walkedLanes[lane], lane);
                        if (key.equals(prevNext)) {
                            // if it's actually pointing to us let's deal with it
                            currNext = getPropertyNext(node, lane);
                            setPropertyNext(index.getChildNode(walkedLanes[lane].getName()), currNext, lane);
                        }
                    }
                } while (entry != null && !key.equals(lane0Next));
            }
            node.remove();
        }
    }
}",,"@Override
void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final String key) {
    for (NodeBuilder node : builders) {
        if (node.hasProperty(""match"") || node.getChildNodeCount(1) > 0) {
            return;
        } else if (node.exists()) {
            if (node.hasProperty(NEXT)) {
                ChildNodeEntry[] walkedLanes = new ChildNodeEntry[OrderedIndex.LANES];
                ChildNodeEntry entry;
                String lane0Next, prevNext, currNext;
                                do {
                    entry = seek(index.getNodeState(), new PredicateEquals(key), walkedLanes);
                    lane0Next = getPropertyNext(walkedLanes[0]);
                    for (int lane = walkedLanes.length - 1; lane >= 0; lane--) {
                        prevNext = getPropertyNext(walkedLanes[lane], lane);
                        if (key.equals(prevNext)) {
                                                        currNext = getPropertyNext(node, lane);
                            setPropertyNext(index.getChildNode(walkedLanes[lane].getName()), currNext, lane);
                        }
                    }
                } while (entry != null && !key.equals(lane0Next));
            }
            node.remove();
        }
    }
}",0.5454545454545454,2.663265306122449,0.6666666666666666,2.5,1.0833333333333333,1.3514582303509641,-0.47318611987381715,0.75,-0.028571428571428574,1.8038170129475206
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1215_a9efe3c4,0,"private boolean matchesPropertyType(PropertyValue value) {
    if (value == null) {
        return false;
    }
    if (propertyType == PropertyType.UNDEFINED) {
        return true;
    }
    return value.getType().tag() == propertyType;
}",,"private boolean matchesPropertyType(PropertyValue value) {
    if (value == null) {
        return false;
    }
    if (propertyType == PropertyType.UNDEFINED) {
        return true;
    }
    return value.getType().tag() == propertyType;
}",-0.22727272727272727,-0.17857142857142863,-0.16666666666666666,-0.5,-0.08333333333333333,-0.3806228373702422,0.36048178950387144,-0.3333333333333333,1.1714285714285715,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-395_962315ba,1,"/**
 * {@inheritDoc}
 */
public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {
    clearResult();
    return localMin(f, goalType, min, startValue, max, getRelativeAccuracy(), getAbsoluteAccuracy());
}","/**
 * {@inheritDoc}
 */
","public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {
    clearResult();
    return localMin(f, goalType, min, startValue, max, getRelativeAccuracy(), getAbsoluteAccuracy());
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7266991683395472,-0.16666666666666666,0.028571428571428574,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-3314_4badd9c5,1,"/**
 * Creates the processor and wraps it in any necessary interceptors and error handlers
 */
protected Processor makeProcessor(RouteContext routeContext) throws Exception {
    Processor processor = null;
    // resolve properties before we create the processor
    resolvePropertyPlaceholders(routeContext);
    // at first use custom factory
    if (routeContext.getCamelContext().getProcessorFactory() != null) {
        processor = routeContext.getCamelContext().getProcessorFactory().createProcessor(routeContext, this);
    }
    // fallback to default implementation if factory did not create the processor
    if (processor == null) {
        processor = createProcessor(routeContext);
    }
    if (processor == null) {
        // no processor to make
        return null;
    }
    return wrapProcessor(routeContext, processor);
}","/**
 * Creates the processor and wraps it in any necessary interceptors and error handlers
 */
","protected Processor makeProcessor(RouteContext routeContext) throws Exception {
    Processor processor = null;
        resolvePropertyPlaceholders(routeContext);
        if (routeContext.getCamelContext().getProcessorFactory() != null) {
        processor = routeContext.getCamelContext().getProcessorFactory().createProcessor(routeContext, this);
    }
        if (processor == null) {
        processor = createProcessor(routeContext);
    }
    if (processor == null) {
                return null;
    }
    return wrapProcessor(routeContext, processor);
}",0.0,-0.33163265306122447,0.0,-0.5,0.0,0.1057834898665349,0.025523372526527123,0.16666666666666666,0.028571428571428574,-0.0039789104895045085
camel,remotes/origin/bugs-dot-jar_CAMEL-7418_cabee0e9,3,"public <T> Set<T> findByType(Class<T> type) {
    Set<T> answer = new LinkedHashSet<T>();
    try {
        NamingEnumeration<NameClassPair> list = getContext().list("""");
        while (list.hasMore()) {
            NameClassPair pair = list.next();
            if (type.isInstance(pair.getClass()) || type.getName().equals(pair.getClassName())) {
                Object instance = context.lookup(pair.getName());
                answer.add(type.cast(instance));
            }
        }
    } catch (NamingException e) {
    // ignore
    }
    return answer;
}",,"public <T> Set<T> findByType(Class<T> type) {
    Set<T> answer = new LinkedHashSet<T>();
    try {
        NamingEnumeration<NameClassPair> list = getContext().list("""");
        while (list.hasMore()) {
            NameClassPair pair = list.next();
            if (type.isInstance(pair.getClass()) || type.getName().equals(pair.getClassName())) {
                Object instance = context.lookup(pair.getName());
                answer.add(type.cast(instance));
            }
        }
    } catch (NamingException e) {
        }
    return answer;
}",0.045454545454545456,1.0255102040816328,0.0,0.5,0.25,-0.05239742956005931,-0.08804129624318922,0.5833333333333334,0.05714285714285714,0.021911847216690022
flink,remotes/origin/bugs-dot-jar_FLINK-2713_63d9800e,1,"@SuppressWarnings(""unchecked"")
public void restoreState(StateHandle<Serializable> snapshot, ClassLoader userCodeClassLoader) throws Exception {
    update(checkpointer.restoreState((C) snapshot.getState(userCodeClassLoader)));
}",,"@SuppressWarnings(""unchecked"")
public void restoreState(StateHandle<Serializable> snapshot, ClassLoader userCodeClassLoader) throws Exception {
    update(checkpointer.restoreState((C) snapshot.getState(userCodeClassLoader)));
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7548035560653857,-0.25,0.6857142857142857,-0.16422749602751402
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-395_a19ecc9e,1,"/**
 * Default Factory Constructor.
 * @param name The configuration name.
 * @param configLocation The configuration location.
 * @return The Configuration.
 */
@Override
public Configuration getConfiguration(final String name, final URI configLocation) {
    if (configLocation == null) {
        final String config = PropertiesUtil.getProperties().getStringProperty(CONFIGURATION_FILE_PROPERTY);
        if (config != null) {
            final ClassLoader loader = this.getClass().getClassLoader();
            final ConfigurationSource source = getInputFromString(config, loader);
            if (source != null) {
                for (final ConfigurationFactory factory : factories) {
                    final String[] types = factory.getSupportedTypes();
                    if (types != null) {
                        for (final String type : types) {
                            if (type.equals(""*"") || config.endsWith(type)) {
                                final Configuration c = factory.getConfiguration(source);
                                if (c != null) {
                                    return c;
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        for (final ConfigurationFactory factory : factories) {
            final String[] types = factory.getSupportedTypes();
            if (types != null) {
                for (final String type : types) {
                    if (type.equals(""*"") || configLocation.toString().endsWith(type)) {
                        final Configuration config = factory.getConfiguration(name, configLocation);
                        if (config != null) {
                            return config;
                        }
                    }
                }
            }
        }
    }
    Configuration config = getConfiguration(true, name);
    if (config == null) {
        config = getConfiguration(true, null);
        if (config == null) {
            config = getConfiguration(false, name);
            if (config == null) {
                config = getConfiguration(false, null);
            }
        }
    }
    return config != null ? config : new DefaultConfiguration();
}","/**
 * Default Factory Constructor.
 * @param name The configuration name.
 * @param configLocation The configuration location.
 * @return The Configuration.
 */
","@Override
public Configuration getConfiguration(final String name, final URI configLocation) {
    if (configLocation == null) {
        final String config = PropertiesUtil.getProperties().getStringProperty(CONFIGURATION_FILE_PROPERTY);
        if (config != null) {
            final ClassLoader loader = this.getClass().getClassLoader();
            final ConfigurationSource source = getInputFromString(config, loader);
            if (source != null) {
                for (final ConfigurationFactory factory : factories) {
                    final String[] types = factory.getSupportedTypes();
                    if (types != null) {
                        for (final String type : types) {
                            if (type.equals(""*"") || config.endsWith(type)) {
                                final Configuration c = factory.getConfiguration(source);
                                if (c != null) {
                                    return c;
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        for (final ConfigurationFactory factory : factories) {
            final String[] types = factory.getSupportedTypes();
            if (types != null) {
                for (final String type : types) {
                    if (type.equals(""*"") || configLocation.toString().endsWith(type)) {
                        final Configuration config = factory.getConfiguration(name, configLocation);
                        if (config != null) {
                            return config;
                        }
                    }
                }
            }
        }
    }
    Configuration config = getConfiguration(true, name);
    if (config == null) {
        config = getConfiguration(true, null);
        if (config == null) {
            config = getConfiguration(false, name);
            if (config == null) {
                config = getConfiguration(false, null);
            }
        }
    }
    return config != null ? config : new DefaultConfiguration();
}",1.6363636363636365,3.214285714285715,2.3333333333333335,3.0,1.5833333333333333,0.8630746416213546,-0.887582449096645,1.0,-0.028571428571428574,1.7424886821625742
Closure,79,1,"/**
 * Create a new variable in a synthetic script. This will prevent
 * subsequent compiler passes from crashing.
 */
private void createSynthesizedExternVar(String varName) {
    Node nameNode = Node.newString(Token.NAME, varName);
    // cases for this configuration though, and it makes them happier.
    if (compiler.getCodingConvention().isConstant(varName)) {
        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
    }
    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));
    varsToDeclareInExterns.remove(varName);
}","/**
 * Create a new variable in a synthetic script. This will prevent
 * subsequent compiler passes from crashing.
 */
","private void createSynthesizedExternVar(String varName) {
    Node nameNode = Node.newString(Token.NAME, varName);
        if (compiler.getCodingConvention().isConstant(varName)) {
        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
    }
    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));
    varsToDeclareInExterns.remove(varName);
}",-0.2727272727272727,-0.31632653061224497,-0.3333333333333333,-0.5,-0.16666666666666666,-0.3806228373702422,0.3200458847146544,0.08333333333333333,0.2285714285714286,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-2172_ea4a3f8a,3,"/**
 *  @see IValueMap#getAsDuration(String, Duration)
 */
public Duration getAsDuration(String key, Duration defaultValue) {
    if (!containsKey(key))
        return defaultValue;
    try {
        return getDuration(key);
    } catch (StringValueConversionException ignored) {
        return defaultValue;
    }
}","/**
 *  @see IValueMap#getAsDuration(String, Duration)
 */
","public Duration getAsDuration(String key, Duration defaultValue) {
    if (!containsKey(key))
        return defaultValue;
    try {
        return getDuration(key);
    } catch (StringValueConversionException ignored) {
        return defaultValue;
    }
}",-0.22727272727272727,-0.035714285714285636,-0.16666666666666666,-0.5,-0.16666666666666666,-0.3806228373702422,0.3880126182965301,-0.3333333333333333,2.4571428571428573,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-3598_7c364566,1,"/**
 *  @return formatter The formatter for the current conversion
 */
@Override
protected DateTimeFormatter getFormat(Locale locale) {
    return DateTimeFormat.forPattern(getDatePattern(locale)).withPivotYear(2000);
}","/**
 *  @return formatter The formatter for the current conversion
 */
","@Override
protected DateTimeFormatter getFormat(Locale locale) {
    return DateTimeFormat.forPattern(getDatePattern(locale)).withPivotYear(2000);
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8210496128477202,-0.25,1.8,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-412_be2fdba7,1,"private List<List<String>> groupFiles(List<String> files, int groups) {
    List<List<String>> result = new ArrayList<List<String>>();
    Iterator<String> iter = files.iterator();
    for (int i = 0; i < groups && iter.hasNext(); i++) {
        List<String> group = new ArrayList<String>();
        for (int j = 0; j < Math.ceil(files.size() / (double) groups) && iter.hasNext(); j++) {
            group.add(iter.next());
        }
        result.add(group);
    }
    return result;
}",,"private List<List<String>> groupFiles(List<String> files, int groups) {
    List<List<String>> result = new ArrayList<List<String>>();
    Iterator<String> iter = files.iterator();
    for (int i = 0; i < groups && iter.hasNext(); i++) {
        List<String> group = new ArrayList<String>();
        for (int j = 0; j < Math.ceil(files.size() / (double) groups) && iter.hasNext(); j++) {
            group.add(iter.next());
        }
        result.add(group);
    }
    return result;
}",-0.09090909090909091,0.1938775510204081,-0.16666666666666666,0.0,0.4166666666666667,0.5981216015818094,0.00200745626613115,0.16666666666666666,-0.028571428571428574,0.47386296957782426
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-466_7b9e48e8,3,"/**
 * Tries to convert the specified URL to a file object. If this fails,
 * <b>null</b> is returned.
 *
 * @param uri the URI
 * @return the resulting file object
 */
public static File fileFromURI(URI uri) {
    if (uri == null || (uri.getScheme() != null && (!PROTOCOL_FILE.equals(uri.getScheme()) && !JBOSS_FILE.equals(uri.getScheme())))) {
        return null;
    }
    if (uri.getScheme() == null) {
        try {
            uri = new File(uri.getPath()).toURI();
        } catch (final Exception ex) {
            LOGGER.warn(""Invalid URI "" + uri);
            return null;
        }
    }
    try {
        return new File(URLDecoder.decode(uri.toURL().getFile(), ""UTF8""));
    } catch (final MalformedURLException ex) {
        LOGGER.warn(""Invalid URL "" + uri, ex);
    } catch (final UnsupportedEncodingException uee) {
        LOGGER.warn(""Invalid encoding: UTF8"", uee);
    }
    return null;
}","/**
 * Tries to convert the specified URL to a file object. If this fails,
 * <b>null</b> is returned.
 *
 * @param uri the URI
 * @return the resulting file object
 */
","public static File fileFromURI(URI uri) {
    if (uri == null || (uri.getScheme() != null && (!PROTOCOL_FILE.equals(uri.getScheme()) && !JBOSS_FILE.equals(uri.getScheme())))) {
        return null;
    }
    if (uri.getScheme() == null) {
        try {
            uri = new File(uri.getPath()).toURI();
        } catch (final Exception ex) {
            LOGGER.warn(""Invalid URI "" + uri);
            return null;
        }
    }
    try {
        return new File(URLDecoder.decode(uri.toURL().getFile(), ""UTF8""));
    } catch (final MalformedURLException ex) {
        LOGGER.warn(""Invalid URL "" + uri, ex);
    } catch (final UnsupportedEncodingException uee) {
        LOGGER.warn(""Invalid encoding: UTF8"", uee);
    }
    return null;
}",0.3181818181818182,0.19897959183673475,0.3333333333333333,0.0,0.3333333333333333,0.827483934750371,-0.29423573272153736,0.6666666666666666,-0.028571428571428574,0.714619176721018
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-579_7d72e6ed,3,public abstract void restrict(FilterImpl f);,,public abstract void restrict(FilterImpl f);,-0.5909090909090909,-1.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.7106395182104968,-0.5,2.7714285714285714,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-3989_6a8fc1cc,1,"/**
 *  Search for the child's markup in the associated markup file.
 *
 *  @param parent
 *             The container expected to contain the markup for child
 *  @param child
 *             The child component to find the markup for
 *  @return The markup associated with the child
 */
@Override
public IMarkupFragment getMarkup(final MarkupContainer parent, final Component child) {
    Args.notNull(tagName, ""tagName"");
    IMarkupFragment associatedMarkup = parent.getAssociatedMarkup();
    if (associatedMarkup == null) {
        throw new MarkupNotFoundException(""Failed to find markup file associated. "" + parent.getClass().getSimpleName() + "": "" + parent.toString());
    }
    // Find <wicket:panel>
    IMarkupFragment markup = findStartTag(associatedMarkup);
    if (markup == null) {
        throw new MarkupNotFoundException(""Expected to find <wicket:"" + tagName + ""> in associated markup file. Markup: "" + associatedMarkup.toString());
    }
    // If child == null, than return the markup fragment starting with <wicket:panel>
    if (child == null) {
        return markup;
    }
    // Find the markup for the child component
    associatedMarkup = markup.find(child.getId());
    if (associatedMarkup != null) {
        return associatedMarkup;
    }
    return findMarkupInAssociatedFileHeader(parent, child);
}","/**
 *  Search for the child's markup in the associated markup file.
 *
 *  @param parent
 *             The container expected to contain the markup for child
 *  @param child
 *             The child component to find the markup for
 *  @return The markup associated with the child
 */
","@Override
public IMarkupFragment getMarkup(final MarkupContainer parent, final Component child) {
    Args.notNull(tagName, ""tagName"");
    IMarkupFragment associatedMarkup = parent.getAssociatedMarkup();
    if (associatedMarkup == null) {
        throw new MarkupNotFoundException(""Failed to find markup file associated. "" + parent.getClass().getSimpleName() + "": "" + parent.toString());
    }
        IMarkupFragment markup = findStartTag(associatedMarkup);
    if (markup == null) {
        throw new MarkupNotFoundException(""Expected to find <wicket:"" + tagName + ""> in associated markup file. Markup: "" + associatedMarkup.toString());
    }
        if (child == null) {
        return markup;
    }
        associatedMarkup = markup.find(child.getId());
    if (associatedMarkup != null) {
        return associatedMarkup;
    }
    return findMarkupInAssociatedFileHeader(parent, child);
}",0.2727272727272727,-0.3367346938775511,0.5,-0.5,0.16666666666666666,0.38062283737024233,-0.262403211930026,0.3333333333333333,-0.028571428571428574,0.3343355562122828
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-678_6c54045d,1,"/**
 * Determine whether this child exists at its direct parent.
 * @return  {@code true} iff this child exists at its direct parent.
 */
private boolean exists() {
    // retrieved from the base state.
    return isRoot() || parent.writeState == null || parent.writeState.hasChildNode(name);
}","/**
 * Determine whether this child exists at its direct parent.
 * @return  {@code true} iff this child exists at its direct parent.
 */
","private boolean exists() {
        return isRoot() || parent.writeState == null || parent.writeState.hasChildNode(name);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.1334651507661888,0.9486664754803554,-0.3333333333333333,2.7714285714285714,-0.1411078417515772
wicket,remotes/origin/bugs-dot-jar_WICKET-4877_6470c3f7,3,"/**
 *  Parses the given URL string.
 *
 *  @param _url
 *             absolute or relative url with query string
 *  @param charset
 *  @return Url object
 */
public static Url parse(CharSequence _url, Charset charset) {
    Args.notNull(_url, ""_url"");
    final Url result = new Url(charset);
    // the url object resolved the charset, use that
    charset = result.getCharset();
    String url = _url.toString();
    // extract query string part
    final String queryString;
    final String absoluteUrl;
    final int queryAt = url.indexOf('?');
    if (queryAt == -1) {
        queryString = """";
        absoluteUrl = url;
    } else {
        absoluteUrl = url.substring(0, queryAt);
        queryString = url.substring(queryAt + 1);
    }
    // get absolute / relative part of url
    String relativeUrl;
    // absolute urls contain a scheme://
    final int idxOfFirstSlash = absoluteUrl.indexOf('/');
    final int protocolAt = absoluteUrl.indexOf(""://"");
    if (protocolAt > -1 && (protocolAt < idxOfFirstSlash)) {
        result.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);
        final String afterProto = absoluteUrl.substring(protocolAt + 3);
        final String hostAndPort;
        final int relativeAt = afterProto.indexOf('/');
        if (relativeAt == -1) {
            relativeUrl = """";
            hostAndPort = afterProto;
        } else {
            relativeUrl = afterProto.substring(relativeAt);
            hostAndPort = afterProto.substring(0, relativeAt);
        }
        final int portAt = hostAndPort.lastIndexOf(':');
        if (portAt == -1) {
            result.host = hostAndPort;
            result.port = getDefaultPortForProtocol(result.protocol);
        } else {
            result.host = hostAndPort.substring(0, portAt);
            result.port = Integer.parseInt(hostAndPort.substring(portAt + 1));
        }
        if (relativeAt < 0) {
            relativeUrl = ""/"";
        }
    } else {
        relativeUrl = absoluteUrl;
    }
    if (relativeUrl.length() > 0) {
        boolean removeLast = false;
        if (relativeUrl.endsWith(""/"")) {
            // we need to append something and remove it after splitting
            // because otherwise the
            // trailing slashes will be lost
            relativeUrl += ""/x"";
            removeLast = true;
        }
        String[] segmentArray = Strings.split(relativeUrl, '/');
        if (removeLast) {
            segmentArray[segmentArray.length - 1] = null;
        }
        for (String s : segmentArray) {
            if (s != null) {
                result.segments.add(decodeSegment(s, charset));
            }
        }
    }
    if (queryString.length() > 0) {
        String[] queryArray = Strings.split(queryString, '&');
        for (String s : queryArray) {
            if (Strings.isEmpty(s) == false) {
                result.parameters.add(parseQueryParameter(s, charset));
            }
        }
    }
    return result;
}","/**
 *  Parses the given URL string.
 *
 *  @param _url
 *             absolute or relative url with query string
 *  @param charset
 *  @return Url object
 */
","public static Url parse(CharSequence _url, Charset charset) {
    Args.notNull(_url, ""_url"");
    final Url result = new Url(charset);
        charset = result.getCharset();
    String url = _url.toString();
        final String queryString;
    final String absoluteUrl;
    final int queryAt = url.indexOf('?');
    if (queryAt == -1) {
        queryString = """";
        absoluteUrl = url;
    } else {
        absoluteUrl = url.substring(0, queryAt);
        queryString = url.substring(queryAt + 1);
    }
        String relativeUrl;
        final int idxOfFirstSlash = absoluteUrl.indexOf('/');
    final int protocolAt = absoluteUrl.indexOf(""://"");
    if (protocolAt > -1 && (protocolAt < idxOfFirstSlash)) {
        result.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);
        final String afterProto = absoluteUrl.substring(protocolAt + 3);
        final String hostAndPort;
        final int relativeAt = afterProto.indexOf('/');
        if (relativeAt == -1) {
            relativeUrl = """";
            hostAndPort = afterProto;
        } else {
            relativeUrl = afterProto.substring(relativeAt);
            hostAndPort = afterProto.substring(0, relativeAt);
        }
        final int portAt = hostAndPort.lastIndexOf(':');
        if (portAt == -1) {
            result.host = hostAndPort;
            result.port = getDefaultPortForProtocol(result.protocol);
        } else {
            result.host = hostAndPort.substring(0, portAt);
            result.port = Integer.parseInt(hostAndPort.substring(portAt + 1));
        }
        if (relativeAt < 0) {
            relativeUrl = ""/"";
        }
    } else {
        relativeUrl = absoluteUrl;
    }
    if (relativeUrl.length() > 0) {
        boolean removeLast = false;
        if (relativeUrl.endsWith(""/"")) {
                                                relativeUrl += ""/x"";
            removeLast = true;
        }
        String[] segmentArray = Strings.split(relativeUrl, '/');
        if (removeLast) {
            segmentArray[segmentArray.length - 1] = null;
        }
        for (String s : segmentArray) {
            if (s != null) {
                result.segments.add(decodeSegment(s, charset));
            }
        }
    }
    if (queryString.length() > 0) {
        String[] queryArray = Strings.split(queryString, '&');
        for (String s : queryArray) {
            if (Strings.isEmpty(s) == false) {
                result.parameters.add(parseQueryParameter(s, charset));
            }
        }
    }
    return result;
}",2.5454545454545454,0.22959183673469397,1.6666666666666667,0.5,1.5,1.980227385071676,-1.1256094063665045,1.9166666666666667,-0.028571428571428574,7.311507146191767
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443,1,"@Override
public void create(String tableName, boolean versioningIter, TimeType timeType) throws AccumuloException, AccumuloSecurityException, TableExistsException {
    if (!tableName.matches(Constants.VALID_TABLE_NAME_REGEX)) {
        throw new IllegalArgumentException();
    }
    acu.createTable(username, tableName, versioningIter, timeType);
}",,"@Override
public void create(String tableName, boolean versioningIter, TimeType timeType) throws AccumuloException, AccumuloSecurityException, TableExistsException {
    if (!tableName.matches(Constants.VALID_TABLE_NAME_REGEX)) {
        throw new IllegalArgumentException();
    }
    acu.createTable(username, tableName, versioningIter, timeType);
}",-0.3181818181818182,-0.11224489795918377,-0.16666666666666666,-0.5,-0.25,-0.3806228373702422,0.42013191855463133,-0.3333333333333333,-0.028571428571428574,-0.16422749602751402
flink,remotes/origin/bugs-dot-jar_FLINK-1820_39d526e6,0,"@Override
public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Byte reusable) {
    int val = 0;
    boolean neg = false;
    final int delimLimit = limit - delimiter.length + 1;
    if (bytes[startPos] == '-') {
        neg = true;
        startPos++;
        // check for empty field with only the sign
        if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);
            return -1;
        }
    }
    for (int i = startPos; i < limit; i++) {
        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {
            this.result = (byte) (neg ? -val : val);
            return i + delimiter.length;
        }
        if (bytes[i] < 48 || bytes[i] > 57) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);
            return -1;
        }
        val *= 10;
        val += bytes[i] - 48;
        if (val > Byte.MAX_VALUE && (!neg || val > -Byte.MIN_VALUE)) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);
            return -1;
        }
    }
    this.result = (byte) (neg ? -val : val);
    return limit;
}",,"@Override
public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Byte reusable) {
    int val = 0;
    boolean neg = false;
    final int delimLimit = limit - delimiter.length + 1;
    if (bytes[startPos] == '-') {
        neg = true;
        startPos++;
                if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);
            return -1;
        }
    }
    for (int i = startPos; i < limit; i++) {
        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {
            this.result = (byte) (neg ? -val : val);
            return i + delimiter.length;
        }
        if (bytes[i] < 48 || bytes[i] > 57) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);
            return -1;
        }
        val *= 10;
        val += bytes[i] - 48;
        if (val > Byte.MAX_VALUE && (!neg || val > -Byte.MIN_VALUE)) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);
            return -1;
        }
    }
    this.result = (byte) (neg ? -val : val);
    return limit;
}",0.8181818181818182,0.3520408163265306,0.8333333333333334,0.0,1.5833333333333333,2.9115175481957487,-0.6119873817034703,-0.08333333333333333,-0.028571428571428574,4.5939712439127804
wicket,remotes/origin/bugs-dot-jar_WICKET-4260_925cae5c,1,"@Override
public void sendRedirect(String url) {
    try {
        redirect = true;
        url = encodeRedirectURL(url);
        // wicket redirects should never be cached
        disableCaching();
        if (webRequest.isAjax()) {
            httpServletResponse.addHeader(""Ajax-Location"", url);
            /*
				 * usually the Ajax-Location header is enough and we do not need to the redirect url
				 * into the response, but sometimes the response is processed via an iframe (eg
				 * using multipart ajax handling) and the headers are not available because XHR is
				 * not used and that is the only way javascript has access to response headers.
				 */
            httpServletResponse.getWriter().write(""<ajax-response><redirect><![CDATA["" + url + ""]]></redirect></ajax-response>"");
            setContentType(""text/xml;charset="" + webRequest.getContainerRequest().getCharacterEncoding());
            disableCaching();
        } else {
            httpServletResponse.sendRedirect(url);
        }
    } catch (IOException e) {
        throw new WicketRuntimeException(e);
    }
}",,"@Override
public void sendRedirect(String url) {
    try {
        redirect = true;
        url = encodeRedirectURL(url);
                disableCaching();
        if (webRequest.isAjax()) {
            httpServletResponse.addHeader(""Ajax-Location"", url);
                        httpServletResponse.getWriter().write(""<ajax-response><redirect><![CDATA["" + url + ""]]></redirect></ajax-response>"");
            setContentType(""text/xml;charset="" + webRequest.getContainerRequest().getCharacterEncoding());
            disableCaching();
        } else {
            httpServletResponse.sendRedirect(url);
        }
    } catch (IOException e) {
        throw new WicketRuntimeException(e);
    }
}",0.18181818181818182,0.5612244897959184,0.0,0.0,-0.25,-0.0958971824023727,-0.12446228850014353,0.4166666666666667,0.0,-0.04692458915286469
wicket,remotes/origin/bugs-dot-jar_WICKET-3906_aadaa4e9,1,"/**
 *  @see org.apache.wicket.request.mapper.parameter.INamedParameters#set(java.lang.String,
 *       java.lang.Object)
 */
public PageParameters set(final String name, final Object value) {
    set(name, value, -1);
    return this;
}","/**
 *  @see org.apache.wicket.request.mapper.parameter.INamedParameters#set(java.lang.String,
 *       java.lang.Object)
 */
","public PageParameters set(final String name, final Object value) {
    set(name, value, -1);
    return this;
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8339546888442785,-0.4166666666666667,0.4285714285714286,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-294_2c8a114f,1,"/**
 * {@inheritDoc}
 * <p>
 * <strong>Algorithm Description</strong>: For small means, uses simulation
 * of a Poisson process using Uniform deviates, as described <a
 * href=""http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm""> here.</a>
 * </p>
 * <p>
 * The Poisson process (and hence value returned) is bounded by 1000 * mean.
 * </p>
 *
 * <p>
 * For large means, uses a reject method as described in <a
 * href=""http://cg.scs.carleton.ca/~luc/rnbookindex.html"">Non-Uniform Random
 * Variate Generation</a>
 * </p>
 *
 * <p>
 * References:
 * <ul>
 * <li>Devroye, Luc. (1986). <i>Non-Uniform Random Variate Generation</i>.
 * New York, NY. Springer-Verlag</li>
 * </ul>
 * </p>
 *
 * @param mean
 *            mean of the Poisson distribution.
 * @return the random Poisson value.
 */
public long nextPoisson(double mean) {
    if (mean <= 0) {
        throw MathRuntimeException.createIllegalArgumentException(""the Poisson mean must be positive ({0})"", mean);
    }
    final RandomGenerator generator = getRan();
    double pivot = 6.0;
    if (mean < pivot) {
        double p = Math.exp(-mean);
        long n = 0;
        double r = 1.0d;
        double rnd = 1.0d;
        while (n < 1000 * mean) {
            rnd = generator.nextDouble();
            r = r * rnd;
            if (r >= p) {
                n++;
            } else {
                return n;
            }
        }
        return n;
    } else {
        double mu = Math.floor(mean);
        // integer
        double delta = Math.floor(pivot + (mu - pivot) / 2.0);
        // between 6
        // and mean
        double mu2delta = 2.0 * mu + delta;
        double muDeltaHalf = mu + delta / 2.0;
        double logMeanMu = Math.log(mean / mu);
        double muFactorialLog = MathUtils.factorialLog((int) mu);
        double c1 = Math.sqrt(Math.PI * mu / 2.0);
        double c2 = c1 + Math.sqrt(Math.PI * muDeltaHalf / (2.0 * Math.exp(1.0 / mu2delta)));
        double c3 = c2 + 2.0;
        double c4 = c3 + Math.exp(1.0 / 78.0);
        double c = c4 + 2.0 / delta * mu2delta * Math.exp(-delta / mu2delta * (1.0 + delta / 2.0));
        double y = 0.0;
        double x = 0.0;
        double w = Double.POSITIVE_INFINITY;
        boolean accept = false;
        while (!accept) {
            double u = nextUniform(0.0, c);
            double e = nextExponential(mean);
            if (u <= c1) {
                double z = nextGaussian(0.0, 1.0);
                y = -Math.abs(z) * Math.sqrt(mu) - 1.0;
                x = Math.floor(y);
                w = -z * z / 2.0 - e - x * logMeanMu;
                if (x < -mu) {
                    w = Double.POSITIVE_INFINITY;
                }
            } else if (c1 < u && u <= c2) {
                double z = nextGaussian(0.0, 1.0);
                y = 1.0 + Math.abs(z) * Math.sqrt(muDeltaHalf);
                x = Math.ceil(y);
                w = (-y * y + 2.0 * y) / mu2delta - e - x * logMeanMu;
                if (x > delta) {
                    w = Double.POSITIVE_INFINITY;
                }
            } else if (c2 < u && u <= c3) {
                x = 0.0;
                w = -e;
            } else if (c3 < u && u <= c4) {
                x = 1.0;
                w = -e - logMeanMu;
            } else if (c4 < u) {
                double v = nextExponential(mean);
                y = delta + v * 2.0 / delta * mu2delta;
                x = Math.ceil(y);
                w = -delta / mu2delta * (1.0 + y / 2.0) - e - x * logMeanMu;
            }
            accept = w <= x * Math.log(mu) - MathUtils.factorialLog((int) (mu + x)) / muFactorialLog;
        }
        // numbers.
        return (long) (x + mu);
    }
}","/**
 * {@inheritDoc}
 * <p>
 * <strong>Algorithm Description</strong>: For small means, uses simulation
 * of a Poisson process using Uniform deviates, as described <a
 * href=""http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm""> here.</a>
 * </p>
 * <p>
 * The Poisson process (and hence value returned) is bounded by 1000 * mean.
 * </p>
 *
 * <p>
 * For large means, uses a reject method as described in <a
 * href=""http://cg.scs.carleton.ca/~luc/rnbookindex.html"">Non-Uniform Random
 * Variate Generation</a>
 * </p>
 *
 * <p>
 * References:
 * <ul>
 * <li>Devroye, Luc. (1986). <i>Non-Uniform Random Variate Generation</i>.
 * New York, NY. Springer-Verlag</li>
 * </ul>
 * </p>
 *
 * @param mean
 *            mean of the Poisson distribution.
 * @return the random Poisson value.
 */
","public long nextPoisson(double mean) {
    if (mean <= 0) {
        throw MathRuntimeException.createIllegalArgumentException(""the Poisson mean must be positive ({0})"", mean);
    }
    final RandomGenerator generator = getRan();
    double pivot = 6.0;
    if (mean < pivot) {
        double p = Math.exp(-mean);
        long n = 0;
        double r = 1.0d;
        double rnd = 1.0d;
        while (n < 1000 * mean) {
            rnd = generator.nextDouble();
            r = r * rnd;
            if (r >= p) {
                n++;
            } else {
                return n;
            }
        }
        return n;
    } else {
        double mu = Math.floor(mean);
                double delta = Math.floor(pivot + (mu - pivot) / 2.0);
                        double mu2delta = 2.0 * mu + delta;
        double muDeltaHalf = mu + delta / 2.0;
        double logMeanMu = Math.log(mean / mu);
        double muFactorialLog = MathUtils.factorialLog((int) mu);
        double c1 = Math.sqrt(Math.PI * mu / 2.0);
        double c2 = c1 + Math.sqrt(Math.PI * muDeltaHalf / (2.0 * Math.exp(1.0 / mu2delta)));
        double c3 = c2 + 2.0;
        double c4 = c3 + Math.exp(1.0 / 78.0);
        double c = c4 + 2.0 / delta * mu2delta * Math.exp(-delta / mu2delta * (1.0 + delta / 2.0));
        double y = 0.0;
        double x = 0.0;
        double w = Double.POSITIVE_INFINITY;
        boolean accept = false;
        while (!accept) {
            double u = nextUniform(0.0, c);
            double e = nextExponential(mean);
            if (u <= c1) {
                double z = nextGaussian(0.0, 1.0);
                y = -Math.abs(z) * Math.sqrt(mu) - 1.0;
                x = Math.floor(y);
                w = -z * z / 2.0 - e - x * logMeanMu;
                if (x < -mu) {
                    w = Double.POSITIVE_INFINITY;
                }
            } else if (c1 < u && u <= c2) {
                double z = nextGaussian(0.0, 1.0);
                y = 1.0 + Math.abs(z) * Math.sqrt(muDeltaHalf);
                x = Math.ceil(y);
                w = (-y * y + 2.0 * y) / mu2delta - e - x * logMeanMu;
                if (x > delta) {
                    w = Double.POSITIVE_INFINITY;
                }
            } else if (c2 < u && u <= c3) {
                x = 0.0;
                w = -e;
            } else if (c3 < u && u <= c4) {
                x = 1.0;
                w = -e - logMeanMu;
            } else if (c4 < u) {
                double v = nextExponential(mean);
                y = delta + v * 2.0 / delta * mu2delta;
                x = Math.ceil(y);
                w = -delta / mu2delta * (1.0 + y / 2.0) - e - x * logMeanMu;
            }
            accept = w <= x * Math.log(mu) - MathUtils.factorialLog((int) (mu + x)) / muFactorialLog;
        }
                return (long) (x + mu);
    }
}",2.6818181818181817,0.8061224489795916,1.6666666666666667,2.5,2.0,4.5902125556104805,-1.2133639231431033,1.75,-0.028571428571428574,24.714550648660918
flink,remotes/origin/bugs-dot-jar_FLINK-1705_5308ac83,1,"public String getHostname() {
    if (hostName == null) {
        String fqdn = getFQDNHostname();
        if (this.fqdnHostNameIsIP) {
            // fqdn to hostname translation is pointless if FQDN is an ip address.
            hostName = fqdn;
        } else {
            hostName = NetUtils.getHostnameFromFQDN(fqdn);
        }
    }
    return hostName;
}",,"public String getHostname() {
    if (hostName == null) {
        String fqdn = getFQDNHostname();
        if (this.fqdnHostNameIsIP) {
                        hostName = fqdn;
        } else {
            hostName = NetUtils.getHostnameFromFQDN(fqdn);
        }
    }
    return hostName;
}",-0.13636363636363635,0.47448979591836743,-0.16666666666666666,0.0,-0.08333333333333333,-0.06426099851705384,0.2563808431316318,-0.3333333333333333,1.885714285714286,-0.11509287693645309
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2999_3bf07779,1,"private Document makeDocument(String path, NodeState state, boolean isUpdate) {
    if (!isIndexable()) {
        return null;
    }
    List<Field> fields = new ArrayList<Field>();
    boolean dirty = false;
    for (PropertyState property : state.getProperties()) {
        String pname = property.getName();
        if (!isVisible(pname)) {
            continue;
        }
        PropertyDefinition pd = indexingRule.getConfig(pname);
        if (pd == null || !pd.index) {
            continue;
        }
        if (pd.ordered) {
            dirty |= addTypedOrderedFields(fields, property, pname, pd);
        }
        dirty |= indexProperty(path, fields, state, property, pname, pd);
    }
    dirty |= indexAggregates(path, fields, state);
    dirty |= indexNullCheckEnabledProps(path, fields, state);
    dirty |= indexNotNullCheckEnabledProps(path, fields, state);
    if (isUpdate && !dirty) {
        // updated the state but had no relevant changes
        return null;
    }
    // none of the properties are indexed
    if (!indexingRule.isFulltextEnabled() && !dirty) {
        return null;
    }
    Document document = new Document();
    document.add(newPathField(path));
    String name = getName(path);
    // TODO Possibly index nodeName without tokenization for node name based queries
    if (indexingRule.isFulltextEnabled()) {
        document.add(newFulltextField(name));
    }
    if (getDefinition().evaluatePathRestrictions()) {
        document.add(newAncestorsField(PathUtils.getParentPath(path)));
        document.add(newDepthField(path));
    }
    // because of LUCENE-5833 we have to merge the suggest fields into a single one
    Field suggestField = null;
    for (Field f : fields) {
        if (FieldNames.SUGGEST.endsWith(f.name())) {
            if (suggestField == null) {
                suggestField = FieldFactory.newSuggestField(f.stringValue());
            } else {
                suggestField = FieldFactory.newSuggestField(suggestField.stringValue(), f.stringValue());
            }
        } else {
            document.add(f);
        }
    }
    if (suggestField != null) {
        document.add(suggestField);
    }
    return document;
}",,"private Document makeDocument(String path, NodeState state, boolean isUpdate) {
    if (!isIndexable()) {
        return null;
    }
    List<Field> fields = new ArrayList<Field>();
    boolean dirty = false;
    for (PropertyState property : state.getProperties()) {
        String pname = property.getName();
        if (!isVisible(pname)) {
            continue;
        }
        PropertyDefinition pd = indexingRule.getConfig(pname);
        if (pd == null || !pd.index) {
            continue;
        }
        if (pd.ordered) {
            dirty |= addTypedOrderedFields(fields, property, pname, pd);
        }
        dirty |= indexProperty(path, fields, state, property, pname, pd);
    }
    dirty |= indexAggregates(path, fields, state);
    dirty |= indexNullCheckEnabledProps(path, fields, state);
    dirty |= indexNotNullCheckEnabledProps(path, fields, state);
    if (isUpdate && !dirty) {
                return null;
    }
        if (!indexingRule.isFulltextEnabled() && !dirty) {
        return null;
    }
    Document document = new Document();
    document.add(newPathField(path));
    String name = getName(path);
        if (indexingRule.isFulltextEnabled()) {
        document.add(newFulltextField(name));
    }
    if (getDefinition().evaluatePathRestrictions()) {
        document.add(newAncestorsField(PathUtils.getParentPath(path)));
        document.add(newDepthField(path));
    }
        Field suggestField = null;
    for (Field f : fields) {
        if (FieldNames.SUGGEST.endsWith(f.name())) {
            if (suggestField == null) {
                suggestField = FieldFactory.newSuggestField(f.stringValue());
            } else {
                suggestField = FieldFactory.newSuggestField(suggestField.stringValue(), f.stringValue());
            }
        } else {
            document.add(f);
        }
    }
    if (suggestField != null) {
        document.add(suggestField);
    }
    return document;
}",1.9090909090909092,0.23979591836734704,2.0,0.5,1.8333333333333333,1.151754819574889,-0.9727559506739321,2.25,-0.028571428571428574,3.0336429945049064
flink,remotes/origin/bugs-dot-jar_FLINK-3684_e3759a5e,1,"@Override
public void processWatermark(Watermark mark) throws Exception {
    // iterate over all keys to trigger the execution of the buffered elements
    for (KEY key : keys) {
        setKeyContext(key);
        PriorityQueue<StreamRecord<IN>> priorityQueue = getPriorityQueue();
        NFA<IN> nfa = getNFA();
        while (!priorityQueue.isEmpty() && priorityQueue.peek().getTimestamp() <= mark.getTimestamp()) {
            StreamRecord<IN> streamRecord = priorityQueue.poll();
            processEvent(nfa, streamRecord.getValue(), streamRecord.getTimestamp());
        }
    }
}",,"@Override
public void processWatermark(Watermark mark) throws Exception {
        for (KEY key : keys) {
        setKeyContext(key);
        PriorityQueue<StreamRecord<IN>> priorityQueue = getPriorityQueue();
        NFA<IN> nfa = getNFA();
        while (!priorityQueue.isEmpty() && priorityQueue.peek().getTimestamp() <= mark.getTimestamp()) {
            StreamRecord<IN> streamRecord = priorityQueue.poll();
            processEvent(nfa, streamRecord.getValue(), streamRecord.getTimestamp());
        }
    }
}",-0.09090909090909091,0.5816326530612246,-0.16666666666666666,0.0,0.0,0.2204646564508157,0.053054201319185396,0.4166666666666667,0.0,0.1140820880499912
camel,remotes/origin/bugs-dot-jar_CAMEL-4370_7345fefc,1,"/**
 * Bind this GenericFile to an Exchange
 */
public void bindToExchange(Exchange exchange) {
    exchange.setProperty(FileComponent.FILE_EXCHANGE_FILE, this);
    GenericFileMessage<T> in = new GenericFileMessage<T>(this);
    exchange.setIn(in);
    populateHeaders(in);
}","/**
 * Bind this GenericFile to an Exchange
 */
","public void bindToExchange(Exchange exchange) {
    exchange.setProperty(FileComponent.FILE_EXCHANGE_FILE, this);
    GenericFileMessage<T> in = new GenericFileMessage<T>(this);
    exchange.setIn(in);
    populateHeaders(in);
}",-0.36363636363636365,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.5540579294522512,-0.25,2.1714285714285717,-0.16422749602751402
Closure,151,2,"private void initConfigFromFlags(String[] args, PrintStream err) {
    // Args4j has a different format that the old command-line parser.
    // So we use some voodoo to get the args into the format that args4j
    // expects.
    Pattern argPattern = Pattern.compile(""(--[a-zA-Z_]+)=(.*)"");
    Pattern quotesPattern = Pattern.compile(""^['\""](.*)['\""]$"");
    List<String> processedArgs = Lists.newArrayList();
    for (String arg : args) {
        Matcher matcher = argPattern.matcher(arg);
        if (matcher.matches()) {
            processedArgs.add(matcher.group(1));
            String value = matcher.group(2);
            Matcher quotesMatcher = quotesPattern.matcher(value);
            if (quotesMatcher.matches()) {
                processedArgs.add(quotesMatcher.group(1));
            } else {
                processedArgs.add(value);
            }
        } else {
            processedArgs.add(arg);
        }
    }
    CmdLineParser parser = new CmdLineParser(flags);
    isConfigValid = true;
    try {
        parser.parseArgument(processedArgs.toArray(new String[] {}));
    } catch (CmdLineException e) {
        err.println(e.getMessage());
        isConfigValid = false;
    }
    if (!isConfigValid || flags.display_help) {
        isConfigValid = false;
        parser.printUsage(err);
    } else {
        getCommandLineConfig().setPrintTree(flags.print_tree).setComputePhaseOrdering(flags.compute_phase_ordering).setPrintAst(flags.print_ast).setPrintPassGraph(flags.print_pass_graph).setJscompDevMode(flags.jscomp_dev_mode).setLoggingLevel(flags.logging_level).setExterns(flags.externs).setJs(flags.js).setJsOutputFile(flags.js_output_file).setModule(flags.module).setVariableMapInputFile(flags.variable_map_input_file).setPropertyMapInputFile(flags.property_map_input_file).setVariableMapOutputFile(flags.variable_map_output_file).setCreateNameMapFiles(flags.create_name_map_files).setPropertyMapOutputFile(flags.property_map_output_file).setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()).setSummaryDetailLevel(flags.summary_detail_level).setOutputWrapper(flags.output_wrapper).setOutputWrapperMarker(flags.output_wrapper_marker).setModuleWrapper(flags.module_wrapper).setModuleOutputPathPrefix(flags.module_output_path_prefix).setCreateSourceMap(flags.create_source_map).setJscompError(flags.jscomp_error).setJscompWarning(flags.jscomp_warning).setJscompOff(flags.jscomp_off).setDefine(flags.define).setCharset(flags.charset).setManageClosureDependencies(flags.manage_closure_dependencies).setOutputManifest(flags.output_manifest);
    }
}",,"private void initConfigFromFlags(String[] args, PrintStream err) {
                Pattern argPattern = Pattern.compile(""(--[a-zA-Z_]+)=(.*)"");
    Pattern quotesPattern = Pattern.compile(""^['\""](.*)['\""]$"");
    List<String> processedArgs = Lists.newArrayList();
    for (String arg : args) {
        Matcher matcher = argPattern.matcher(arg);
        if (matcher.matches()) {
            processedArgs.add(matcher.group(1));
            String value = matcher.group(2);
            Matcher quotesMatcher = quotesPattern.matcher(value);
            if (quotesMatcher.matches()) {
                processedArgs.add(quotesMatcher.group(1));
            } else {
                processedArgs.add(value);
            }
        } else {
            processedArgs.add(arg);
        }
    }
    CmdLineParser parser = new CmdLineParser(flags);
    isConfigValid = true;
    try {
        parser.parseArgument(processedArgs.toArray(new String[] {}));
    } catch (CmdLineException e) {
        err.println(e.getMessage());
        isConfigValid = false;
    }
    if (!isConfigValid || flags.display_help) {
        isConfigValid = false;
        parser.printUsage(err);
    } else {
        getCommandLineConfig().setPrintTree(flags.print_tree).setComputePhaseOrdering(flags.compute_phase_ordering).setPrintAst(flags.print_ast).setPrintPassGraph(flags.print_pass_graph).setJscompDevMode(flags.jscomp_dev_mode).setLoggingLevel(flags.logging_level).setExterns(flags.externs).setJs(flags.js).setJsOutputFile(flags.js_output_file).setModule(flags.module).setVariableMapInputFile(flags.variable_map_input_file).setPropertyMapInputFile(flags.property_map_input_file).setVariableMapOutputFile(flags.variable_map_output_file).setCreateNameMapFiles(flags.create_name_map_files).setPropertyMapOutputFile(flags.property_map_output_file).setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()).setSummaryDetailLevel(flags.summary_detail_level).setOutputWrapper(flags.output_wrapper).setOutputWrapperMarker(flags.output_wrapper_marker).setModuleWrapper(flags.module_wrapper).setModuleOutputPathPrefix(flags.module_output_path_prefix).setCreateSourceMap(flags.create_source_map).setJscompError(flags.jscomp_error).setJscompWarning(flags.jscomp_warning).setJscompOff(flags.jscomp_off).setDefine(flags.define).setCharset(flags.charset).setManageClosureDependencies(flags.manage_closure_dependencies).setOutputManifest(flags.output_manifest);
    }
}",0.9090909090909091,0.5255102040816325,0.5,0.5,0.4166666666666667,-0.03657933761739987,-0.7218239174075138,3.5833333333333335,-0.028571428571428574,0.7759303754909394
wicket,remotes/origin/bugs-dot-jar_WICKET-4121_8967eb2b,1,"/**
 *  @see org.apache.wicket.extensions.wizard.IWizardModel#reset()
 */
public void reset() {
    history.clear();
    activeStep = null;
    setActiveStep(findNextVisibleStep());
}","/**
 *  @see org.apache.wicket.extensions.wizard.IWizardModel#reset()
 */
","public void reset() {
    history.clear();
    activeStep = null;
    setActiveStep(findNextVisibleStep());
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7731574419271581,-0.25,2.628571428571429,-0.16422749602751402
Closure,153,2,"/**
 * Remove duplicate VAR declarations encountered discovered during
 * scope creation.
 */
@Override
public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {
    Preconditions.checkState(n.getType() == Token.NAME);
    Var v = s.getVar(name);
    // If name is ""arguments"", Var maybe null.
    if (v != null && v.getParentNode().getType() == Token.CATCH) {
        // Redeclaration of a catch expression variable is hard to model
        // without support for ""with"" expressions.
        // The EcmaScript spec (section 12.14), declares that a catch
        // ""catch (e) {}"" is handled like ""with ({'e': e}) {}"" so that
        // ""var e"" would refer to the scope variable, but any following
        // reference would still refer to ""e"" of the catch expression.
        // Until we have support for this disallow it.
        // Currently the Scope object adds the catch expression to the
        // function scope, which is technically not true but a good
        // approximation for most uses.
        // TODO(johnlenz): Consider improving how scope handles catch
        // expression.
        // Use the name of the var before it was made unique.
        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);
        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));
    } else if (v != null && parent.getType() == Token.FUNCTION) {
        if (v.getParentNode().getType() == Token.VAR) {
            s.undeclare(v);
            s.declare(name, n, n.getJSType(), v.input);
            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());
        }
    } else if (parent.getType() == Token.VAR) {
        Preconditions.checkState(parent.hasOneChild());
        replaceVarWithAssignment(n, parent, gramps);
    }
}","/**
 * Remove duplicate VAR declarations encountered discovered during
 * scope creation.
 */
","@Override
public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {
    Preconditions.checkState(n.getType() == Token.NAME);
    Var v = s.getVar(name);
        if (v != null && v.getParentNode().getType() == Token.CATCH) {
                                                                                                                name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);
        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));
    } else if (v != null && parent.getType() == Token.FUNCTION) {
        if (v.getParentNode().getType() == Token.VAR) {
            s.undeclare(v);
            s.declare(name, n, n.getJSType(), v.input);
            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());
        }
    } else if (parent.getType() == Token.VAR) {
        Preconditions.checkState(parent.hasOneChild());
        replaceVarWithAssignment(n, parent, gramps);
    }
}",0.18181818181818182,0.413265306122449,0.16666666666666666,0.5,0.3333333333333333,0.44784972812654494,-0.29251505592199617,1.5,-0.028571428571428574,0.8416059550884225
Math,100,0,"/**
 * Guess the errors in unbound estimated parameters.
 * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>
 * @param problem estimation problem
 * @return errors in estimated parameters
 * @exception EstimationException if the covariances matrix cannot be computed
 * or the number of degrees of freedom is not positive (number of measurements
 * lesser or equal to number of parameters)
 */
public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException {
    int m = problem.getMeasurements().length;
    int p = problem.getAllParameters().length;
    if (m <= p) {
        throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"", new Object[] { new Integer(m), new Integer(p) });
    }
    double[] errors = new double[problem.getAllParameters().length];
    final double c = Math.sqrt(getChiSquare(problem) / (m - p));
    double[][] covar = getCovariances(problem);
    for (int i = 0; i < errors.length; ++i) {
        errors[i] = Math.sqrt(covar[i][i]) * c;
    }
    return errors;
}","/**
 * Guess the errors in unbound estimated parameters.
 * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>
 * @param problem estimation problem
 * @return errors in estimated parameters
 * @exception EstimationException if the covariances matrix cannot be computed
 * or the number of degrees of freedom is not positive (number of measurements
 * lesser or equal to number of parameters)
 */
","public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException {
    int m = problem.getMeasurements().length;
    int p = problem.getAllParameters().length;
    if (m <= p) {
        throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"", new Object[] { new Integer(m), new Integer(p) });
    }
    double[] errors = new double[problem.getAllParameters().length];
    final double c = Math.sqrt(getChiSquare(problem) / (m - p));
    double[][] covar = getCovariances(problem);
    for (int i = 0; i < errors.length; ++i) {
        errors[i] = Math.sqrt(covar[i][i]) * c;
    }
    return errors;
}",0.0,-0.44897959183673464,0.0,-0.5,0.08333333333333333,0.9935739001482948,-0.08115858904502435,0.08333333333333333,-0.028571428571428574,0.7618607081518409
Math,39,1,"/**
 * {@inheritDoc}
 */
@Override
public void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {
    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();
    // create some internal working arrays
    final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp = y0.clone();
    final double[] yDotTmp = new double[y.length];
    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());
    // set up integration control objects
    stepStart = equations.getTime();
    double hNew = 0;
    boolean firstTime = true;
    initIntegration(equations.getTime(), y0, t);
    // main integration loop
    isLastStep = false;
    do {
        interpolator.shift();
        // iterate over step size, ensuring local normalized error is smaller than 1
        double error = 10;
        while (error >= 1.0) {
            if (firstTime || !fsal) {
                // first stage
                computeDerivatives(stepStart, y, yDotK[0]);
            }
            if (firstTime) {
                final double[] scale = new double[mainSetDimension];
                if (vecAbsoluteTolerance == null) {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
                    }
                } else {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
                    }
                }
                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }
            stepSize = hNew;
            // next stages
            for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
            // estimate the error at the end of the step
            error = estimateError(yDotK, y, yTmp, stepSize);
            if (error >= 1.0) {
                // reject the step and attempt to reduce error by stepsize control
                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            }
        }
        // local error is small enough: accept the step, trigger events and step handlers
        interpolator.storeTime(stepStart + stepSize);
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
        stepStart = acceptStep(interpolator, y, yDotTmp, t);
        System.arraycopy(y, 0, yTmp, 0, y.length);
        if (!isLastStep) {
            // prepare next step
            interpolator.storeTime(stepStart);
            if (fsal) {
                // save the last evaluation for the next step
                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
            }
            // stepsize control for next step
            final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
            final double filteredNextT = stepStart + hNew;
            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
            if (filteredNextIsLast) {
                hNew = t - stepStart;
            }
        }
    } while (!isLastStep);
    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);
    resetInternalState();
}","/**
 * {@inheritDoc}
 */
","@Override
public void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {
    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();
        final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp = y0.clone();
    final double[] yDotTmp = new double[y.length];
        final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());
        stepStart = equations.getTime();
    double hNew = 0;
    boolean firstTime = true;
    initIntegration(equations.getTime(), y0, t);
        isLastStep = false;
    do {
        interpolator.shift();
                double error = 10;
        while (error >= 1.0) {
            if (firstTime || !fsal) {
                                computeDerivatives(stepStart, y, yDotK[0]);
            }
            if (firstTime) {
                final double[] scale = new double[mainSetDimension];
                if (vecAbsoluteTolerance == null) {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
                    }
                } else {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
                    }
                }
                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }
            stepSize = hNew;
                        for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
                        for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
                        error = estimateError(yDotK, y, yTmp, stepSize);
            if (error >= 1.0) {
                                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            }
        }
                interpolator.storeTime(stepStart + stepSize);
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
        stepStart = acceptStep(interpolator, y, yDotTmp, t);
        System.arraycopy(y, 0, yTmp, 0, y.length);
        if (!isLastStep) {
                        interpolator.storeTime(stepStart);
            if (fsal) {
                                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
            }
                        final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
            final double filteredNextT = stepStart + hNew;
            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
            if (filteredNextIsLast) {
                hNew = t - stepStart;
            }
        }
    } while (!isLastStep);
        equations.setTime(stepStart);
    equations.setCompleteState(y);
    resetInternalState();
}",3.4545454545454546,1.5255102040816326,2.5,1.5,2.3333333333333335,4.295600593178448,-1.3753943217665618,2.9166666666666665,-0.028571428571428574,28.777210993614037
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1505_994df698,1,"@Override
public void addMutation(Mutation m) throws MutationsRejectedException {
    acu.addMutation(tablename, m);
}",,"@Override
public void addMutation(Mutation m) throws MutationsRejectedException {
    acu.addMutation(tablename, m);
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8695153427014626,-0.4166666666666667,1.2,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-4520_b91154ea,1,"/**
 *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT OVERRIDE OR CALL.
 *
 *  Internal initialization.
 */
protected void internalInit() {
    settingsAccessible = true;
    IPageSettings pageSettings = getPageSettings();
    // Install default component resolvers
    pageSettings.addComponentResolver(new MarkupInheritanceResolver());
    pageSettings.addComponentResolver(new HtmlHeaderResolver());
    pageSettings.addComponentResolver(new WicketLinkTagHandler());
    pageSettings.addComponentResolver(new WicketMessageResolver());
    pageSettings.addComponentResolver(new WicketMessageTagHandler());
    pageSettings.addComponentResolver(new FragmentResolver());
    pageSettings.addComponentResolver(new RelativePathPrefixHandler());
    pageSettings.addComponentResolver(new EnclosureHandler());
    pageSettings.addComponentResolver(new InlineEnclosureHandler());
    pageSettings.addComponentResolver(new WicketContainerResolver());
    // Install button image resource factory
    getResourceSettings().addResourceFactory(""buttonFactory"", new DefaultButtonImageResourceFactory());
    String applicationKey = getApplicationKey();
    applicationKeyToApplication.put(applicationKey, this);
    converterLocator = newConverterLocator();
    setPageManagerProvider(new DefaultPageManagerProvider(this));
    resourceReferenceRegistry = newResourceReferenceRegistry();
    sharedResources = newSharedResources(resourceReferenceRegistry);
    resourceBundles = newResourceBundles(resourceReferenceRegistry);
    // set up default request mapper
    setRootRequestMapper(new SystemMapper(this));
    pageFactory = newPageFactory();
    requestCycleProvider = new DefaultRequestCycleProvider();
    exceptionMapperProvider = new DefaultExceptionMapperProvider();
    // add a request cycle listener that logs each request for the requestlogger.
    getRequestCycleListeners().add(new RequestLoggerRequestCycleListener());
}","/**
 *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT OVERRIDE OR CALL.
 *
 *  Internal initialization.
 */
","protected void internalInit() {
    settingsAccessible = true;
    IPageSettings pageSettings = getPageSettings();
        pageSettings.addComponentResolver(new MarkupInheritanceResolver());
    pageSettings.addComponentResolver(new HtmlHeaderResolver());
    pageSettings.addComponentResolver(new WicketLinkTagHandler());
    pageSettings.addComponentResolver(new WicketMessageResolver());
    pageSettings.addComponentResolver(new WicketMessageTagHandler());
    pageSettings.addComponentResolver(new FragmentResolver());
    pageSettings.addComponentResolver(new RelativePathPrefixHandler());
    pageSettings.addComponentResolver(new EnclosureHandler());
    pageSettings.addComponentResolver(new InlineEnclosureHandler());
    pageSettings.addComponentResolver(new WicketContainerResolver());
        getResourceSettings().addResourceFactory(""buttonFactory"", new DefaultButtonImageResourceFactory());
    String applicationKey = getApplicationKey();
    applicationKeyToApplication.put(applicationKey, this);
    converterLocator = newConverterLocator();
    setPageManagerProvider(new DefaultPageManagerProvider(this));
    resourceReferenceRegistry = newResourceReferenceRegistry();
    sharedResources = newSharedResources(resourceReferenceRegistry);
    resourceBundles = newResourceBundles(resourceReferenceRegistry);
        setRootRequestMapper(new SystemMapper(this));
    pageFactory = newPageFactory();
    requestCycleProvider = new DefaultRequestCycleProvider();
    exceptionMapperProvider = new DefaultExceptionMapperProvider();
        getRequestCycleListeners().add(new RequestLoggerRequestCycleListener());
}",0.5909090909090909,-1.0051020408163265,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,-0.4212790364209923,1.5,-0.028571428571428574,-0.16422749602751402
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1008_0c20bfd8,1,"/**
 * Finds matching classes within a jar files that contains a folder structure
 * matching the package structure.  If the File is not a JarFile or does not exist a warning
 * will be logged, but no error will be raised.
 *
 * @param test a Test used to filter the classes that are discovered
 * @param parent the parent package under which classes must be in order to be considered
 * @param stream The jar InputStream
 */
private void loadImplementationsInJar(final Test test, final String parent, final String path, final JarInputStream stream) {
    try {
        JarEntry entry;
        while ((entry = stream.getNextJarEntry()) != null) {
            final String name = entry.getName();
            if (!entry.isDirectory() && name.startsWith(parent) && isTestApplicable(test, name)) {
                addIfMatching(test, name);
            }
        }
    } catch (final IOException ioe) {
        LOGGER.error(""Could not search jar file '"" + path + ""' for classes matching criteria: "" + test + "" due to an IOException"", ioe);
    }
}","/**
 * Finds matching classes within a jar files that contains a folder structure
 * matching the package structure.  If the File is not a JarFile or does not exist a warning
 * will be logged, but no error will be raised.
 *
 * @param test a Test used to filter the classes that are discovered
 * @param parent the parent package under which classes must be in order to be considered
 * @param stream The jar InputStream
 */
","private void loadImplementationsInJar(final Test test, final String parent, final String path, final JarInputStream stream) {
    try {
        JarEntry entry;
        while ((entry = stream.getNextJarEntry()) != null) {
            final String name = entry.getName();
            if (!entry.isDirectory() && name.startsWith(parent) && isTestApplicable(test, name)) {
                addIfMatching(test, name);
            }
        }
    } catch (final IOException ioe) {
        LOGGER.error(""Could not search jar file '"" + path + ""' for classes matching criteria: "" + test + "" due to an IOException"", ioe);
    }
}",-0.045454545454545456,0.8418367346938775,0.0,0.5,0.4166666666666667,0.24221453287197237,-0.003441353599082437,0.08333333333333333,0.1142857142857143,0.15029916781237018
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3110_d10362c0,1,"public Directory wrapForWrite(IndexDefinition definition, Directory remote, boolean reindexMode) throws IOException {
    Directory local = createLocalDirForIndexWriter(definition);
    return new CopyOnWriteDirectory(remote, local, reindexMode, getIndexPathForLogging(definition));
}",,"public Directory wrapForWrite(IndexDefinition definition, Directory remote, boolean reindexMode) throws IOException {
    Directory local = createLocalDirForIndexWriter(definition);
    return new CopyOnWriteDirectory(remote, local, reindexMode, getIndexPathForLogging(definition));
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7347289934040726,-0.3333333333333333,0.05714285714285714,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-2350_cd281092,1,"/**
 *  @see org.apache.wicket.validation.IErrorMessageSource#getMessage(java.lang.String)
 */
public String getMessage(String key) {
    final FormComponent<T> formComponent = FormComponent.this;
    // Use the following log4j config for detailed logging on the property resolution
    // process
    // log4j.logger.org.apache.wicket.resource.loader=DEBUG
    // log4j.logger.org.apache.wicket.Localizer=DEBUG
    final Localizer localizer = formComponent.getLocalizer();
    // retrieve prefix that will be used to construct message keys
    String prefix = formComponent.getValidatorKeyPrefix();
    String message = null;
    // first try the full form of key [prefix].[form-component-id].[key]
    String resource = prefix(prefix, getId() + ""."" + key);
    message = getString(localizer, resource, formComponent);
    // if not found, try a more general form (without prefix) [form-component-id].[key]
    if (Strings.isEmpty(message) && Strings.isEmpty(prefix)) {
        resource = getId() + ""."" + key;
        message = getString(localizer, resource, formComponent);
    }
    // If not found try a more general form [prefix].[key]
    if (Strings.isEmpty(message)) {
        resource = prefix(prefix, key);
        message = getString(localizer, key, formComponent);
    }
    // If not found try the most general form [key]
    if (Strings.isEmpty(message) && Strings.isEmpty(prefix)) {
        // Try a variation of the resource key
        message = getString(localizer, key, formComponent);
    }
    // returned from localizer
    if (Strings.isEmpty(message)) {
        message = null;
    }
    return message;
}","/**
 *  @see org.apache.wicket.validation.IErrorMessageSource#getMessage(java.lang.String)
 */
","public String getMessage(String key) {
    final FormComponent<T> formComponent = FormComponent.this;
                    final Localizer localizer = formComponent.getLocalizer();
        String prefix = formComponent.getValidatorKeyPrefix();
    String message = null;
        String resource = prefix(prefix, getId() + ""."" + key);
    message = getString(localizer, resource, formComponent);
        if (Strings.isEmpty(message) && Strings.isEmpty(prefix)) {
        resource = getId() + ""."" + key;
        message = getString(localizer, resource, formComponent);
    }
        if (Strings.isEmpty(message)) {
        resource = prefix(prefix, key);
        message = getString(localizer, key, formComponent);
    }
        if (Strings.isEmpty(message) && Strings.isEmpty(prefix)) {
                message = getString(localizer, key, formComponent);
    }
        if (Strings.isEmpty(message)) {
        message = null;
    }
    return message;
}",0.4090909090909091,-0.39285714285714285,0.16666666666666666,-0.5,0.4166666666666667,0.37073652990608014,-0.36191568683682274,0.8333333333333334,-0.028571428571428574,0.5131038499920765
wicket,remotes/origin/bugs-dot-jar_WICKET-5265_0eb596df,1,"@Override
protected boolean shouldRecurseInto(Component component) {
    return component.getMetaData(FENCE_KEY) == null;
}",,"@Override
protected boolean shouldRecurseInto(Component component) {
    return component.getMetaData(FENCE_KEY) == null;
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8611987381703473,-0.4166666666666667,2.342857142857143,-0.16422749602751402
flink,remotes/origin/bugs-dot-jar_FLINK-3260_6968a57a,0,"// --------------------------------------------------------------------------------------------
// Internal Actions
// --------------------------------------------------------------------------------------------
private boolean processFail(Throwable t, boolean isCallback) {
    // atomically switch to failed
    while (true) {
        ExecutionState current = this.state;
        if (current == FAILED) {
            // already failed. It is enough to remember once that we failed (its sad enough)
            return false;
        }
        if (current == CANCELED) {
            // we are already aborting or are already aborted
            if (LOG.isDebugEnabled()) {
                LOG.debug(String.format(""Ignoring transition of vertex %s to %s while being %s"", getVertexWithAttempt(), FAILED, CANCELED));
            }
            return false;
        }
        if (transitionState(current, FAILED, t)) {
            // success (in a manner of speaking)
            this.failureCause = t;
            try {
                if (assignedResource != null) {
                    assignedResource.releaseSlot();
                }
                vertex.getExecutionGraph().deregisterExecution(this);
            } finally {
                vertex.executionFailed(t);
            }
            if (!isCallback && (current == RUNNING || current == DEPLOYING)) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Sending out cancel request, to remove task execution from TaskManager."");
                }
                try {
                    if (assignedResource != null) {
                        sendCancelRpcCall();
                    }
                } catch (Throwable tt) {
                    // no reason this should ever happen, but log it to be safe
                    LOG.error(""Error triggering cancel call while marking task as failed."", tt);
                }
            }
            // leave the loop
            return true;
        }
    }
}",,"private boolean processFail(Throwable t, boolean isCallback) {
        while (true) {
        ExecutionState current = this.state;
        if (current == FAILED) {
                        return false;
        }
        if (current == CANCELED) {
                        if (LOG.isDebugEnabled()) {
                LOG.debug(String.format(""Ignoring transition of vertex %s to %s while being %s"", getVertexWithAttempt(), FAILED, CANCELED));
            }
            return false;
        }
        if (transitionState(current, FAILED, t)) {
                        this.failureCause = t;
            try {
                if (assignedResource != null) {
                    assignedResource.releaseSlot();
                }
                vertex.getExecutionGraph().deregisterExecution(this);
            } finally {
                vertex.executionFailed(t);
            }
            if (!isCallback && (current == RUNNING || current == DEPLOYING)) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Sending out cancel request, to remove task execution from TaskManager."");
                }
                try {
                    if (assignedResource != null) {
                        sendCancelRpcCall();
                    }
                } catch (Throwable tt) {
                                        LOG.error(""Error triggering cancel call while marking task as failed."", tt);
                }
            }
                        return true;
        }
    }
}",1.0909090909090908,1.2499999999999998,1.1666666666666667,1.5,1.0,0.6534849233811174,-0.6234585603670781,0.5833333333333334,-0.028571428571428574,0.699607248555557
camel,remotes/origin/bugs-dot-jar_CAMEL-4682_1e54865c,3,"protected synchronized void doStop() throws Exception {
    stopWatch.restart();
    log.info(""Apache Camel "" + getVersion() + "" (CamelContext:"" + getName() + "") is shutting down"");
    EventHelper.notifyCamelContextStopping(this);
    // stop route inputs in the same order as they was started so we stop the very first inputs first
    try {
        shutdownStrategy.shutdown(this, getRouteStartupOrder());
    } catch (Throwable e) {
        log.warn(""Error occurred while shutting down routes. This exception will be ignored."", e);
    }
    getRouteStartupOrder().clear();
    shutdownServices(routeServices.values());
    // do not clear route services or startup listeners as we can start Camel again and get the route back as before
    // but clear any suspend routes
    suspendedRouteServices.clear();
    // the stop order is important
    // shutdown debugger
    ServiceHelper.stopAndShutdownService(getDebugger());
    shutdownServices(endpoints.values());
    endpoints.clear();
    shutdownServices(components.values());
    components.clear();
    try {
        for (LifecycleStrategy strategy : lifecycleStrategies) {
            strategy.onContextStop(this);
        }
    } catch (Throwable e) {
        log.warn(""Error occurred while stopping lifecycle strategies. This exception will be ignored."", e);
    }
    // shutdown services as late as possible
    shutdownServices(servicesToClose);
    servicesToClose.clear();
    // must notify that we are stopped before stopping the management strategy
    EventHelper.notifyCamelContextStopped(this);
    // stop the notifier service
    for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {
        shutdownServices(notifier);
    }
    // shutdown management as the last one
    shutdownServices(managementStrategy);
    shutdownServices(lifecycleStrategies);
    lifecycleStrategies.clear();
    // stop the lazy created so they can be re-created on restart
    forceStopLazyInitialization();
    stopWatch.stop();
    if (log.isInfoEnabled()) {
        log.info(""Uptime: "" + getUptime());
        log.info(""Apache Camel "" + getVersion() + "" (CamelContext: "" + getName() + "") is shutdown in "" + TimeUtils.printDuration(stopWatch.taken()));
    }
    // and clear start date
    startDate = null;
}",,"protected synchronized void doStop() throws Exception {
    stopWatch.restart();
    log.info(""Apache Camel "" + getVersion() + "" (CamelContext:"" + getName() + "") is shutting down"");
    EventHelper.notifyCamelContextStopping(this);
        try {
        shutdownStrategy.shutdown(this, getRouteStartupOrder());
    } catch (Throwable e) {
        log.warn(""Error occurred while shutting down routes. This exception will be ignored."", e);
    }
    getRouteStartupOrder().clear();
    shutdownServices(routeServices.values());
            suspendedRouteServices.clear();
            ServiceHelper.stopAndShutdownService(getDebugger());
    shutdownServices(endpoints.values());
    endpoints.clear();
    shutdownServices(components.values());
    components.clear();
    try {
        for (LifecycleStrategy strategy : lifecycleStrategies) {
            strategy.onContextStop(this);
        }
    } catch (Throwable e) {
        log.warn(""Error occurred while stopping lifecycle strategies. This exception will be ignored."", e);
    }
        shutdownServices(servicesToClose);
    servicesToClose.clear();
        EventHelper.notifyCamelContextStopped(this);
        for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {
        shutdownServices(notifier);
    }
        shutdownServices(managementStrategy);
    shutdownServices(lifecycleStrategies);
    lifecycleStrategies.clear();
        forceStopLazyInitialization();
    stopWatch.stop();
    if (log.isInfoEnabled()) {
        log.info(""Uptime: "" + getUptime());
        log.info(""Apache Camel "" + getVersion() + "" (CamelContext: "" + getName() + "") is shutdown in "" + TimeUtils.printDuration(stopWatch.taken()));
    }
        startDate = null;
}",1.2272727272727273,-0.4183673469387754,0.3333333333333333,0.0,-0.25,-0.042511122095897164,-0.6842558072841987,3.0,-0.028571428571428574,0.25420483893764373
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2062_5c4589bd,1,"private void readOakProperties(ArrayList<PropertyValue> target, Tree t, String oakPropertyName, Integer propertyType) {
    boolean skipCurrentNode = false;
    while (true) {
        if (t == null || !t.exists()) {
            return;
        }
        int slash = oakPropertyName.indexOf('/');
        if (slash < 0) {
            break;
        }
        String parent = oakPropertyName.substring(0, slash);
        oakPropertyName = oakPropertyName.substring(slash + 1);
        if (parent.equals("".."")) {
            t = t.isRoot() ? null : t.getParent();
        } else if (parent.equals(""."")) {
        // same node
        } else if (parent.equals(""*"")) {
            for (Tree child : t.getChildren()) {
                readOakProperties(target, child, oakPropertyName, propertyType);
            }
            skipCurrentNode = true;
        } else {
            t = t.getChild(parent);
        }
    }
    if (skipCurrentNode) {
        return;
    }
    if (!""*"".equals(oakPropertyName)) {
        PropertyValue value = currentOakProperty(t, oakPropertyName, propertyType);
        if (value != null) {
            target.add(value);
        }
        return;
    }
    for (PropertyState p : t.getProperties()) {
        if (propertyType == null || p.getType().tag() == propertyType) {
            PropertyValue v = PropertyValues.create(p);
            target.add(v);
        }
    }
}",,"private void readOakProperties(ArrayList<PropertyValue> target, Tree t, String oakPropertyName, Integer propertyType) {
    boolean skipCurrentNode = false;
    while (true) {
        if (t == null || !t.exists()) {
            return;
        }
        int slash = oakPropertyName.indexOf('/');
        if (slash < 0) {
            break;
        }
        String parent = oakPropertyName.substring(0, slash);
        oakPropertyName = oakPropertyName.substring(slash + 1);
        if (parent.equals("".."")) {
            t = t.isRoot() ? null : t.getParent();
        } else if (parent.equals(""."")) {
                } else if (parent.equals(""*"")) {
            for (Tree child : t.getChildren()) {
                readOakProperties(target, child, oakPropertyName, propertyType);
            }
            skipCurrentNode = true;
        } else {
            t = t.getChild(parent);
        }
    }
    if (skipCurrentNode) {
        return;
    }
    if (!""*"".equals(oakPropertyName)) {
        PropertyValue value = currentOakProperty(t, oakPropertyName, propertyType);
        if (value != null) {
            target.add(value);
        }
        return;
    }
    for (PropertyState p : t.getProperties()) {
        if (propertyType == null || p.getType().tag() == propertyType) {
            PropertyValue v = PropertyValues.create(p);
            target.add(v);
        }
    }
}",1.2272727272727273,0.2346938775510204,1.8333333333333333,1.5,1.75,0.971824023727138,-0.7651276168626331,1.1666666666666667,-0.028571428571428574,1.7694716058265985
commons-math,remotes/origin/bugs-dot-jar_MATH-757_76b7413d,1,"/**
 * The contraction criterion defines when the internal array will contract
 * to store only the number of elements in the element array.
 * If  the <code>expansionMode</code> is <code>MULTIPLICATIVE_MODE</code>,
 * contraction is triggered when the ratio between storage array length
 * and <code>numElements</code> exceeds <code>contractionFactor</code>.
 * If the <code>expansionMode</code> is <code>ADDITIVE_MODE</code>, the
 * number of excess storage locations is compared to
 * <code>contractionFactor.</code>
 *
 * @return the contraction criterion used to reclaim memory.
 * @since 3.1
 */
public double getContractionCriterion() {
    return contractionCriterion;
}","/**
 * The contraction criterion defines when the internal array will contract
 * to store only the number of elements in the element array.
 * If  the <code>expansionMode</code> is <code>MULTIPLICATIVE_MODE</code>,
 * contraction is triggered when the ratio between storage array length
 * and <code>numElements</code> exceeds <code>contractionFactor</code>.
 * If the <code>expansionMode</code> is <code>ADDITIVE_MODE</code>, the
 * number of excess storage locations is compared to
 * <code>contractionFactor.</code>
 *
 * @return the contraction criterion used to reclaim memory.
 * @since 3.1
 */
","public double getContractionCriterion() {
    return contractionCriterion;
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.2776025236593067,-0.5,0.0,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-5359_61122bab,3,"/**
 *  Convert to character, returning default value if text is inconvertible.
 *
 *  @param defaultValue
 *             the default value
 *  @return the converted text as a primitive char or the default value if text is not a single character
 */
public final char toChar(final char defaultValue) {
    if (text != null) {
        try {
            return toChar();
        } catch (StringValueConversionException x) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(String.format(""An error occurred while converting '%s' to a character: %s"", text, x.getMessage()), x);
            }
        }
    }
    return defaultValue;
}","/**
 *  Convert to character, returning default value if text is inconvertible.
 *
 *  @param defaultValue
 *             the default value
 *  @return the converted text as a primitive char or the default value if text is not a single character
 */
","public final char toChar(final char defaultValue) {
    if (text != null) {
        try {
            return toChar();
        } catch (StringValueConversionException x) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(String.format(""An error occurred while converting '%s' to a character: %s"", text, x.getMessage()), x);
            }
        }
    }
    return defaultValue;
}",-0.09090909090909091,0.933673469387755,0.0,0.5,-0.08333333333333333,-0.3806228373702422,0.1892744479495267,-0.08333333333333333,1.1714285714285715,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-442_246d53c5,1,"/**
 *  Registers a debug feedback message for this component
 *
 *  @param message
 *             The feedback message
 */
public final void debug(final String message) {
    getPage().getFeedbackMessages().debug(this, message);
}","/**
 *  Registers a debug feedback message for this component
 *
 *  @param message
 *             The feedback message
 */
","public final void debug(final String message) {
    getPage().getFeedbackMessages().debug(this, message);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.0585030111843994,-0.25,2.7714285714285714,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-555_328513f3,3,"/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */
public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    } catch (RuntimeException ex) {
        throw new MathRuntimeException(ex);
    }
}","/**
 * Round the given value to the specified number of decimal places. The
 * value is rounded using the given method which is any method defined in
 * {@link BigDecimal}.
 *
 * @param x the value to round.
 * @param scale the number of digits to the right of the decimal point.
 * @param roundingMethod the rounding method as defined in
 *        {@link BigDecimal}.
 * @return the rounded value.
 * @since 1.1
 */
","public static double round(double x, int scale, int roundingMethod) {
    try {
        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
    } catch (NumberFormatException ex) {
        if (Double.isInfinite(x)) {
            return x;
        } else {
            return Double.NaN;
        }
    } catch (RuntimeException ex) {
        throw new MathRuntimeException(ex);
    }
}",-0.045454545454545456,0.35714285714285726,0.16666666666666666,0.0,-0.16666666666666666,-0.3806228373702422,0.11585890450243742,-0.16666666666666666,0.1142857142857143,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3333_194999ed,1,"/**
 * Collect _revisions and _commitRoot entries that can be moved to a
 * previous document.
 */
private void collectRevisionsAndCommitRoot() {
    NavigableMap<Revision, String> revisions = new TreeMap<Revision, String>(context.getRevisionComparator());
    for (Map.Entry<Revision, String> entry : doc.getLocalRevisions().entrySet()) {
        if (splitRevs.contains(entry.getKey())) {
            revisions.put(entry.getKey(), entry.getValue());
            numValues++;
        } else {
            // local changes
            if (context.getClusterId() != entry.getKey().getClusterId()) {
                // only consider local changes
                continue;
            }
            if (doc.isCommitted(entry.getKey()) && !mostRecentRevs.contains(entry.getKey())) {
                // this is a commit root for changes in other documents
                revisions.put(entry.getKey(), entry.getValue());
                numValues++;
                trackHigh(entry.getKey());
                trackLow(entry.getKey());
            }
        }
    }
    committedChanges.put(REVISIONS, revisions);
    NavigableMap<Revision, String> commitRoot = new TreeMap<Revision, String>(context.getRevisionComparator());
    for (Map.Entry<Revision, String> entry : doc.getLocalCommitRoot().entrySet()) {
        Revision r = entry.getKey();
        if (splitRevs.contains(r)) {
            commitRoot.put(r, entry.getValue());
            numValues++;
        } else if (r.getClusterId() == context.getClusterId() && !changes.contains(r)) {
            // OAK-2528: _commitRoot entry without associated
            // change -> consider as garbage
            addGarbage(r, COMMIT_ROOT);
        }
    }
    committedChanges.put(COMMIT_ROOT, commitRoot);
}","/**
 * Collect _revisions and _commitRoot entries that can be moved to a
 * previous document.
 */
","private void collectRevisionsAndCommitRoot() {
    NavigableMap<Revision, String> revisions = new TreeMap<Revision, String>(context.getRevisionComparator());
    for (Map.Entry<Revision, String> entry : doc.getLocalRevisions().entrySet()) {
        if (splitRevs.contains(entry.getKey())) {
            revisions.put(entry.getKey(), entry.getValue());
            numValues++;
        } else {
                        if (context.getClusterId() != entry.getKey().getClusterId()) {
                                continue;
            }
            if (doc.isCommitted(entry.getKey()) && !mostRecentRevs.contains(entry.getKey())) {
                                revisions.put(entry.getKey(), entry.getValue());
                numValues++;
                trackHigh(entry.getKey());
                trackLow(entry.getKey());
            }
        }
    }
    committedChanges.put(REVISIONS, revisions);
    NavigableMap<Revision, String> commitRoot = new TreeMap<Revision, String>(context.getRevisionComparator());
    for (Map.Entry<Revision, String> entry : doc.getLocalCommitRoot().entrySet()) {
        Revision r = entry.getKey();
        if (splitRevs.contains(r)) {
            commitRoot.put(r, entry.getValue());
            numValues++;
        } else if (r.getClusterId() == context.getClusterId() && !changes.contains(r)) {
                                    addGarbage(r, COMMIT_ROOT);
        }
    }
    committedChanges.put(COMMIT_ROOT, commitRoot);
}",0.7727272727272727,0.872448979591837,0.8333333333333334,0.5,1.0,1.434503213049926,-0.5856036707771726,2.4166666666666665,-0.028571428571428574,2.262111263871579
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1364_05c89637,1,"@Override
public ConcurrentMap<K, V> asMap() {
    return new ConcurrentMap<K, V>() {

        @Override
        public int size() {
            long size = CacheLIRS.this.size();
            return (int) Math.min(size, Integer.MAX_VALUE);
        }

        @Override
        public boolean isEmpty() {
            return CacheLIRS.this.size() == 0;
        }

        @Override
        public boolean containsKey(Object key) {
            return CacheLIRS.this.containsKey(key);
        }

        @Override
        public boolean containsValue(Object value) {
            return CacheLIRS.this.containsValue(value);
        }

        @SuppressWarnings(""unchecked"")
        @Override
        public V get(Object key) {
            return CacheLIRS.this.getUnchecked((K) key);
        }

        @Override
        public V put(K key, V value) {
            return CacheLIRS.this.put(key, value, sizeOf(key, value));
        }

        @Override
        public V remove(Object key) {
            @SuppressWarnings(""unchecked"")
            V old = CacheLIRS.this.getUnchecked((K) key);
            CacheLIRS.this.invalidate(key);
            return old;
        }

        @Override
        public void putAll(Map<? extends K, ? extends V> m) {
            for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {
                put(e.getKey(), e.getValue());
            }
        }

        @Override
        public void clear() {
            CacheLIRS.this.clear();
        }

        @Override
        public Set<K> keySet() {
            return CacheLIRS.this.keySet();
        }

        @Override
        public Collection<V> values() {
            return CacheLIRS.this.values();
        }

        @Override
        public Set<java.util.Map.Entry<K, V>> entrySet() {
            return CacheLIRS.this.entrySet();
        }

        @Override
        public V putIfAbsent(K key, V value) {
            return CacheLIRS.this.putIfAbsent(key, value);
        }

        @Override
        public boolean remove(Object key, Object value) {
            return CacheLIRS.this.remove(key, value);
        }

        @Override
        public boolean replace(K key, V oldValue, V newValue) {
            return CacheLIRS.this.replace(key, oldValue, newValue);
        }

        @Override
        public V replace(K key, V value) {
            return CacheLIRS.this.replace(key, value);
        }
    };
}",,"@Override
public ConcurrentMap<K, V> asMap() {
    return new ConcurrentMap<K, V>() {

        @Override
        public int size() {
            long size = CacheLIRS.this.size();
            return (int) Math.min(size, Integer.MAX_VALUE);
        }

        @Override
        public boolean isEmpty() {
            return CacheLIRS.this.size() == 0;
        }

        @Override
        public boolean containsKey(Object key) {
            return CacheLIRS.this.containsKey(key);
        }

        @Override
        public boolean containsValue(Object value) {
            return CacheLIRS.this.containsValue(value);
        }

        @SuppressWarnings(""unchecked"")
        @Override
        public V get(Object key) {
            return CacheLIRS.this.getUnchecked((K) key);
        }

        @Override
        public V put(K key, V value) {
            return CacheLIRS.this.put(key, value, sizeOf(key, value));
        }

        @Override
        public V remove(Object key) {
            @SuppressWarnings(""unchecked"")
            V old = CacheLIRS.this.getUnchecked((K) key);
            CacheLIRS.this.invalidate(key);
            return old;
        }

        @Override
        public void putAll(Map<? extends K, ? extends V> m) {
            for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {
                put(e.getKey(), e.getValue());
            }
        }

        @Override
        public void clear() {
            CacheLIRS.this.clear();
        }

        @Override
        public Set<K> keySet() {
            return CacheLIRS.this.keySet();
        }

        @Override
        public Collection<V> values() {
            return CacheLIRS.this.values();
        }

        @Override
        public Set<java.util.Map.Entry<K, V>> entrySet() {
            return CacheLIRS.this.entrySet();
        }

        @Override
        public V putIfAbsent(K key, V value) {
            return CacheLIRS.this.putIfAbsent(key, value);
        }

        @Override
        public boolean remove(Object key, Object value) {
            return CacheLIRS.this.remove(key, value);
        }

        @Override
        public boolean replace(K key, V oldValue, V newValue) {
            return CacheLIRS.this.replace(key, oldValue, newValue);
        }

        @Override
        public V replace(K key, V value) {
            return CacheLIRS.this.replace(key, value);
        }
    };
}",2.8181818181818183,-0.13775510204081634,-0.3333333333333333,0.0,-0.4166666666666667,0.3351458230350965,-1.0238026957269863,1.3333333333333333,-0.028571428571428574,1.3405501946625207
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7,3,"public boolean equals(setTableProperty_result that) {
    if (that == null)
        return false;
    boolean this_present_ouch1 = true && this.isSetOuch1();
    boolean that_present_ouch1 = true && that.isSetOuch1();
    if (this_present_ouch1 || that_present_ouch1) {
        if (!(this_present_ouch1 && that_present_ouch1))
            return false;
        if (!this.ouch1.equals(that.ouch1))
            return false;
    }
    boolean this_present_ouch2 = true && this.isSetOuch2();
    boolean that_present_ouch2 = true && that.isSetOuch2();
    if (this_present_ouch2 || that_present_ouch2) {
        if (!(this_present_ouch2 && that_present_ouch2))
            return false;
        if (!this.ouch2.equals(that.ouch2))
            return false;
    }
    return true;
}",,"public boolean equals(setTableProperty_result that) {
    if (that == null)
        return false;
    boolean this_present_ouch1 = true && this.isSetOuch1();
    boolean that_present_ouch1 = true && that.isSetOuch1();
    if (this_present_ouch1 || that_present_ouch1) {
        if (!(this_present_ouch1 && that_present_ouch1))
            return false;
        if (!this.ouch1.equals(that.ouch1))
            return false;
    }
    boolean this_present_ouch2 = true && this.isSetOuch2();
    boolean that_present_ouch2 = true && that.isSetOuch2();
    if (this_present_ouch2 || that_present_ouch2) {
        if (!(this_present_ouch2 && that_present_ouch2))
            return false;
        if (!this.ouch2.equals(that.ouch2))
            return false;
    }
    return true;
}",0.3181818181818182,0.3061224489795919,0.6666666666666666,-0.5,1.25,0.726643598615917,-0.26641812446228874,0.0,-0.028571428571428574,0.4473725913457626
commons-math,remotes/origin/bugs-dot-jar_MATH-1123_a197ba85,1,"/**
 * Fit a sub-hyperplane inside the cell defined by the instance.
 * <p>Fitting is done by chopping off the parts of the
 * sub-hyperplane that lie outside of the cell using the
 * cut-hyperplanes of the parent nodes of the instance.</p>
 * @param sub sub-hyperplane to fit
 * @return a new sub-hyperplane, guaranteed to have no part outside
 * of the instance cell
 */
private SubHyperplane<S> fitToCell(final SubHyperplane<S> sub) {
    SubHyperplane<S> s = sub;
    for (BSPTree<S> tree = this; tree.parent != null; tree = tree.parent) {
        if (tree == tree.parent.plus) {
            s = s.split(tree.parent.cut.getHyperplane()).getPlus();
        } else {
            s = s.split(tree.parent.cut.getHyperplane()).getMinus();
        }
    }
    return s;
}","/**
 * Fit a sub-hyperplane inside the cell defined by the instance.
 * <p>Fitting is done by chopping off the parts of the
 * sub-hyperplane that lie outside of the cell using the
 * cut-hyperplanes of the parent nodes of the instance.</p>
 * @param sub sub-hyperplane to fit
 * @return a new sub-hyperplane, guaranteed to have no part outside
 * of the instance cell
 */
","private SubHyperplane<S> fitToCell(final SubHyperplane<S> sub) {
    SubHyperplane<S> s = sub;
    for (BSPTree<S> tree = this; tree.parent != null; tree = tree.parent) {
        if (tree == tree.parent.plus) {
            s = s.split(tree.parent.cut.getHyperplane()).getPlus();
        } else {
            s = s.split(tree.parent.cut.getHyperplane()).getMinus();
        }
    }
    return s;
}",-0.13636363636363635,0.47448979591836743,-0.16666666666666666,0.0,0.0,0.12555610479485918,0.10037281330656728,0.0,-0.028571428571428574,0.05955945023363786
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-579_7d72e6ed,3,"@Override
public void execute(NodeState rootState) {
    cursor = index.query(createFilter(), rootState);
}",,"@Override
public void execute(NodeState rootState) {
    cursor = index.query(createFilter(), rootState);
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8399770576426728,-0.3333333333333333,1.2857142857142858,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-3989_6a8fc1cc,1,"/**
 *  Get the markup for the child component, which is assumed to be a child of 'container'.
 */
public IMarkupFragment getMarkup(final MarkupContainer container, final Component child) {
    // If the sourcing strategy did not provide one, than ask the component.
    // Get the markup for the container
    IMarkupFragment markup = container.getMarkup();
    if (markup == null) {
        return null;
    }
    if (child == null) {
        return markup;
    }
    // Find the child's markup
    markup = markup.find(child.getId());
    if (markup != null) {
        return markup;
    }
    // ""synchronous"" search possible.
    for (Component ch : container) {
        if ((ch != child) && (ch instanceof MarkupContainer) && (ch instanceof IComponentResolver)) {
            markup = ((MarkupContainer) ch).getMarkup(child);
            if (markup != null) {
                return markup;
            }
        }
    }
    // This is to make migration for Items from 1.4 to 1.5 more easy
    if (Character.isDigit(child.getId().charAt(0))) {
        String id = child.getId();
        boolean miss = false;
        for (int i = 1; i < id.length(); i++) {
            if (Character.isDigit(id.charAt(i)) == false) {
                miss = true;
                break;
            }
        }
        if (miss == false) {
            // The LoopItems markup is equal to the Loops markup
            markup = container.getMarkup();
            if (!(child instanceof AbstractItem) && log.isWarnEnabled()) {
                log.warn(""1.4 to 1.5 migration issue: the childs wicket-id contains decimals only. "" + ""By convention that "" + ""is only the case for children (Items) of Loop, ListView, "" + ""Tree etc.. To avoid the warning, the childs container should implement:\n"" + ""@Override public IMarkupFragment getMarkup(Component child) {\n"" + ""// The childs markup is always equal to the parents markup.\n"" + ""return getMarkup(); }\n"" + ""Child: "" + child.toString() + ""\nContainer: "" + container.toString());
            }
        }
    }
    return markup;
}","/**
 *  Get the markup for the child component, which is assumed to be a child of 'container'.
 */
","public IMarkupFragment getMarkup(final MarkupContainer container, final Component child) {
            IMarkupFragment markup = container.getMarkup();
    if (markup == null) {
        return null;
    }
    if (child == null) {
        return markup;
    }
        markup = markup.find(child.getId());
    if (markup != null) {
        return markup;
    }
        for (Component ch : container) {
        if ((ch != child) && (ch instanceof MarkupContainer) && (ch instanceof IComponentResolver)) {
            markup = ((MarkupContainer) ch).getMarkup(child);
            if (markup != null) {
                return markup;
            }
        }
    }
        if (Character.isDigit(child.getId().charAt(0))) {
        String id = child.getId();
        boolean miss = false;
        for (int i = 1; i < id.length(); i++) {
            if (Character.isDigit(id.charAt(i)) == false) {
                miss = true;
                break;
            }
        }
        if (miss == false) {
                        markup = container.getMarkup();
            if (!(child instanceof AbstractItem) && log.isWarnEnabled()) {
                log.warn(""1.4 to 1.5 migration issue: the childs wicket-id contains decimals only. "" + ""By convention that "" + ""is only the case for children (Items) of Loop, ListView, "" + ""Tree etc.. To avoid the warning, the childs container should implement:\n"" + ""@Override public IMarkupFragment getMarkup(Component child) {\n"" + ""// The childs markup is always equal to the parents markup.\n"" + ""return getMarkup(); }\n"" + ""Child: "" + child.toString() + ""\nContainer: "" + container.toString());
            }
        }
    }
    return markup;
}",1.0909090909090908,0.6785714285714284,1.5,0.5,1.5833333333333333,1.5056846267918933,-0.7117866360768573,0.8333333333333334,-0.028571428571428574,2.4453895606066447
wicket,remotes/origin/bugs-dot-jar_WICKET-2839_15477252,1,"/**
 *  Convenience method to write an {@link InputStream} to response.
 *
 *  @param attributes
 *  @param stream
 */
protected final void writeStream(Attributes attributes, InputStream stream) {
    final Response response = attributes.getResponse();
    OutputStream s = new OutputStream() {

        @Override
        public void write(int b) throws IOException {
            response.write(new byte[] { (byte) b });
        }

        @Override
        public void write(byte[] b) throws IOException {
            response.write(b);
        }

        @Override
        public void write(byte[] b, int off, int len) throws IOException {
            if (off == 0 || len == b.length) {
                write(b);
            } else {
                byte[] copy = new byte[len];
                System.arraycopy(b, off, copy, 0, len);
                write(copy);
            }
        }
    };
    try {
        Streams.copy(stream, s);
    } catch (IOException e) {
        throw new WicketRuntimeException(e);
    }
}","/**
 *  Convenience method to write an {@link InputStream} to response.
 *
 *  @param attributes
 *  @param stream
 */
","protected final void writeStream(Attributes attributes, InputStream stream) {
    final Response response = attributes.getResponse();
    OutputStream s = new OutputStream() {

        @Override
        public void write(int b) throws IOException {
            response.write(new byte[] { (byte) b });
        }

        @Override
        public void write(byte[] b) throws IOException {
            response.write(b);
        }

        @Override
        public void write(byte[] b, int off, int len) throws IOException {
            if (off == 0 || len == b.length) {
                write(b);
            } else {
                byte[] copy = new byte[len];
                System.arraycopy(b, off, copy, 0, len);
                write(copy);
            }
        }
    };
    try {
        Streams.copy(stream, s);
    } catch (IOException e) {
        throw new WicketRuntimeException(e);
    }
}",0.6363636363636364,0.729591836734694,0.0,0.0,0.0,0.08601087493821061,-0.4037854889589906,0.08333333333333333,0.028571428571428574,0.15162261597303422
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-276_1bf5c550,1,"public void writeHead(Id id) {
    head = id;
}",,"public void writeHead(Id id) {
    head = id;
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.0785775738457126,-0.5,2.685714285714286,-0.16422749602751402
Cli,26,3,"/**
 * Create an Option using the current settings and with
 * the specified Option <code>char</code>.
 *
 * @param opt the <code>java.lang.String</code> representation
 * of the Option
 * @return the Option instance
 * @throws IllegalArgumentException if <code>opt</code> is not
 * a valid character.  See Option.
 */
public static Option create(String opt) throws IllegalArgumentException {
    // create the option
    Option option = new Option(opt, description);
    // set the option properties
    option.setLongOpt(longopt);
    option.setRequired(required);
    option.setOptionalArg(optionalArg);
    option.setArgs(numberOfArgs);
    option.setType(type);
    option.setValueSeparator(valuesep);
    option.setArgName(argName);
    // reset the OptionBuilder properties
    OptionBuilder.reset();
    // return the Option instance
    return option;
}","/**
 * Create an Option using the current settings and with
 * the specified Option <code>char</code>.
 *
 * @param opt the <code>java.lang.String</code> representation
 * of the Option
 * @return the Option instance
 * @throws IllegalArgumentException if <code>opt</code> is not
 * a valid character.  See Option.
 */
","public static Option create(String opt) throws IllegalArgumentException {
        Option option = new Option(opt, description);
        option.setLongOpt(longopt);
    option.setRequired(required);
    option.setOptionalArg(optionalArg);
    option.setArgs(numberOfArgs);
    option.setType(type);
    option.setValueSeparator(valuesep);
    option.setArgName(argName);
        OptionBuilder.reset();
        return option;
}",-0.09090909090909091,-0.7806122448979592,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.1029538285058791,0.16666666666666666,0.028571428571428574,-0.16422749602751402
Closure,149,2,"/**
 * Generates JavaScript source code for an AST.
 */
private String toSource(Node n, SourceMap sourceMap) {
    CodePrinter.Builder builder = new CodePrinter.Builder(n);
    builder.setPrettyPrint(options.prettyPrint);
    builder.setLineBreak(options.lineBreak);
    builder.setSourceMap(sourceMap);
    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);
    Charset charset = options.outputCharset;
    builder.setOutputCharset(charset);
    return builder.build();
}","/**
 * Generates JavaScript source code for an AST.
 */
","private String toSource(Node n, SourceMap sourceMap) {
    CodePrinter.Builder builder = new CodePrinter.Builder(n);
    builder.setPrettyPrint(options.prettyPrint);
    builder.setLineBreak(options.lineBreak);
    builder.setSourceMap(sourceMap);
    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);
    Charset charset = options.outputCharset;
    builder.setOutputCharset(charset);
    return builder.build();
}",-0.18181818181818182,-0.7244897959183674,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.1775164898193289,0.0,0.0,-0.16422749602751402
Closure,95,2,"/**
 * Defines a typed variable. The defining node will be annotated with the
 * variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is
 * inferred.
 *
 * Slots may be any variable or any qualified name in the global scope.
 *
 * @param n the defining NAME or GETPROP node.
 * @param parent the {@code n}'s parent.
 * @param type the variable's type. It may be {@code null} if
 *     {@code inferred} is {@code true}.
 */
void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
    Preconditions.checkArgument(inferred || type != null);
    // Only allow declarations of NAMEs and qualfied names.
    boolean shouldDeclareOnGlobalThis = false;
    if (n.getType() == Token.NAME) {
        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);
        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);
    } else {
        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));
    }
    String variableName = n.getQualifiedName();
    Preconditions.checkArgument(!variableName.isEmpty());
    // If n is a property, then we should really declare it in the
    // scope where the root object appears. This helps out people
    // who declare ""global"" names in an anonymous namespace.
    Scope scopeToDeclareIn = scope;
    // declared in closest scope?
    if (scopeToDeclareIn.isDeclared(variableName, false)) {
        Var oldVar = scopeToDeclareIn.getVar(variableName);
        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);
    } else {
        if (!inferred) {
            setDeferredType(n, type);
        }
        CompilerInput input = compiler.getInput(sourceName);
        scopeToDeclareIn.declare(variableName, n, type, input, inferred);
        if (shouldDeclareOnGlobalThis) {
            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
            boolean isExtern = input.isExtern();
            if (inferred) {
                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);
            } else {
                globalThis.defineDeclaredProperty(variableName, type, isExtern);
            }
        }
        // in the scope chain.
        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {
            FunctionType fnType = (FunctionType) type;
            if (fnType.isConstructor() || fnType.isInterface()) {
                FunctionType superClassCtor = fnType.getSuperClassConstructor();
                scopeToDeclareIn.declare(variableName + "".prototype"", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */
                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));
            }
        }
    }
}","/**
 * Defines a typed variable. The defining node will be annotated with the
 * variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is
 * inferred.
 *
 * Slots may be any variable or any qualified name in the global scope.
 *
 * @param n the defining NAME or GETPROP node.
 * @param parent the {@code n}'s parent.
 * @param type the variable's type. It may be {@code null} if
 *     {@code inferred} is {@code true}.
 */
","void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
    Preconditions.checkArgument(inferred || type != null);
        boolean shouldDeclareOnGlobalThis = false;
    if (n.getType() == Token.NAME) {
        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);
        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);
    } else {
        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));
    }
    String variableName = n.getQualifiedName();
    Preconditions.checkArgument(!variableName.isEmpty());
                Scope scopeToDeclareIn = scope;
        if (scopeToDeclareIn.isDeclared(variableName, false)) {
        Var oldVar = scopeToDeclareIn.getVar(variableName);
        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);
    } else {
        if (!inferred) {
            setDeferredType(n, type);
        }
        CompilerInput input = compiler.getInput(sourceName);
        scopeToDeclareIn.declare(variableName, n, type, input, inferred);
        if (shouldDeclareOnGlobalThis) {
            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
            boolean isExtern = input.isExtern();
            if (inferred) {
                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);
            } else {
                globalThis.defineDeclaredProperty(variableName, type, isExtern);
            }
        }
                if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {
            FunctionType fnType = (FunctionType) type;
            if (fnType.isConstructor() || fnType.isInterface()) {
                FunctionType superClassCtor = fnType.getSuperClassConstructor();
                scopeToDeclareIn.declare(variableName + "".prototype"", n, fnType.getPrototype(), compiler.getInput(sourceName),                 superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));
            }
        }
    }
}",1.1818181818181819,0.6836734693877553,0.8333333333333334,0.5,1.1666666666666667,1.1122095897182405,-0.810151993117293,2.6666666666666665,-0.028571428571428574,3.896539761265371
wicket,remotes/origin/bugs-dot-jar_WICKET-5019_917dd2b5,3,"/**
 *  Initializes the cache for the existence of the minified resource.
 *  @return the name of the minified resource or the special constant {@link #NO_MINIFIED_NAME}
 *  if there is no minified version
 */
private String internalGetMinifiedName() {
    String minifiedName = MINIFIED_NAMES_CACHE.get(this);
    if (minifiedName != null && minifiedName != NO_MINIFIED_NAME) {
        return minifiedName;
    }
    String name = getMinifiedName();
    IResourceStreamLocator locator = Application.get().getResourceSettings().getResourceStreamLocator();
    String absolutePath = Packages.absolutePath(getScope(), name);
    IResourceStream stream = locator.locate(getScope(), absolutePath, getStyle(), getVariation(), getLocale(), null, true);
    minifiedName = stream != null ? name : NO_MINIFIED_NAME;
    MINIFIED_NAMES_CACHE.put(this, minifiedName);
    if (minifiedName == NO_MINIFIED_NAME && log.isDebugEnabled()) {
        log.debug(""No minified version of '"" + super.getName() + ""' found, expected a file with the name '"" + name + ""', using full version"");
    }
    return minifiedName;
}","/**
 *  Initializes the cache for the existence of the minified resource.
 *  @return the name of the minified resource or the special constant {@link #NO_MINIFIED_NAME}
 *  if there is no minified version
 */
","private String internalGetMinifiedName() {
    String minifiedName = MINIFIED_NAMES_CACHE.get(this);
    if (minifiedName != null && minifiedName != NO_MINIFIED_NAME) {
        return minifiedName;
    }
    String name = getMinifiedName();
    IResourceStreamLocator locator = Application.get().getResourceSettings().getResourceStreamLocator();
    String absolutePath = Packages.absolutePath(getScope(), name);
    IResourceStream stream = locator.locate(getScope(), absolutePath, getStyle(), getVariation(), getLocale(), null, true);
    minifiedName = stream != null ? name : NO_MINIFIED_NAME;
    MINIFIED_NAMES_CACHE.put(this, minifiedName);
    if (minifiedName == NO_MINIFIED_NAME && log.isDebugEnabled()) {
        log.debug(""No minified version of '"" + super.getName() + ""' found, expected a file with the name '"" + name + ""', using full version"");
    }
    return minifiedName;
}",0.09090909090909091,-0.5204081632653061,0.0,-0.5,0.25,0.3153732081067722,-0.17006022368798418,0.8333333333333334,-0.028571428571428574,0.39674320394378987
Csv,7,1,"/**
 * Initializes the name to index mapping if the format defines a header.
 *
 * @return null if the format has no header.
 */
private Map<String, Integer> initializeHeader() throws IOException {
    Map<String, Integer> hdrMap = null;
    final String[] formatHeader = this.format.getHeader();
    if (formatHeader != null) {
        hdrMap = new LinkedHashMap<String, Integer>();
        String[] header = null;
        if (formatHeader.length == 0) {
            // read the header from the first line of the file
            final CSVRecord nextRecord = this.nextRecord();
            if (nextRecord != null) {
                header = nextRecord.values();
            }
        } else {
            if (this.format.getSkipHeaderRecord()) {
                this.nextRecord();
            }
            header = formatHeader;
        }
        // build the name to index mappings
        if (header != null) {
            for (int i = 0; i < header.length; i++) {
                hdrMap.put(header[i], Integer.valueOf(i));
            }
        }
    }
    return hdrMap;
}","/**
 * Initializes the name to index mapping if the format defines a header.
 *
 * @return null if the format has no header.
 */
","private Map<String, Integer> initializeHeader() throws IOException {
    Map<String, Integer> hdrMap = null;
    final String[] formatHeader = this.format.getHeader();
    if (formatHeader != null) {
        hdrMap = new LinkedHashMap<String, Integer>();
        String[] header = null;
        if (formatHeader.length == 0) {
                        final CSVRecord nextRecord = this.nextRecord();
            if (nextRecord != null) {
                header = nextRecord.values();
            }
        } else {
            if (this.format.getSkipHeaderRecord()) {
                this.nextRecord();
            }
            header = formatHeader;
        }
                if (header != null) {
            for (int i = 0; i < header.length; i++) {
                hdrMap.put(header[i], Integer.valueOf(i));
            }
        }
    }
    return hdrMap;
}",0.5,0.7704081632653063,0.5,0.5,0.6666666666666666,0.6258032624814632,-0.38055635216518496,0.08333333333333333,-0.028571428571428574,0.5615146414483405
camel,remotes/origin/bugs-dot-jar_CAMEL-8954_7b1253db,3,"protected void doReleaseExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {
    if (!markerFile) {
        // if not using marker file then nothing to release
        return;
    }
    // only release the file if camel get the lock before
    if (exchange.getProperty(Exchange.FILE_LOCK_FILE_ACQUIRED, false, Boolean.class)) {
        String lockFileName = exchange.getProperty(Exchange.FILE_LOCK_FILE_NAME, getLockFileName(file), String.class);
        File lock = new File(lockFileName);
        if (lock.exists()) {
            LOG.trace(""Unlocking file: {}"", lockFileName);
            boolean deleted = FileUtil.deleteFile(lock);
            LOG.trace(""Lock file: {} was deleted: {}"", lockFileName, deleted);
        }
    }
}",,"protected void doReleaseExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {
    if (!markerFile) {
                return;
    }
        if (exchange.getProperty(Exchange.FILE_LOCK_FILE_ACQUIRED, false, Boolean.class)) {
        String lockFileName = exchange.getProperty(Exchange.FILE_LOCK_FILE_NAME, getLockFileName(file), String.class);
        File lock = new File(lockFileName);
        if (lock.exists()) {
            LOG.trace(""Unlocking file: {}"", lockFileName);
            boolean deleted = FileUtil.deleteFile(lock);
            LOG.trace(""Lock file: {} was deleted: {}"", lockFileName, deleted);
        }
    }
}",0.0,0.4438775510204082,0.0,0.0,0.08333333333333333,-0.056351952545724164,-0.045884714654431,0.08333333333333333,-0.028571428571428574,0.008407536373409397
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-4170_2a489d05,3,"@Override
public void restrict(FilterImpl f) {
    if (propertyName != null) {
        if (f.getSelector().equals(selector)) {
            String p = propertyName;
            if (relativePath != null) {
                p = PathUtils.concat(relativePath, p);
            }
            p = normalizePropertyName(p);
            restrictPropertyOnFilter(p, f);
        }
    }
    f.restrictFulltextCondition(fullTextSearchExpression.currentValue().getValue(Type.STRING));
}",,"@Override
public void restrict(FilterImpl f) {
    if (propertyName != null) {
        if (f.getSelector().equals(selector)) {
            String p = propertyName;
            if (relativePath != null) {
                p = PathUtils.concat(relativePath, p);
            }
            p = normalizePropertyName(p);
            restrictPropertyOnFilter(p, f);
        }
    }
    f.restrictFulltextCondition(fullTextSearchExpression.currentValue().getValue(Type.STRING));
}",0.0,1.1173469387755102,0.0,0.5,0.16666666666666666,-0.08798813643104299,-0.0005735589331802703,0.16666666666666666,0.39999999999999997,-0.04955863646292417
flink,remotes/origin/bugs-dot-jar_FLINK-3566_434e88fd,1,"@SuppressWarnings(""unchecked"")
private static void validateInfo(ArrayList<Type> typeHierarchy, Type type, TypeInformation<?> typeInfo) {
    if (type == null) {
        throw new InvalidTypesException(""Unknown Error. Type is null."");
    }
    if (typeInfo == null) {
        throw new InvalidTypesException(""Unknown Error. TypeInformation is null."");
    }
    if (!(type instanceof TypeVariable<?>)) {
        // check for basic type
        if (typeInfo.isBasicType()) {
            TypeInformation<?> actual;
            // check if basic type at all
            if (!(type instanceof Class<?>) || (actual = BasicTypeInfo.getInfoFor((Class<?>) type)) == null) {
                throw new InvalidTypesException(""Basic type expected."");
            }
            // check if correct basic type
            if (!typeInfo.equals(actual)) {
                throw new InvalidTypesException(""Basic type '"" + typeInfo + ""' expected but was '"" + actual + ""'."");
            }
        } else // check for tuple
        if (typeInfo.isTupleType()) {
            // check if tuple at all
            if (!(isClassType(type) && Tuple.class.isAssignableFrom(typeToClass(type)))) {
                throw new InvalidTypesException(""Tuple type expected."");
            }
            // do not allow usage of Tuple as type
            if (isClassType(type) && typeToClass(type).equals(Tuple.class)) {
                throw new InvalidTypesException(""Concrete subclass of Tuple expected."");
            }
            // go up the hierarchy until we reach immediate child of Tuple (with or without generics)
            while (!(isClassType(type) && typeToClass(type).getSuperclass().equals(Tuple.class))) {
                typeHierarchy.add(type);
                type = typeToClass(type).getGenericSuperclass();
            }
            if (type == Tuple0.class) {
                return;
            }
            // check if immediate child of Tuple has generics
            if (type instanceof Class<?>) {
                throw new InvalidTypesException(""Parameterized Tuple type expected."");
            }
            TupleTypeInfo<?> tti = (TupleTypeInfo<?>) typeInfo;
            Type[] subTypes = ((ParameterizedType) type).getActualTypeArguments();
            if (subTypes.length != tti.getArity()) {
                throw new InvalidTypesException(""Tuple arity '"" + tti.getArity() + ""' expected but was '"" + subTypes.length + ""'."");
            }
            for (int i = 0; i < subTypes.length; i++) {
                validateInfo(new ArrayList<Type>(typeHierarchy), subTypes[i], tti.getTypeAt(i));
            }
        } else // check for Either
        if (typeInfo instanceof EitherTypeInfo) {
            // check if Either at all
            if (!(isClassType(type) && Either.class.isAssignableFrom(typeToClass(type)))) {
                throw new InvalidTypesException(""Either type expected."");
            }
            // go up the hierarchy until we reach Either (with or without generics)
            while (!(isClassType(type) && typeToClass(type).equals(Either.class))) {
                typeHierarchy.add(type);
                type = typeToClass(type).getGenericSuperclass();
            }
            // check if Either has generics
            if (type instanceof Class<?>) {
                throw new InvalidTypesException(""Parameterized Either type expected."");
            }
            EitherTypeInfo<?, ?> eti = (EitherTypeInfo<?, ?>) typeInfo;
            Type[] subTypes = ((ParameterizedType) type).getActualTypeArguments();
            validateInfo(new ArrayList<Type>(typeHierarchy), subTypes[0], eti.getLeftType());
            validateInfo(new ArrayList<Type>(typeHierarchy), subTypes[1], eti.getRightType());
        } else // check for Writable
        if (typeInfo instanceof WritableTypeInfo<?>) {
            // check if writable at all
            if (!(type instanceof Class<?> && Writable.class.isAssignableFrom((Class<?>) type))) {
                throw new InvalidTypesException(""Writable type expected."");
            }
            // check writable type contents
            Class<?> clazz;
            if (((WritableTypeInfo<?>) typeInfo).getTypeClass() != (clazz = (Class<?>) type)) {
                throw new InvalidTypesException(""Writable type '"" + ((WritableTypeInfo<?>) typeInfo).getTypeClass().getCanonicalName() + ""' expected but was '"" + clazz.getCanonicalName() + ""'."");
            }
        } else // check for primitive array
        if (typeInfo instanceof PrimitiveArrayTypeInfo) {
            Type component;
            // check if array at all
            if (!(type instanceof Class<?> && ((Class<?>) type).isArray() && (component = ((Class<?>) type).getComponentType()) != null) && !(type instanceof GenericArrayType && (component = ((GenericArrayType) type).getGenericComponentType()) != null)) {
                throw new InvalidTypesException(""Array type expected."");
            }
            if (component instanceof TypeVariable<?>) {
                component = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) component);
                if (component instanceof TypeVariable) {
                    return;
                }
            }
            if (!(component instanceof Class<?> && ((Class<?>) component).isPrimitive())) {
                throw new InvalidTypesException(""Primitive component expected."");
            }
        } else // check for basic array
        if (typeInfo instanceof BasicArrayTypeInfo<?, ?>) {
            Type component;
            // check if array at all
            if (!(type instanceof Class<?> && ((Class<?>) type).isArray() && (component = ((Class<?>) type).getComponentType()) != null) && !(type instanceof GenericArrayType && (component = ((GenericArrayType) type).getGenericComponentType()) != null)) {
                throw new InvalidTypesException(""Array type expected."");
            }
            if (component instanceof TypeVariable<?>) {
                component = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) component);
                if (component instanceof TypeVariable) {
                    return;
                }
            }
            validateInfo(typeHierarchy, component, ((BasicArrayTypeInfo<?, ?>) typeInfo).getComponentInfo());
        } else // check for object array
        if (typeInfo instanceof ObjectArrayTypeInfo<?, ?>) {
            // check if array at all
            if (!(type instanceof Class<?> && ((Class<?>) type).isArray()) && !(type instanceof GenericArrayType)) {
                throw new InvalidTypesException(""Object array type expected."");
            }
            // check component
            Type component;
            if (type instanceof Class<?>) {
                component = ((Class<?>) type).getComponentType();
            } else {
                component = ((GenericArrayType) type).getGenericComponentType();
            }
            if (component instanceof TypeVariable<?>) {
                component = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) component);
                if (component instanceof TypeVariable) {
                    return;
                }
            }
            validateInfo(typeHierarchy, component, ((ObjectArrayTypeInfo<?, ?>) typeInfo).getComponentInfo());
        } else // check for value
        if (typeInfo instanceof ValueTypeInfo<?>) {
            // check if value at all
            if (!(type instanceof Class<?> && Value.class.isAssignableFrom((Class<?>) type))) {
                throw new InvalidTypesException(""Value type expected."");
            }
            TypeInformation<?> actual;
            // check value type contents
            if (!((ValueTypeInfo<?>) typeInfo).equals(actual = ValueTypeInfo.getValueTypeInfo((Class<? extends Value>) type))) {
                throw new InvalidTypesException(""Value type '"" + typeInfo + ""' expected but was '"" + actual + ""'."");
            }
        } else // check for POJO
        if (typeInfo instanceof PojoTypeInfo) {
            Class<?> clazz = null;
            if (!(isClassType(type) && ((PojoTypeInfo<?>) typeInfo).getTypeClass() == (clazz = typeToClass(type)))) {
                throw new InvalidTypesException(""POJO type '"" + ((PojoTypeInfo<?>) typeInfo).getTypeClass().getCanonicalName() + ""' expected but was '"" + clazz.getCanonicalName() + ""'."");
            }
        } else // check for Enum
        if (typeInfo instanceof EnumTypeInfo) {
            if (!(type instanceof Class<?> && Enum.class.isAssignableFrom((Class<?>) type))) {
                throw new InvalidTypesException(""Enum type expected."");
            }
            // check enum type contents
            if (!(typeInfo.getTypeClass() == type)) {
                throw new InvalidTypesException(""Enum type '"" + typeInfo.getTypeClass().getCanonicalName() + ""' expected but was '"" + typeToClass(type).getCanonicalName() + ""'."");
            }
        } else // check for generic object
        if (typeInfo instanceof GenericTypeInfo<?>) {
            Class<?> clazz = null;
            if (!(isClassType(type) && ((GenericTypeInfo<?>) typeInfo).getTypeClass() == (clazz = typeToClass(type)))) {
                throw new InvalidTypesException(""Generic object type '"" + ((GenericTypeInfo<?>) typeInfo).getTypeClass().getCanonicalName() + ""' expected but was '"" + clazz.getCanonicalName() + ""'."");
            }
        }
    } else {
        type = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) type);
        if (!(type instanceof TypeVariable)) {
            validateInfo(typeHierarchy, type, typeInfo);
        }
    }
}",,"@SuppressWarnings(""unchecked"")
private static void validateInfo(ArrayList<Type> typeHierarchy, Type type, TypeInformation<?> typeInfo) {
    if (type == null) {
        throw new InvalidTypesException(""Unknown Error. Type is null."");
    }
    if (typeInfo == null) {
        throw new InvalidTypesException(""Unknown Error. TypeInformation is null."");
    }
    if (!(type instanceof TypeVariable<?>)) {
                if (typeInfo.isBasicType()) {
            TypeInformation<?> actual;
                        if (!(type instanceof Class<?>) || (actual = BasicTypeInfo.getInfoFor((Class<?>) type)) == null) {
                throw new InvalidTypesException(""Basic type expected."");
            }
                        if (!typeInfo.equals(actual)) {
                throw new InvalidTypesException(""Basic type '"" + typeInfo + ""' expected but was '"" + actual + ""'."");
            }
        } else         if (typeInfo.isTupleType()) {
                        if (!(isClassType(type) && Tuple.class.isAssignableFrom(typeToClass(type)))) {
                throw new InvalidTypesException(""Tuple type expected."");
            }
                        if (isClassType(type) && typeToClass(type).equals(Tuple.class)) {
                throw new InvalidTypesException(""Concrete subclass of Tuple expected."");
            }
                        while (!(isClassType(type) && typeToClass(type).getSuperclass().equals(Tuple.class))) {
                typeHierarchy.add(type);
                type = typeToClass(type).getGenericSuperclass();
            }
            if (type == Tuple0.class) {
                return;
            }
                        if (type instanceof Class<?>) {
                throw new InvalidTypesException(""Parameterized Tuple type expected."");
            }
            TupleTypeInfo<?> tti = (TupleTypeInfo<?>) typeInfo;
            Type[] subTypes = ((ParameterizedType) type).getActualTypeArguments();
            if (subTypes.length != tti.getArity()) {
                throw new InvalidTypesException(""Tuple arity '"" + tti.getArity() + ""' expected but was '"" + subTypes.length + ""'."");
            }
            for (int i = 0; i < subTypes.length; i++) {
                validateInfo(new ArrayList<Type>(typeHierarchy), subTypes[i], tti.getTypeAt(i));
            }
        } else         if (typeInfo instanceof EitherTypeInfo) {
                        if (!(isClassType(type) && Either.class.isAssignableFrom(typeToClass(type)))) {
                throw new InvalidTypesException(""Either type expected."");
            }
                        while (!(isClassType(type) && typeToClass(type).equals(Either.class))) {
                typeHierarchy.add(type);
                type = typeToClass(type).getGenericSuperclass();
            }
                        if (type instanceof Class<?>) {
                throw new InvalidTypesException(""Parameterized Either type expected."");
            }
            EitherTypeInfo<?, ?> eti = (EitherTypeInfo<?, ?>) typeInfo;
            Type[] subTypes = ((ParameterizedType) type).getActualTypeArguments();
            validateInfo(new ArrayList<Type>(typeHierarchy), subTypes[0], eti.getLeftType());
            validateInfo(new ArrayList<Type>(typeHierarchy), subTypes[1], eti.getRightType());
        } else         if (typeInfo instanceof WritableTypeInfo<?>) {
                        if (!(type instanceof Class<?> && Writable.class.isAssignableFrom((Class<?>) type))) {
                throw new InvalidTypesException(""Writable type expected."");
            }
                        Class<?> clazz;
            if (((WritableTypeInfo<?>) typeInfo).getTypeClass() != (clazz = (Class<?>) type)) {
                throw new InvalidTypesException(""Writable type '"" + ((WritableTypeInfo<?>) typeInfo).getTypeClass().getCanonicalName() + ""' expected but was '"" + clazz.getCanonicalName() + ""'."");
            }
        } else         if (typeInfo instanceof PrimitiveArrayTypeInfo) {
            Type component;
                        if (!(type instanceof Class<?> && ((Class<?>) type).isArray() && (component = ((Class<?>) type).getComponentType()) != null) && !(type instanceof GenericArrayType && (component = ((GenericArrayType) type).getGenericComponentType()) != null)) {
                throw new InvalidTypesException(""Array type expected."");
            }
            if (component instanceof TypeVariable<?>) {
                component = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) component);
                if (component instanceof TypeVariable) {
                    return;
                }
            }
            if (!(component instanceof Class<?> && ((Class<?>) component).isPrimitive())) {
                throw new InvalidTypesException(""Primitive component expected."");
            }
        } else         if (typeInfo instanceof BasicArrayTypeInfo<?, ?>) {
            Type component;
                        if (!(type instanceof Class<?> && ((Class<?>) type).isArray() && (component = ((Class<?>) type).getComponentType()) != null) && !(type instanceof GenericArrayType && (component = ((GenericArrayType) type).getGenericComponentType()) != null)) {
                throw new InvalidTypesException(""Array type expected."");
            }
            if (component instanceof TypeVariable<?>) {
                component = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) component);
                if (component instanceof TypeVariable) {
                    return;
                }
            }
            validateInfo(typeHierarchy, component, ((BasicArrayTypeInfo<?, ?>) typeInfo).getComponentInfo());
        } else         if (typeInfo instanceof ObjectArrayTypeInfo<?, ?>) {
                        if (!(type instanceof Class<?> && ((Class<?>) type).isArray()) && !(type instanceof GenericArrayType)) {
                throw new InvalidTypesException(""Object array type expected."");
            }
                        Type component;
            if (type instanceof Class<?>) {
                component = ((Class<?>) type).getComponentType();
            } else {
                component = ((GenericArrayType) type).getGenericComponentType();
            }
            if (component instanceof TypeVariable<?>) {
                component = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) component);
                if (component instanceof TypeVariable) {
                    return;
                }
            }
            validateInfo(typeHierarchy, component, ((ObjectArrayTypeInfo<?, ?>) typeInfo).getComponentInfo());
        } else         if (typeInfo instanceof ValueTypeInfo<?>) {
                        if (!(type instanceof Class<?> && Value.class.isAssignableFrom((Class<?>) type))) {
                throw new InvalidTypesException(""Value type expected."");
            }
            TypeInformation<?> actual;
                        if (!((ValueTypeInfo<?>) typeInfo).equals(actual = ValueTypeInfo.getValueTypeInfo((Class<? extends Value>) type))) {
                throw new InvalidTypesException(""Value type '"" + typeInfo + ""' expected but was '"" + actual + ""'."");
            }
        } else         if (typeInfo instanceof PojoTypeInfo) {
            Class<?> clazz = null;
            if (!(isClassType(type) && ((PojoTypeInfo<?>) typeInfo).getTypeClass() == (clazz = typeToClass(type)))) {
                throw new InvalidTypesException(""POJO type '"" + ((PojoTypeInfo<?>) typeInfo).getTypeClass().getCanonicalName() + ""' expected but was '"" + clazz.getCanonicalName() + ""'."");
            }
        } else         if (typeInfo instanceof EnumTypeInfo) {
            if (!(type instanceof Class<?> && Enum.class.isAssignableFrom((Class<?>) type))) {
                throw new InvalidTypesException(""Enum type expected."");
            }
                        if (!(typeInfo.getTypeClass() == type)) {
                throw new InvalidTypesException(""Enum type '"" + typeInfo.getTypeClass().getCanonicalName() + ""' expected but was '"" + typeToClass(type).getCanonicalName() + ""'."");
            }
        } else         if (typeInfo instanceof GenericTypeInfo<?>) {
            Class<?> clazz = null;
            if (!(isClassType(type) && ((GenericTypeInfo<?>) typeInfo).getTypeClass() == (clazz = typeToClass(type)))) {
                throw new InvalidTypesException(""Generic object type '"" + ((GenericTypeInfo<?>) typeInfo).getTypeClass().getCanonicalName() + ""' expected but was '"" + clazz.getCanonicalName() + ""'."");
            }
        }
    } else {
        type = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) type);
        if (!(type instanceof TypeVariable)) {
            validateInfo(typeHierarchy, type, typeInfo);
        }
    }
}",6.2272727272727275,0.35714285714285726,10.833333333333334,5.5,7.5,3.3109243697479,-1.9698881560080304,6.25,-0.028571428571428574,26.760438750904786
camel,remotes/origin/bugs-dot-jar_CAMEL-3789_9319e139,1,"public boolean storeFile(String fileName, Exchange exchange) throws GenericFileOperationFailedException {
    ObjectHelper.notNull(endpoint, ""endpoint"");
    File file = new File(fileName);
    // if an existing file already exists what should we do?
    if (file.exists()) {
        if (endpoint.getFileExist() == GenericFileExist.Ignore) {
            // ignore but indicate that the file was written
            LOG.trace(""An existing file already exists: {}. Ignore and do not override it."", file);
            return true;
        } else if (endpoint.getFileExist() == GenericFileExist.Fail) {
            throw new GenericFileOperationFailedException(""File already exist: "" + file + "". Cannot write new file."");
        }
    }
    // 3. write stream to file
    try {
        // is the body file based
        File source = null;
        // get the File Object from in message
        source = exchange.getIn().getBody(File.class);
        if (source != null) {
            // okay we know the body is a file type
            // so try to see if we can optimize by renaming the local work path file instead of doing
            // a full file to file copy, as the local work copy is to be deleted afterwards anyway
            // local work path
            File local = exchange.getIn().getHeader(Exchange.FILE_LOCAL_WORK_PATH, File.class);
            if (local != null && local.exists()) {
                boolean renamed = writeFileByLocalWorkPath(local, file);
                if (renamed) {
                    // try to keep last modified timestamp if configured to do so
                    keepLastModified(exchange, file);
                    // clear header as we have renamed the file
                    exchange.getIn().setHeader(Exchange.FILE_LOCAL_WORK_PATH, null);
                    // to the target.
                    return true;
                }
            } else if (source.exists()) {
                // no there is no local work file so use file to file copy if the source exists
                writeFileByFile(source, file);
                // try to keep last modified timestamp if configured to do so
                keepLastModified(exchange, file);
                return true;
            }
        }
        // fallback and use stream based
        InputStream in = ExchangeHelper.getMandatoryInBody(exchange, InputStream.class);
        writeFileByStream(in, file);
        // try to keep last modified timestamp if configured to do so
        keepLastModified(exchange, file);
        return true;
    } catch (IOException e) {
        throw new GenericFileOperationFailedException(""Cannot store file: "" + file, e);
    } catch (InvalidPayloadException e) {
        throw new GenericFileOperationFailedException(""Cannot store file: "" + file, e);
    }
}",,"public boolean storeFile(String fileName, Exchange exchange) throws GenericFileOperationFailedException {
    ObjectHelper.notNull(endpoint, ""endpoint"");
    File file = new File(fileName);
        if (file.exists()) {
        if (endpoint.getFileExist() == GenericFileExist.Ignore) {
                        LOG.trace(""An existing file already exists: {}. Ignore and do not override it."", file);
            return true;
        } else if (endpoint.getFileExist() == GenericFileExist.Fail) {
            throw new GenericFileOperationFailedException(""File already exist: "" + file + "". Cannot write new file."");
        }
    }
        try {
                File source = null;
                source = exchange.getIn().getBody(File.class);
        if (source != null) {
                                                            File local = exchange.getIn().getHeader(Exchange.FILE_LOCAL_WORK_PATH, File.class);
            if (local != null && local.exists()) {
                boolean renamed = writeFileByLocalWorkPath(local, file);
                if (renamed) {
                                        keepLastModified(exchange, file);
                                        exchange.getIn().setHeader(Exchange.FILE_LOCAL_WORK_PATH, null);
                                        return true;
                }
            } else if (source.exists()) {
                                writeFileByFile(source, file);
                                keepLastModified(exchange, file);
                return true;
            }
        }
                InputStream in = ExchangeHelper.getMandatoryInBody(exchange, InputStream.class);
        writeFileByStream(in, file);
                keepLastModified(exchange, file);
        return true;
    } catch (IOException e) {
        throw new GenericFileOperationFailedException(""Cannot store file: "" + file, e);
    } catch (InvalidPayloadException e) {
        throw new GenericFileOperationFailedException(""Cannot store file: "" + file, e);
    }
}",1.1363636363636365,1.1428571428571428,1.5,1.0,1.0,0.5625308947108255,-0.7304273014052196,1.1666666666666667,-0.028571428571428574,1.2015795717852844
wicket,remotes/origin/bugs-dot-jar_WICKET-4066_4d3d1f85,1,"public IRequestHandler mapRequest(Request request) {
    InterceptData data = InterceptData.get();
    if (data != null) {
        if (data.originalUrl.equals(request.getOriginalUrl())) {
            if (data.postParameters.isEmpty() == false && request.getPostParameters() instanceof IWritableRequestParameters) {
                IWritableRequestParameters parameters = (IWritableRequestParameters) request.getPostParameters();
                parameters.reset();
                for (String s : data.postParameters.keySet()) {
                    parameters.setParameterValues(s, data.postParameters.get(s));
                }
            }
            InterceptData.clear();
        }
    }
    return null;
}",,"public IRequestHandler mapRequest(Request request) {
    InterceptData data = InterceptData.get();
    if (data != null) {
        if (data.originalUrl.equals(request.getOriginalUrl())) {
            if (data.postParameters.isEmpty() == false && request.getPostParameters() instanceof IWritableRequestParameters) {
                IWritableRequestParameters parameters = (IWritableRequestParameters) request.getPostParameters();
                parameters.reset();
                for (String s : data.postParameters.keySet()) {
                    parameters.setParameterValues(s, data.postParameters.get(s));
                }
            }
            InterceptData.clear();
        }
    }
    return null;
}",0.09090909090909091,1.5918367346938773,0.16666666666666666,1.0,0.3333333333333333,0.36085022244191806,-0.11127043303699445,0.4166666666666667,-0.028571428571428574,0.2218338965483273
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2359_b3071839,0,"/**
 * Get the latest property value that is larger or equal the min revision,
 * and smaller or equal the readRevision revision. A {@code null} return
 * value indicates that the property was not set or removed within the given
 * range. A non-null value means the the property was either set or removed
 * depending on {@link Value#value}.
 *
 * @param valueMap the sorted revision-value map
 * @param min the minimum revision (null meaning unlimited)
 * @param readRevision the maximum revision
 * @param validRevisions map of revision to commit value considered valid
 *                       against the given readRevision.
 * @param lastRevs to keep track of the most recent modification.
 * @return the value, or null if not found
 */
@CheckForNull
private Value getLatestValue(@Nonnull RevisionContext context, @Nonnull Map<Revision, String> valueMap, @Nullable Revision min, @Nonnull Revision readRevision, @Nonnull Map<Revision, String> validRevisions, @Nonnull LastRevs lastRevs) {
    for (Map.Entry<Revision, String> entry : valueMap.entrySet()) {
        Revision propRev = entry.getKey();
        String commitValue = validRevisions.get(propRev);
        if (commitValue == null) {
            // resolve revision
            NodeDocument commitRoot = getCommitRoot(propRev);
            if (commitRoot == null) {
                continue;
            }
            commitValue = commitRoot.getCommitValue(propRev);
            if (commitValue == null) {
                continue;
            }
        }
        Revision commitRev = resolveCommitRevision(propRev, commitValue);
        if (Utils.isCommitted(commitValue)) {
            lastRevs.update(commitRev);
        } else {
            // branch commit
            lastRevs.updateBranch(commitRev.asBranchRevision());
        }
        if (min != null && isRevisionNewer(context, min, commitRev)) {
            continue;
        }
        if (isValidRevision(context, propRev, commitValue, readRevision, validRevisions)) {
            // TODO: need to check older revisions as well?
            return new Value(commitRev, entry.getValue());
        }
    }
    return null;
}","/**
 * Get the latest property value that is larger or equal the min revision,
 * and smaller or equal the readRevision revision. A {@code null} return
 * value indicates that the property was not set or removed within the given
 * range. A non-null value means the the property was either set or removed
 * depending on {@link Value#value}.
 *
 * @param valueMap the sorted revision-value map
 * @param min the minimum revision (null meaning unlimited)
 * @param readRevision the maximum revision
 * @param validRevisions map of revision to commit value considered valid
 *                       against the given readRevision.
 * @param lastRevs to keep track of the most recent modification.
 * @return the value, or null if not found
 */
","@CheckForNull
private Value getLatestValue(@Nonnull RevisionContext context, @Nonnull Map<Revision, String> valueMap, @Nullable Revision min, @Nonnull Revision readRevision, @Nonnull Map<Revision, String> validRevisions, @Nonnull LastRevs lastRevs) {
    for (Map.Entry<Revision, String> entry : valueMap.entrySet()) {
        Revision propRev = entry.getKey();
        String commitValue = validRevisions.get(propRev);
        if (commitValue == null) {
                        NodeDocument commitRoot = getCommitRoot(propRev);
            if (commitRoot == null) {
                continue;
            }
            commitValue = commitRoot.getCommitValue(propRev);
            if (commitValue == null) {
                continue;
            }
        }
        Revision commitRev = resolveCommitRevision(propRev, commitValue);
        if (Utils.isCommitted(commitValue)) {
            lastRevs.update(commitRev);
        } else {
                        lastRevs.updateBranch(commitRev.asBranchRevision());
        }
        if (min != null && isRevisionNewer(context, min, commitRev)) {
            continue;
        }
        if (isValidRevision(context, propRev, commitValue, readRevision, validRevisions)) {
                        return new Value(commitRev, entry.getValue());
        }
    }
    return null;
}",0.7272727272727273,0.5714285714285713,1.1666666666666667,0.5,1.0833333333333333,0.5111220958971825,-0.5615141955835963,0.5833333333333334,-0.028571428571428574,0.8636077453839928
camel,remotes/origin/bugs-dot-jar_CAMEL-3789_9319e139,1,"private void writeFileByStream(InputStream in, File target) throws IOException {
    FileChannel out = null;
    try {
        out = prepareOutputFileChannel(target, out);
        LOG.trace(""Using InputStream to transfer from: {} to: {}"", in, out);
        int size = endpoint.getBufferSize();
        byte[] buffer = new byte[size];
        ByteBuffer byteBuffer = ByteBuffer.wrap(buffer);
        int bytesRead;
        while ((bytesRead = in.read(buffer)) != -1) {
            if (bytesRead < size) {
                byteBuffer.limit(bytesRead);
            }
            out.write(byteBuffer);
            byteBuffer.clear();
        }
    } finally {
        IOHelper.close(in, target.getName(), LOG);
        IOHelper.close(out, target.getName(), LOG);
    }
}",,"private void writeFileByStream(InputStream in, File target) throws IOException {
    FileChannel out = null;
    try {
        out = prepareOutputFileChannel(target, out);
        LOG.trace(""Using InputStream to transfer from: {} to: {}"", in, out);
        int size = endpoint.getBufferSize();
        byte[] buffer = new byte[size];
        ByteBuffer byteBuffer = ByteBuffer.wrap(buffer);
        int bytesRead;
        while ((bytesRead = in.read(buffer)) != -1) {
            if (bytesRead < size) {
                byteBuffer.limit(bytesRead);
            }
            out.write(byteBuffer);
            byteBuffer.clear();
        }
    } finally {
        IOHelper.close(in, target.getName(), LOG);
        IOHelper.close(out, target.getName(), LOG);
    }
}",0.3181818181818182,0.43877551020408156,-0.16666666666666666,0.5,-0.08333333333333333,0.37073652990608014,-0.27444794952681417,0.5,-0.028571428571428574,0.3822580852403408
Lang,63,1,"/**
 * <p>Formats the time gap as a string, using the specified format.
 * Padding the left hand side of numbers with zeroes is optional and
 * the timezone may be specified.
 *
 * @param startMillis  the start of the duration
 * @param endMillis  the end of the duration
 * @param format  the way in which to format the duration
 * @param padWithZeros whether to pad the left hand side of numbers with 0's
 * @param timezone the millis are defined in
 * @return the time as a String
 */
public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {
    long millis = endMillis - startMillis;
    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {
        return formatDuration(millis, format, padWithZeros);
    }
    Token[] tokens = lexx(format);
    // timezones get funky around 0, so normalizing everything to GMT
    // stops the hours being off
    Calendar start = Calendar.getInstance(timezone);
    start.setTime(new Date(startMillis));
    Calendar end = Calendar.getInstance(timezone);
    end.setTime(new Date(endMillis));
    // initial estimates
    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);
    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);
    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);
    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);
    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);
    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);
    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);
    // each initial estimate is adjusted in case it is under 0
    while (milliseconds < 0) {
        milliseconds += 1000;
        seconds -= 1;
    }
    while (seconds < 0) {
        seconds += 60;
        minutes -= 1;
    }
    while (minutes < 0) {
        minutes += 60;
        hours -= 1;
    }
    while (hours < 0) {
        hours += 24;
        days -= 1;
    }
    while (days < 0) {
        days += 31;
        // days += 31; // TODO: Need tests to show this is bad and the new code is good.
        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is
        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.
        // Also it's contextual - if asked for no M in the format then I should probably
        // be doing no calculating here.
        months -= 1;
    }
    while (months < 0) {
        months += 12;
        years -= 1;
    }
    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);
    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);
    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);
    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);
    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);
    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);
    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);
    // number of months and get the real count and not just 0->11.
    if (!Token.containsTokenWithValue(tokens, y)) {
        if (Token.containsTokenWithValue(tokens, M)) {
            months += 12 * years;
            years = 0;
        } else {
            // TODO: this is a bit weak, needs work to know about leap years
            days += 365 * years;
            years = 0;
        }
    }
    if (!Token.containsTokenWithValue(tokens, M)) {
        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);
        months = 0;
    }
    if (!Token.containsTokenWithValue(tokens, d)) {
        hours += 24 * days;
        days = 0;
    }
    if (!Token.containsTokenWithValue(tokens, H)) {
        minutes += 60 * hours;
        hours = 0;
    }
    if (!Token.containsTokenWithValue(tokens, m)) {
        seconds += 60 * minutes;
        minutes = 0;
    }
    if (!Token.containsTokenWithValue(tokens, s)) {
        milliseconds += 1000 * seconds;
        seconds = 0;
    }
    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);
}","/**
 * <p>Formats the time gap as a string, using the specified format.
 * Padding the left hand side of numbers with zeroes is optional and
 * the timezone may be specified.
 *
 * @param startMillis  the start of the duration
 * @param endMillis  the end of the duration
 * @param format  the way in which to format the duration
 * @param padWithZeros whether to pad the left hand side of numbers with 0's
 * @param timezone the millis are defined in
 * @return the time as a String
 */
","public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {
    long millis = endMillis - startMillis;
    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {
        return formatDuration(millis, format, padWithZeros);
    }
    Token[] tokens = lexx(format);
            Calendar start = Calendar.getInstance(timezone);
    start.setTime(new Date(startMillis));
    Calendar end = Calendar.getInstance(timezone);
    end.setTime(new Date(endMillis));
        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);
    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);
    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);
    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);
    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);
    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);
    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);
        while (milliseconds < 0) {
        milliseconds += 1000;
        seconds -= 1;
    }
    while (seconds < 0) {
        seconds += 60;
        minutes -= 1;
    }
    while (minutes < 0) {
        minutes += 60;
        hours -= 1;
    }
    while (hours < 0) {
        hours += 24;
        days -= 1;
    }
    while (days < 0) {
        days += 31;
                                                months -= 1;
    }
    while (months < 0) {
        months += 12;
        years -= 1;
    }
    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);
    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);
    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);
    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);
    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);
    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);
    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);
        if (!Token.containsTokenWithValue(tokens, y)) {
        if (Token.containsTokenWithValue(tokens, M)) {
            months += 12 * years;
            years = 0;
        } else {
                        days += 365 * years;
            years = 0;
        }
    }
    if (!Token.containsTokenWithValue(tokens, M)) {
        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);
        months = 0;
    }
    if (!Token.containsTokenWithValue(tokens, d)) {
        hours += 24 * days;
        days = 0;
    }
    if (!Token.containsTokenWithValue(tokens, H)) {
        minutes += 60 * hours;
        hours = 0;
    }
    if (!Token.containsTokenWithValue(tokens, m)) {
        seconds += 60 * minutes;
        minutes = 0;
    }
    if (!Token.containsTokenWithValue(tokens, s)) {
        milliseconds += 1000 * seconds;
        seconds = 0;
    }
    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);
}",2.9545454545454546,-0.2602040816326532,1.8333333333333333,0.0,2.25,2.5318833415719233,-1.23831373673645,2.5833333333333335,-0.028571428571428574,12.717912806609531
Compress,4,1,"/**
 * Performs all changes collected in this ChangeSet on the input stream and
 * streams the result to the output stream. Perform may be called more than once.
 *
 * This method finishes the stream, no other entries should be added
 * after that.
 *
 * @param in
 *            the InputStream to perform the changes on
 * @param out
 *            the resulting OutputStream with all modifications
 * @throws IOException
 *             if an read/write error occurs
 * @return the results of this operation
 */
public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out) throws IOException {
    ChangeSetResults results = new ChangeSetResults();
    Set workingSet = new LinkedHashSet(changes);
    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    ArchiveEntry entry = null;
    while ((entry = in.getNextEntry()) != null) {
        boolean copy = true;
        for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
            Change change = (Change) it.next();
            final int type = change.type();
            final String name = entry.getName();
            if (type == Change.TYPE_DELETE && name != null) {
                if (name.equals(change.targetFile())) {
                    copy = false;
                    it.remove();
                    results.deleted(name);
                    break;
                }
            } else if (type == Change.TYPE_DELETE_DIR && name != null) {
                if (name.startsWith(change.targetFile() + ""/"")) {
                    copy = false;
                    results.deleted(name);
                    break;
                }
            }
        }
        if (copy) {
            if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {
                copyStream(in, out, entry);
                results.addedFromStream(entry.getName());
            }
        }
    }
    // Adds files which hasn't been added from the original and do not have replace mode on
    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && !change.isReplaceMode() && !results.hasBeenAdded(change.getEntry().getName())) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    return results;
}","/**
 * Performs all changes collected in this ChangeSet on the input stream and
 * streams the result to the output stream. Perform may be called more than once.
 *
 * This method finishes the stream, no other entries should be added
 * after that.
 *
 * @param in
 *            the InputStream to perform the changes on
 * @param out
 *            the resulting OutputStream with all modifications
 * @throws IOException
 *             if an read/write error occurs
 * @return the results of this operation
 */
","public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out) throws IOException {
    ChangeSetResults results = new ChangeSetResults();
    Set workingSet = new LinkedHashSet(changes);
    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    ArchiveEntry entry = null;
    while ((entry = in.getNextEntry()) != null) {
        boolean copy = true;
        for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
            Change change = (Change) it.next();
            final int type = change.type();
            final String name = entry.getName();
            if (type == Change.TYPE_DELETE && name != null) {
                if (name.equals(change.targetFile())) {
                    copy = false;
                    it.remove();
                    results.deleted(name);
                    break;
                }
            } else if (type == Change.TYPE_DELETE_DIR && name != null) {
                if (name.startsWith(change.targetFile() + ""/"")) {
                    copy = false;
                    results.deleted(name);
                    break;
                }
            }
        }
        if (copy) {
            if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {
                copyStream(in, out, entry);
                results.addedFromStream(entry.getName());
            }
        }
    }
        for (Iterator it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change) it.next();
        if (change.type() == Change.TYPE_ADD && !change.isReplaceMode() && !results.hasBeenAdded(change.getEntry().getName())) {
            copyStream(change.getInput(), out, change.getEntry());
            it.remove();
            results.addedFromChangeSet(change.getEntry().getName());
        }
    }
    return results;
}",1.6363636363636365,1.306122448979592,1.8333333333333333,1.5,2.4166666666666665,1.5353435491843799,-0.9308861485517642,3.3333333333333335,-0.028571428571428574,4.324827287873531
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2649_72d24f4b,3,"@Override
public void run() {
    String name = reference.name;
    try {
        if (!local.fileExists(name)) {
            long start = System.currentTimeMillis();
            remote.copy(local, name, name, IOContext.READ);
            reference.markValid();
            downloadTime.addAndGet(System.currentTimeMillis() - start);
            downloadSize.addAndGet(remote.fileLength(name));
        } else {
            long localLength = local.fileLength(name);
            long remoteLength = remote.fileLength(name);
            // updated but still do a check if the copy is consistent
            if (localLength != remoteLength) {
                log.warn(""Found local copy for {} in {} but size of local {} differs from remote {}. "" + ""Content would be read from remote file only"", name, local, localLength, remoteLength);
                invalidFileCount.incrementAndGet();
            } else {
                reference.markValid();
            }
        }
    } catch (IOException e) {
        // TODO In case of exception there would not be any other attempt
        // to download the file. Look into support for retry
        log.warn(""Error occurred while copying file [{}] "" + ""from {} to {}"", name, remote, local, e);
    }
}",,"@Override
public void run() {
    String name = reference.name;
    try {
        if (!local.fileExists(name)) {
            long start = System.currentTimeMillis();
            remote.copy(local, name, name, IOContext.READ);
            reference.markValid();
            downloadTime.addAndGet(System.currentTimeMillis() - start);
            downloadSize.addAndGet(remote.fileLength(name));
        } else {
            long localLength = local.fileLength(name);
            long remoteLength = remote.fileLength(name);
                        if (localLength != remoteLength) {
                log.warn(""Found local copy for {} in {} but size of local {} differs from remote {}. "" + ""Content would be read from remote file only"", name, local, localLength, remoteLength);
                invalidFileCount.incrementAndGet();
            } else {
                reference.markValid();
            }
        }
    } catch (IOException e) {
                        log.warn(""Error occurred while copying file [{}] "" + ""from {} to {}"", name, remote, local, e);
    }
}",0.45454545454545453,0.9744897959183673,0.0,0.5,0.08333333333333333,0.41028175976272874,-0.3616289073702324,0.6666666666666666,-0.028571428571428574,0.48728590334973726
wicket,remotes/origin/bugs-dot-jar_WICKET-1897_8ee095bf,1,"/**
 *  @return The interface name
 */
public String getInterfaceName() {
    return interfaceName;
}","/**
 *  @return The interface name
 */
","public String getInterfaceName() {
    return interfaceName;
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.2001720676799543,-0.5,2.8285714285714287,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2494_0dc92ca1,1,"public long getSum() {
    return sum;
}",,"public long getSum() {
    return sum;
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.2776025236593067,-0.5,2.685714285714286,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-5826_a04674f2,1,"@Override
String getNext(boolean first) {
    String next = scanner.next();
    if (next == null) {
        return null;
    }
    // initialize inherited namespaces on first
    if (first && inheritNamespaceToken != null) {
        rootTokenNamespaces = getNamespacesFromNamespaceToken(next);
    }
    // make sure next is positioned at start token as we can have leading data
    // or we reached EOL and there is no more start tags
    Matcher matcher = startTokenPattern.matcher(next);
    if (!matcher.find()) {
        return null;
    } else {
        int index = matcher.start();
        next = next.substring(index);
    }
    // build answer accordingly to whether namespaces should be inherited or not
    StringBuilder sb = new StringBuilder();
    if (inheritNamespaceToken != null && rootTokenNamespaces != null) {
        // append root namespaces to local start token
        String tag = ObjectHelper.before(next, "">"");
        // grab the text
        String text = ObjectHelper.after(next, "">"");
        // build result with inherited namespaces
        next = sb.append(tag).append(rootTokenNamespaces).append("">"").append(text).append(endToken).toString();
    } else {
        next = sb.append(next).append(endToken).toString();
    }
    return next;
}",,"@Override
String getNext(boolean first) {
    String next = scanner.next();
    if (next == null) {
        return null;
    }
        if (first && inheritNamespaceToken != null) {
        rootTokenNamespaces = getNamespacesFromNamespaceToken(next);
    }
            Matcher matcher = startTokenPattern.matcher(next);
    if (!matcher.find()) {
        return null;
    } else {
        int index = matcher.start();
        next = next.substring(index);
    }
        StringBuilder sb = new StringBuilder();
    if (inheritNamespaceToken != null && rootTokenNamespaces != null) {
                String tag = ObjectHelper.before(next, "">"");
                String text = ObjectHelper.after(next, "">"");
                next = sb.append(tag).append(rootTokenNamespaces).append("">"").append(text).append(endToken).toString();
    } else {
        next = sb.append(next).append(endToken).toString();
    }
    return next;
}",0.5454545454545454,-0.2346938775510204,0.16666666666666666,-0.5,0.5,0.6139396935244688,-0.4330369945511905,0.9166666666666666,-0.028571428571428574,0.8230691148316137
Lang,37,1,"/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(null, null)     = null
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * ArrayUtils.addAll([null], [null]) = [null, null]
 * ArrayUtils.addAll([""a"", ""b"", ""c""], [""1"", ""2"", ""3""]) = [""a"", ""b"", ""c"", ""1"", ""2"", ""3""]
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array, may be <code>null</code>
 * @param array2  the second array whose elements are added to the new array, may be <code>null</code>
 * @return The new array, <code>null</code> if both arrays are <code>null</code>.
 *      The type of the new array is the type of the first array,
 *      unless the first array is null, in which case the type is the same as the second array.
 * @since 2.1
 */
@SuppressWarnings(""unchecked"")
public static <T> T[] addAll(T[] array1, T... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    final Class<?> type1 = array1.getClass().getComponentType();
    T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    // Check if problem is incompatible types
    return joinedArray;
}","/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(null, null)     = null
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * ArrayUtils.addAll([null], [null]) = [null, null]
 * ArrayUtils.addAll([""a"", ""b"", ""c""], [""1"", ""2"", ""3""]) = [""a"", ""b"", ""c"", ""1"", ""2"", ""3""]
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array, may be <code>null</code>
 * @param array2  the second array whose elements are added to the new array, may be <code>null</code>
 * @return The new array, <code>null</code> if both arrays are <code>null</code>.
 *      The type of the new array is the type of the first array,
 *      unless the first array is null, in which case the type is the same as the second array.
 * @since 2.1
 */
","@SuppressWarnings(""unchecked"")
public static <T> T[] addAll(T[] array1, T... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    final Class<?> type1 = array1.getClass().getComponentType();
    T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
        return joinedArray;
}",-0.045454545454545456,-0.28571428571428575,-0.16666666666666666,0.0,-0.08333333333333333,0.12357884330202672,-0.009463722397476294,0.08333333333333333,-0.028571428571428574,0.11243741460761263
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3310_4416a9f8,1,"private Property internalRemoveProperty(final String jcrName) throws RepositoryException {
    final String oakName = getOakName(checkNotNull(jcrName));
    return perform(new ItemWriteOperation<Property>(""internalRemoveProperty"") {

        @Nonnull
        @Override
        public Property perform() throws RepositoryException {
            PropertyDelegate property = dlg.getPropertyOrNull(oakName);
            if (property != null) {
                property.remove();
            } else {
                // Return an instance which throws on access; see OAK-395
                property = dlg.getProperty(oakName);
            }
            return new PropertyImpl(property, sessionContext);
        }

        @Override
        public String toString() {
            return String.format(""Removing property [%s]"", jcrName);
        }
    });
}",,"private Property internalRemoveProperty(final String jcrName) throws RepositoryException {
    final String oakName = getOakName(checkNotNull(jcrName));
    return perform(new ItemWriteOperation<Property>(""internalRemoveProperty"") {

        @Nonnull
        @Override
        public Property perform() throws RepositoryException {
            PropertyDelegate property = dlg.getPropertyOrNull(oakName);
            if (property != null) {
                property.remove();
            } else {
                                property = dlg.getProperty(oakName);
            }
            return new PropertyImpl(property, sessionContext);
        }

        @Override
        public String toString() {
            return String.format(""Removing property [%s]"", jcrName);
        }
    });
}",0.2727272727272727,0.7193877551020407,-0.3333333333333333,0.0,-0.25,-0.040533860603064735,-0.1843991970174938,0.08333333333333333,0.05714285714285714,0.0004068853568384531
maven,remotes/origin/bugs-dot-jar_MNG-5209_ed651a4d,3,"public List<String> getRuntimeClasspathElements() throws DependencyResolutionRequiredException {
    List<String> list = new ArrayList<String>(getArtifacts().size() + 1);
    list.add(getBuild().getOutputDirectory());
    for (Artifact a : getArtifacts()) {
        if (a.getArtifactHandler().isAddedToClasspath()) {
            // TODO: let the scope handler deal with this
            if (Artifact.SCOPE_COMPILE.equals(a.getScope()) || Artifact.SCOPE_RUNTIME.equals(a.getScope())) {
                addArtifactPath(a, list);
            }
        }
    }
    return list;
}",,"public List<String> getRuntimeClasspathElements() throws DependencyResolutionRequiredException {
    List<String> list = new ArrayList<String>(getArtifacts().size() + 1);
    list.add(getBuild().getOutputDirectory());
    for (Artifact a : getArtifacts()) {
        if (a.getArtifactHandler().isAddedToClasspath()) {
                        if (Artifact.SCOPE_COMPILE.equals(a.getScope()) || Artifact.SCOPE_RUNTIME.equals(a.getScope())) {
                addArtifactPath(a, list);
            }
        }
    }
    return list;
}",-0.09090909090909091,0.8826530612244898,0.0,0.5,0.16666666666666666,-0.04844290657439445,0.06739317464869501,0.5833333333333334,0.0,-0.030426458684004277
Csv,11,1,"/**
 * Initializes the name to index mapping if the format defines a header.
 *
 * @return null if the format has no header.
 * @throws IOException if there is a problem reading the header or skipping the first record
 */
private Map<String, Integer> initializeHeader() throws IOException {
    Map<String, Integer> hdrMap = null;
    final String[] formatHeader = this.format.getHeader();
    if (formatHeader != null) {
        hdrMap = new LinkedHashMap<String, Integer>();
        String[] headerRecord = null;
        if (formatHeader.length == 0) {
            // read the header from the first line of the file
            final CSVRecord nextRecord = this.nextRecord();
            if (nextRecord != null) {
                headerRecord = nextRecord.values();
            }
        } else {
            if (this.format.getSkipHeaderRecord()) {
                this.nextRecord();
            }
            headerRecord = formatHeader;
        }
        // build the name to index mappings
        if (headerRecord != null) {
            for (int i = 0; i < headerRecord.length; i++) {
                final String header = headerRecord[i];
                final boolean containsHeader = hdrMap.containsKey(header);
                final boolean emptyHeader = header.trim().isEmpty();
                if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {
                    throw new IllegalArgumentException(""The header contains a duplicate name: \"""" + header + ""\"" in "" + Arrays.toString(headerRecord));
                }
                hdrMap.put(header, Integer.valueOf(i));
            }
        }
    }
    return hdrMap;
}","/**
 * Initializes the name to index mapping if the format defines a header.
 *
 * @return null if the format has no header.
 * @throws IOException if there is a problem reading the header or skipping the first record
 */
","private Map<String, Integer> initializeHeader() throws IOException {
    Map<String, Integer> hdrMap = null;
    final String[] formatHeader = this.format.getHeader();
    if (formatHeader != null) {
        hdrMap = new LinkedHashMap<String, Integer>();
        String[] headerRecord = null;
        if (formatHeader.length == 0) {
                        final CSVRecord nextRecord = this.nextRecord();
            if (nextRecord != null) {
                headerRecord = nextRecord.values();
            }
        } else {
            if (this.format.getSkipHeaderRecord()) {
                this.nextRecord();
            }
            headerRecord = formatHeader;
        }
                if (headerRecord != null) {
            for (int i = 0; i < headerRecord.length; i++) {
                final String header = headerRecord[i];
                final boolean containsHeader = hdrMap.containsKey(header);
                final boolean emptyHeader = header.trim().isEmpty();
                if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {
                    throw new IllegalArgumentException(""The header contains a duplicate name: \"""" + header + ""\"" in "" + Arrays.toString(headerRecord));
                }
                hdrMap.put(header, Integer.valueOf(i));
            }
        }
    }
    return hdrMap;
}",0.7727272727272727,1.0918367346938775,0.8333333333333334,1.0,1.25,1.4562530894710826,-0.5692572411815318,0.5,-0.028571428571428574,2.0389924661963934
wicket,remotes/origin/bugs-dot-jar_WICKET-5418_e350f19e,1,"/**
 *  Marks the form component required if necessary
 */
private void setComponentRequiredFlag() {
    BeanValidationContext config = BeanValidationConfiguration.get();
    Validator validator = config.getValidator();
    Property property = getProperty();
    // if the property has a NotNull constraint mark the form component required
    Iterator<ConstraintDescriptor<?>> it = new ConstraintIterator(validator, property);
    while (it.hasNext()) {
        ConstraintDescriptor<?> desc = it.next();
        if (desc.getAnnotation().annotationType().equals(NotNull.class)) {
            component.setRequired(true);
            break;
        }
    }
}","/**
 *  Marks the form component required if necessary
 */
","private void setComponentRequiredFlag() {
    BeanValidationContext config = BeanValidationConfiguration.get();
    Validator validator = config.getValidator();
    Property property = getProperty();
        Iterator<ConstraintDescriptor<?>> it = new ConstraintIterator(validator, property);
    while (it.hasNext()) {
        ConstraintDescriptor<?> desc = it.next();
        if (desc.getAnnotation().annotationType().equals(NotNull.class)) {
            component.setRequired(true);
            break;
        }
    }
}",-0.045454545454545456,0.34183673469387754,0.0,0.0,-0.08333333333333333,-0.3806228373702422,0.03412675652423281,0.25,0.4571428571428572,-0.16422749602751402
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-492_61ccbb95,3,"/**
 * Unregisters all MBeans associated with the specified logger context
 * (including MBeans for {@code LoggerConfig}s and {@code Appender}s from
 * the platform MBean server.
 *
 * @param loggerContextName name of the logger context to unregister
 * @param mbs the MBean Server to unregister the instrumented objects from
 */
public static void unregisterContext(String contextName, MBeanServer mbs) {
    final String pattern = LoggerContextAdminMBean.PATTERN;
    final String search = String.format(pattern, contextName, ""*"");
    // unregister context mbean
    unregisterAllMatching(search, mbs);
    unregisterLoggerConfigs(contextName, mbs);
    unregisterAppenders(contextName, mbs);
    unregisterAsyncAppenders(contextName, mbs);
    unregisterAsyncLoggerRingBufferAdmins(contextName, mbs);
    unregisterAsyncLoggerConfigRingBufferAdmins(contextName, mbs);
}","/**
 * Unregisters all MBeans associated with the specified logger context
 * (including MBeans for {@code LoggerConfig}s and {@code Appender}s from
 * the platform MBean server.
 *
 * @param loggerContextName name of the logger context to unregister
 * @param mbs the MBean Server to unregister the instrumented objects from
 */
","public static void unregisterContext(String contextName, MBeanServer mbs) {
    final String pattern = LoggerContextAdminMBean.PATTERN;
    final String search = String.format(pattern, contextName, ""*"");
        unregisterAllMatching(search, mbs);
    unregisterLoggerConfigs(contextName, mbs);
    unregisterAppenders(contextName, mbs);
    unregisterAsyncAppenders(contextName, mbs);
    unregisterAsyncLoggerRingBufferAdmins(contextName, mbs);
    unregisterAsyncLoggerConfigRingBufferAdmins(contextName, mbs);
}",-0.18181818181818182,-0.7244897959183674,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.19673071408087184,0.08333333333333333,0.028571428571428574,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-3718_73ce9cfb,0,"public boolean equals(Mutation m) {
    serialize();
    m.serialize();
    if (Arrays.equals(row, m.row) && entries == m.entries && Arrays.equals(data, m.data)) {
        if (values == null && m.values == null)
            return true;
        if (values != null && m.values != null && values.size() == m.values.size()) {
            for (int i = 0; i < values.size(); i++) {
                if (!Arrays.equals(values.get(i), m.values.get(i)))
                    return false;
            }
            return true;
        }
    }
    return false;
}",,"public boolean equals(Mutation m) {
    serialize();
    m.serialize();
    if (Arrays.equals(row, m.row) && entries == m.entries && Arrays.equals(data, m.data)) {
        if (values == null && m.values == null)
            return true;
        if (values != null && m.values != null && values.size() == m.values.size()) {
            for (int i = 0; i < values.size(); i++) {
                if (!Arrays.equals(values.get(i), m.values.get(i)))
                    return false;
            }
            return true;
        }
    }
    return false;
}",0.09090909090909091,1.2551020408163267,0.3333333333333333,0.5,1.75,1.503707365299061,-0.15887582449096668,0.3333333333333333,-0.028571428571428574,1.126991061371161
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2219_f2740ce1,1,"@Override
public Cursor query(IndexPlan plan, NodeState root) {
    LOG.debug(""query(IndexPlan, NodeState)"");
    LOG.debug(""query() - plan: {}"", plan);
    LOG.debug(""query() - rootState: {}"", root);
    Filter filter = plan.getFilter();
    List<OrderEntry> sortOrder = plan.getSortOrder();
    String pathPrefix = plan.getPathPrefix();
    Iterable<String> paths = null;
    OrderedContentMirrorStoreStrategy strategy = OrderedPropertyIndexLookup.getStrategy(plan.getDefinition());
    int depth = 1;
    PropertyRestriction pr = plan.getPropertyRestriction();
    if (pr != null) {
        String propertyName = PathUtils.getName(pr.propertyName);
        depth = PathUtils.getDepth(propertyName);
        paths = strategy.query(plan.getFilter(), propertyName, plan.getDefinition(), pr, pathPrefix);
    }
    if (paths == null && sortOrder != null && !sortOrder.isEmpty()) {
        // we could be here if we have a query where the ORDER BY makes us play it.
        for (OrderEntry oe : sortOrder) {
            String propertyName = PathUtils.getName(oe.getPropertyName());
            depth = PathUtils.getDepth(oe.getPropertyName());
            paths = strategy.query(plan.getFilter(), propertyName, plan.getDefinition(), new PropertyRestriction(), pathPrefix);
        }
    }
    if (paths == null) {
        // if still here then something went wrong.
        throw new IllegalStateException(""OrderedPropertyIndex index is used even when no index is available for filter "" + filter);
    }
    Cursor cursor = Cursors.newPathCursor(paths, filter.getQueryEngineSettings());
    if (depth > 1) {
        cursor = Cursors.newAncestorCursor(cursor, depth - 1, filter.getQueryEngineSettings());
    }
    return cursor;
}",,"@Override
public Cursor query(IndexPlan plan, NodeState root) {
    LOG.debug(""query(IndexPlan, NodeState)"");
    LOG.debug(""query() - plan: {}"", plan);
    LOG.debug(""query() - rootState: {}"", root);
    Filter filter = plan.getFilter();
    List<OrderEntry> sortOrder = plan.getSortOrder();
    String pathPrefix = plan.getPathPrefix();
    Iterable<String> paths = null;
    OrderedContentMirrorStoreStrategy strategy = OrderedPropertyIndexLookup.getStrategy(plan.getDefinition());
    int depth = 1;
    PropertyRestriction pr = plan.getPropertyRestriction();
    if (pr != null) {
        String propertyName = PathUtils.getName(pr.propertyName);
        depth = PathUtils.getDepth(propertyName);
        paths = strategy.query(plan.getFilter(), propertyName, plan.getDefinition(), pr, pathPrefix);
    }
    if (paths == null && sortOrder != null && !sortOrder.isEmpty()) {
                for (OrderEntry oe : sortOrder) {
            String propertyName = PathUtils.getName(oe.getPropertyName());
            depth = PathUtils.getDepth(oe.getPropertyName());
            paths = strategy.query(plan.getFilter(), propertyName, plan.getDefinition(), new PropertyRestriction(), pathPrefix);
        }
    }
    if (paths == null) {
                throw new IllegalStateException(""OrderedPropertyIndex index is used even when no index is available for filter "" + filter);
    }
    Cursor cursor = Cursors.newPathCursor(paths, filter.getQueryEngineSettings());
    if (depth > 1) {
        cursor = Cursors.newAncestorCursor(cursor, depth - 1, filter.getQueryEngineSettings());
    }
    return cursor;
}",0.8636363636363636,0.005102040816326422,0.5,0.0,0.5,1.5650024715768662,-0.6521365070260974,1.6666666666666667,-0.028571428571428574,3.4896415554156444
commons-math,remotes/origin/bugs-dot-jar_MATH-1103_a6f96306,1,"/**
 * {@inheritDoc}
 */
public Optimum optimize(final LeastSquaresProblem lsp) {
    // create local evaluation and iteration counts
    final Incrementor evaluationCounter = lsp.getEvaluationCounter();
    final Incrementor iterationCounter = lsp.getIterationCounter();
    final ConvergenceChecker<Evaluation> checker = lsp.getConvergenceChecker();
    // Computation will be useless without a checker (see ""for-loop"").
    if (checker == null) {
        throw new NullArgumentException();
    }
    final int nC = lsp.getParameterSize();
    final RealVector currentPoint = lsp.getStart();
    // iterate until convergence is reached
    Evaluation current = null;
    while (true) {
        iterationCounter.incrementCount();
        // evaluate the objective function and its jacobian
        Evaluation previous = current;
        // Value of the objective function at ""currentPoint"".
        evaluationCounter.incrementCount();
        current = lsp.evaluate(currentPoint);
        final RealVector currentResiduals = current.getResiduals();
        final RealMatrix weightedJacobian = current.getJacobian();
        // Check convergence.
        if (previous != null) {
            if (checker.converged(iterationCounter.getCount(), previous, current)) {
                return new OptimumImpl(current, evaluationCounter.getCount(), iterationCounter.getCount());
            }
        }
        // solve the linearized least squares problem
        final RealVector dX = this.decomposition.solve(weightedJacobian, currentResiduals);
        // update the estimated parameters
        for (int i = 0; i < nC; ++i) {
            currentPoint.setEntry(i, currentPoint.getEntry(i) + dX.getEntry(i));
        }
    }
}","/**
 * {@inheritDoc}
 */
","public Optimum optimize(final LeastSquaresProblem lsp) {
        final Incrementor evaluationCounter = lsp.getEvaluationCounter();
    final Incrementor iterationCounter = lsp.getIterationCounter();
    final ConvergenceChecker<Evaluation> checker = lsp.getConvergenceChecker();
        if (checker == null) {
        throw new NullArgumentException();
    }
    final int nC = lsp.getParameterSize();
    final RealVector currentPoint = lsp.getStart();
        Evaluation current = null;
    while (true) {
        iterationCounter.incrementCount();
                Evaluation previous = current;
                evaluationCounter.incrementCount();
        current = lsp.evaluate(currentPoint);
        final RealVector currentResiduals = current.getResiduals();
        final RealMatrix weightedJacobian = current.getJacobian();
                if (previous != null) {
            if (checker.converged(iterationCounter.getCount(), previous, current)) {
                return new OptimumImpl(current, evaluationCounter.getCount(), iterationCounter.getCount());
            }
        }
                final RealVector dX = this.decomposition.solve(weightedJacobian, currentResiduals);
                for (int i = 0; i < nC; ++i) {
            currentPoint.setEntry(i, currentPoint.getEntry(i) + dX.getEntry(i));
        }
    }
}",0.6363636363636364,0.27040816326530603,0.5,0.5,0.5833333333333334,0.8492338111715275,-0.5124749067966736,1.0,-0.028571428571428574,1.345008801572719
camel,remotes/origin/bugs-dot-jar_CAMEL-5261_55c2e2d8,1,"public synchronized BlockingQueue<Exchange> getQueue() {
    if (queue == null) {
        if (size > 0) {
            queue = new LinkedBlockingQueue<Exchange>(size);
        } else {
            queue = new LinkedBlockingQueue<Exchange>();
        }
    }
    return queue;
}",,"public synchronized BlockingQueue<Exchange> getQueue() {
    if (queue == null) {
        if (size > 0) {
            queue = new LinkedBlockingQueue<Exchange>(size);
        } else {
            queue = new LinkedBlockingQueue<Exchange>();
        }
    }
    return queue;
}",-0.18181818181818182,0.5510204081632651,-0.16666666666666666,0.0,-0.08333333333333333,-0.028670291646070156,0.30054488098652155,-0.5,0.5142857142857143,-0.10963204714730534
wicket,remotes/origin/bugs-dot-jar_WICKET-5114_518c933b,1,"/**
 *  Stringizes this url
 *
 *  @param mode
 *             {@link StringMode} that determins how to stringize the url
 *  @param charset
 *             charset
 *  @return sringized version of this url
 */
public String toString(StringMode mode, Charset charset) {
    StringBuilder result = new StringBuilder();
    final String path = getPath(charset);
    if (StringMode.FULL == mode) {
        if (Strings.isEmpty(host)) {
            throw new IllegalStateException(""Cannot render this url in "" + StringMode.FULL.name() + "" mode because it does not have a host set."");
        }
        if (Strings.isEmpty(protocol) == false) {
            result.append(protocol);
            result.append(""://"");
        } else if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false) {
            result.append(""//"");
        }
        result.append(host);
        if (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false) {
            result.append(':');
            result.append(port);
        }
        if (path.contains("".."")) {
            throw new IllegalStateException(""Cannot render this url in "" + StringMode.FULL.name() + "" mode because it has a `..` segment: "" + toString());
        }
        if (!path.startsWith(""/"")) {
            result.append('/');
        }
    }
    result.append(path);
    result.append(getQueryString(charset));
    return result.toString();
}","/**
 *  Stringizes this url
 *
 *  @param mode
 *             {@link StringMode} that determins how to stringize the url
 *  @param charset
 *             charset
 *  @return sringized version of this url
 */
","public String toString(StringMode mode, Charset charset) {
    StringBuilder result = new StringBuilder();
    final String path = getPath(charset);
    if (StringMode.FULL == mode) {
        if (Strings.isEmpty(host)) {
            throw new IllegalStateException(""Cannot render this url in "" + StringMode.FULL.name() + "" mode because it does not have a host set."");
        }
        if (Strings.isEmpty(protocol) == false) {
            result.append(protocol);
            result.append(""://"");
        } else if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false) {
            result.append(""//"");
        }
        result.append(host);
        if (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false) {
            result.append(':');
            result.append(port);
        }
        if (path.contains("".."")) {
            throw new IllegalStateException(""Cannot render this url in "" + StringMode.FULL.name() + "" mode because it has a `..` segment: "" + toString());
        }
        if (!path.startsWith(""/"")) {
            result.append('/');
        }
    }
    result.append(path);
    result.append(getQueryString(charset));
    return result.toString();
}",0.6818181818181818,0.2653061224489796,1.0,0.5,1.1666666666666667,1.0944142362827487,-0.538571838256381,1.4166666666666667,-0.028571428571428574,1.5298075646412341
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2427_e6d4f9a6,1,"@Override
public String toString() {
    StringBuilder buff = new StringBuilder();
    buff.append(s1).append("" union "").append(s2);
    // order by ...
    if (orderList != null && !orderList.isEmpty()) {
        buff.append("" order by "");
        for (int i = 0; i < orderList.size(); i++) {
            if (i > 0) {
                buff.append("", "");
            }
            buff.append(orderList.get(i));
        }
    }
    // leave original xpath string as a comment
    if (xpathQuery != null) {
        buff.append("" /* xpath: "");
        buff.append(xpathQuery);
        buff.append("" */"");
    }
    return buff.toString();
}",,"@Override
public String toString() {
    StringBuilder buff = new StringBuilder();
    buff.append(s1).append("" union "").append(s2);
        if (orderList != null && !orderList.isEmpty()) {
        buff.append("" order by "");
        for (int i = 0; i < orderList.size(); i++) {
            if (i > 0) {
                buff.append("", "");
            }
            buff.append(orderList.get(i));
        }
    }
        if (xpathQuery != null) {
        buff.append("" /* xpath: "");
        buff.append(xpathQuery);
        buff.append("" */"");
    }
    return buff.toString();
}",0.2727272727272727,0.6377551020408161,0.16666666666666666,0.5,0.4166666666666667,0.9678695007414733,-0.24118153140235157,0.5833333333333334,0.05714285714285714,0.6727699470192435
wicket,remotes/origin/bugs-dot-jar_WICKET-3617_7ae109a6,1,"/*
	 * TODO: simplify the code below. See WICKET-3347
	 */
@Override
public void respond(RequestCycle requestCycle) {
    Url currentUrl = requestCycle.getUrlRenderer().getBaseUrl();
    Url targetUrl = requestCycle.mapUrlFor(getRenderPageRequestHandler());
    // 
    // the code below is little hairy but we have to handle 3 redirect policies,
    // 3 rendering strategies and two kind of requests (ajax and normal)
    // 
    // try to get an already rendered buffered response for current URL
    BufferedWebResponse bufferedResponse = getAndRemoveBufferedResponse(currentUrl);
    boolean isAjax = isAjax(requestCycle);
    boolean shouldPreserveClientUrl = ((WebRequest) requestCycle.getRequest()).shouldPreserveClientUrl();
    if (bufferedResponse != null) {
        logger.warn(""The Buffered response should be handled by BufferedResponseRequestHandler"");
        // if there is saved response for this URL render it
        bufferedResponse.writeTo((WebResponse) requestCycle.getResponse());
    } else if (// 
    getRedirectPolicy() == RedirectPolicy.NEVER_REDIRECT || isOnePassRender() || (// 
    !isAjax && // 
    (targetUrl.equals(currentUrl) && !getPageProvider().isNewPageInstance() && !getPage().isPageStateless()) || // 
    (targetUrl.equals(currentUrl) && isRedirectToRender())) || // 
    shouldPreserveClientUrl) {
        // if the policy is never to redirect
        // or one pass render mode is on
        // or the targetUrl matches current url and the page is not stateless
        // or the targetUrl matches current url, page is stateless but it's redirect-to-render
        // or the request determines that the current url should be preserved
        // just render the page
        BufferedWebResponse response = renderPage(currentUrl, requestCycle);
        if (response != null) {
            response.writeTo((WebResponse) requestCycle.getResponse());
        }
    } else if (// 
    (!targetUrl.equals(currentUrl) && getRedirectPolicy() == RedirectPolicy.ALWAYS_REDIRECT) || // 
    isRedirectToRender() || (isAjax && targetUrl.equals(currentUrl))) {
        // if target URL is different
        // and render policy is always-redirect or it's redirect-to-render
        redirectTo(targetUrl, requestCycle);
    } else if (// 
    !targetUrl.equals(currentUrl) && (getPageProvider().isNewPageInstance() || (isSessionTemporary() && getPage().isPageStateless()))) {
        // if target URL is different and session is temporary and page is stateless
        // this is special case when page is stateless but there is no session so we can't
        // render it to buffer
        // alternatively if URLs are different and we have a page class and not an instance we
        // can redirect to the url which will instantiate the instance of us
        // note: if we had session here we would render the page to buffer and then redirect to
        // URL generated *after* page has been rendered (the statelessness may change during
        // render). this would save one redirect because now we have to render to URL generated
        // *before* page is rendered, render the page, get URL after render and if the URL is
        // different (meaning page is not stateless), save the buffer and redirect again (which
        // is pretty much what the next step does)
        redirectTo(targetUrl, requestCycle);
    } else if (isRedirectToBuffer()) {
        // redirect to buffer
        BufferedWebResponse response = renderPage(targetUrl, requestCycle);
        if (response == null) {
            return;
        }
        // check if the url hasn't changed after page has been rendered
        // (i.e. the stateless flag might have changed which could result in different page url)
        Url targetUrl2 = requestCycle.mapUrlFor(getRenderPageRequestHandler());
        if (targetUrl.getSegments().equals(targetUrl2.getSegments()) == false) {
            // the amount of segments is different - generated relative URLs will not work, we
            // need to rerender the page. This shouldn't happen, but in theory it can - with
            // RequestHandlerEncoders that produce different URLs with different amount of
            // segments for stateless and stateful pages
            response = renderPage(targetUrl2, requestCycle);
        }
        if (currentUrl.equals(targetUrl2)) {
            // no need to redirect when both urls are exactly the same
            response.writeTo((WebResponse) requestCycle.getResponse());
        } else // if page is still stateless after render
        if (getPage().isPageStateless() && !enableRedirectForStatelessPage()) {
            // we don't want the redirect to happen for stateless page
            // example:
            // when a normal mounted stateful page is hit at /mount/point
            // wicket renders the page to buffer and redirects to /mount/point?12
            // but for stateless page the redirect is not necessary
            // also for listener interface on stateful page we want to redirect
            // after the listener is invoked, but on stateless page the user
            // must ask for redirect explicitly
            response.writeTo((WebResponse) requestCycle.getResponse());
        } else {
            storeBufferedResponse(targetUrl2, response);
            redirectTo(targetUrl2, requestCycle);
        }
    } else {
        throw new IllegalStateException(""Unknown RenderStrategy."");
    }
}",,"@Override
public void respond(RequestCycle requestCycle) {
    Url currentUrl = requestCycle.getUrlRenderer().getBaseUrl();
    Url targetUrl = requestCycle.mapUrlFor(getRenderPageRequestHandler());
                        BufferedWebResponse bufferedResponse = getAndRemoveBufferedResponse(currentUrl);
    boolean isAjax = isAjax(requestCycle);
    boolean shouldPreserveClientUrl = ((WebRequest) requestCycle.getRequest()).shouldPreserveClientUrl();
    if (bufferedResponse != null) {
        logger.warn(""The Buffered response should be handled by BufferedResponseRequestHandler"");
                bufferedResponse.writeTo((WebResponse) requestCycle.getResponse());
    } else if (    getRedirectPolicy() == RedirectPolicy.NEVER_REDIRECT || isOnePassRender() || (    !isAjax &&     (targetUrl.equals(currentUrl) && !getPageProvider().isNewPageInstance() && !getPage().isPageStateless()) ||     (targetUrl.equals(currentUrl) && isRedirectToRender())) ||     shouldPreserveClientUrl) {
                                                        BufferedWebResponse response = renderPage(currentUrl, requestCycle);
        if (response != null) {
            response.writeTo((WebResponse) requestCycle.getResponse());
        }
    } else if (    (!targetUrl.equals(currentUrl) && getRedirectPolicy() == RedirectPolicy.ALWAYS_REDIRECT) ||     isRedirectToRender() || (isAjax && targetUrl.equals(currentUrl))) {
                        redirectTo(targetUrl, requestCycle);
    } else if (    !targetUrl.equals(currentUrl) && (getPageProvider().isNewPageInstance() || (isSessionTemporary() && getPage().isPageStateless()))) {
                                                                                                redirectTo(targetUrl, requestCycle);
    } else if (isRedirectToBuffer()) {
                BufferedWebResponse response = renderPage(targetUrl, requestCycle);
        if (response == null) {
            return;
        }
                        Url targetUrl2 = requestCycle.mapUrlFor(getRenderPageRequestHandler());
        if (targetUrl.getSegments().equals(targetUrl2.getSegments()) == false) {
                                                            response = renderPage(targetUrl2, requestCycle);
        }
        if (currentUrl.equals(targetUrl2)) {
                        response.writeTo((WebResponse) requestCycle.getResponse());
        } else         if (getPage().isPageStateless() && !enableRedirectForStatelessPage()) {
                                                                                                            response.writeTo((WebResponse) requestCycle.getResponse());
        } else {
            storeBufferedResponse(targetUrl2, response);
            redirectTo(targetUrl2, requestCycle);
        }
    } else {
        throw new IllegalStateException(""Unknown RenderStrategy."");
    }
}",1.5909090909090908,0.09693877551020405,1.3333333333333333,2.5,3.25,1.2901631240731588,-0.8901634642959568,3.9166666666666665,-0.028571428571428574,3.4551076961294496
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3324_5f863af6,1,"@Override
public boolean isGranted(long repositoryPermissions) {
    return hasPermissions(getEntryIterator(new EntryPredicate()), repositoryPermissions, null);
}",,"@Override
public boolean isGranted(long repositoryPermissions) {
    return hasPermissions(getEntryIterator(new EntryPredicate()), repositoryPermissions, null);
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8850014338973328,-0.3333333333333333,0.3428571428571429,-0.16422749602751402
Closure,171,2,"/**
 * Determines whether a qualified name is inferred.
 * NOTE(nicksantos): Determining whether a property is declared or not
 * is really really obnoxious.
 *
 * The problem is that there are two (equally valid) coding styles:
 *
 * (function() {
 *   /* The authoritative definition of goog.bar. /
 *   goog.bar = function() {};
 * })();
 *
 * function f() {
 *   goog.bar();
 *   /* Reset goog.bar to a no-op. /
 *   goog.bar = function() {};
 * }
 *
 * In a dynamic language with first-class functions, it's very difficult
 * to know which one the user intended without looking at lots of
 * contextual information (the second example demonstrates a small case
 * of this, but there are some really pathological cases as well).
 *
 * The current algorithm checks if either the declaration has
 * JsDoc type information, or @const with a known type,
 * or a function literal with a name we haven't seen before.
 */
private boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {
    if (valueType == null) {
        return true;
    }
    // Prototype sets are always declared.
    boolean inferred = true;
    if (info != null) {
        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
    }
    if (inferred && rhsValue != null && rhsValue.isFunction()) {
        if (info != null) {
            return false;
        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {
            // Functions assigned in conditional blocks are inferred.
            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {
                if (NodeUtil.isControlStructure(current)) {
                    return true;
                }
            }
            // Check if this is assigned in an inner scope.
            // Functions assigned in inner scopes are inferred.
            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());
            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {
                return false;
            }
        }
    }
    return inferred;
}","/**
 * Determines whether a qualified name is inferred.
 * NOTE(nicksantos): Determining whether a property is declared or not
 * is really really obnoxious.
 *
 * The problem is that there are two (equally valid) coding styles:
 *
 * (function() {
 *   /* The authoritative definition of goog.bar. /
 *   goog.bar = function() {};
 * })();
 *
 * function f() {
 *   goog.bar();
 *   /* Reset goog.bar to a no-op. /
 *   goog.bar = function() {};
 * }
 *
 * In a dynamic language with first-class functions, it's very difficult
 * to know which one the user intended without looking at lots of
 * contextual information (the second example demonstrates a small case
 * of this, but there are some really pathological cases as well).
 *
 * The current algorithm checks if either the declaration has
 * JsDoc type information, or @const with a known type,
 * or a function literal with a name we haven't seen before.
 */
","private boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {
    if (valueType == null) {
        return true;
    }
        boolean inferred = true;
    if (info != null) {
        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
    }
    if (inferred && rhsValue != null && rhsValue.isFunction()) {
        if (info != null) {
            return false;
        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {
                        for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {
                if (NodeUtil.isControlStructure(current)) {
                    return true;
                }
            }
                                    AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());
            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {
                return false;
            }
        }
    }
    return inferred;
}",0.5,1.1224489795918366,0.8333333333333334,1.5,1.8333333333333333,0.8709836875926843,-0.4654430742758821,0.9166666666666666,-0.028571428571428574,1.298473965761668
Csv,5,1,"/**
 * Outputs the record separator.
 *
 * @throws IOException
 *             If an I/O error occurs
 */
public void println() throws IOException {
    final String recordSeparator = format.getRecordSeparator();
    out.append(recordSeparator);
    newRecord = true;
}","/**
 * Outputs the record separator.
 *
 * @throws IOException
 *             If an I/O error occurs
 */
","public void println() throws IOException {
    final String recordSeparator = format.getRecordSeparator();
    out.append(recordSeparator);
    newRecord = true;
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.6888442787496416,-0.3333333333333333,2.8000000000000003,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-4029_5ca779a0,1,"@Override
public int hashCode() {
    return toThrift(false).hashCode();
}",,"@Override
public int hashCode() {
    return toThrift(false).hashCode();
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9836535704043596,-0.3333333333333333,1.7714285714285716,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-1117_f4c926ea,1,"/**
 * Create a list of hyperplanes representing the boundary of a box.
 * @param xMin low bound along the x direction
 * @param xMax high bound along the x direction
 * @param yMin low bound along the y direction
 * @param yMax high bound along the y direction
 * @param tolerance tolerance below which points are considered identical
 * @return boundary of the box
 */
private static Line[] boxBoundary(final double xMin, final double xMax, final double yMin, final double yMax, final double tolerance) {
    final Vector2D minMin = new Vector2D(xMin, yMin);
    final Vector2D minMax = new Vector2D(xMin, yMax);
    final Vector2D maxMin = new Vector2D(xMax, yMin);
    final Vector2D maxMax = new Vector2D(xMax, yMax);
    return new Line[] { new Line(minMin, maxMin, tolerance), new Line(maxMin, maxMax, tolerance), new Line(maxMax, minMax, tolerance), new Line(minMax, minMin, tolerance) };
}","/**
 * Create a list of hyperplanes representing the boundary of a box.
 * @param xMin low bound along the x direction
 * @param xMax high bound along the x direction
 * @param yMin low bound along the y direction
 * @param yMax high bound along the y direction
 * @param tolerance tolerance below which points are considered identical
 * @return boundary of the box
 */
","private static Line[] boxBoundary(final double xMin, final double xMax, final double yMin, final double yMax, final double tolerance) {
    final Vector2D minMin = new Vector2D(xMin, yMin);
    final Vector2D minMax = new Vector2D(xMin, yMax);
    final Vector2D maxMin = new Vector2D(xMax, yMin);
    final Vector2D maxMax = new Vector2D(xMax, yMax);
    return new Line[] { new Line(minMin, maxMin, tolerance), new Line(maxMin, maxMax, tolerance), new Line(maxMax, minMax, tolerance), new Line(minMax, minMin, tolerance) };
}",-0.3181818181818182,-0.6173469387755102,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.3369658732434759,-0.5,-0.028571428571428574,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1505_b082fc1e,1,"synchronized void addMutation(Mutation m) {
    long now = System.currentTimeMillis();
    mutationCount++;
    for (ColumnUpdate u : m.getUpdates()) {
        Key key = new Key(m.getRow(), 0, m.getRow().length, u.getColumnFamily(), 0, u.getColumnFamily().length, u.getColumnQualifier(), 0, u.getColumnQualifier().length, u.getColumnVisibility(), 0, u.getColumnVisibility().length, u.getTimestamp());
        if (u.isDeleted())
            key.setDeleted(true);
        if (!u.hasTimestamp())
            if (timeType.equals(TimeType.LOGICAL))
                key.setTimestamp(mutationCount);
            else
                key.setTimestamp(now);
        table.put(new MockMemKey(key, mutationCount), new Value(u.getValue()));
    }
}",,"synchronized void addMutation(Mutation m) {
    long now = System.currentTimeMillis();
    mutationCount++;
    for (ColumnUpdate u : m.getUpdates()) {
        Key key = new Key(m.getRow(), 0, m.getRow().length, u.getColumnFamily(), 0, u.getColumnFamily().length, u.getColumnQualifier(), 0, u.getColumnQualifier().length, u.getColumnVisibility(), 0, u.getColumnVisibility().length, u.getTimestamp());
        if (u.isDeleted())
            key.setDeleted(true);
        if (!u.hasTimestamp())
            if (timeType.equals(TimeType.LOGICAL))
                key.setTimestamp(mutationCount);
            else
                key.setTimestamp(now);
        table.put(new MockMemKey(key, mutationCount), new Value(u.getValue()));
    }
}",0.045454545454545456,0.9846938775510206,0.16666666666666666,-0.5,0.08333333333333333,0.0029658922392486655,-0.14367651276168644,1.0833333333333333,-0.028571428571428574,0.13895349086221148
commons-math,remotes/origin/bugs-dot-jar_MATH-369_f4a4464b,3,"/**
 * {@inheritDoc}
 */
public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException {
    return solve(min, max);
}","/**
 * {@inheritDoc}
 */
","public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException {
    return solve(min, max);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9675939202753088,-0.4166666666666667,2.142857142857143,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-5432_93935780,1,"public Producer createProducer() throws Exception {
    return new SedaProducer(this, getQueue(), getWaitForTaskToComplete(), getTimeout(), isBlockWhenFull());
}",,"public Producer createProducer() throws Exception {
    return new SedaProducer(this, getQueue(), getWaitForTaskToComplete(), getTimeout(), isBlockWhenFull());
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.0106108402638376,-0.16666666666666666,0.028571428571428574,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-7795_19b2aa31,1,"public void done(boolean doneSync) {
    try {
        if (!doneSync) {
            // when done asynchronously then restore information from previous thread
            if (breadcrumbId != null) {
                MDC.put(MDC_BREADCRUMB_ID, breadcrumbId);
            }
            if (exchangeId != null) {
                MDC.put(MDC_EXCHANGE_ID, exchangeId);
            }
            if (messageId != null) {
                MDC.put(MDC_MESSAGE_ID, messageId);
            }
            if (correlationId != null) {
                MDC.put(MDC_CORRELATION_ID, correlationId);
            }
            if (routeId != null) {
                MDC.put(MDC_ROUTE_ID, routeId);
            }
            if (camelContextId != null) {
                MDC.put(MDC_CAMEL_CONTEXT_ID, camelContextId);
            }
        }
    } finally {
        // muse ensure delegate is invoked
        delegate.done(doneSync);
    }
}",,"public void done(boolean doneSync) {
    try {
        if (!doneSync) {
                        if (breadcrumbId != null) {
                MDC.put(MDC_BREADCRUMB_ID, breadcrumbId);
            }
            if (exchangeId != null) {
                MDC.put(MDC_EXCHANGE_ID, exchangeId);
            }
            if (messageId != null) {
                MDC.put(MDC_MESSAGE_ID, messageId);
            }
            if (correlationId != null) {
                MDC.put(MDC_CORRELATION_ID, correlationId);
            }
            if (routeId != null) {
                MDC.put(MDC_ROUTE_ID, routeId);
            }
            if (camelContextId != null) {
                MDC.put(MDC_CAMEL_CONTEXT_ID, camelContextId);
            }
        }
    } finally {
                delegate.done(doneSync);
    }
}",0.5454545454545454,0.8571428571428572,0.6666666666666666,0.5,0.75,0.06623826000988631,-0.34327502150846007,0.08333333333333333,-0.028571428571428574,0.04865063966661098
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_add180fb,1,"/**
 * @deprecated since 1.4 {@link #attachIterator(String, IteratorSetting)}
 */
@Override
public void addAggregators(String tableName, List<? extends PerColumnIteratorConfig> aggregators) throws AccumuloSecurityException, TableNotFoundException, AccumuloException {
    acu.addAggregators(tableName, aggregators);
}","/**
 * @deprecated since 1.4 {@link #attachIterator(String, IteratorSetting)}
 */
","@Override
public void addAggregators(String tableName, List<? extends PerColumnIteratorConfig> aggregators) throws AccumuloSecurityException, TableNotFoundException, AccumuloException {
    acu.addAggregators(tableName, aggregators);
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7823343848580444,-0.4166666666666667,1.4285714285714286,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-4509_8e3450f4,1,"public void process(Exchange exchange) throws Exception {
    ObjectHelper.notNull(dataFormat, ""dataFormat"");
    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    Message in = exchange.getIn();
    Object body = in.getBody();
    // lets setup the out message before we invoke the dataFormat
    // so that it can mutate it if necessary
    Message out = exchange.getOut();
    out.copyFrom(in);
    dataFormat.marshal(exchange, body, buffer);
    byte[] data = buffer.toByteArray();
    out.setBody(data);
}",,"public void process(Exchange exchange) throws Exception {
    ObjectHelper.notNull(dataFormat, ""dataFormat"");
    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    Message in = exchange.getIn();
    Object body = in.getBody();
            Message out = exchange.getOut();
    out.copyFrom(in);
    dataFormat.marshal(exchange, body, buffer);
    byte[] data = buffer.toByteArray();
    out.setBody(data);
}",-0.13636363636363635,-0.7551020408163265,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.1187266991683396,0.16666666666666666,0.20000000000000004,-0.16422749602751402
Closure,144,2,"FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) {
    return new FunctionType(registry, null, null, new ArrowType(registry, call.parameters, newReturnType, inferred), typeOfThis, null, false, false);
}",,"FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) {
    return new FunctionType(registry, null, null, new ArrowType(registry, call.parameters, newReturnType, inferred), typeOfThis, null, false, false);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8683682248351021,-0.5,-0.028571428571428574,-0.16422749602751402
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1008_0c20bfd8,1,"/**
 * Scans for classes starting at the package provided and descending into subpackages.
 * Each class is offered up to the Test as it is discovered, and if the Test returns
 * true the class is retained.  Accumulated classes can be fetched by calling
 * {@link #getClasses()}.
 *
 * @param test an instance of {@link Test} that will be used to filter classes
 * @param packageName the name of the package from which to start scanning for
 *        classes, e.g. {@code net.sourceforge.stripes}
 */
public void findInPackage(final Test test, String packageName) {
    packageName = packageName.replace('.', '/');
    final ClassLoader loader = getClassLoader();
    Enumeration<URL> urls;
    try {
        urls = loader.getResources(packageName);
    } catch (final IOException ioe) {
        LOGGER.warn(""Could not read package: "" + packageName, ioe);
        return;
    }
    while (urls.hasMoreElements()) {
        try {
            final URL url = urls.nextElement();
            final String urlPath = extractPath(url);
            LOGGER.info(""Scanning for classes in ["" + urlPath + ""] matching criteria: "" + test);
            // Check for a jar in a war in JBoss
            if (VFSZIP.equals(url.getProtocol())) {
                final String path = urlPath.substring(0, urlPath.length() - packageName.length() - 2);
                final URL newURL = new URL(url.getProtocol(), url.getHost(), path);
                @SuppressWarnings(""resource"")
                final JarInputStream stream = new JarInputStream(newURL.openStream());
                try {
                    loadImplementationsInJar(test, packageName, path, stream);
                } finally {
                    close(stream, newURL);
                }
            } else if (BUNDLE_RESOURCE.equals(url.getProtocol())) {
                loadImplementationsInBundle(test, packageName);
            } else {
                final File file = new File(urlPath);
                if (file.isDirectory()) {
                    loadImplementationsInDirectory(test, packageName, file);
                } else {
                    loadImplementationsInJar(test, packageName, file);
                }
            }
        } catch (final IOException ioe) {
            LOGGER.warn(""could not read entries"", ioe);
        }
    }
}","/**
 * Scans for classes starting at the package provided and descending into subpackages.
 * Each class is offered up to the Test as it is discovered, and if the Test returns
 * true the class is retained.  Accumulated classes can be fetched by calling
 * {@link #getClasses()}.
 *
 * @param test an instance of {@link Test} that will be used to filter classes
 * @param packageName the name of the package from which to start scanning for
 *        classes, e.g. {@code net.sourceforge.stripes}
 */
","public void findInPackage(final Test test, String packageName) {
    packageName = packageName.replace('.', '/');
    final ClassLoader loader = getClassLoader();
    Enumeration<URL> urls;
    try {
        urls = loader.getResources(packageName);
    } catch (final IOException ioe) {
        LOGGER.warn(""Could not read package: "" + packageName, ioe);
        return;
    }
    while (urls.hasMoreElements()) {
        try {
            final URL url = urls.nextElement();
            final String urlPath = extractPath(url);
            LOGGER.info(""Scanning for classes in ["" + urlPath + ""] matching criteria: "" + test);
                        if (VFSZIP.equals(url.getProtocol())) {
                final String path = urlPath.substring(0, urlPath.length() - packageName.length() - 2);
                final URL newURL = new URL(url.getProtocol(), url.getHost(), path);
                @SuppressWarnings(""resource"")
                final JarInputStream stream = new JarInputStream(newURL.openStream());
                try {
                    loadImplementationsInJar(test, packageName, path, stream);
                } finally {
                    close(stream, newURL);
                }
            } else if (BUNDLE_RESOURCE.equals(url.getProtocol())) {
                loadImplementationsInBundle(test, packageName);
            } else {
                final File file = new File(urlPath);
                if (file.isDirectory()) {
                    loadImplementationsInDirectory(test, packageName, file);
                } else {
                    loadImplementationsInJar(test, packageName, file);
                }
            }
        } catch (final IOException ioe) {
            LOGGER.warn(""could not read entries"", ioe);
        }
    }
}",1.1818181818181819,1.3877551020408165,0.5,1.5,0.3333333333333333,0.022738507167572957,-0.7089188414109552,1.5833333333333333,-0.028571428571428574,0.44398473537461286
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1429_c2f5ca6c,1,"@Override
public DocumentNodeState apply(String input) {
    return getNode(input, readRevision);
}",,"@Override
public DocumentNodeState apply(String input) {
    return getNode(input, readRevision);
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8850014338973328,-0.4166666666666667,1.657142857142857,-0.16422749602751402
Math,64,1,"/**
 * {@inheritDoc}
 */
@Override
protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    // arrays shared with the other private methods
    solvedCols = Math.min(rows, cols);
    diagR = new double[cols];
    jacNorm = new double[cols];
    beta = new double[cols];
    permutation = new int[cols];
    lmDir = new double[cols];
    // local point
    double delta = 0;
    double xNorm = 0;
    double[] diag = new double[cols];
    double[] oldX = new double[cols];
    double[] oldRes = new double[rows];
    double[] work1 = new double[cols];
    double[] work2 = new double[cols];
    double[] work3 = new double[cols];
    // evaluate the function at the starting point and calculate its norm
    updateResidualsAndCost();
    // outer loop
    lmPar = 0;
    boolean firstIteration = true;
    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
    while (true) {
        incrementIterationsCounter();
        // compute the Q.R. decomposition of the jacobian matrix
        VectorialPointValuePair previous = current;
        updateJacobian();
        qrDecomposition();
        // compute Qt.res
        qTy(residuals);
        // so let jacobian contain the R matrix with its diagonal elements
        for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            jacobian[k][pk] = diagR[pk];
        }
        if (firstIteration) {
            // scale the point according to the norms of the columns
            // of the initial jacobian
            xNorm = 0;
            for (int k = 0; k < cols; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * point[k];
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = Math.sqrt(xNorm);
            // initialize the step bound delta
            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }
        // check orthogonality between function vector and jacobian columns
        double maxCosine = 0;
        if (cost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += jacobian[i][pj] * residuals[i];
                    }
                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
            // convergence has been reached
            return current;
        }
        // rescale if necessary
        for (int j = 0; j < cols; ++j) {
            diag[j] = Math.max(diag[j], jacNorm[j]);
        }
        // inner loop
        for (double ratio = 0; ratio < 1.0e-4; ) {
            // save the state
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = point[pj];
            }
            double previousCost = cost;
            double[] tmpVec = residuals;
            residuals = oldRes;
            oldRes = tmpVec;
            // determine the Levenberg-Marquardt parameter
            determineLMParameter(oldRes, delta, diag, work1, work2, work3);
            // compute the new point and the norm of the evolution direction
            double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                point[pj] = oldX[pj] + lmDir[pj];
                double s = diag[pj] * lmDir[pj];
                lmNorm += s * s;
            }
            lmNorm = Math.sqrt(lmNorm);
            // on the first iteration, adjust the initial step bound.
            if (firstIteration) {
                delta = Math.min(delta, lmNorm);
            }
            // evaluate the function at x + p and calculate its norm
            updateResidualsAndCost();
            current = new VectorialPointValuePair(point, objective);
            // compute the scaled actual reduction
            double actRed = -1.0;
            if (0.1 * cost < previousCost) {
                double r = cost / previousCost;
                actRed = 1.0 - r * r;
            }
            // and the scaled directional derivative
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0; i <= j; ++i) {
                    work1[i] += jacobian[i][pj] * dirJ;
                }
            }
            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                coeff1 += work1[j] * work1[j];
            }
            double pc2 = previousCost * previousCost;
            coeff1 = coeff1 / pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);
            // ratio of the actual to the predicted reduction
            ratio = (preRed == 0) ? 0 : (actRed / preRed);
            // update the step bound
            if (ratio <= 0.25) {
                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                    tmp = 0.1;
                }
                delta = tmp * Math.min(delta, 10.0 * lmNorm);
                lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }
            // test for successful iteration.
            if (ratio >= 1.0e-4) {
                // successful iteration, update the norm
                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double xK = diag[k] * point[k];
                    xNorm += xK * xK;
                }
                xNorm = Math.sqrt(xNorm);
            // tests for convergence.
            // we use the vectorial convergence checker
            } else {
                // failed iteration, reset the previous values
                cost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    point[pj] = oldX[pj];
                }
                tmpVec = residuals;
                residuals = oldRes;
                oldRes = tmpVec;
            }
            if (checker == null) {
                if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) {
                    return current;
                }
            } else {
                if (checker.converged(getIterations(), previous, current)) {
                    return current;
                }
            }
            // (2.2204e-16 is the machine epsilon for IEEE754)
            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);
            } else if (delta <= 2.2204e-16 * xNorm) {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);
            } else if (maxCosine <= 2.2204e-16) {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);
            }
        }
    }
}","/**
 * {@inheritDoc}
 */
","@Override
protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
        solvedCols = Math.min(rows, cols);
    diagR = new double[cols];
    jacNorm = new double[cols];
    beta = new double[cols];
    permutation = new int[cols];
    lmDir = new double[cols];
        double delta = 0;
    double xNorm = 0;
    double[] diag = new double[cols];
    double[] oldX = new double[cols];
    double[] oldRes = new double[rows];
    double[] work1 = new double[cols];
    double[] work2 = new double[cols];
    double[] work3 = new double[cols];
        updateResidualsAndCost();
        lmPar = 0;
    boolean firstIteration = true;
    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
    while (true) {
        incrementIterationsCounter();
                VectorialPointValuePair previous = current;
        updateJacobian();
        qrDecomposition();
                qTy(residuals);
                for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            jacobian[k][pk] = diagR[pk];
        }
        if (firstIteration) {
                                    xNorm = 0;
            for (int k = 0; k < cols; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * point[k];
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = Math.sqrt(xNorm);
                        delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }
                double maxCosine = 0;
        if (cost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += jacobian[i][pj] * residuals[i];
                    }
                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
                        return current;
        }
                for (int j = 0; j < cols; ++j) {
            diag[j] = Math.max(diag[j], jacNorm[j]);
        }
                for (double ratio = 0; ratio < 1.0e-4; ) {
                        for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = point[pj];
            }
            double previousCost = cost;
            double[] tmpVec = residuals;
            residuals = oldRes;
            oldRes = tmpVec;
                        determineLMParameter(oldRes, delta, diag, work1, work2, work3);
                        double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                point[pj] = oldX[pj] + lmDir[pj];
                double s = diag[pj] * lmDir[pj];
                lmNorm += s * s;
            }
            lmNorm = Math.sqrt(lmNorm);
                        if (firstIteration) {
                delta = Math.min(delta, lmNorm);
            }
                        updateResidualsAndCost();
            current = new VectorialPointValuePair(point, objective);
                        double actRed = -1.0;
            if (0.1 * cost < previousCost) {
                double r = cost / previousCost;
                actRed = 1.0 - r * r;
            }
                        for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0; i <= j; ++i) {
                    work1[i] += jacobian[i][pj] * dirJ;
                }
            }
            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                coeff1 += work1[j] * work1[j];
            }
            double pc2 = previousCost * previousCost;
            coeff1 = coeff1 / pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);
                        ratio = (preRed == 0) ? 0 : (actRed / preRed);
                        if (ratio <= 0.25) {
                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                    tmp = 0.1;
                }
                delta = tmp * Math.min(delta, 10.0 * lmNorm);
                lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }
                        if (ratio >= 1.0e-4) {
                                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double xK = diag[k] * point[k];
                    xNorm += xK * xK;
                }
                xNorm = Math.sqrt(xNorm);
                                    } else {
                                cost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    point[pj] = oldX[pj];
                }
                tmpVec = residuals;
                residuals = oldRes;
                oldRes = tmpVec;
            }
            if (checker == null) {
                if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) {
                    return current;
                }
            } else {
                if (checker.converged(getIterations(), previous, current)) {
                    return current;
                }
            }
                        if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);
            } else if (delta <= 2.2204e-16 * xNorm) {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);
            } else if (maxCosine <= 2.2204e-16) {
                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);
            }
        }
    }
}",6.590909090909091,0.9438775510204083,5.666666666666667,1.5,5.25,7.0301532377656955,-1.821623171780901,1.1666666666666667,-0.028571428571428574,66.8449809620483
camel,remotes/origin/bugs-dot-jar_CAMEL-3433_e76d23b0,3,"/**
 * Returns an expression which converts the given expression to the given type the type
 * expression is evaluated to
 */
public static Expression convertToExpression(final Expression expression, final Expression type) {
    return new ExpressionAdapter() {

        public Object evaluate(Exchange exchange) {
            return expression.evaluate(exchange, type.evaluate(exchange, Object.class).getClass());
        }

        @Override
        public String toString() {
            return """" + expression + "".convertToEvaluatedType("" + type + "")"";
        }
    };
}","/**
 * Returns an expression which converts the given expression to the given type the type
 * expression is evaluated to
 */
","public static Expression convertToExpression(final Expression expression, final Expression type) {
    return new ExpressionAdapter() {

        public Object evaluate(Exchange exchange) {
            return expression.evaluate(exchange, type.evaluate(exchange, Object.class).getClass());
        }

        @Override
        public String toString() {
            return """" + expression + "".convertToEvaluatedType("" + type + "")"";
        }
    };
}",-0.13636363636363635,0.4591836734693877,-0.5,-0.5,-0.4166666666666667,-0.3806228373702422,0.1915686836822482,-0.25,0.7999999999999999,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3897_94c6c575,1,"@Nonnull
public String reset(@Nonnull String branchRevisionId, @Nonnull String ancestorRevisionId) throws DocumentStoreException {
    RevisionVector branch = RevisionVector.fromString(branchRevisionId);
    if (!branch.isBranch()) {
        throw new DocumentStoreException(""Not a branch revision: "" + branchRevisionId);
    }
    RevisionVector ancestor = RevisionVector.fromString(ancestorRevisionId);
    if (!ancestor.isBranch()) {
        throw new DocumentStoreException(""Not a branch revision: "" + ancestorRevisionId);
    }
    try {
        return nodeStore.reset(branch, ancestor, null).toString();
    } catch (DocumentStoreException e) {
        throw new DocumentStoreException(e);
    }
}",,"@Nonnull
public String reset(@Nonnull String branchRevisionId, @Nonnull String ancestorRevisionId) throws DocumentStoreException {
    RevisionVector branch = RevisionVector.fromString(branchRevisionId);
    if (!branch.isBranch()) {
        throw new DocumentStoreException(""Not a branch revision: "" + branchRevisionId);
    }
    RevisionVector ancestor = RevisionVector.fromString(ancestorRevisionId);
    if (!ancestor.isBranch()) {
        throw new DocumentStoreException(""Not a branch revision: "" + ancestorRevisionId);
    }
    try {
        return nodeStore.reset(branch, ancestor, null).toString();
    } catch (DocumentStoreException e) {
        throw new DocumentStoreException(e);
    }
}",0.09090909090909091,-0.19897959183673475,0.5,-0.5,-0.08333333333333333,0.09589718240237279,-0.09951247490679667,0.0,0.028571428571428574,0.04559685798844445
camel,remotes/origin/bugs-dot-jar_CAMEL-7586_1f92fa42,3,"@ManagedAttribute(description = ""Message History"")
Boolean getMessageHistory();",,"@ManagedAttribute(description = ""Message History"")
Boolean getMessageHistory();",-0.5454545454545454,-1.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.2899340407226842,-0.5,2.8000000000000003,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-621_00b4b8a0,1,"private boolean isDisconnected() {
    if (isRoot()) {
        return false;
    }
    if (parent.nodeBuilder == null) {
        return false;
    }
    if (!parent.nodeBuilder.isConnected()) {
        return true;
    }
    return !getNodeBuilder().isConnected();
}",,"private boolean isDisconnected() {
    if (isRoot()) {
        return false;
    }
    if (parent.nodeBuilder == null) {
        return false;
    }
    if (!parent.nodeBuilder.isConnected()) {
        return true;
    }
    return !getNodeBuilder().isConnected();
}",-0.09090909090909091,-0.2346938775510204,0.0,-0.5,0.08333333333333333,-0.10380622837370242,0.23343848580441648,-0.16666666666666666,0.28571428571428575,-0.1276849079796643
camel,remotes/origin/bugs-dot-jar_CAMEL-6593_7f8a295a,3,"/**
 * Returns some descriptive text to describe this node
 */
public String getLabel() {
    String language = getExpression();
    if (ObjectHelper.isEmpty(language)) {
        Predicate predicate = getPredicate();
        if (predicate != null) {
            return predicate.toString();
        }
        Expression expressionValue = getExpressionValue();
        if (expressionValue != null) {
            return expressionValue.toString();
        }
    } else {
        return language;
    }
    return """";
}","/**
 * Returns some descriptive text to describe this node
 */
","public String getLabel() {
    String language = getExpression();
    if (ObjectHelper.isEmpty(language)) {
        Predicate predicate = getPredicate();
        if (predicate != null) {
            return predicate.toString();
        }
        Expression expressionValue = getExpressionValue();
        if (expressionValue != null) {
            return expressionValue.toString();
        }
    } else {
        return language;
    }
    return """";
}",0.09090909090909091,0.22448979591836732,0.0,0.0,0.16666666666666666,-0.07217004448838356,-0.007456266131345144,0.0,1.2,-0.08050762160518415
Closure,155,2,"/**
 * For each node, update the block stack and reference collection
 * as appropriate.
 */
public void visit(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.NAME) {
        Var v = t.getScope().getVar(n.getString());
        if (v != null && varFilter.apply(v)) {
            addReference(t, v, new Reference(n, parent, t, blockStack.peek()));
        }
    }
    if (isBlockBoundary(n, parent)) {
        blockStack.pop();
    }
}","/**
 * For each node, update the block stack and reference collection
 * as appropriate.
 */
","public void visit(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.NAME) {
        Var v = t.getScope().getVar(n.getString());
        if (v != null && varFilter.apply(v)) {
            addReference(t, v, new Reference(n, parent, t, blockStack.peek()));
        }
    }
    if (isBlockBoundary(n, parent)) {
        blockStack.pop();
    }
}",-0.13636363636363635,0.26020408163265296,0.0,0.0,0.4166666666666667,0.24616905585763724,0.09521078290794362,0.25,0.17142857142857146,0.10961919813603677
Math,4,1,"/**
 * Get the intersection of the instance and another sub-line.
 * <p>
 * This method is related to the {@link Line#intersection(Line)
 * intersection} method in the {@link Line Line} class, but in addition
 * to compute the point along infinite lines, it also checks the point
 * lies on both sub-line ranges.
 * </p>
 * @param subLine other sub-line which may intersect instance
 * @param includeEndPoints if true, endpoints are considered to belong to
 * instance (i.e. they are closed sets) and may be returned, otherwise endpoints
 * are considered to not belong to instance (i.e. they are open sets) and intersection
 * occurring on endpoints lead to null being returned
 * @return the intersection point if there is one, null if the sub-lines don't intersect
 */
public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {
    // retrieve the underlying lines
    Line line1 = (Line) getHyperplane();
    Line line2 = (Line) subLine.getHyperplane();
    // compute the intersection on infinite line
    Vector2D v2D = line1.intersection(line2);
    // check location of point with respect to first sub-line
    Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));
    // check location of point with respect to second sub-line
    Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));
    if (includeEndPoints) {
        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;
    } else {
        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;
    }
}","/**
 * Get the intersection of the instance and another sub-line.
 * <p>
 * This method is related to the {@link Line#intersection(Line)
 * intersection} method in the {@link Line Line} class, but in addition
 * to compute the point along infinite lines, it also checks the point
 * lies on both sub-line ranges.
 * </p>
 * @param subLine other sub-line which may intersect instance
 * @param includeEndPoints if true, endpoints are considered to belong to
 * instance (i.e. they are closed sets) and may be returned, otherwise endpoints
 * are considered to not belong to instance (i.e. they are open sets) and intersection
 * occurring on endpoints lead to null being returned
 * @return the intersection point if there is one, null if the sub-lines don't intersect
 */
","public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {
        Line line1 = (Line) getHyperplane();
    Line line2 = (Line) subLine.getHyperplane();
        Vector2D v2D = line1.intersection(line2);
        Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));
        Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));
    if (includeEndPoints) {
        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;
    } else {
        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;
    }
}",-0.09090909090909091,-0.3622448979591837,0.0,-0.5,0.25,0.64755313890262,0.0014338973329508797,0.25,-0.028571428571428574,0.47909251716413753
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2999_3bf07779,1,"@Override
public void propertyChanged(PropertyState before, PropertyState after) {
    markPropertyChanged(before.getName());
    checkAggregates(before.getName());
}",,"@Override
public void propertyChanged(PropertyState before, PropertyState after) {
    markPropertyChanged(before.getName());
    checkAggregates(before.getName());
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7183825638084315,-0.16666666666666666,-0.028571428571428574,-0.16422749602751402
Cli,16,3,"public void addOption(Option option) {
    options.add(option);
    nameToOption.put(option.getPreferredName(), option);
    for (Iterator i = option.getTriggers().iterator(); i.hasNext(); ) {
        nameToOption.put(i.next(), option);
    }
// ensure that all parent options are also added
}",,"public void addOption(Option option) {
    options.add(option);
    nameToOption.put(option.getPreferredName(), option);
    for (Iterator i = option.getTriggers().iterator(); i.hasNext(); ) {
        nameToOption.put(i.next(), option);
    }
}",-0.3181818181818182,-0.2346938775510204,-0.3333333333333333,-0.5,-0.25,-0.3806228373702422,0.4232864926871235,0.16666666666666666,0.0,-0.16422749602751402
flink,remotes/origin/bugs-dot-jar_FLINK-1640_8f321c72,1,"/**
 *  Normalizes a path string.
 *
 *  @param path
 *         the path string to normalize
 *  @return the normalized path string
 */
private String normalizePath(String path) {
    // remove double slashes & backslashes
    path = path.replace(""//"", ""/"");
    path = path.replace(""\\"", ""/"");
    return path;
}","/**
 *  Normalizes a path string.
 *
 *  @param path
 *         the path string to normalize
 *  @return the normalized path string
 */
","private String normalizePath(String path) {
        path = path.replace(""//"", ""/"");
    path = path.replace(""\\"", ""/"");
    return path;
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.669916833954689,-0.3333333333333333,2.428571428571429,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-678_6c54045d,1,"@Nonnull
private MutableNodeState write(long newRevision, boolean reconnect) {
    // make sure that all revision numbers up to the root gets updated
    if (!isRoot()) {
        checkState(reconnect || exists(), ""This node has been removed"");
        parent.write(newRevision, reconnect);
    }
    if (writeState == null || revision != root.revision) {
        // root never gets here since revision == root.revision
        assert (!isRoot());
        // The builder could have been reset, need to re-get base state
        baseState = parent.getBaseState(name);
        writeState = parent.getWriteState(name);
        if (writeState == null) {
            if (exists()) {
                assert baseState != null;
                writeState = new MutableNodeState(baseState);
            } else {
                writeState = new MutableNodeState(null);
            }
            // guaranteed by called parent.write()
            assert parent.writeState != null;
            parent.writeState.nodes.put(name, writeState);
        }
    }
    revision = newRevision;
    assert classInvariants();
    assert writeState != null;
    return writeState;
}",,"@Nonnull
private MutableNodeState write(long newRevision, boolean reconnect) {
        if (!isRoot()) {
        checkState(reconnect || exists(), ""This node has been removed"");
        parent.write(newRevision, reconnect);
    }
    if (writeState == null || revision != root.revision) {
                assert (!isRoot());
                baseState = parent.getBaseState(name);
        writeState = parent.getWriteState(name);
        if (writeState == null) {
            if (exists()) {
                assert baseState != null;
                writeState = new MutableNodeState(baseState);
            } else {
                writeState = new MutableNodeState(null);
            }
                        assert parent.writeState != null;
            parent.writeState.nodes.put(name, writeState);
        }
    }
    revision = newRevision;
    assert classInvariants();
    assert writeState != null;
    return writeState;
}",0.5454545454545454,0.8826530612244898,0.16666666666666666,0.5,0.4166666666666667,-0.3806228373702422,0.07169486664754805,0.3333333333333333,-0.028571428571428574,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-4255_c250db9c,1,"/**
 *  Returns <code>true</code> if the authority is properly formatted. An authority is the
 *  combination of host name and port. A <code>null</code> authority value is considered invalid.
 *
 *  @param authority
 *             an authority value to validate
 *  @return true if authority (host name and port) is valid.
 */
protected boolean isValidAuthority(String authority) {
    if (authority == null) {
        return false;
    }
    Matcher authorityMatcher = Pattern.compile(AUTHORITY_PATTERN).matcher(authority);
    if (!authorityMatcher.matches()) {
        return false;
    }
    boolean ipV4Address = false;
    boolean hostname = false;
    // check if authority is IP address or hostname
    String hostIP = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP);
    Matcher matchIPV4Pat = Pattern.compile(IP_V4_DOMAIN_PATTERN).matcher(hostIP);
    ipV4Address = matchIPV4Pat.matches();
    if (ipV4Address) {
        // this is an IP address so check components
        for (int i = 1; i <= 4; i++) {
            String ipSegment = matchIPV4Pat.group(i);
            if (ipSegment == null || ipSegment.length() <= 0) {
                return false;
            }
            try {
                if (Integer.parseInt(ipSegment) > 255) {
                    return false;
                }
            } catch (NumberFormatException e) {
                return false;
            }
        }
    } else {
        // Domain is hostname name
        hostname = Pattern.compile(DOMAIN_PATTERN).matcher(hostIP).matches();
    }
    // rightmost hostname will never start with a digit.
    if (hostname) {
        // LOW-TECH FIX FOR VALIDATOR-202
        // TODO: Rewrite to use ArrayList and .add semantics: see
        // VALIDATOR-203
        char[] chars = hostIP.toCharArray();
        int size = 1;
        for (char ch : chars) {
            if (ch == '.') {
                size++;
            }
        }
        String[] domainSegment = new String[size];
        boolean match = true;
        int segmentCount = 0;
        int segmentLength = 0;
        while (match) {
            Matcher atomMatcher = Pattern.compile(ATOM_PATTERN).matcher(hostIP);
            match = atomMatcher.find();
            if (match) {
                domainSegment[segmentCount] = atomMatcher.group(1);
                segmentLength = domainSegment[segmentCount].length() + 1;
                hostIP = (segmentLength >= hostIP.length()) ? """" : hostIP.substring(segmentLength);
                segmentCount++;
            }
        }
        if (segmentCount > 1) {
            String topLevel = domainSegment[segmentCount - 1];
            if (topLevel.length() < 2 || topLevel.length() > 4) {
                return false;
            }
            // First letter of top level must be a alpha
            Matcher alphaMatcher = Pattern.compile(ALPHA_PATTERN).matcher(topLevel.substring(0, 1));
            if (!alphaMatcher.matches()) {
                return false;
            }
        }
    }
    if (!hostname && !ipV4Address) {
        return false;
    }
    String port = authorityMatcher.group(PARSE_AUTHORITY_PORT);
    if (port != null) {
        Matcher portMatcher = Pattern.compile(PORT_PATTERN).matcher(port);
        if (!portMatcher.matches()) {
            return false;
        }
    }
    String extra = authorityMatcher.group(PARSE_AUTHORITY_EXTRA);
    if (!isBlankOrNull(extra)) {
        return false;
    }
    return true;
}","/**
 *  Returns <code>true</code> if the authority is properly formatted. An authority is the
 *  combination of host name and port. A <code>null</code> authority value is considered invalid.
 *
 *  @param authority
 *             an authority value to validate
 *  @return true if authority (host name and port) is valid.
 */
","protected boolean isValidAuthority(String authority) {
    if (authority == null) {
        return false;
    }
    Matcher authorityMatcher = Pattern.compile(AUTHORITY_PATTERN).matcher(authority);
    if (!authorityMatcher.matches()) {
        return false;
    }
    boolean ipV4Address = false;
    boolean hostname = false;
        String hostIP = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP);
    Matcher matchIPV4Pat = Pattern.compile(IP_V4_DOMAIN_PATTERN).matcher(hostIP);
    ipV4Address = matchIPV4Pat.matches();
    if (ipV4Address) {
                for (int i = 1; i <= 4; i++) {
            String ipSegment = matchIPV4Pat.group(i);
            if (ipSegment == null || ipSegment.length() <= 0) {
                return false;
            }
            try {
                if (Integer.parseInt(ipSegment) > 255) {
                    return false;
                }
            } catch (NumberFormatException e) {
                return false;
            }
        }
    } else {
                hostname = Pattern.compile(DOMAIN_PATTERN).matcher(hostIP).matches();
    }
        if (hostname) {
                                char[] chars = hostIP.toCharArray();
        int size = 1;
        for (char ch : chars) {
            if (ch == '.') {
                size++;
            }
        }
        String[] domainSegment = new String[size];
        boolean match = true;
        int segmentCount = 0;
        int segmentLength = 0;
        while (match) {
            Matcher atomMatcher = Pattern.compile(ATOM_PATTERN).matcher(hostIP);
            match = atomMatcher.find();
            if (match) {
                domainSegment[segmentCount] = atomMatcher.group(1);
                segmentLength = domainSegment[segmentCount].length() + 1;
                hostIP = (segmentLength >= hostIP.length()) ? """" : hostIP.substring(segmentLength);
                segmentCount++;
            }
        }
        if (segmentCount > 1) {
            String topLevel = domainSegment[segmentCount - 1];
            if (topLevel.length() < 2 || topLevel.length() > 4) {
                return false;
            }
                        Matcher alphaMatcher = Pattern.compile(ALPHA_PATTERN).matcher(topLevel.substring(0, 1));
            if (!alphaMatcher.matches()) {
                return false;
            }
        }
    }
    if (!hostname && !ipV4Address) {
        return false;
    }
    String port = authorityMatcher.group(PARSE_AUTHORITY_PORT);
    if (port != null) {
        Matcher portMatcher = Pattern.compile(PORT_PATTERN).matcher(port);
        if (!portMatcher.matches()) {
            return false;
        }
    }
    String extra = authorityMatcher.group(PARSE_AUTHORITY_EXTRA);
    if (!isBlankOrNull(extra)) {
        return false;
    }
    return true;
}",2.9545454545454546,0.7653061224489793,2.8333333333333335,1.0,2.9166666666666665,3.219970341077608,-1.2205334098078582,2.25,-0.028571428571428574,10.673793584916975
flink,remotes/origin/bugs-dot-jar_FLINK-2082_0cfa43d7,3,"@Override
public void registerInputOutput() {
    this.userClassLoader = getUserCodeClassLoader();
    this.configuration = new StreamConfig(getTaskConfiguration());
    this.context = createRuntimeContext(getEnvironment().getTaskName());
    this.stateHandleProvider = getStateHandleProvider();
    outputHandler = new OutputHandler<OUT>(this);
    streamOperator = configuration.getStreamOperator(userClassLoader);
    if (streamOperator != null) {
        // IterationHead and IterationTail don't have an Operator...
        streamOperator.setup(outputHandler.getOutput(), this.context);
    }
    hasChainedOperators = !outputHandler.getChainedOperators().isEmpty();
}",,"@Override
public void registerInputOutput() {
    this.userClassLoader = getUserCodeClassLoader();
    this.configuration = new StreamConfig(getTaskConfiguration());
    this.context = createRuntimeContext(getEnvironment().getTaskName());
    this.stateHandleProvider = getStateHandleProvider();
    outputHandler = new OutputHandler<OUT>(this);
    streamOperator = configuration.getStreamOperator(userClassLoader);
    if (streamOperator != null) {
                streamOperator.setup(outputHandler.getOutput(), this.context);
    }
    hasChainedOperators = !outputHandler.getChainedOperators().isEmpty();
}",-0.045454545454545456,-0.4540816326530613,-0.3333333333333333,-0.5,-0.25,-0.12753336628769152,0.03441353599082315,0.4166666666666667,0.0,-0.056171594262488175
Lang,32,1,"/**
 * <p>
 * Registers the given object. Used by the reflection methods to avoid infinite loops.
 * </p>
 *
 * @param value
 *            The object to register.
 */
static void register(Object value) {
    getRegistry().add(new IDKey(value));
}","/**
 * <p>
 * Registers the given object. Used by the reflection methods to avoid infinite loops.
 * </p>
 *
 * @param value
 *            The object to register.
 */
","static void register(Object value) {
    getRegistry().add(new IDKey(value));
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.046171494121021,-0.3333333333333333,2.8285714285714287,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-3718_73ce9cfb,0,"public TMutation toThrift() {
    serialize();
    return new TMutation(java.nio.ByteBuffer.wrap(row), java.nio.ByteBuffer.wrap(data), ByteBufferUtil.toByteBuffers(values), entries);
}",,"public TMutation toThrift() {
    serialize();
    return new TMutation(java.nio.ByteBuffer.wrap(row), java.nio.ByteBuffer.wrap(data), ByteBufferUtil.toByteBuffers(values), entries);
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7381703470031546,-0.16666666666666666,-0.028571428571428574,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2899_31aea2ad,0,"// given a wal path, transform it to a recovery path
public static Path getRecoveryPath(VolumeManager fs, Path walPath) throws IOException {
    if (walPath.depth() >= 3 && walPath.toUri().getScheme() != null) {
        // its a fully qualified path
        String uuid = walPath.getName();
        // drop uuid
        walPath = walPath.getParent();
        // drop server
        walPath = walPath.getParent();
        if (!walPath.getName().equals(FileType.WAL.getDirectory()))
            throw new IllegalArgumentException(""Bad path "" + walPath);
        // drop wal
        walPath = walPath.getParent();
        walPath = new Path(walPath, FileType.RECOVERY.getDirectory());
        walPath = new Path(walPath, uuid);
        return walPath;
    }
    throw new IllegalArgumentException(""Bad path "" + walPath);
}",,"public static Path getRecoveryPath(VolumeManager fs, Path walPath) throws IOException {
    if (walPath.depth() >= 3 && walPath.toUri().getScheme() != null) {
                String uuid = walPath.getName();
                walPath = walPath.getParent();
                walPath = walPath.getParent();
        if (!walPath.getName().equals(FileType.WAL.getDirectory()))
            throw new IllegalArgumentException(""Bad path "" + walPath);
                walPath = walPath.getParent();
        walPath = new Path(walPath, FileType.RECOVERY.getDirectory());
        walPath = new Path(walPath, uuid);
        return walPath;
    }
    throw new IllegalArgumentException(""Bad path "" + walPath);
}",0.0,0.1326530612244897,0.16666666666666666,-0.5,0.16666666666666666,0.934256055363322,-0.0854602810438774,0.4166666666666667,-0.028571428571428574,0.7077578047035947
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7,3,"@Override
public String toString() {
    StringBuilder sb = new StringBuilder(""setTableProperty_result("");
    boolean first = true;
    sb.append(""ouch1:"");
    if (this.ouch1 == null) {
        sb.append(""null"");
    } else {
        sb.append(this.ouch1);
    }
    first = false;
    if (!first)
        sb.append("", "");
    sb.append(""ouch2:"");
    if (this.ouch2 == null) {
        sb.append(""null"");
    } else {
        sb.append(this.ouch2);
    }
    first = false;
    sb.append("")"");
    return sb.toString();
}",,"@Override
public String toString() {
    StringBuilder sb = new StringBuilder(""setTableProperty_result("");
    boolean first = true;
    sb.append(""ouch1:"");
    if (this.ouch1 == null) {
        sb.append(""null"");
    } else {
        sb.append(this.ouch1);
    }
    first = false;
    if (!first)
        sb.append("", "");
    sb.append(""ouch2:"");
    if (this.ouch2 == null) {
        sb.append(""null"");
    } else {
        sb.append(this.ouch2);
    }
    first = false;
    sb.append("")"");
    return sb.toString();
}",0.4090909090909091,-0.3520408163265306,0.0,-0.5,0.08333333333333333,0.11369253583786461,-0.26584456552910807,0.25,0.0,0.08033201845118018
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5,3,"@Override
public void read(org.apache.thrift.protocol.TProtocol prot, update_result struct) throws org.apache.thrift.TException {
    TTupleProtocol iprot = (TTupleProtocol) prot;
    BitSet incoming = iprot.readBitSet(2);
    if (incoming.get(0)) {
        struct.ouch1 = new UnknownWriter();
        struct.ouch1.read(iprot);
        struct.setOuch1IsSet(true);
    }
    if (incoming.get(1)) {
        struct.ouch2 = new MutationsRejectedException();
        struct.ouch2.read(iprot);
        struct.setOuch2IsSet(true);
    }
}",,"@Override
public void read(org.apache.thrift.protocol.TProtocol prot, update_result struct) throws org.apache.thrift.TException {
    TTupleProtocol iprot = (TTupleProtocol) prot;
    BitSet incoming = iprot.readBitSet(2);
    if (incoming.get(0)) {
        struct.ouch1 = new UnknownWriter();
        struct.ouch1.read(iprot);
        struct.setOuch1IsSet(true);
    }
    if (incoming.get(1)) {
        struct.ouch2 = new MutationsRejectedException();
        struct.ouch2.read(iprot);
        struct.setOuch2IsSet(true);
    }
}",0.045454545454545456,-0.015306122448979493,-0.16666666666666666,-0.5,-0.08333333333333333,-0.3806228373702422,-0.08115858904502435,0.08333333333333333,-0.028571428571428574,-0.16422749602751402
Closure,162,2,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (isCallToScopeMethod(n)) {
        validateScopeCall(t, n, n.getParent());
    }
    // Validate the top level of the goog.scope block.
    if (t.getScopeDepth() == 2) {
        int type = n.getType();
        if (type == Token.NAME && parent.getType() == Token.VAR) {
            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
                String name = n.getString();
                Var aliasVar = t.getScope().getVar(name);
                aliases.put(name, aliasVar);
                aliasDefinitionsInOrder.add(n);
                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();
                transformation.addAlias(name, qualifiedName);
                // twice.
                return;
            } else {
                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
            }
        }
        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {
            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());
        }
        if (type == Token.RETURN) {
            report(t, n, GOOG_SCOPE_USES_RETURN);
        } else if (type == Token.THIS) {
            report(t, n, GOOG_SCOPE_REFERENCES_THIS);
        } else if (type == Token.THROW) {
            report(t, n, GOOG_SCOPE_USES_THROW);
        }
    }
    // Validate all descendent scopes of the goog.scope block.
    if (t.getScopeDepth() >= 2) {
        // Check if this name points to an alias.
        if (n.getType() == Token.NAME) {
            String name = n.getString();
            Var aliasVar = aliases.get(name);
            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {
                // Note, to support the transitive case, it's important we don't
                // clone aliasedNode here.  For example,
                // var g = goog; var d = g.dom; d.createElement('DIV');
                // The node in aliasedNode (which is ""g"") will be replaced in the
                // changes pass above with ""goog"".  If we cloned here, we'd end up
                // with <code>g.dom.createElement('DIV')</code>.
                Node aliasedNode = aliasVar.getInitialValue();
                aliasUsages.add(new AliasedNode(n, aliasedNode));
            }
        }
        JSDocInfo info = n.getJSDocInfo();
        if (info != null) {
            for (Node node : info.getTypeNodes()) {
                fixTypeNode(node);
            }
        }
    // TODO(robbyw): Error for goog.scope not at root.
    }
}",,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (isCallToScopeMethod(n)) {
        validateScopeCall(t, n, n.getParent());
    }
        if (t.getScopeDepth() == 2) {
        int type = n.getType();
        if (type == Token.NAME && parent.getType() == Token.VAR) {
            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
                String name = n.getString();
                Var aliasVar = t.getScope().getVar(name);
                aliases.put(name, aliasVar);
                aliasDefinitionsInOrder.add(n);
                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();
                transformation.addAlias(name, qualifiedName);
                                return;
            } else {
                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
            }
        }
        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {
            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());
        }
        if (type == Token.RETURN) {
            report(t, n, GOOG_SCOPE_USES_RETURN);
        } else if (type == Token.THIS) {
            report(t, n, GOOG_SCOPE_REFERENCES_THIS);
        } else if (type == Token.THROW) {
            report(t, n, GOOG_SCOPE_USES_THROW);
        }
    }
        if (t.getScopeDepth() >= 2) {
                if (n.getType() == Token.NAME) {
            String name = n.getString();
            Var aliasVar = aliases.get(name);
            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {
                                                                                                                Node aliasedNode = aliasVar.getInitialValue();
                aliasUsages.add(new AliasedNode(n, aliasedNode));
            }
        }
        JSDocInfo info = n.getJSDocInfo();
        if (info != null) {
            for (Node node : info.getTypeNodes()) {
                fixTypeNode(node);
            }
        }
        }
}",1.5454545454545454,0.8163265306122449,1.6666666666666667,1.0,2.25,0.5981216015818094,-0.8984800688270722,2.5833333333333335,-0.028571428571428574,2.0233295214599902
camel,remotes/origin/bugs-dot-jar_CAMEL-3433_e76d23b0,3,"public Object evaluate(Exchange exchange) {
    return expression.evaluate(exchange, type.evaluate(exchange, Object.class).getClass());
}",,"public Object evaluate(Exchange exchange) {
    return expression.evaluate(exchange, type.evaluate(exchange, Object.class).getClass());
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9638657872096357,-0.25,-0.028571428571428574,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2235_29d3d8f1,3,"@Override
public void enter(NodeState before, NodeState after) throws CommitFailedException {
}",,"@Override
public void enter(NodeState before, NodeState after) throws CommitFailedException {
}",-0.5,-1.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.046171494121021,-0.5,0.31428571428571433,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-7883_d57f402b,1,"@Override
public Reader getCharacterStream() {
    InputStream is = getByteStream();
    return camelContext.getTypeConverter().convertTo(Reader.class, is);
}",,"@Override
public Reader getCharacterStream() {
    InputStream is = getByteStream();
    return camelContext.getTypeConverter().convertTo(Reader.class, is);
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7054774878118727,-0.25,0.5428571428571429,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1348_ef0f6ddc,1,"public int start() throws IOException {
    if (configError)
        return 1;
    String input;
    if (isVerbose())
        printInfo();
    String home = System.getProperty(""HOME"");
    if (home == null)
        home = System.getenv(""HOME"");
    String configDir = home + ""/.accumulo"";
    String historyPath = configDir + ""/shell_history.txt"";
    File accumuloDir = new File(configDir);
    if (!accumuloDir.exists() && !accumuloDir.mkdirs())
        log.warn(""Unable to make directory for history at "" + accumuloDir);
    try {
        History history = new History();
        history.setHistoryFile(new File(historyPath));
        reader.setHistory(history);
    } catch (IOException e) {
        log.warn(""Unable to load history file at "" + historyPath);
    }
    ShellCompletor userCompletor = null;
    if (execFile != null) {
        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));
        while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());
    } else if (execCommand != null) {
        for (String command : execCommand.split(""\n"")) {
            execCommand(command, true, isVerbose());
        }
        return exitCode;
    }
    while (true) {
        if (hasExited())
            return exitCode;
        // If tab completion is true we need to reset
        if (tabCompletion) {
            if (userCompletor != null)
                reader.removeCompletor(userCompletor);
            userCompletor = setupCompletion();
            reader.addCompletor(userCompletor);
        }
        reader.setDefaultPrompt(getDefaultPrompt());
        input = reader.readLine();
        if (input == null) {
            reader.printNewline();
            return exitCode;
        }
        // user canceled
        execCommand(input, disableAuthTimeout, false);
    }
}",,"public int start() throws IOException {
    if (configError)
        return 1;
    String input;
    if (isVerbose())
        printInfo();
    String home = System.getProperty(""HOME"");
    if (home == null)
        home = System.getenv(""HOME"");
    String configDir = home + ""/.accumulo"";
    String historyPath = configDir + ""/shell_history.txt"";
    File accumuloDir = new File(configDir);
    if (!accumuloDir.exists() && !accumuloDir.mkdirs())
        log.warn(""Unable to make directory for history at "" + accumuloDir);
    try {
        History history = new History();
        history.setHistoryFile(new File(historyPath));
        reader.setHistory(history);
    } catch (IOException e) {
        log.warn(""Unable to load history file at "" + historyPath);
    }
    ShellCompletor userCompletor = null;
    if (execFile != null) {
        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));
        while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());
    } else if (execCommand != null) {
        for (String command : execCommand.split(""\n"")) {
            execCommand(command, true, isVerbose());
        }
        return exitCode;
    }
    while (true) {
        if (hasExited())
            return exitCode;
                if (tabCompletion) {
            if (userCompletor != null)
                reader.removeCompletor(userCompletor);
            userCompletor = setupCompletion();
            reader.addCompletor(userCompletor);
        }
        reader.setDefaultPrompt(getDefaultPrompt());
        input = reader.readLine();
        if (input == null) {
            reader.printNewline();
            return exitCode;
        }
                execCommand(input, disableAuthTimeout, false);
    }
}",1.5909090909090908,0.1479591836734694,1.8333333333333333,0.5,1.6666666666666667,0.8057340583292142,-0.8844278749641529,1.6666666666666667,-0.028571428571428574,2.0024541611522997
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-509_b896c926,3,"@Override
@CheckForNull
public String getJcrName(String oakName) {
    checkNotNull(oakName);
    // hidden name
    checkArgument(!oakName.startsWith("":""));
    // expanded name
    checkArgument(isExpandedName(oakName));
    if (hasSessionLocalMappings()) {
        int colon = oakName.indexOf(':');
        if (colon > 0) {
            String oakPrefix = oakName.substring(0, colon);
            String uri = getNamespaceMap().get(oakPrefix);
            if (uri == null) {
                throw new IllegalStateException(""No namespace mapping found for "" + oakName);
            }
            Map<String, String> local = getSessionLocalMappings();
            for (Map.Entry<String, String> entry : local.entrySet()) {
                if (uri.equals(entry.getValue())) {
                    String jcrPrefix = entry.getKey();
                    if (jcrPrefix.equals(oakPrefix)) {
                        return oakName;
                    } else {
                        return jcrPrefix + oakName.substring(colon);
                    }
                }
            }
            // is no conflicting local mapping for the prefix
            if (local.containsKey(oakPrefix)) {
                for (int i = 2; true; i++) {
                    String jcrPrefix = oakPrefix + i;
                    if (!local.containsKey(jcrPrefix)) {
                        return jcrPrefix + oakName.substring(colon);
                    }
                }
            }
        }
    }
    return oakName;
}",,"@Override
@CheckForNull
public String getJcrName(String oakName) {
    checkNotNull(oakName);
        checkArgument(!oakName.startsWith("":""));
        checkArgument(isExpandedName(oakName));
    if (hasSessionLocalMappings()) {
        int colon = oakName.indexOf(':');
        if (colon > 0) {
            String oakPrefix = oakName.substring(0, colon);
            String uri = getNamespaceMap().get(oakPrefix);
            if (uri == null) {
                throw new IllegalStateException(""No namespace mapping found for "" + oakName);
            }
            Map<String, String> local = getSessionLocalMappings();
            for (Map.Entry<String, String> entry : local.entrySet()) {
                if (uri.equals(entry.getValue())) {
                    String jcrPrefix = entry.getKey();
                    if (jcrPrefix.equals(oakPrefix)) {
                        return oakName;
                    } else {
                        return jcrPrefix + oakName.substring(colon);
                    }
                }
            }
                        if (local.containsKey(oakPrefix)) {
                for (int i = 2; true; i++) {
                    String jcrPrefix = oakPrefix + i;
                    if (!local.containsKey(jcrPrefix)) {
                        return jcrPrefix + oakName.substring(colon);
                    }
                }
            }
        }
    }
    return oakName;
}",1.0454545454545454,2.1785714285714284,1.1666666666666667,1.5,1.0833333333333333,0.9975284231339596,-0.6647548035560658,1.1666666666666667,-0.028571428571428574,1.4887506906343557
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1822_3e83a4c1,1,"public static void setModified(@Nonnull UpdateOp op, @Nonnull Revision revision) {
    checkNotNull(op).set(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));
}",,"public static void setModified(@Nonnull UpdateOp op, @Nonnull Revision revision) {
    checkNotNull(op).set(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9065098938915972,-0.08333333333333333,0.14285714285714285,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-326_ce185345,1,"/**
 * {@inheritDoc}
 */
public double getNorm() {
    double res = 0;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res += iter.value() * iter.value();
    }
    return Math.sqrt(res);
}","/**
 * {@inheritDoc}
 */
","public double getNorm() {
    double res = 0;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res += iter.value() * iter.value();
    }
    return Math.sqrt(res);
}",-0.22727272727272727,-0.17857142857142863,-0.3333333333333333,-0.5,-0.25,-0.07612456747404842,0.3125896185833093,0.0,1.657142857142857,-0.10097181355228049
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443,1,"@Override
public void clearLocatorCache(String tableName) throws TableNotFoundException {
}",,"@Override
public void clearLocatorCache(String tableName) throws TableNotFoundException {
}",-0.5,-1.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.1015199311729282,-0.5,2.4571428571428573,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd,1,"/**
 * Search for a given set of values.
 *
 * @param filter the filter (used for logging)
 * @param indexName the name of the index (for logging)
 * @param indexMeta the index metadata node (may not be null)
 * @param values values to look for (null to check for property existence)
 * @return an iterator of paths
 */
Iterable<String> query(Filter filter, String indexName, NodeState indexMeta, Iterable<String> values);","/**
 * Search for a given set of values.
 *
 * @param filter the filter (used for logging)
 * @param indexName the name of the index (for logging)
 * @param indexMeta the index metadata node (may not be null)
 * @param values values to look for (null to check for property existence)
 * @return an iterator of paths
 */
","Iterable<String> query(Filter filter, String indexName, NodeState indexMeta, Iterable<String> values);",-0.5909090909090909,-1.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.459133926010898,-0.5,1.9714285714285713,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2494_0dc92ca1,1,"public double getStdDev() {
    return Math.sqrt(partialStdDev / count - getAverage() * getAverage());
}",,"public double getStdDev() {
    return Math.sqrt(partialStdDev / count - getAverage() * getAverage());
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.15521502718734553,0.9736162890737022,-0.25,2.428571428571429,-0.14634167234164666
wicket,remotes/origin/bugs-dot-jar_WICKET-4072_7d5b8645,1,"/**
 *  render full representation of url (including protocol, host and port)
 *  into string representation
 */
public String toAbsoluteString() {
    return toAbsoluteString(getCharset());
}","/**
 *  render full representation of url (including protocol, host and port)
 *  into string representation
 */
","public String toAbsoluteString() {
    return toAbsoluteString(getCharset());
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.1669056495554921,-0.3333333333333333,2.8285714285714287,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3377_00b9bc52,1,"FullTextExpression parseTerm() throws ParseException {
    if (parseIndex >= text.length()) {
        throw getSyntaxError(""term"");
    }
    boolean not = false;
    StringBuilder buff = new StringBuilder();
    char c = text.charAt(parseIndex);
    if (c == '-') {
        if (++parseIndex >= text.length()) {
            throw getSyntaxError(""term"");
        }
        not = true;
    }
    boolean escaped = false;
    String boost = null;
    if (c == '\""') {
        parseIndex++;
        while (true) {
            if (parseIndex >= text.length()) {
                throw getSyntaxError(""double quote"");
            }
            c = text.charAt(parseIndex++);
            if (c == '\\') {
                escaped = true;
                if (parseIndex >= text.length()) {
                    throw getSyntaxError(""escaped char"");
                }
                c = text.charAt(parseIndex++);
                buff.append(c);
            } else if (c == '\""') {
                if (parseIndex < text.length()) {
                    if (text.charAt(parseIndex) == '^') {
                        boost = """";
                    } else if (text.charAt(parseIndex) != ' ') {
                        throw getSyntaxError(""space"");
                    }
                }
                parseIndex++;
                break;
            } else {
                buff.append(c);
            }
        }
    } else if (c == '\'' && FullTextSearchImpl.JACKRABBIT_2_SINGLE_QUOTED_PHRASE) {
        // basically the same as double quote
        parseIndex++;
        while (true) {
            if (parseIndex >= text.length()) {
                throw getSyntaxError(""single quote"");
            }
            c = text.charAt(parseIndex++);
            if (c == '\\') {
                escaped = true;
                if (parseIndex >= text.length()) {
                    throw getSyntaxError(""escaped char"");
                }
                c = text.charAt(parseIndex++);
                buff.append(c);
            } else if (c == '\'') {
                if (parseIndex < text.length()) {
                    if (text.charAt(parseIndex) == '^') {
                        boost = """";
                    } else if (text.charAt(parseIndex) != ' ') {
                        throw getSyntaxError(""space"");
                    }
                }
                parseIndex++;
                break;
            } else {
                buff.append(c);
            }
        }
    } else {
        do {
            c = text.charAt(parseIndex++);
            if (c == '\\') {
                escaped = true;
                if (parseIndex >= text.length()) {
                    throw getSyntaxError(""escaped char"");
                }
                c = text.charAt(parseIndex++);
                buff.append(c);
            } else if (c == '^') {
                boost = """";
                break;
            } else if (c == ' ') {
                break;
            } else {
                buff.append(c);
            }
        } while (parseIndex < text.length());
    }
    if (boost != null) {
        StringBuilder b = new StringBuilder();
        while (parseIndex < text.length()) {
            c = text.charAt(parseIndex++);
            if ((c < '0' || c > '9') && c != '.') {
                break;
            }
            b.append(c);
        }
        boost = b.toString();
    }
    if (buff.length() == 0) {
        throw getSyntaxError(""term"");
    }
    String text = buff.toString();
    FullTextTerm term = new FullTextTerm(propertyName, text, not, escaped, boost);
    return term.simplify();
}",,"FullTextExpression parseTerm() throws ParseException {
    if (parseIndex >= text.length()) {
        throw getSyntaxError(""term"");
    }
    boolean not = false;
    StringBuilder buff = new StringBuilder();
    char c = text.charAt(parseIndex);
    if (c == '-') {
        if (++parseIndex >= text.length()) {
            throw getSyntaxError(""term"");
        }
        not = true;
    }
    boolean escaped = false;
    String boost = null;
    if (c == '\""') {
        parseIndex++;
        while (true) {
            if (parseIndex >= text.length()) {
                throw getSyntaxError(""double quote"");
            }
            c = text.charAt(parseIndex++);
            if (c == '\\') {
                escaped = true;
                if (parseIndex >= text.length()) {
                    throw getSyntaxError(""escaped char"");
                }
                c = text.charAt(parseIndex++);
                buff.append(c);
            } else if (c == '\""') {
                if (parseIndex < text.length()) {
                    if (text.charAt(parseIndex) == '^') {
                        boost = """";
                    } else if (text.charAt(parseIndex) != ' ') {
                        throw getSyntaxError(""space"");
                    }
                }
                parseIndex++;
                break;
            } else {
                buff.append(c);
            }
        }
    } else if (c == '\'' && FullTextSearchImpl.JACKRABBIT_2_SINGLE_QUOTED_PHRASE) {
                parseIndex++;
        while (true) {
            if (parseIndex >= text.length()) {
                throw getSyntaxError(""single quote"");
            }
            c = text.charAt(parseIndex++);
            if (c == '\\') {
                escaped = true;
                if (parseIndex >= text.length()) {
                    throw getSyntaxError(""escaped char"");
                }
                c = text.charAt(parseIndex++);
                buff.append(c);
            } else if (c == '\'') {
                if (parseIndex < text.length()) {
                    if (text.charAt(parseIndex) == '^') {
                        boost = """";
                    } else if (text.charAt(parseIndex) != ' ') {
                        throw getSyntaxError(""space"");
                    }
                }
                parseIndex++;
                break;
            } else {
                buff.append(c);
            }
        }
    } else {
        do {
            c = text.charAt(parseIndex++);
            if (c == '\\') {
                escaped = true;
                if (parseIndex >= text.length()) {
                    throw getSyntaxError(""escaped char"");
                }
                c = text.charAt(parseIndex++);
                buff.append(c);
            } else if (c == '^') {
                boost = """";
                break;
            } else if (c == ' ') {
                break;
            } else {
                buff.append(c);
            }
        } while (parseIndex < text.length());
    }
    if (boost != null) {
        StringBuilder b = new StringBuilder();
        while (parseIndex < text.length()) {
            c = text.charAt(parseIndex++);
            if ((c < '0' || c > '9') && c != '.') {
                break;
            }
            b.append(c);
        }
        boost = b.toString();
    }
    if (buff.length() == 0) {
        throw getSyntaxError(""term"");
    }
    String text = buff.toString();
    FullTextTerm term = new FullTextTerm(propertyName, text, not, escaped, boost);
    return term.simplify();
}",4.318181818181818,1.3520408163265305,7.0,3.0,2.8333333333333335,3.554127533366288,-1.5531975910524811,3.1666666666666665,-0.028571428571428574,13.231119448691757
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-193_c831e44d,3,"public String toStringNoTime() {
    String labelString = new ColumnVisibility(colVisibility).toString();
    String s = new String(row, 0, row.length) + "" "" + new String(colFamily, 0, colFamily.length) + "":"" + new String(colQualifier, 0, colQualifier.length) + "" "" + labelString;
    return s;
}",,"public String toStringNoTime() {
    String labelString = new ColumnVisibility(colVisibility).toString();
    String s = new String(row, 0, row.length) + "" "" + new String(colFamily, 0, colFamily.length) + "":"" + new String(colQualifier, 0, colQualifier.length) + "" "" + labelString;
    return s;
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,0.01482946119624324,0.5414396329222828,-0.4166666666666667,-0.028571428571428574,-0.04868490369666055
wicket,remotes/origin/bugs-dot-jar_WICKET-5712_145da021,3,"@Override
protected UrlInfo parseRequest(Request request) {
    if (matches(request)) {
        Url url = request.getUrl();
        // try to extract page and component information from URL
        PageComponentInfo info = getPageComponentInfo(url);
        List<String> segments = url.getSegments();
        // load the page class
        String className;
        if (segments.size() >= 3) {
            className = segments.get(2);
        } else {
            className = segments.get(1);
        }
        Class<? extends IRequestablePage> pageClass = getPageClass(className);
        if (pageClass != null && IRequestablePage.class.isAssignableFrom(pageClass)) {
            if (Application.exists()) {
                Application application = Application.get();
                if (application.getSecuritySettings().getEnforceMounts()) {
                    // we make an exception if the homepage itself was mounted, see WICKET-1898
                    if (!pageClass.equals(application.getHomePage())) {
                        // WICKET-5094 only enforce mount if page is mounted
                        if (isPageMounted(pageClass, application)) {
                            return null;
                        }
                    }
                }
            }
            // extract the PageParameters from URL if there are any
            PageParameters pageParameters = extractPageParameters(request, 3, pageParametersEncoder);
            return new UrlInfo(info, pageClass, pageParameters);
        }
    }
    return null;
}",,"@Override
protected UrlInfo parseRequest(Request request) {
    if (matches(request)) {
        Url url = request.getUrl();
                PageComponentInfo info = getPageComponentInfo(url);
        List<String> segments = url.getSegments();
                String className;
        if (segments.size() >= 3) {
            className = segments.get(2);
        } else {
            className = segments.get(1);
        }
        Class<? extends IRequestablePage> pageClass = getPageClass(className);
        if (pageClass != null && IRequestablePage.class.isAssignableFrom(pageClass)) {
            if (Application.exists()) {
                Application application = Application.get();
                if (application.getSecuritySettings().getEnforceMounts()) {
                                        if (!pageClass.equals(application.getHomePage())) {
                                                if (isPageMounted(pageClass, application)) {
                            return null;
                        }
                    }
                }
            }
                        PageParameters pageParameters = extractPageParameters(request, 3, pageParametersEncoder);
            return new UrlInfo(info, pageClass, pageParameters);
        }
    }
    return null;
}",0.7272727272727273,2.0306122448979593,0.6666666666666666,2.0,1.1666666666666667,0.3133959466139397,-0.5213650702609697,0.9166666666666666,-0.028571428571428574,0.5337265130781519
Closure,20,2,"private Node tryFoldSimpleFunctionCall(Node n) {
    Preconditions.checkState(n.isCall());
    Node callTarget = n.getFirstChild();
    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(""String"")) {
        // Fold String(a) to '' + (a) on immutable literals,
        // which allows further optimizations
        // 
        // We can't do this in the general case, because String(a) has
        // slightly different semantics than '' + (a). See
        // http://code.google.com/p/closure-compiler/issues/detail?id=759
        Node value = callTarget.getNext();
        if (value != null) {
            Node addition = IR.add(IR.string("""").srcref(callTarget), value.detachFromParent());
            n.getParent().replaceChild(n, addition);
            reportCodeChange();
            return addition;
        }
    }
    return n;
}",,"private Node tryFoldSimpleFunctionCall(Node n) {
    Preconditions.checkState(n.isCall());
    Node callTarget = n.getFirstChild();
    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(""String"")) {
                                                        Node value = callTarget.getNext();
        if (value != null) {
            Node addition = IR.add(IR.string("""").srcref(callTarget), value.detachFromParent());
            n.getParent().replaceChild(n, addition);
            reportCodeChange();
            return addition;
        }
    }
    return n;
}",0.0,0.586734693877551,-0.16666666666666666,0.0,0.25,-0.030647553138902585,-0.04645827358761127,0.6666666666666666,0.17142857142857146,0.030876174078404657
Math,6,1,"/**
 * {@inheritDoc}
 */
@Override
public PointVectorValuePair doOptimize() {
    checkParameters();
    final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();
    // Computation will be useless without a checker (see ""for-loop"").
    if (checker == null) {
        throw new NullArgumentException();
    }
    final double[] targetValues = getTarget();
    // Number of observed data.
    final int nR = targetValues.length;
    final RealMatrix weightMatrix = getWeight();
    // Diagonal of the weight matrix.
    final double[] residualsWeights = new double[nR];
    for (int i = 0; i < nR; i++) {
        residualsWeights[i] = weightMatrix.getEntry(i, i);
    }
    final double[] currentPoint = getStartPoint();
    final int nC = currentPoint.length;
    // iterate until convergence is reached
    PointVectorValuePair current = null;
    int iter = 0;
    for (boolean converged = false; !converged; ) {
        ++iter;
        // evaluate the objective function and its jacobian
        PointVectorValuePair previous = current;
        // Value of the objective function at ""currentPoint"".
        final double[] currentObjective = computeObjectiveValue(currentPoint);
        final double[] currentResiduals = computeResiduals(currentObjective);
        final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);
        current = new PointVectorValuePair(currentPoint, currentObjective);
        // build the linear problem
        final double[] b = new double[nC];
        final double[][] a = new double[nC][nC];
        for (int i = 0; i < nR; ++i) {
            final double[] grad = weightedJacobian.getRow(i);
            final double weight = residualsWeights[i];
            final double residual = currentResiduals[i];
            // compute the normal equation
            final double wr = weight * residual;
            for (int j = 0; j < nC; ++j) {
                b[j] += wr * grad[j];
            }
            // build the contribution matrix for measurement i
            for (int k = 0; k < nC; ++k) {
                double[] ak = a[k];
                double wgk = weight * grad[k];
                for (int l = 0; l < nC; ++l) {
                    ak[l] += wgk * grad[l];
                }
            }
        }
        try {
            // solve the linearized least squares problem
            RealMatrix mA = new BlockRealMatrix(a);
            DecompositionSolver solver = useLU ? new LUDecomposition(mA).getSolver() : new QRDecomposition(mA).getSolver();
            final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();
            // update the estimated parameters
            for (int i = 0; i < nC; ++i) {
                currentPoint[i] += dX[i];
            }
        } catch (SingularMatrixException e) {
            throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);
        }
        // Check convergence.
        if (previous != null) {
            converged = checker.converged(iter, previous, current);
            if (converged) {
                setCost(computeCost(currentResiduals));
                return current;
            }
        }
    }
    // Must never happen.
    throw new MathInternalError();
}","/**
 * {@inheritDoc}
 */
","@Override
public PointVectorValuePair doOptimize() {
    checkParameters();
    final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();
        if (checker == null) {
        throw new NullArgumentException();
    }
    final double[] targetValues = getTarget();
        final int nR = targetValues.length;
    final RealMatrix weightMatrix = getWeight();
        final double[] residualsWeights = new double[nR];
    for (int i = 0; i < nR; i++) {
        residualsWeights[i] = weightMatrix.getEntry(i, i);
    }
    final double[] currentPoint = getStartPoint();
    final int nC = currentPoint.length;
        PointVectorValuePair current = null;
    int iter = 0;
    for (boolean converged = false; !converged; ) {
        ++iter;
                PointVectorValuePair previous = current;
                final double[] currentObjective = computeObjectiveValue(currentPoint);
        final double[] currentResiduals = computeResiduals(currentObjective);
        final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);
        current = new PointVectorValuePair(currentPoint, currentObjective);
                final double[] b = new double[nC];
        final double[][] a = new double[nC][nC];
        for (int i = 0; i < nR; ++i) {
            final double[] grad = weightedJacobian.getRow(i);
            final double weight = residualsWeights[i];
            final double residual = currentResiduals[i];
                        final double wr = weight * residual;
            for (int j = 0; j < nC; ++j) {
                b[j] += wr * grad[j];
            }
                        for (int k = 0; k < nC; ++k) {
                double[] ak = a[k];
                double wgk = weight * grad[k];
                for (int l = 0; l < nC; ++l) {
                    ak[l] += wgk * grad[l];
                }
            }
        }
        try {
                        RealMatrix mA = new BlockRealMatrix(a);
            DecompositionSolver solver = useLU ? new LUDecomposition(mA).getSolver() : new QRDecomposition(mA).getSolver();
            final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();
                        for (int i = 0; i < nC; ++i) {
                currentPoint[i] += dX[i];
            }
        } catch (SingularMatrixException e) {
            throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);
        }
                if (previous != null) {
            converged = checker.converged(iter, previous, current);
            if (converged) {
                setCost(computeCost(currentResiduals));
                return current;
            }
        }
    }
        throw new MathInternalError();
}",2.227272727272727,0.8214285714285714,2.0,1.0,1.3333333333333333,1.5907068709836882,-1.082879265844566,0.9166666666666666,-0.028571428571428574,5.793816199176806
flink,remotes/origin/bugs-dot-jar_FLINK-3107_937963e3,1,"/**
 *  Resets the state of {@link Execution} instances back to the state of a savepoint.
 *
 *  <p>The execution vertices need to be in state {@link ExecutionState#CREATED} when calling
 *  this method. The operation might block. Make sure that calls don't block the job manager
 *  actor.
 *
 *  @param tasks         Tasks that will possibly be reset
 *  @param savepointPath The path of the savepoint to rollback to
 *  @return The application ID of the rolled back savepoint
 *  @throws IllegalStateException If coordinator is shut down
 *  @throws IllegalStateException If mismatch between program and savepoint state
 *  @throws Exception             If savepoint store failure
 */
public ApplicationID restoreSavepoint(Map<JobVertexID, ExecutionJobVertex> tasks, String savepointPath) throws Exception {
    checkNotNull(savepointPath, ""Savepoint path"");
    synchronized (lock) {
        if (isShutdown()) {
            throw new IllegalStateException(""CheckpointCoordinator is shut down"");
        }
        long recoveryTimestamp = System.currentTimeMillis();
        LOG.info(""Rolling back to savepoint '{}'."", savepointPath);
        Savepoint savepoint = savepointStore.getState(savepointPath);
        CompletedCheckpoint checkpoint = savepoint.getCompletedCheckpoint();
        LOG.info(""Savepoint: {}@{}"", checkpoint.getCheckpointID(), checkpoint.getTimestamp());
        // Set the initial state of all tasks
        LOG.debug(""Rolling back individual operators."");
        for (StateForTask state : checkpoint.getStates()) {
            LOG.debug(""Rolling back subtask {} of operator {}."", state.getSubtask(), state.getOperatorId());
            ExecutionJobVertex vertex = tasks.get(state.getOperatorId());
            if (vertex == null) {
                String msg = String.format(""Failed to rollback to savepoint %s. "" + ""Cannot map old state for task %s to the new program. "" + ""This indicates that the program has been changed in a "" + ""non-compatible way  after the savepoint."", savepoint, state.getOperatorId());
                throw new IllegalStateException(msg);
            }
            if (state.getSubtask() >= vertex.getParallelism()) {
                String msg = String.format(""Failed to rollback to savepoint %s. "" + ""Parallelism mismatch between savepoint state and new program. "" + ""Cannot map subtask %d of operator %s to new program with "" + ""parallelism %d. This indicates that the program has been changed "" + ""in a non-compatible way after the savepoint."", savepoint, state.getSubtask(), state.getOperatorId(), vertex.getParallelism());
                throw new IllegalStateException(msg);
            }
            Execution exec = vertex.getTaskVertices()[state.getSubtask()].getCurrentExecutionAttempt();
            exec.setInitialState(state.getState(), recoveryTimestamp);
        }
        // Reset the checkpoint ID counter
        long nextCheckpointId = checkpoint.getCheckpointID();
        checkpointIdCounter.setCount(nextCheckpointId + 1);
        LOG.info(""Reset the checkpoint ID to {}"", nextCheckpointId);
        this.appId = savepoint.getApplicationId();
        LOG.info(""Reset the application ID to {}"", appId);
        return appId;
    }
}","/**
 *  Resets the state of {@link Execution} instances back to the state of a savepoint.
 *
 *  <p>The execution vertices need to be in state {@link ExecutionState#CREATED} when calling
 *  this method. The operation might block. Make sure that calls don't block the job manager
 *  actor.
 *
 *  @param tasks         Tasks that will possibly be reset
 *  @param savepointPath The path of the savepoint to rollback to
 *  @return The application ID of the rolled back savepoint
 *  @throws IllegalStateException If coordinator is shut down
 *  @throws IllegalStateException If mismatch between program and savepoint state
 *  @throws Exception             If savepoint store failure
 */
","public ApplicationID restoreSavepoint(Map<JobVertexID, ExecutionJobVertex> tasks, String savepointPath) throws Exception {
    checkNotNull(savepointPath, ""Savepoint path"");
    synchronized (lock) {
        if (isShutdown()) {
            throw new IllegalStateException(""CheckpointCoordinator is shut down"");
        }
        long recoveryTimestamp = System.currentTimeMillis();
        LOG.info(""Rolling back to savepoint '{}'."", savepointPath);
        Savepoint savepoint = savepointStore.getState(savepointPath);
        CompletedCheckpoint checkpoint = savepoint.getCompletedCheckpoint();
        LOG.info(""Savepoint: {}@{}"", checkpoint.getCheckpointID(), checkpoint.getTimestamp());
                LOG.debug(""Rolling back individual operators."");
        for (StateForTask state : checkpoint.getStates()) {
            LOG.debug(""Rolling back subtask {} of operator {}."", state.getSubtask(), state.getOperatorId());
            ExecutionJobVertex vertex = tasks.get(state.getOperatorId());
            if (vertex == null) {
                String msg = String.format(""Failed to rollback to savepoint %s. "" + ""Cannot map old state for task %s to the new program. "" + ""This indicates that the program has been changed in a "" + ""non-compatible way  after the savepoint."", savepoint, state.getOperatorId());
                throw new IllegalStateException(msg);
            }
            if (state.getSubtask() >= vertex.getParallelism()) {
                String msg = String.format(""Failed to rollback to savepoint %s. "" + ""Parallelism mismatch between savepoint state and new program. "" + ""Cannot map subtask %d of operator %s to new program with "" + ""parallelism %d. This indicates that the program has been changed "" + ""in a non-compatible way after the savepoint."", savepoint, state.getSubtask(), state.getOperatorId(), vertex.getParallelism());
                throw new IllegalStateException(msg);
            }
            Execution exec = vertex.getTaskVertices()[state.getSubtask()].getCurrentExecutionAttempt();
            exec.setInitialState(state.getState(), recoveryTimestamp);
        }
                long nextCheckpointId = checkpoint.getCheckpointID();
        checkpointIdCounter.setCount(nextCheckpointId + 1);
        LOG.info(""Reset the checkpoint ID to {}"", nextCheckpointId);
        this.appId = savepoint.getApplicationId();
        LOG.info(""Reset the application ID to {}"", appId);
        return appId;
    }
}",0.9090909090909091,0.4693877551020408,0.6666666666666666,0.5,0.16666666666666666,0.374691052891745,-0.6736449670203618,2.3333333333333335,-0.028571428571428574,1.2648609522830552
Closure,114,2,"private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
    Node nameNode = n.getFirstChild();
    Node parent = n.getParent();
    NameInformation ns = createNameInformation(t, nameNode);
    if (ns != null) {
        if (parent.isFor() && !NodeUtil.isForIn(parent)) {
            // logic.
            if (parent.getFirstChild().getNext() != n) {
                recordDepScope(recordNode, ns);
            } else {
                recordDepScope(nameNode, ns);
            }
        } else {
            // The rhs of the assignment is the caller, so it's used by the
            // context. Don't associate it w/ the lhs.
            // FYI: this fixes only the specific case where the assignment is the
            // caller expression, but it could be nested deeper in the caller and
            // we would still get a bug.
            // See testAssignWithCall2 for an example of this.
            recordDepScope(recordNode, ns);
        }
    }
}",,"private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
    Node nameNode = n.getFirstChild();
    Node parent = n.getParent();
    NameInformation ns = createNameInformation(t, nameNode);
    if (ns != null) {
        if (parent.isFor() && !NodeUtil.isForIn(parent)) {
                        if (parent.getFirstChild().getNext() != n) {
                recordDepScope(recordNode, ns);
            } else {
                recordDepScope(nameNode, ns);
            }
        } else {
                                                                                    recordDepScope(recordNode, ns);
        }
    }
}",0.09090909090909091,1.0051020408163267,0.0,0.5,0.4166666666666667,0.4300543746910529,-0.09148264984227125,0.3333333333333333,-0.028571428571428574,0.2222364989014096
flink,remotes/origin/bugs-dot-jar_FLINK-1133_27e40205,1,"private <IN1, IN2> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> returnTypeHierarchy, TypeInformation<IN1> in1TypeInfo, TypeInformation<IN2> in2TypeInfo) {
    Type matReturnTypeVar = materializeTypeVariable(returnTypeHierarchy, returnTypeVar);
    // variable could be resolved
    if (!(matReturnTypeVar instanceof TypeVariable)) {
        return createTypeInfoWithTypeHierarchy(returnTypeHierarchy, matReturnTypeVar, in1TypeInfo, in2TypeInfo);
    } else {
        returnTypeVar = (TypeVariable<?>) matReturnTypeVar;
    }
    TypeInformation<?> info = null;
    if (in1TypeInfo != null) {
        // find the deepest type variable that describes the type of input 1
        ParameterizedType baseClass = (ParameterizedType) returnTypeHierarchy.get(returnTypeHierarchy.size() - 1);
        Type in1Type = baseClass.getActualTypeArguments()[0];
        if (in1Type instanceof TypeVariable) {
            in1Type = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) in1Type);
            info = findCorrespondingInfo(returnTypeVar, in1Type, in1TypeInfo);
        }
    }
    if (info == null && in2TypeInfo != null) {
        // find the deepest type variable that describes the type of input 2
        ParameterizedType baseClass = (ParameterizedType) returnTypeHierarchy.get(returnTypeHierarchy.size() - 1);
        Type in2Type = baseClass.getActualTypeArguments()[1];
        if (in2Type instanceof TypeVariable) {
            in2Type = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) in2Type);
            info = findCorrespondingInfo(returnTypeVar, in2Type, in2TypeInfo);
        }
    }
    if (info != null) {
        return info;
    }
    return null;
}",,"private <IN1, IN2> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> returnTypeHierarchy, TypeInformation<IN1> in1TypeInfo, TypeInformation<IN2> in2TypeInfo) {
    Type matReturnTypeVar = materializeTypeVariable(returnTypeHierarchy, returnTypeVar);
        if (!(matReturnTypeVar instanceof TypeVariable)) {
        return createTypeInfoWithTypeHierarchy(returnTypeHierarchy, matReturnTypeVar, in1TypeInfo, in2TypeInfo);
    } else {
        returnTypeVar = (TypeVariable<?>) matReturnTypeVar;
    }
    TypeInformation<?> info = null;
    if (in1TypeInfo != null) {
                ParameterizedType baseClass = (ParameterizedType) returnTypeHierarchy.get(returnTypeHierarchy.size() - 1);
        Type in1Type = baseClass.getActualTypeArguments()[0];
        if (in1Type instanceof TypeVariable) {
            in1Type = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) in1Type);
            info = findCorrespondingInfo(returnTypeVar, in1Type, in1TypeInfo);
        }
    }
    if (info == null && in2TypeInfo != null) {
                ParameterizedType baseClass = (ParameterizedType) returnTypeHierarchy.get(returnTypeHierarchy.size() - 1);
        Type in2Type = baseClass.getActualTypeArguments()[1];
        if (in2Type instanceof TypeVariable) {
            in2Type = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) in2Type);
            info = findCorrespondingInfo(returnTypeVar, in2Type, in2TypeInfo);
        }
    }
    if (info != null) {
        return info;
    }
    return null;
}",0.6818181818181818,0.11224489795918377,0.5,0.0,0.6666666666666666,1.683638161146812,-0.529681674792085,0.5,-0.028571428571428574,2.3856630732265156
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-3897_699b8bf0,3,"@Override
public long isReady(long tid, Master master) throws Exception {
    // suppress assignment of tablets to the server
    if (force) {
        return 0;
    }
    // only send this request once
    if (!requestedShutdown) {
        master.shutdownTServer(server);
    }
    if (master.onlineTabletServers().contains(server)) {
        TServerConnection connection = master.getConnection(server);
        if (connection != null) {
            try {
                TabletServerStatus status = connection.getTableMap(false);
                if (status.tableMap != null && status.tableMap.isEmpty()) {
                    log.info(""tablet server hosts no tablets "" + server);
                    connection.halt(master.getMasterLock());
                    log.info(""tablet server asked to halt "" + server);
                    return 0;
                }
            } catch (TTransportException ex) {
            // expected
            } catch (Exception ex) {
                log.error(""Error talking to tablet server "" + server + "": "" + ex);
            }
            // tserver to ack the request and stop itself.
            return 1000;
        }
    }
    return 0;
}",,"@Override
public long isReady(long tid, Master master) throws Exception {
        if (force) {
        return 0;
    }
        if (!requestedShutdown) {
        master.shutdownTServer(server);
    }
    if (master.onlineTabletServers().contains(server)) {
        TServerConnection connection = master.getConnection(server);
        if (connection != null) {
            try {
                TabletServerStatus status = connection.getTableMap(false);
                if (status.tableMap != null && status.tableMap.isEmpty()) {
                    log.info(""tablet server hosts no tablets "" + server);
                    connection.halt(master.getMasterLock());
                    log.info(""tablet server asked to halt "" + server);
                    return 0;
                }
            } catch (TTransportException ex) {
                        } catch (Exception ex) {
                log.error(""Error talking to tablet server "" + server + "": "" + ex);
            }
                        return 1000;
        }
    }
    return 0;
}",0.6363636363636364,1.7040816326530615,0.6666666666666666,1.0,0.6666666666666666,0.2778052397429561,-0.4554057929452251,0.4166666666666667,-0.028571428571428574,0.36354135882577165
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1429_c2f5ca6c,1,"// ------------------------------< internal >--------------------------------
private boolean dispatch(@Nonnull String jsonDiff, @Nonnull DocumentNodeState base, @Nonnull NodeStateDiff diff) {
    if (!AbstractNodeState.comparePropertiesAgainstBaseState(this, base, diff)) {
        return false;
    }
    if (jsonDiff.trim().isEmpty()) {
        return true;
    }
    JsopTokenizer t = new JsopTokenizer(jsonDiff);
    boolean continueComparison = true;
    while (continueComparison) {
        int r = t.read();
        if (r == JsopReader.END) {
            break;
        }
        switch(r) {
            case '+':
                {
                    String path = t.readString();
                    t.read(':');
                    t.read('{');
                    while (t.read() != '}') {
                    // skip properties
                    }
                    String name = PathUtils.getName(path);
                    continueComparison = diff.childNodeAdded(name, getChildNode(name));
                    break;
                }
            case '-':
                {
                    String path = t.readString();
                    String name = PathUtils.getName(path);
                    continueComparison = diff.childNodeDeleted(name, base.getChildNode(name));
                    break;
                }
            case '^':
                {
                    String path = t.readString();
                    t.read(':');
                    if (t.matches('{')) {
                        t.read('}');
                        String name = PathUtils.getName(path);
                        continueComparison = diff.childNodeChanged(name, base.getChildNode(name), getChildNode(name));
                    } else if (t.matches('[')) {
                        // ignore multi valued property
                        while (t.read() != ']') {
                        // skip values
                        }
                    } else {
                        // ignore single valued property
                        t.read();
                    }
                    break;
                }
            case '>':
                {
                    String from = t.readString();
                    t.read(':');
                    String to = t.readString();
                    String fromName = PathUtils.getName(from);
                    continueComparison = diff.childNodeDeleted(fromName, base.getChildNode(fromName));
                    if (!continueComparison) {
                        break;
                    }
                    String toName = PathUtils.getName(to);
                    continueComparison = diff.childNodeAdded(toName, getChildNode(toName));
                    break;
                }
            default:
                throw new IllegalArgumentException(""jsonDiff: illegal token '"" + t.getToken() + ""' at pos: "" + t.getLastPos() + ' ' + jsonDiff);
        }
    }
    return continueComparison;
}",,"private boolean dispatch(@Nonnull String jsonDiff, @Nonnull DocumentNodeState base, @Nonnull NodeStateDiff diff) {
    if (!AbstractNodeState.comparePropertiesAgainstBaseState(this, base, diff)) {
        return false;
    }
    if (jsonDiff.trim().isEmpty()) {
        return true;
    }
    JsopTokenizer t = new JsopTokenizer(jsonDiff);
    boolean continueComparison = true;
    while (continueComparison) {
        int r = t.read();
        if (r == JsopReader.END) {
            break;
        }
        switch(r) {
            case '+':
                {
                    String path = t.readString();
                    t.read(':');
                    t.read('{');
                    while (t.read() != '}') {
                                        }
                    String name = PathUtils.getName(path);
                    continueComparison = diff.childNodeAdded(name, getChildNode(name));
                    break;
                }
            case '-':
                {
                    String path = t.readString();
                    String name = PathUtils.getName(path);
                    continueComparison = diff.childNodeDeleted(name, base.getChildNode(name));
                    break;
                }
            case '^':
                {
                    String path = t.readString();
                    t.read(':');
                    if (t.matches('{')) {
                        t.read('}');
                        String name = PathUtils.getName(path);
                        continueComparison = diff.childNodeChanged(name, base.getChildNode(name), getChildNode(name));
                    } else if (t.matches('[')) {
                                                while (t.read() != ']') {
                                                }
                    } else {
                                                t.read();
                    }
                    break;
                }
            case '>':
                {
                    String from = t.readString();
                    t.read(':');
                    String to = t.readString();
                    String fromName = PathUtils.getName(from);
                    continueComparison = diff.childNodeDeleted(fromName, base.getChildNode(fromName));
                    if (!continueComparison) {
                        break;
                    }
                    String toName = PathUtils.getName(to);
                    continueComparison = diff.childNodeAdded(toName, getChildNode(toName));
                    break;
                }
            default:
                throw new IllegalArgumentException(""jsonDiff: illegal token '"" + t.getToken() + ""' at pos: "" + t.getLastPos() + ' ' + jsonDiff);
        }
    }
    return continueComparison;
}",2.5,1.9489795918367347,3.0,2.0,1.4166666666666667,0.8452792881858627,-1.123315170633783,2.5833333333333335,-0.028571428571428574,2.640655984855299
wicket,remotes/origin/bugs-dot-jar_WICKET-5916_def03add,1,"/**
 *  @see org.apache.wicket.model.IModel#getObject()
 */
@Override
public final T getObject() {
    if (!attached) {
        transientModelObject = load();
        if (log.isDebugEnabled()) {
            log.debug(""loaded transient object "" + transientModelObject + "" for "" + this + "", requestCycle "" + RequestCycle.get());
        }
        attached = true;
        onAttach();
    }
    return transientModelObject;
}","/**
 *  @see org.apache.wicket.model.IModel#getObject()
 */
","@Override
public final T getObject() {
    if (!attached) {
        transientModelObject = load();
        if (log.isDebugEnabled()) {
            log.debug(""loaded transient object "" + transientModelObject + "" for "" + this + "", requestCycle "" + RequestCycle.get());
        }
        attached = true;
        onAttach();
    }
    return transientModelObject;
}",-0.09090909090909091,0.3826530612244898,-0.16666666666666666,0.0,-0.08333333333333333,-0.13544241225902123,0.15486091195870355,-0.08333333333333333,1.2857142857142858,-0.10706224489358877
maven,remotes/origin/bugs-dot-jar_MNG-5727_ce6f0bfd,1,"// DefaultProjectBuilder
public Artifact createDependencyArtifact(Dependency d) {
    VersionRange versionRange;
    try {
        versionRange = VersionRange.createFromVersionSpec(d.getVersion());
    } catch (InvalidVersionSpecificationException e) {
        return null;
    }
    Artifact artifact = XcreateDependencyArtifact(d.getGroupId(), d.getArtifactId(), versionRange, d.getType(), d.getClassifier(), d.getScope(), d.isOptional());
    if (Artifact.SCOPE_SYSTEM.equals(d.getScope()) && d.getSystemPath() != null) {
        artifact.setFile(new File(d.getSystemPath()));
    }
    if (!d.getExclusions().isEmpty()) {
        List<String> exclusions = new ArrayList<String>();
        for (Exclusion exclusion : d.getExclusions()) {
            exclusions.add(exclusion.getGroupId() + ':' + exclusion.getArtifactId());
        }
        artifact.setDependencyFilter(new ExcludesArtifactFilter(exclusions));
    }
    return artifact;
}",,"public Artifact createDependencyArtifact(Dependency d) {
    VersionRange versionRange;
    try {
        versionRange = VersionRange.createFromVersionSpec(d.getVersion());
    } catch (InvalidVersionSpecificationException e) {
        return null;
    }
    Artifact artifact = XcreateDependencyArtifact(d.getGroupId(), d.getArtifactId(), versionRange, d.getType(), d.getClassifier(), d.getScope(), d.isOptional());
    if (Artifact.SCOPE_SYSTEM.equals(d.getScope()) && d.getSystemPath() != null) {
        artifact.setFile(new File(d.getSystemPath()));
    }
    if (!d.getExclusions().isEmpty()) {
        List<String> exclusions = new ArrayList<String>();
        for (Exclusion exclusion : d.getExclusions()) {
            exclusions.add(exclusion.getGroupId() + ':' + exclusion.getArtifactId());
        }
        artifact.setDependencyFilter(new ExcludesArtifactFilter(exclusions));
    }
    return artifact;
}",0.2727272727272727,-0.056122448979591774,0.16666666666666666,0.0,0.16666666666666666,0.3470093919920911,-0.29251505592199617,1.25,-0.028571428571428574,0.4724538613420364
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-102_7f391872,0,"/**
 * Returns the priority value based on the Facility and Log Level.
 * @param facility The Facility.
 * @param level The Level.
 * @return The integer value of the priority.
 */
public static int getPriority(Facility facility, Level level) {
    return facility.getCode() << 3 + Severity.getSeverity(level).getCode();
}","/**
 * Returns the priority value based on the Facility and Log Level.
 * @param facility The Facility.
 * @param level The Level.
 * @return The integer value of the priority.
 */
","public static int getPriority(Facility facility, Level level) {
    return facility.getCode() << 3 + Severity.getSeverity(level).getCode();
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.12357884330202666,0.9159736162890739,-0.25,2.628571428571429,-0.1342850167679597
Closure,96,2,"/**
 * Visits the parameters of a CALL or a NEW node.
 */
private void visitParameterList(NodeTraversal t, Node call, FunctionType functionType) {
    Iterator<Node> arguments = call.children().iterator();
    // skip the function name
    arguments.next();
    Iterator<Node> parameters = functionType.getParameters().iterator();
    int ordinal = 0;
    Node parameter = null;
    Node argument = null;
    while (arguments.hasNext() && parameters.hasNext()) {
        // If there are no parameters left in the list, then the while loop
        // above implies that this must be a var_args function.
        parameter = parameters.next();
        argument = arguments.next();
        ordinal++;
        validator.expectArgumentMatchesParameter(t, argument, getJSType(argument), getJSType(parameter), call, ordinal);
    }
    int numArgs = call.getChildCount() - 1;
    int minArgs = functionType.getMinArguments();
    int maxArgs = functionType.getMaxArguments();
    if (minArgs > numArgs || maxArgs < numArgs) {
        report(t, call, WRONG_ARGUMENT_COUNT, validator.getReadableJSTypeName(call.getFirstChild(), false), String.valueOf(numArgs), String.valueOf(minArgs), maxArgs != Integer.MAX_VALUE ? "" and no more than "" + maxArgs + "" argument(s)"" : """");
    }
}","/**
 * Visits the parameters of a CALL or a NEW node.
 */
","private void visitParameterList(NodeTraversal t, Node call, FunctionType functionType) {
    Iterator<Node> arguments = call.children().iterator();
        arguments.next();
    Iterator<Node> parameters = functionType.getParameters().iterator();
    int ordinal = 0;
    Node parameter = null;
    Node argument = null;
    while (arguments.hasNext() && parameters.hasNext()) {
                        parameter = parameters.next();
        argument = arguments.next();
        ordinal++;
        validator.expectArgumentMatchesParameter(t, argument, getJSType(argument), getJSType(parameter), call, ordinal);
    }
    int numArgs = call.getChildCount() - 1;
    int minArgs = functionType.getMinArguments();
    int maxArgs = functionType.getMaxArguments();
    if (minArgs > numArgs || maxArgs < numArgs) {
        report(t, call, WRONG_ARGUMENT_COUNT, validator.getReadableJSTypeName(call.getFirstChild(), false), String.valueOf(numArgs), String.valueOf(minArgs), maxArgs != Integer.MAX_VALUE ? "" and no more than "" + maxArgs + "" argument(s)"" : """");
    }
}",0.2727272727272727,-0.37244897959183676,0.0,-0.5,0.4166666666666667,1.2189817103311915,-0.344422139374821,1.1666666666666667,-0.028571428571428574,1.9104809384917834
Closure,132,2,"/**
 * Try turning IF nodes into smaller HOOKs
 *
 * Returns the replacement for n or the original if no replacement was
 * necessary.
 */
private Node tryMinimizeIf(Node n) {
    Node parent = n.getParent();
    Node cond = n.getFirstChild();
    /* If the condition is a literal, we'll let other
     * optimizations try to remove useless code.
     */
    if (NodeUtil.isLiteralValue(cond, true)) {
        return n;
    }
    Node thenBranch = cond.getNext();
    Node elseBranch = thenBranch.getNext();
    if (elseBranch == null) {
        if (isFoldableExpressBlock(thenBranch)) {
            Node expr = getBlockExpression(thenBranch);
            if (!late && isPropertyAssignmentInExpression(expr)) {
                // until CollapseProperties has been run.
                return n;
            }
            if (cond.isNot()) {
                // if(!x)bar(); -> x||bar();
                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {
                    // It's not okay to add two sets of parentheses.
                    return n;
                }
                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);
                Node newExpr = NodeUtil.newExpr(or);
                parent.replaceChild(n, newExpr);
                reportCodeChange();
                return newExpr;
            }
            // if(x)foo(); -> x&&foo();
            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {
                // we can further optimize its parent.
                return n;
            }
            n.removeChild(cond);
            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);
            Node newExpr = NodeUtil.newExpr(and);
            parent.replaceChild(n, newExpr);
            reportCodeChange();
            return newExpr;
        } else {
            // Try to combine two IF-ELSE
            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {
                Node innerIf = thenBranch.getFirstChild();
                if (innerIf.isIf()) {
                    Node innerCond = innerIf.getFirstChild();
                    Node innerThenBranch = innerCond.getNext();
                    Node innerElseBranch = innerThenBranch.getNext();
                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {
                        n.detachChildren();
                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));
                        n.addChildrenToBack(innerThenBranch.detachFromParent());
                        reportCodeChange();
                        // the inner IF-ELSE wasn't able to be folded into && anyways.
                        return n;
                    }
                }
            }
        }
        return n;
    }
    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a
     * peephole optimization. This should probably get moved to another pass.
     */
    tryRemoveRepeatedStatements(n);
    // An additional set of curly braces isn't worth it.
    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {
        n.replaceChild(cond, cond.removeFirstChild());
        n.removeChild(thenBranch);
        n.addChildToBack(thenBranch);
        reportCodeChange();
        return n;
    }
    // if(x)return 1;else return 2; -> return x?1:2;
    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
        Node thenExpr = getBlockReturnExpression(thenBranch);
        Node elseExpr = getBlockReturnExpression(elseBranch);
        n.removeChild(cond);
        thenExpr.detachFromParent();
        elseExpr.detachFromParent();
        // note - we ignore any cases with ""return;"", technically this
        // can be converted to ""return undefined;"" or some variant, but
        // that does not help code size.
        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));
        parent.replaceChild(n, returnNode);
        reportCodeChange();
        return returnNode;
    }
    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);
    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
        Node thenOp = getBlockExpression(thenBranch).getFirstChild();
        Node elseOp = getBlockExpression(elseBranch).getFirstChild();
        if (thenOp.getType() == elseOp.getType()) {
            // if(x)a=1;else a=2; -> a=x?1:2;
            if (NodeUtil.isAssignmentOp(thenOp)) {
                Node lhs = thenOp.getFirstChild();
                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // proceed even if there are side effects...
                !mayEffectMutableState(lhs)) {
                    n.removeChild(cond);
                    Node assignName = thenOp.removeFirstChild();
                    Node thenExpr = thenOp.removeFirstChild();
                    Node elseExpr = elseOp.getLastChild();
                    elseOp.removeChild(elseExpr);
                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);
                    Node expr = NodeUtil.newExpr(assign);
                    parent.replaceChild(n, expr);
                    reportCodeChange();
                    return expr;
                }
            }
        }
        // if(x)foo();else bar(); -> x?foo():bar()
        n.removeChild(cond);
        thenOp.detachFromParent();
        elseOp.detachFromParent();
        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));
        parent.replaceChild(n, expr);
        reportCodeChange();
        return expr;
    }
    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);
    // if(x)var y=1;else y=2  ->  var y=x?1:2
    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {
        Node var = getBlockVar(thenBranch);
        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();
        Node name1 = var.getFirstChild();
        Node maybeName2 = elseAssign.getFirstChild();
        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {
            Node thenExpr = name1.removeChildren();
            Node elseExpr = elseAssign.getLastChild().detachFromParent();
            cond.detachFromParent();
            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
            var.detachFromParent();
            name1.addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            reportCodeChange();
            return var;
        }
    // if(x)y=1;else var y=2  ->  var y=x?1:2
    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {
        Node var = getBlockVar(elseBranch);
        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();
        Node maybeName1 = thenAssign.getFirstChild();
        Node name2 = var.getFirstChild();
        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {
            Node thenExpr = thenAssign.getLastChild().detachFromParent();
            Node elseExpr = name2.removeChildren();
            cond.detachFromParent();
            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
            var.detachFromParent();
            name2.addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            reportCodeChange();
            return var;
        }
    }
    return n;
}","/**
 * Try turning IF nodes into smaller HOOKs
 *
 * Returns the replacement for n or the original if no replacement was
 * necessary.
 */
","private Node tryMinimizeIf(Node n) {
    Node parent = n.getParent();
    Node cond = n.getFirstChild();
        if (NodeUtil.isLiteralValue(cond, true)) {
        return n;
    }
    Node thenBranch = cond.getNext();
    Node elseBranch = thenBranch.getNext();
    if (elseBranch == null) {
        if (isFoldableExpressBlock(thenBranch)) {
            Node expr = getBlockExpression(thenBranch);
            if (!late && isPropertyAssignmentInExpression(expr)) {
                                return n;
            }
            if (cond.isNot()) {
                                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {
                                        return n;
                }
                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);
                Node newExpr = NodeUtil.newExpr(or);
                parent.replaceChild(n, newExpr);
                reportCodeChange();
                return newExpr;
            }
                        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {
                                return n;
            }
            n.removeChild(cond);
            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);
            Node newExpr = NodeUtil.newExpr(and);
            parent.replaceChild(n, newExpr);
            reportCodeChange();
            return newExpr;
        } else {
                        if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {
                Node innerIf = thenBranch.getFirstChild();
                if (innerIf.isIf()) {
                    Node innerCond = innerIf.getFirstChild();
                    Node innerThenBranch = innerCond.getNext();
                    Node innerElseBranch = innerThenBranch.getNext();
                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {
                        n.detachChildren();
                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));
                        n.addChildrenToBack(innerThenBranch.detachFromParent());
                        reportCodeChange();
                                                return n;
                    }
                }
            }
        }
        return n;
    }
        tryRemoveRepeatedStatements(n);
        if (cond.isNot() && !consumesDanglingElse(elseBranch)) {
        n.replaceChild(cond, cond.removeFirstChild());
        n.removeChild(thenBranch);
        n.addChildToBack(thenBranch);
        reportCodeChange();
        return n;
    }
        if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
        Node thenExpr = getBlockReturnExpression(thenBranch);
        Node elseExpr = getBlockReturnExpression(elseBranch);
        n.removeChild(cond);
        thenExpr.detachFromParent();
        elseExpr.detachFromParent();
                                Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));
        parent.replaceChild(n, returnNode);
        reportCodeChange();
        return returnNode;
    }
    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);
    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
        Node thenOp = getBlockExpression(thenBranch).getFirstChild();
        Node elseOp = getBlockExpression(elseBranch).getFirstChild();
        if (thenOp.getType() == elseOp.getType()) {
                        if (NodeUtil.isAssignmentOp(thenOp)) {
                Node lhs = thenOp.getFirstChild();
                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&                 !mayEffectMutableState(lhs)) {
                    n.removeChild(cond);
                    Node assignName = thenOp.removeFirstChild();
                    Node thenExpr = thenOp.removeFirstChild();
                    Node elseExpr = elseOp.getLastChild();
                    elseOp.removeChild(elseExpr);
                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);
                    Node expr = NodeUtil.newExpr(assign);
                    parent.replaceChild(n, expr);
                    reportCodeChange();
                    return expr;
                }
            }
        }
                n.removeChild(cond);
        thenOp.detachFromParent();
        elseOp.detachFromParent();
        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));
        parent.replaceChild(n, expr);
        reportCodeChange();
        return expr;
    }
    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);
        if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {
        Node var = getBlockVar(thenBranch);
        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();
        Node name1 = var.getFirstChild();
        Node maybeName2 = elseAssign.getFirstChild();
        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {
            Node thenExpr = name1.removeChildren();
            Node elseExpr = elseAssign.getLastChild().detachFromParent();
            cond.detachFromParent();
            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
            var.detachFromParent();
            name1.addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            reportCodeChange();
            return var;
        }
        } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {
        Node var = getBlockVar(elseBranch);
        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();
        Node maybeName1 = thenAssign.getFirstChild();
        Node name2 = var.getFirstChild();
        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {
            Node thenExpr = thenAssign.getLastChild().detachFromParent();
            Node elseExpr = name2.removeChildren();
            cond.detachFromParent();
            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
            var.detachFromParent();
            name2.addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            reportCodeChange();
            return var;
        }
    }
    return n;
}",5.7272727272727275,1.3214285714285716,2.8333333333333335,1.5,6.5,1.729115175481958,-1.6139948379696019,11.75,-0.028571428571428574,14.799923762533139
wicket,remotes/origin/bugs-dot-jar_WICKET-3563_c62b66c1,1,"/**
 *  Renders a placeholder tag for the component when it is invisible and
 *  {@link #setOutputMarkupPlaceholderTag(boolean)} has been called with <code>true</code>.
 *
 *  @param tag
 *             component tag
 *  @param response
 *             response
 */
protected void renderPlaceholderTag(final ComponentTag tag, final Response response) {
    String ns = Strings.isEmpty(tag.getNamespace()) ? null : tag.getNamespace() + "":"";
    response.write(""<"");
    if (ns != null) {
        response.write(ns);
    }
    response.write(tag.getName());
    response.write("" id=\"""");
    response.write(getMarkupId());
    response.write(""\"" style=\""display:none\""></"");
    if (ns != null) {
        response.write(ns);
    }
    response.write(tag.getName());
    response.write("">"");
}","/**
 *  Renders a placeholder tag for the component when it is invisible and
 *  {@link #setOutputMarkupPlaceholderTag(boolean)} has been called with <code>true</code>.
 *
 *  @param tag
 *             component tag
 *  @param response
 *             response
 */
","protected void renderPlaceholderTag(final ComponentTag tag, final Response response) {
    String ns = Strings.isEmpty(tag.getNamespace()) ? null : tag.getNamespace() + "":"";
    response.write(""<"");
    if (ns != null) {
        response.write(ns);
    }
    response.write(tag.getName());
    response.write("" id=\"""");
    response.write(getMarkupId());
    response.write(""\"" style=\""display:none\""></"");
    if (ns != null) {
        response.write(ns);
    }
    response.write(tag.getName());
    response.write("">"");
}",0.09090909090909091,-0.5204081632653061,0.0,-0.5,0.08333333333333333,0.10380622837370251,-0.10438772583882998,0.75,-0.028571428571428574,0.08734757860382644
flink,remotes/origin/bugs-dot-jar_FLINK-1496_0a4c7694,1,"// ------------------------------------------------------------------------
// Task events
// ------------------------------------------------------------------------
@Override
public void sendTaskEvent(TaskEvent event) throws IOException, InterruptedException {
    // remote input channels.
    synchronized (requestLock) {
        for (InputChannel inputChannel : inputChannels.values()) {
            inputChannel.sendTaskEvent(event);
        }
    }
}",,"@Override
public void sendTaskEvent(TaskEvent event) throws IOException, InterruptedException {
        synchronized (requestLock) {
        for (InputChannel inputChannel : inputChannels.values()) {
            inputChannel.sendTaskEvent(event);
        }
    }
}",-0.2727272727272727,0.6071428571428571,-0.3333333333333333,0.0,-0.4166666666666667,-0.3806228373702422,0.4536851161456839,-0.3333333333333333,2.5142857142857147,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1183_742960f1,3,"@Override
public String createBatchScanner(ByteBuffer login, String tableName, BatchScanOptions opts) throws TException {
    try {
        Connector connector = getConnector(login);
        int threads = 10;
        Authorizations auth;
        if (opts != null && opts.isSetAuthorizations()) {
            auth = getAuthorizations(opts.authorizations);
        } else {
            auth = connector.securityOperations().getUserAuthorizations(connector.whoami());
        }
        if (opts != null && opts.threads > 0)
            threads = opts.threads;
        BatchScanner scanner = connector.createBatchScanner(tableName, auth, threads);
        if (opts != null) {
            if (opts.iterators != null) {
                for (org.apache.accumulo.proxy.thrift.IteratorSetting iter : opts.iterators) {
                    IteratorSetting is = new IteratorSetting(iter.getPriority(), iter.getName(), iter.getIteratorClass(), iter.getProperties());
                    scanner.addScanIterator(is);
                }
            }
            ArrayList<Range> ranges = new ArrayList<Range>();
            if (opts.ranges == null) {
                ranges.add(new Range());
            } else {
                for (org.apache.accumulo.proxy.thrift.Range range : opts.ranges) {
                    Range aRange = new Range(range.getStart() == null ? null : Util.fromThrift(range.getStart()), true, range.getStop() == null ? null : Util.fromThrift(range.getStop()), false);
                    ranges.add(aRange);
                }
            }
            scanner.setRanges(ranges);
        }
        UUID uuid = UUID.randomUUID();
        ScannerPlusIterator spi = new ScannerPlusIterator();
        spi.scanner = scanner;
        spi.iterator = scanner.iterator();
        scannerCache.put(uuid, spi);
        return uuid.toString();
    } catch (Exception e) {
        throw translateException(e);
    }
}",,"@Override
public String createBatchScanner(ByteBuffer login, String tableName, BatchScanOptions opts) throws TException {
    try {
        Connector connector = getConnector(login);
        int threads = 10;
        Authorizations auth;
        if (opts != null && opts.isSetAuthorizations()) {
            auth = getAuthorizations(opts.authorizations);
        } else {
            auth = connector.securityOperations().getUserAuthorizations(connector.whoami());
        }
        if (opts != null && opts.threads > 0)
            threads = opts.threads;
        BatchScanner scanner = connector.createBatchScanner(tableName, auth, threads);
        if (opts != null) {
            if (opts.iterators != null) {
                for (org.apache.accumulo.proxy.thrift.IteratorSetting iter : opts.iterators) {
                    IteratorSetting is = new IteratorSetting(iter.getPriority(), iter.getName(), iter.getIteratorClass(), iter.getProperties());
                    scanner.addScanIterator(is);
                }
            }
            ArrayList<Range> ranges = new ArrayList<Range>();
            if (opts.ranges == null) {
                ranges.add(new Range());
            } else {
                for (org.apache.accumulo.proxy.thrift.Range range : opts.ranges) {
                    Range aRange = new Range(range.getStart() == null ? null : Util.fromThrift(range.getStart()), true, range.getStop() == null ? null : Util.fromThrift(range.getStop()), false);
                    ranges.add(aRange);
                }
            }
            scanner.setRanges(ranges);
        }
        UUID uuid = UUID.randomUUID();
        ScannerPlusIterator spi = new ScannerPlusIterator();
        spi.scanner = scanner;
        spi.iterator = scanner.iterator();
        scannerCache.put(uuid, spi);
        return uuid.toString();
    } catch (Exception e) {
        throw translateException(e);
    }
}",1.2727272727272727,1.0612244897959182,1.3333333333333333,1.0,0.9166666666666666,0.49925852694018796,-0.8250645253799829,1.6666666666666667,-0.028571428571428574,1.8303844852471938
wicket,remotes/origin/bugs-dot-jar_WICKET-4309_b4274415,1,"/**
 *  Convert to object types, returning null if text is null.
 *
 *  @return converted
 *  @throws StringValueConversionException
 */
public final Long toOptionalLong() throws StringValueConversionException {
    return (text == null) ? null : toLongObject();
}","/**
 *  Convert to object types, returning null if text is null.
 *
 *  @return converted
 *  @throws StringValueConversionException
 */
","public final Long toOptionalLong() throws StringValueConversionException {
    return (text == null) ? null : toLongObject();
}",-0.5,-0.576530612244898,-0.3333333333333333,-1.0,-0.25,-0.3806228373702422,1.012044737596788,-0.4166666666666667,2.8285714285714287,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-4345_4f08e6f2,1,"private Url decryptUrl(final Request request, final Url encryptedUrl) {
    if (encryptedUrl.getSegments().isEmpty() && encryptedUrl.getQueryParameters().isEmpty()) {
        return encryptedUrl;
    }
    List<String> encryptedSegments = encryptedUrl.getSegments();
    if (encryptedSegments.size() < 1) {
        return null;
    }
    Url url = new Url(request.getCharset());
    try {
        String encryptedUrlString = encryptedSegments.get(0);
        if (Strings.isEmpty(encryptedUrlString)) {
            return null;
        }
        String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);
        if (decryptedUrl == null) {
            return null;
        }
        Url originalUrl = Url.parse(decryptedUrl, request.getCharset());
        int originalNumberOfSegments = originalUrl.getSegments().size();
        int encryptedNumberOfSegments = encryptedUrl.getSegments().size();
        HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);
        int segNo = 1;
        for (; segNo < encryptedNumberOfSegments; segNo++) {
            if (segNo > originalNumberOfSegments || !generator.next().equals(encryptedSegments.get(segNo))) {
                break;
            }
            // unmodified segment
            url.getSegments().add(originalUrl.getSegments().get(segNo - 1));
        }
        for (; segNo < encryptedNumberOfSegments; segNo++) {
            // modified or additional segment
            url.getSegments().add(encryptedUrl.getSegments().get(segNo));
        }
        url.getQueryParameters().addAll(originalUrl.getQueryParameters());
    } catch (Exception e) {
        log.error(""Error decrypting URL"", e);
        url = null;
    }
    return url;
}",,"private Url decryptUrl(final Request request, final Url encryptedUrl) {
    if (encryptedUrl.getSegments().isEmpty() && encryptedUrl.getQueryParameters().isEmpty()) {
        return encryptedUrl;
    }
    List<String> encryptedSegments = encryptedUrl.getSegments();
    if (encryptedSegments.size() < 1) {
        return null;
    }
    Url url = new Url(request.getCharset());
    try {
        String encryptedUrlString = encryptedSegments.get(0);
        if (Strings.isEmpty(encryptedUrlString)) {
            return null;
        }
        String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);
        if (decryptedUrl == null) {
            return null;
        }
        Url originalUrl = Url.parse(decryptedUrl, request.getCharset());
        int originalNumberOfSegments = originalUrl.getSegments().size();
        int encryptedNumberOfSegments = encryptedUrl.getSegments().size();
        HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);
        int segNo = 1;
        for (; segNo < encryptedNumberOfSegments; segNo++) {
            if (segNo > originalNumberOfSegments || !generator.next().equals(encryptedSegments.get(segNo))) {
                break;
            }
                        url.getSegments().add(originalUrl.getSegments().get(segNo - 1));
        }
        for (; segNo < encryptedNumberOfSegments; segNo++) {
                        url.getSegments().add(encryptedUrl.getSegments().get(segNo));
        }
        url.getQueryParameters().addAll(originalUrl.getQueryParameters());
    } catch (Exception e) {
        log.error(""Error decrypting URL"", e);
        url = null;
    }
    return url;
}",1.1363636363636365,0.15816326530612249,1.0,0.5,1.25,1.7745921898171038,-0.7238313736736455,2.1666666666666665,-0.028571428571428574,3.2433474244156915
Math,18,1,"/**
 * @param x Original objective variables.
 * @return the normalized objective variables.
 */
public double[] encode(final double[] x) {
    if (boundaries == null) {
        return x;
    }
    double[] res = new double[x.length];
    for (int i = 0; i < x.length; i++) {
        double diff = boundaries[1][i] - boundaries[0][i];
        res[i] = (x[i] - boundaries[0][i]) / diff;
    }
    return res;
}","/**
 * @param x Original objective variables.
 * @return the normalized objective variables.
 */
","public double[] encode(final double[] x) {
    if (boundaries == null) {
        return x;
    }
    double[] res = new double[x.length];
    for (int i = 0; i < x.length; i++) {
        double diff = boundaries[1][i] - boundaries[0][i];
        res[i] = (x[i] - boundaries[0][i]) / diff;
    }
    return res;
}",-0.13636363636363635,-0.17857142857142863,-0.16666666666666666,-0.5,0.0,1.2901631240731588,0.12962431889876677,-0.5,2.0571428571428574,0.4426141741726307
camel,remotes/origin/bugs-dot-jar_CAMEL-5707_3f70d612,3,"/**
 * Sets a condition when tne <tt>n'th</tt> (by index) {@link Exchange} is done being processed.
 * <p/>
 * The difference between <i>done</i> and <i>completed</i> is that done can also include failed
 * messages, where as completed is only successful processed messages.
 *
 * @param index the message by index to be done
 * @return the builder
 */
public NotifyBuilder whenDoneByIndex(final int index) {
    stack.add(new EventPredicateSupport() {

        private AtomicInteger current = new AtomicInteger();

        private String id;

        private AtomicBoolean done = new AtomicBoolean();

        @Override
        public boolean onExchangeCreated(Exchange exchange) {
            if (current.get() == index) {
                id = exchange.getExchangeId();
            }
            current.incrementAndGet();
            return true;
        }

        @Override
        public boolean onExchangeCompleted(Exchange exchange) {
            if (exchange.getExchangeId().equals(id)) {
                done.set(false);
            }
            return true;
        }

        @Override
        public boolean onExchangeFailed(Exchange exchange) {
            if (exchange.getExchangeId().equals(id)) {
                done.set(true);
            }
            return true;
        }

        public boolean matches() {
            return done.get();
        }

        @Override
        public void reset() {
            current.set(0);
            id = null;
            done.set(false);
        }

        @Override
        public String toString() {
            return ""whenDoneByIndex("" + index + "")"";
        }
    });
    return this;
}","/**
 * Sets a condition when tne <tt>n'th</tt> (by index) {@link Exchange} is done being processed.
 * <p/>
 * The difference between <i>done</i> and <i>completed</i> is that done can also include failed
 * messages, where as completed is only successful processed messages.
 *
 * @param index the message by index to be done
 * @return the builder
 */
","public NotifyBuilder whenDoneByIndex(final int index) {
    stack.add(new EventPredicateSupport() {

        private AtomicInteger current = new AtomicInteger();

        private String id;

        private AtomicBoolean done = new AtomicBoolean();

        @Override
        public boolean onExchangeCreated(Exchange exchange) {
            if (current.get() == index) {
                id = exchange.getExchangeId();
            }
            current.incrementAndGet();
            return true;
        }

        @Override
        public boolean onExchangeCompleted(Exchange exchange) {
            if (exchange.getExchangeId().equals(id)) {
                done.set(false);
            }
            return true;
        }

        @Override
        public boolean onExchangeFailed(Exchange exchange) {
            if (exchange.getExchangeId().equals(id)) {
                done.set(true);
            }
            return true;
        }

        public boolean matches() {
            return done.get();
        }

        @Override
        public void reset() {
            current.set(0);
            id = null;
            done.set(false);
        }

        @Override
        public String toString() {
            return ""whenDoneByIndex("" + index + "")"";
        }
    });
    return this;
}",1.3181818181818181,0.26020408163265296,0.0,0.0,0.16666666666666666,0.044488383588729634,-0.6392314310295386,0.5833333333333334,-0.028571428571428574,0.2026032096830149
flink,remotes/origin/bugs-dot-jar_FLINK-2812_e494c279,3,"public static <X, K> KeySelector<X, K> getSelectorForOneKey(Keys<X> keys, Partitioner<K> partitioner, TypeInformation<X> typeInfo, ExecutionConfig executionConfig) {
    if (partitioner != null) {
        keys.validateCustomPartitioner(partitioner, null);
    }
    int[] logicalKeyPositions = keys.computeLogicalKeyPositions();
    if (logicalKeyPositions.length != 1) {
        throw new IllegalArgumentException(""There must be exactly 1 key specified"");
    }
    TypeComparator<X> comparator = ((CompositeType<X>) typeInfo).createComparator(logicalKeyPositions, new boolean[1], 0, executionConfig);
    return new OneKeySelector<X, K>(comparator);
}",,"public static <X, K> KeySelector<X, K> getSelectorForOneKey(Keys<X> keys, Partitioner<K> partitioner, TypeInformation<X> typeInfo, ExecutionConfig executionConfig) {
    if (partitioner != null) {
        keys.validateCustomPartitioner(partitioner, null);
    }
    int[] logicalKeyPositions = keys.computeLogicalKeyPositions();
    if (logicalKeyPositions.length != 1) {
        throw new IllegalArgumentException(""There must be exactly 1 key specified"");
    }
    TypeComparator<X> comparator = ((CompositeType<X>) typeInfo).createComparator(logicalKeyPositions, new boolean[1], 0, executionConfig);
    return new OneKeySelector<X, K>(comparator);
}",-0.13636363636363635,-0.3112244897959183,0.0,-0.5,-0.08333333333333333,-0.03657933761739987,0.06481215944938318,-0.25,-0.028571428571428574,0.020489889969633492
camel,remotes/origin/bugs-dot-jar_CAMEL-6667_1fc7bd7a,1,"public void done(boolean doneSync) {
    // we only have to handle async completion of the routing slip
    if (doneSync) {
        return;
    }
    Exchange target = exchange;
    // increment index as we have just processed once
    index.getAndIncrement();
    // continue looping asynchronously
    while (index.get() < count.get()) {
        // and prepare for next iteration
        target = prepareExchange(exchange, index.get());
        // process again
        boolean sync = process(target, callback, index, count);
        if (!sync) {
            LOG.trace(""Processing exchangeId: {} is continued being processed asynchronously"", target.getExchangeId());
            // so we break out now, then the callback will be invoked which then continue routing from where we left here
            return;
        }
        // increment counter before next loop
        index.getAndIncrement();
    }
    // we are done so prepare the result
    ExchangeHelper.copyResults(exchange, target);
    LOG.trace(""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
    callback.done(false);
}",,"public void done(boolean doneSync) {
        if (doneSync) {
        return;
    }
    Exchange target = exchange;
        index.getAndIncrement();
        while (index.get() < count.get()) {
                target = prepareExchange(exchange, index.get());
                boolean sync = process(target, callback, index, count);
        if (!sync) {
            LOG.trace(""Processing exchangeId: {} is continued being processed asynchronously"", target.getExchangeId());
                        return;
        }
                index.getAndIncrement();
    }
        ExchangeHelper.copyResults(exchange, target);
    LOG.trace(""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
    callback.done(false);
}",0.22727272727272727,0.12244897959183662,0.0,0.0,0.16666666666666666,0.024715768660405344,-0.1795239460854605,0.5833333333333334,-0.028571428571428574,0.039189484369177796
JxPath,13,1,"public NodePointer createAttribute(JXPathContext context, QName name) {
    if (!(node instanceof Element)) {
        return super.createAttribute(context, name);
    }
    Element element = (Element) node;
    String prefix = name.getPrefix();
    if (prefix != null) {
        String ns = getNamespaceURI(prefix);
        if (ns == null) {
            throw new JXPathException(""Unknown namespace prefix: "" + prefix);
        }
        element.setAttributeNS(ns, name.toString(), """");
    } else {
        if (!element.hasAttribute(name.getName())) {
            element.setAttribute(name.getName(), """");
        }
    }
    NodeIterator it = attributeIterator(name);
    it.setPosition(1);
    return it.getNodePointer();
}",,"public NodePointer createAttribute(JXPathContext context, QName name) {
    if (!(node instanceof Element)) {
        return super.createAttribute(context, name);
    }
    Element element = (Element) node;
    String prefix = name.getPrefix();
    if (prefix != null) {
        String ns = getNamespaceURI(prefix);
        if (ns == null) {
            throw new JXPathException(""Unknown namespace prefix: "" + prefix);
        }
        element.setAttributeNS(ns, name.toString(), """");
    } else {
        if (!element.hasAttribute(name.getName())) {
            element.setAttribute(name.getName(), """");
        }
    }
    NodeIterator it = attributeIterator(name);
    it.setPosition(1);
    return it.getNodePointer();
}",0.3181818181818182,0.0714285714285715,0.3333333333333333,0.0,0.3333333333333333,0.3450321304992586,-0.2907943791224549,0.5,-0.028571428571428574,0.3513048170943246
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1008_0c20bfd8,1,"/**
 * Will be called repeatedly with candidate classes. Must return True if a class
 * is to be included in the results, false otherwise.
 * @param type The Class to match against.
 * @return true if the Class matches.
 */
boolean matches(Class<?> type);","/**
 * Will be called repeatedly with candidate classes. Must return True if a class
 * is to be included in the results, false otherwise.
 * @param type The Class to match against.
 * @return true if the Class matches.
 */
",boolean matches(Class<?> type);,-0.5909090909090909,-1.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.7106395182104968,-0.5,2.8000000000000003,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-6447_020c451a,1,"protected boolean continueRouting(Iterator<Processor> it, Exchange exchange) {
    boolean answer = it.hasNext();
    if (answer) {
        Object matched = exchange.getProperty(Exchange.FILTER_MATCHED);
        if (matched != null) {
            boolean hasMatched = exchange.getContext().getTypeConverter().convertTo(Boolean.class, matched);
            if (hasMatched) {
                LOG.debug(""ExchangeId: {} has been matched: {}"", exchange.getExchangeId(), exchange);
                answer = false;
            }
        }
    }
    LOG.trace(""ExchangeId: {} should continue matching: {}"", exchange.getExchangeId(), answer);
    return answer;
}",,"protected boolean continueRouting(Iterator<Processor> it, Exchange exchange) {
    boolean answer = it.hasNext();
    if (answer) {
        Object matched = exchange.getProperty(Exchange.FILTER_MATCHED);
        if (matched != null) {
            boolean hasMatched = exchange.getContext().getTypeConverter().convertTo(Boolean.class, matched);
            if (hasMatched) {
                LOG.debug(""ExchangeId: {} has been matched: {}"", exchange.getExchangeId(), exchange);
                answer = false;
            }
        }
    }
    LOG.trace(""ExchangeId: {} should continue matching: {}"", exchange.getExchangeId(), answer);
    return answer;
}",0.045454545454545456,1.0255102040816328,0.0,0.5,0.08333333333333333,-0.06030647553138898,-0.0656724978491542,0.25,-0.028571428571428574,-0.007902141930178469
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-554_3f51fb09,1,"/**
 * Create a {@code PropertyState} based on a {@link Value}. The
 * {@link Type} of the property state is determined by the
 * type of the value.
 * @param name  The name of the property state
 * @param value  The value of the property state
 * @return  The new property state
 * @throws RepositoryException forwarded from {@code value}
 */
@Nonnull
public static PropertyState createProperty(String name, Value value) throws RepositoryException {
    int type = value.getType();
    switch(type) {
        case PropertyType.STRING:
            return StringPropertyState.stringProperty(name, value.getString());
        case PropertyType.BINARY:
            return BinaryPropertyState.binaryProperty(name, value);
        case PropertyType.LONG:
            return LongPropertyState.createLongProperty(name, value.getLong());
        case PropertyType.DOUBLE:
            return DoublePropertyState.doubleProperty(name, value.getDouble());
        case PropertyType.DATE:
            return LongPropertyState.createDateProperty(name, value.getLong());
        case PropertyType.BOOLEAN:
            return BooleanPropertyState.booleanProperty(name, value.getBoolean());
        case PropertyType.DECIMAL:
            return DecimalPropertyState.decimalProperty(name, value.getDecimal());
        default:
            return new GenericPropertyState(name, value.getString(), Type.fromTag(type, false));
    }
}","/**
 * Create a {@code PropertyState} based on a {@link Value}. The
 * {@link Type} of the property state is determined by the
 * type of the value.
 * @param name  The name of the property state
 * @param value  The value of the property state
 * @return  The new property state
 * @throws RepositoryException forwarded from {@code value}
 */
","@Nonnull
public static PropertyState createProperty(String name, Value value) throws RepositoryException {
    int type = value.getType();
    switch(type) {
        case PropertyType.STRING:
            return StringPropertyState.stringProperty(name, value.getString());
        case PropertyType.BINARY:
            return BinaryPropertyState.binaryProperty(name, value);
        case PropertyType.LONG:
            return LongPropertyState.createLongProperty(name, value.getLong());
        case PropertyType.DOUBLE:
            return DoublePropertyState.doubleProperty(name, value.getDouble());
        case PropertyType.DATE:
            return LongPropertyState.createDateProperty(name, value.getLong());
        case PropertyType.BOOLEAN:
            return BooleanPropertyState.booleanProperty(name, value.getBoolean());
        case PropertyType.DECIMAL:
            return DecimalPropertyState.decimalProperty(name, value.getDecimal());
        default:
            return new GenericPropertyState(name, value.getString(), Type.fromTag(type, false));
    }
}",0.36363636363636365,0.5459183673469387,0.8333333333333334,0.0,0.25,-0.3806228373702422,-0.3530255233725267,0.8333333333333334,-0.028571428571428574,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-5484_ecdfc124,1,"/**
 *  Should the page be rendered immediately.
 */
protected boolean shouldRenderPageAndWriteResponse(RequestCycle cycle, Url currentUrl, Url targetUrl) {
    return neverRedirect(getRedirectPolicy()) || (!isAjax(cycle) && ((isOnePassRender() && notForcedRedirect(getRedirectPolicy())) || (targetUrl.equals(currentUrl) && notNewAndNotStatelessPage(isNewPageInstance(), isPageStateless())))) || (targetUrl.equals(currentUrl) && isRedirectToRender()) || shouldPreserveClientUrl(cycle);
}","/**
 *  Should the page be rendered immediately.
 */
","protected boolean shouldRenderPageAndWriteResponse(RequestCycle cycle, Url currentUrl, Url targetUrl) {
    return neverRedirect(getRedirectPolicy()) || (!isAjax(cycle) && ((isOnePassRender() && notForcedRedirect(getRedirectPolicy())) || (targetUrl.equals(currentUrl) && notNewAndNotStatelessPage(isNewPageInstance(), isPageStateless())))) || (targetUrl.equals(currentUrl) && isRedirectToRender()) || shouldPreserveClientUrl(cycle);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.08403361344537813,0.7636937195296818,0.5833333333333334,2.7142857142857144,-0.06828392888500563
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd,1,"@Override
public IndexRow next() {
    final IndexRow r = c.next();
    return new IndexRow() {

        @Override
        public String getPath() {
            String sub = r.getPath();
            if (PathUtils.isAbsolute(sub)) {
                return path + sub;
            } else {
                return PathUtils.concat(path, r.getPath());
            }
        }

        @Override
        public PropertyValue getValue(String columnName) {
            return r.getValue(columnName);
        }
    };
}",,"@Override
public IndexRow next() {
    final IndexRow r = c.next();
    return new IndexRow() {

        @Override
        public String getPath() {
            String sub = r.getPath();
            if (PathUtils.isAbsolute(sub)) {
                return path + sub;
            } else {
                return PathUtils.concat(path, r.getPath());
            }
        }

        @Override
        public PropertyValue getValue(String columnName) {
            return r.getValue(columnName);
        }
    };
}",0.22727272727272727,0.9387755102040818,-0.3333333333333333,0.0,-0.16666666666666666,0.03855659911023239,-0.1052480642386006,0.0,1.1428571428571428,-0.02380493487692788
wicket,remotes/origin/bugs-dot-jar_WICKET-4932_f20b2d70,1,"/**
 *  Creates a {@code IRequestHandler} that processes a hybrid request. When the page identified
 *  by {@code pageInfo} was not available, the request should be treated as a bookmarkable
 *  request.
 *
 *  @param pageInfo
 *  @param pageClass
 *  @param pageParameters
 *  @param renderCount
 *  @return a {@code IRequestHandler} capable of processing the hybrid request.
 */
protected IRequestHandler processHybrid(PageInfo pageInfo, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters, Integer renderCount) {
    PageProvider provider = new PageProvider(pageInfo.getPageId(), pageClass, pageParameters, renderCount);
    provider.setPageSource(getContext());
    return new RenderPageRequestHandler(provider);
}","/**
 *  Creates a {@code IRequestHandler} that processes a hybrid request. When the page identified
 *  by {@code pageInfo} was not available, the request should be treated as a bookmarkable
 *  request.
 *
 *  @param pageInfo
 *  @param pageClass
 *  @param pageParameters
 *  @param renderCount
 *  @return a {@code IRequestHandler} capable of processing the hybrid request.
 */
","protected IRequestHandler processHybrid(PageInfo pageInfo, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters, Integer renderCount) {
    PageProvider provider = new PageProvider(pageInfo.getPageId(), pageClass, pageParameters, renderCount);
    provider.setPageSource(getContext());
    return new RenderPageRequestHandler(provider);
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.571264697447663,-0.25,1.2285714285714286,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5,3,"public boolean equals(update_result that) {
    if (that == null)
        return false;
    boolean this_present_ouch1 = true && this.isSetOuch1();
    boolean that_present_ouch1 = true && that.isSetOuch1();
    if (this_present_ouch1 || that_present_ouch1) {
        if (!(this_present_ouch1 && that_present_ouch1))
            return false;
        if (!this.ouch1.equals(that.ouch1))
            return false;
    }
    boolean this_present_ouch2 = true && this.isSetOuch2();
    boolean that_present_ouch2 = true && that.isSetOuch2();
    if (this_present_ouch2 || that_present_ouch2) {
        if (!(this_present_ouch2 && that_present_ouch2))
            return false;
        if (!this.ouch2.equals(that.ouch2))
            return false;
    }
    return true;
}",,"public boolean equals(update_result that) {
    if (that == null)
        return false;
    boolean this_present_ouch1 = true && this.isSetOuch1();
    boolean that_present_ouch1 = true && that.isSetOuch1();
    if (this_present_ouch1 || that_present_ouch1) {
        if (!(this_present_ouch1 && that_present_ouch1))
            return false;
        if (!this.ouch1.equals(that.ouch1))
            return false;
    }
    boolean this_present_ouch2 = true && this.isSetOuch2();
    boolean that_present_ouch2 = true && that.isSetOuch2();
    if (this_present_ouch2 || that_present_ouch2) {
        if (!(this_present_ouch2 && that_present_ouch2))
            return false;
        if (!this.ouch2.equals(that.ouch2))
            return false;
    }
    return true;
}",0.3181818181818182,0.3061224489795919,0.6666666666666666,-0.5,1.25,0.726643598615917,-0.26641812446228874,0.0,-0.028571428571428574,0.4473725913457626
Closure,37,2,"/**
 * Traverses a function.
 */
private void traverseFunction(Node n, Node parent) {
    Preconditions.checkState(n.getChildCount() == 3);
    Preconditions.checkState(n.isFunction());
    final Node fnName = n.getFirstChild();
    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);
    if (!isFunctionExpression) {
        // Functions declarations are in the scope containing the declaration.
        traverseBranch(fnName, n);
    }
    curNode = n;
    pushScope(n);
    if (isFunctionExpression) {
        // Function expression names are only accessible within the function
        // scope.
        traverseBranch(fnName, n);
    }
    final Node args = fnName.getNext();
    final Node body = args.getNext();
    // Args
    traverseBranch(args, n);
    // Body
    Preconditions.checkState(body.getNext() == null && body.isBlock());
    traverseBranch(body, n);
    popScope();
}","/**
 * Traverses a function.
 */
","private void traverseFunction(Node n, Node parent) {
    Preconditions.checkState(n.getChildCount() == 3);
    Preconditions.checkState(n.isFunction());
    final Node fnName = n.getFirstChild();
    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);
    if (!isFunctionExpression) {
                traverseBranch(fnName, n);
    }
    curNode = n;
    pushScope(n);
    if (isFunctionExpression) {
                        traverseBranch(fnName, n);
    }
    final Node args = fnName.getNext();
    final Node body = args.getNext();
        traverseBranch(args, n);
        Preconditions.checkState(body.getNext() == null && body.isBlock());
    traverseBranch(body, n);
    popScope();
}",0.2727272727272727,-0.6275510204081632,-0.16666666666666666,-0.5,-0.16666666666666666,0.633712308452793,-0.2520791511327791,0.9166666666666666,0.2571428571428572,0.5752202534681623
camel,remotes/origin/bugs-dot-jar_CAMEL-8954_7b1253db,3,"@Override
public boolean acquireExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {
    if (!markerFile) {
        // if not using marker file then we assume acquired
        return true;
    }
    String lockFileName = getLockFileName(file);
    LOG.trace(""Locking the file: {} using the lock file name: {}"", file, lockFileName);
    // create a plain file as marker filer for locking (do not use FileLock)
    boolean acquired = FileUtil.createNewFile(new File(lockFileName));
    exchange.setProperty(Exchange.FILE_LOCK_FILE_ACQUIRED, acquired);
    exchange.setProperty(Exchange.FILE_LOCK_FILE_NAME, lockFileName);
    return acquired;
}",,"@Override
public boolean acquireExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {
    if (!markerFile) {
                return true;
    }
    String lockFileName = getLockFileName(file);
    LOG.trace(""Locking the file: {} using the lock file name: {}"", file, lockFileName);
        boolean acquired = FileUtil.createNewFile(new File(lockFileName));
    exchange.setProperty(Exchange.FILE_LOCK_FILE_ACQUIRED, acquired);
    exchange.setProperty(Exchange.FILE_LOCK_FILE_NAME, lockFileName);
    return acquired;
}",-0.09090909090909091,-0.413265306122449,-0.3333333333333333,-0.5,-0.25,-0.07217004448838356,0.0696874103814165,-0.08333333333333333,-0.028571428571428574,-0.030794797007036967
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-4387_ca05fd06,1,"private Statement convertToStatement(String query) throws ParseException {
    query = query.trim();
    Statement statement = new Statement();
    if (query.startsWith(""explain "")) {
        query = query.substring(""explain"".length()).trim();
        statement.setExplain(true);
    }
    if (query.startsWith(""measure"")) {
        query = query.substring(""measure"".length()).trim();
        statement.setMeasure(true);
    }
    if (query.isEmpty()) {
        // special case, will always result in an empty result
        query = ""//jcr:root"";
    }
    statement.setOriginalQuery(query);
    initialize(query);
    expected = new ArrayList<String>();
    read();
    if (currentTokenType == END) {
        throw getSyntaxError(""the query may not be empty"");
    }
    currentSelector.name = ""a"";
    String pathPattern = """";
    boolean startOfQuery = true;
    while (true) {
        // if true, path or nodeType conditions are not allowed
        boolean shortcut = false;
        boolean slash = readIf(""/"");
        if (!slash) {
            if (startOfQuery) {
                // the query doesn't start with ""/""
                currentSelector.path = ""/"";
                pathPattern = ""/"";
                currentSelector.isChild = true;
            } else {
                break;
            }
        } else if (readIf(""jcr:root"")) {
            // ""/jcr:root"" may only appear at the beginning
            if (!pathPattern.isEmpty()) {
                throw getSyntaxError(""jcr:root needs to be at the beginning"");
            }
            if (readIf(""/"")) {
                // ""/jcr:root/""
                currentSelector.path = ""/"";
                pathPattern = ""/"";
                if (readIf(""/"")) {
                    // ""/jcr:root//""
                    pathPattern = ""//"";
                    currentSelector.isDescendant = true;
                } else {
                    currentSelector.isChild = true;
                }
            } else {
                // for example ""/jcr:root[condition]""
                pathPattern = ""/%"";
                currentSelector.path = ""/"";
                shortcut = true;
            }
        } else if (readIf(""/"")) {
            // ""//"" was read
            pathPattern += ""%"";
            if (currentSelector.isDescendant) {
                // the query started with ""//"", and now ""//"" was read
                nextSelector(true);
            }
            currentSelector.isDescendant = true;
        } else {
            // the token ""/"" was read
            pathPattern += ""/"";
            if (startOfQuery) {
                currentSelector.path = ""/"";
            } else {
                if (currentSelector.isDescendant) {
                    // the query started with ""//"", and now ""/"" was read
                    nextSelector(true);
                }
                currentSelector.isChild = true;
            }
        }
        int startParseIndex = parseIndex;
        if (shortcut) {
        // ""*"" and so on are not allowed now
        } else if (readIf(""*"")) {
            // ""...*""
            pathPattern += ""%"";
            if (!currentSelector.isDescendant) {
                if (selectors.size() == 0 && currentSelector.path.equals("""")) {
                    // the query /* is special
                    currentSelector.path = ""/"";
                }
            }
        } else if (readIf(""text"")) {
            // ""...text()""
            currentSelector.isChild = false;
            pathPattern += ""jcr:xmltext"";
            read(""("");
            read("")"");
            if (currentSelector.isDescendant) {
                currentSelector.nodeName = ""jcr:xmltext"";
            } else {
                currentSelector.path = PathUtils.concat(currentSelector.path, ""jcr:xmltext"");
            }
        } else if (readIf(""element"")) {
            // ""...element(...""
            read(""("");
            if (readIf("")"")) {
                // any
                pathPattern += ""%"";
            } else {
                if (readIf(""*"")) {
                    // any
                    pathPattern += ""%"";
                } else {
                    String name = readPathSegment();
                    pathPattern += name;
                    appendNodeName(name);
                }
                if (readIf("","")) {
                    currentSelector.nodeType = readIdentifier();
                }
                read("")"");
            }
        } else if (readIf(""@"")) {
            rewindSelector();
            Expression.Property p = readProperty();
            statement.addSelectColumn(p);
        } else if (readIf(""rep:excerpt"")) {
            rewindSelector();
            readExcerpt();
            Expression.Property p = new Expression.Property(currentSelector, ""rep:excerpt"", false);
            statement.addSelectColumn(p);
        } else if (readIf(""("")) {
            rewindSelector();
            do {
                if (readIf(""@"")) {
                    Expression.Property p = readProperty();
                    statement.addSelectColumn(p);
                } else if (readIf(""rep:excerpt"")) {
                    readExcerpt();
                    Expression.Property p = new Expression.Property(currentSelector, ""rep:excerpt"", false);
                    statement.addSelectColumn(p);
                } else if (readIf(""rep:spellcheck"")) {
                    // only rep:spellcheck() is currently supported
                    read(""("");
                    read("")"");
                    Expression.Property p = new Expression.Property(currentSelector, ""rep:spellcheck()"", false);
                    statement.addSelectColumn(p);
                } else if (readIf(""rep:suggest"")) {
                    readExcerpt();
                    Expression.Property p = new Expression.Property(currentSelector, ""rep:suggest()"", false);
                    statement.addSelectColumn(p);
                }
            } while (readIf(""|""));
            if (!readIf("")"")) {
                return convertToUnion(query, statement, startParseIndex - 1);
            }
        } else if (currentTokenType == IDENTIFIER) {
            // path restriction
            String name = readPathSegment();
            pathPattern += name;
            appendNodeName(name);
        } else if (readIf(""."")) {
            // ""a/./b"" is the same as ""a/b""
            if (readIf(""."")) {
                // "".."" means ""the parent of the node""
                // handle like a regular path restriction
                String name = "".."";
                pathPattern += name;
                if (!currentSelector.isChild) {
                    currentSelector.nodeName = name;
                } else {
                    if (currentSelector.isChild) {
                        currentSelector.isChild = false;
                        currentSelector.isParent = true;
                    }
                }
            } else {
                if (selectors.size() > 0) {
                    currentSelector = selectors.remove(selectors.size() - 1);
                    currentSelector.condition = null;
                    currentSelector.joinCondition = null;
                }
            }
        } else {
            throw getSyntaxError();
        }
        if (readIf(""["")) {
            Expression c = parseConstraint();
            currentSelector.condition = Expression.and(currentSelector.condition, c);
            read(""]"");
        }
        startOfQuery = false;
        nextSelector(false);
    }
    if (selectors.size() == 0) {
        nextSelector(true);
    }
    // the current selector wasn't used so far
    // go back to the last one
    currentSelector = selectors.get(selectors.size() - 1);
    if (selectors.size() == 1) {
        currentSelector.onlySelector = true;
    }
    if (readIf(""order"")) {
        read(""by"");
        do {
            Order order = new Order();
            order.expr = parseExpression();
            if (readIf(""descending"")) {
                order.descending = true;
            } else {
                readIf(""ascending"");
            }
            statement.addOrderBy(order);
        } while (readIf("",""));
    }
    if (!currentToken.isEmpty()) {
        throw getSyntaxError(""<end>"");
    }
    statement.setColumnSelector(currentSelector);
    statement.setSelectors(selectors);
    Expression where = null;
    for (Selector s : selectors) {
        where = Expression.and(where, s.condition);
    }
    statement.setWhere(where);
    return statement;
}",,"private Statement convertToStatement(String query) throws ParseException {
    query = query.trim();
    Statement statement = new Statement();
    if (query.startsWith(""explain "")) {
        query = query.substring(""explain"".length()).trim();
        statement.setExplain(true);
    }
    if (query.startsWith(""measure"")) {
        query = query.substring(""measure"".length()).trim();
        statement.setMeasure(true);
    }
    if (query.isEmpty()) {
                query = ""//jcr:root"";
    }
    statement.setOriginalQuery(query);
    initialize(query);
    expected = new ArrayList<String>();
    read();
    if (currentTokenType == END) {
        throw getSyntaxError(""the query may not be empty"");
    }
    currentSelector.name = ""a"";
    String pathPattern = """";
    boolean startOfQuery = true;
    while (true) {
                boolean shortcut = false;
        boolean slash = readIf(""/"");
        if (!slash) {
            if (startOfQuery) {
                                currentSelector.path = ""/"";
                pathPattern = ""/"";
                currentSelector.isChild = true;
            } else {
                break;
            }
        } else if (readIf(""jcr:root"")) {
                        if (!pathPattern.isEmpty()) {
                throw getSyntaxError(""jcr:root needs to be at the beginning"");
            }
            if (readIf(""/"")) {
                                currentSelector.path = ""/"";
                pathPattern = ""/"";
                if (readIf(""/"")) {
                                        pathPattern = ""//"";
                    currentSelector.isDescendant = true;
                } else {
                    currentSelector.isChild = true;
                }
            } else {
                                pathPattern = ""/%"";
                currentSelector.path = ""/"";
                shortcut = true;
            }
        } else if (readIf(""/"")) {
                        pathPattern += ""%"";
            if (currentSelector.isDescendant) {
                                nextSelector(true);
            }
            currentSelector.isDescendant = true;
        } else {
                        pathPattern += ""/"";
            if (startOfQuery) {
                currentSelector.path = ""/"";
            } else {
                if (currentSelector.isDescendant) {
                                        nextSelector(true);
                }
                currentSelector.isChild = true;
            }
        }
        int startParseIndex = parseIndex;
        if (shortcut) {
                } else if (readIf(""*"")) {
                        pathPattern += ""%"";
            if (!currentSelector.isDescendant) {
                if (selectors.size() == 0 && currentSelector.path.equals("""")) {
                                        currentSelector.path = ""/"";
                }
            }
        } else if (readIf(""text"")) {
                        currentSelector.isChild = false;
            pathPattern += ""jcr:xmltext"";
            read(""("");
            read("")"");
            if (currentSelector.isDescendant) {
                currentSelector.nodeName = ""jcr:xmltext"";
            } else {
                currentSelector.path = PathUtils.concat(currentSelector.path, ""jcr:xmltext"");
            }
        } else if (readIf(""element"")) {
                        read(""("");
            if (readIf("")"")) {
                                pathPattern += ""%"";
            } else {
                if (readIf(""*"")) {
                                        pathPattern += ""%"";
                } else {
                    String name = readPathSegment();
                    pathPattern += name;
                    appendNodeName(name);
                }
                if (readIf("","")) {
                    currentSelector.nodeType = readIdentifier();
                }
                read("")"");
            }
        } else if (readIf(""@"")) {
            rewindSelector();
            Expression.Property p = readProperty();
            statement.addSelectColumn(p);
        } else if (readIf(""rep:excerpt"")) {
            rewindSelector();
            readExcerpt();
            Expression.Property p = new Expression.Property(currentSelector, ""rep:excerpt"", false);
            statement.addSelectColumn(p);
        } else if (readIf(""("")) {
            rewindSelector();
            do {
                if (readIf(""@"")) {
                    Expression.Property p = readProperty();
                    statement.addSelectColumn(p);
                } else if (readIf(""rep:excerpt"")) {
                    readExcerpt();
                    Expression.Property p = new Expression.Property(currentSelector, ""rep:excerpt"", false);
                    statement.addSelectColumn(p);
                } else if (readIf(""rep:spellcheck"")) {
                                        read(""("");
                    read("")"");
                    Expression.Property p = new Expression.Property(currentSelector, ""rep:spellcheck()"", false);
                    statement.addSelectColumn(p);
                } else if (readIf(""rep:suggest"")) {
                    readExcerpt();
                    Expression.Property p = new Expression.Property(currentSelector, ""rep:suggest()"", false);
                    statement.addSelectColumn(p);
                }
            } while (readIf(""|""));
            if (!readIf("")"")) {
                return convertToUnion(query, statement, startParseIndex - 1);
            }
        } else if (currentTokenType == IDENTIFIER) {
                        String name = readPathSegment();
            pathPattern += name;
            appendNodeName(name);
        } else if (readIf(""."")) {
                        if (readIf(""."")) {
                                                String name = "".."";
                pathPattern += name;
                if (!currentSelector.isChild) {
                    currentSelector.nodeName = name;
                } else {
                    if (currentSelector.isChild) {
                        currentSelector.isChild = false;
                        currentSelector.isParent = true;
                    }
                }
            } else {
                if (selectors.size() > 0) {
                    currentSelector = selectors.remove(selectors.size() - 1);
                    currentSelector.condition = null;
                    currentSelector.joinCondition = null;
                }
            }
        } else {
            throw getSyntaxError();
        }
        if (readIf(""["")) {
            Expression c = parseConstraint();
            currentSelector.condition = Expression.and(currentSelector.condition, c);
            read(""]"");
        }
        startOfQuery = false;
        nextSelector(false);
    }
    if (selectors.size() == 0) {
        nextSelector(true);
    }
            currentSelector = selectors.get(selectors.size() - 1);
    if (selectors.size() == 1) {
        currentSelector.onlySelector = true;
    }
    if (readIf(""order"")) {
        read(""by"");
        do {
            Order order = new Order();
            order.expr = parseExpression();
            if (readIf(""descending"")) {
                order.descending = true;
            } else {
                readIf(""ascending"");
            }
            statement.addOrderBy(order);
        } while (readIf("",""));
    }
    if (!currentToken.isEmpty()) {
        throw getSyntaxError(""<end>"");
    }
    statement.setColumnSelector(currentSelector);
    statement.setSelectors(selectors);
    Expression where = null;
    for (Selector s : selectors) {
        where = Expression.and(where, s.condition);
    }
    statement.setWhere(where);
    return statement;
}",8.681818181818182,1.1938775510204083,8.333333333333334,5.5,6.083333333333333,1.7864557587740981,-2.0177803269285923,7.666666666666667,-0.028571428571428574,16.130169050158255
wicket,remotes/origin/bugs-dot-jar_WICKET-3965_6051019b,1,"/**
 *  Gets a URL for the listener interface (e.g. ILinkListener).
 *
 *  @see RequestCycle#urlFor(IRequestHandler)
 *
 *  @param listener
 *             The listener interface that the URL should call
 *  @return The URL
 */
public final CharSequence urlFor(final RequestListenerInterface listener) {
    PageAndComponentProvider provider = new PageAndComponentProvider(getPage(), this);
    IRequestHandler handler;
    if (getPage().isPageStateless()) {
        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener);
    } else {
        handler = new ListenerInterfaceRequestHandler(provider, listener);
    }
    return getRequestCycle().urlFor(handler);
}","/**
 *  Gets a URL for the listener interface (e.g. ILinkListener).
 *
 *  @see RequestCycle#urlFor(IRequestHandler)
 *
 *  @param listener
 *             The listener interface that the URL should call
 *  @return The URL
 */
","public final CharSequence urlFor(final RequestListenerInterface listener) {
    PageAndComponentProvider provider = new PageAndComponentProvider(getPage(), this);
    IRequestHandler handler;
    if (getPage().isPageStateless()) {
        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener);
    } else {
        handler = new ListenerInterfaceRequestHandler(provider, listener);
    }
    return getRequestCycle().urlFor(handler);
}",-0.18181818181818182,-0.2500000000000001,-0.3333333333333333,-0.5,-0.25,-0.3806228373702422,0.2494981359334673,-0.08333333333333333,0.5714285714285714,-0.16422749602751402
Codec,17,1,"/**
 * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.
 *
 * @param bytes
 *            The bytes to be decoded into characters, may be <code>null</code>
 * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or
 *         <code>null</code> if the input byte array was <code>null</code>.
 * @throws NullPointerException
 *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
 */
public static String newStringIso8859_1(final byte[] bytes) {
    return new String(bytes, Charsets.ISO_8859_1);
}","/**
 * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.
 *
 * @param bytes
 *            The bytes to be decoded into characters, may be <code>null</code>
 * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or
 *         <code>null</code> if the input byte array was <code>null</code>.
 * @throws NullPointerException
 *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
 */
","public static String newStringIso8859_1(final byte[] bytes) {
    return new String(bytes, Charsets.ISO_8859_1);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.0585030111843994,-0.5,0.028571428571428574,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-5681_78c73502,1,"public Exchange call() throws Exception {
    // the aggregation task to early and pile up too many threads
    if (aggregationTaskSubmitted.compareAndSet(false, true)) {
        // but only submit the task once
        aggregateExecutorService.submit(aggregateOnTheFlyTask);
    }
    if (!running.get()) {
        // do not start processing the task if we are not running
        return subExchange;
    }
    try {
        doProcessParallel(pair);
    } catch (Throwable e) {
        subExchange.setException(e);
    }
    // Decide whether to continue with the multicast or not; similar logic to the Pipeline
    Integer number = getExchangeIndex(subExchange);
    boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, ""Parallel processing failed for number "" + number, LOG);
    if (stopOnException && !continueProcessing) {
        // signal to stop running
        running.set(false);
        // throw caused exception
        if (subExchange.getException() != null) {
            // wrap in exception to explain where it failed
            throw new CamelExchangeException(""Parallel processing failed for number "" + number, subExchange, subExchange.getException());
        }
    }
    LOG.trace(""Parallel processing complete for exchange: {}"", subExchange);
    return subExchange;
}",,"public Exchange call() throws Exception {
        if (aggregationTaskSubmitted.compareAndSet(false, true)) {
                aggregateExecutorService.submit(aggregateOnTheFlyTask);
    }
    if (!running.get()) {
                return subExchange;
    }
    try {
        doProcessParallel(pair);
    } catch (Throwable e) {
        subExchange.setException(e);
    }
        Integer number = getExchangeIndex(subExchange);
    boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, ""Parallel processing failed for number "" + number, LOG);
    if (stopOnException && !continueProcessing) {
                running.set(false);
                if (subExchange.getException() != null) {
                        throw new CamelExchangeException(""Parallel processing failed for number "" + number, subExchange, subExchange.getException());
        }
    }
    LOG.trace(""Parallel processing complete for exchange: {}"", subExchange);
    return subExchange;
}",0.4090909090909091,-0.13775510204081634,0.5,0.0,0.4166666666666667,0.2303509639149778,-0.330943504445082,0.4166666666666667,-0.028571428571428574,0.24566881245154848
Closure,148,2,"private void closeLine() throws IOException {
    out.append(""]\n"");
}",,"private void closeLine() throws IOException {
    out.append(""]\n"");
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.1015199311729282,-0.4166666666666667,2.4571428571428573,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-5965_31c88569,1,"/**
 *  Handle tag &lt;head&gt;
 *  @param tag
 */
private void handleHeadTag(ComponentTag tag) {
    // we found <head>
    if (tag.isOpen()) {
        if (foundHead) {
            throw new MarkupException(new MarkupStream(markup), ""Tag <head> is not allowed at this position (do you have multiple <head> tags in your markup?)."");
        }
        foundHead = true;
        if (tag.getId() == null) {
            tag.setId(HEADER_ID);
            tag.setAutoComponentTag(true);
            tag.setModified(true);
        }
    } else if (tag.isClose()) {
        if (foundHeaderItemsTag) {
            // revert the settings from above
            ComponentTag headOpenTag = tag.getOpenTag();
            // change the id because it is special. See HtmlHeaderResolver
            headOpenTag.setId(HEADER_ID + ""-Ignored"");
            headOpenTag.setAutoComponentTag(false);
            headOpenTag.setModified(false);
            headOpenTag.setFlag(ComponentTag.RENDER_RAW, true);
        }
        foundClosingHead = true;
    }
}","/**
 *  Handle tag &lt;head&gt;
 *  @param tag
 */
","private void handleHeadTag(ComponentTag tag) {
        if (tag.isOpen()) {
        if (foundHead) {
            throw new MarkupException(new MarkupStream(markup), ""Tag <head> is not allowed at this position (do you have multiple <head> tags in your markup?)."");
        }
        foundHead = true;
        if (tag.getId() == null) {
            tag.setId(HEADER_ID);
            tag.setAutoComponentTag(true);
            tag.setModified(true);
        }
    } else if (tag.isClose()) {
        if (foundHeaderItemsTag) {
                        ComponentTag headOpenTag = tag.getOpenTag();
                        headOpenTag.setId(HEADER_ID + ""-Ignored"");
            headOpenTag.setAutoComponentTag(false);
            headOpenTag.setModified(false);
            headOpenTag.setFlag(ComponentTag.RENDER_RAW, true);
        }
        foundClosingHead = true;
    }
}",0.36363636363636365,0.3979591836734693,0.5,0.5,0.4166666666666667,-0.00889767671774591,-0.2856323487238317,0.4166666666666667,-0.028571428571428574,0.04751992667497569
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1822_3e83a4c1,1,"/**
 * Apply the changes to the in-memory document.
 *
 * @param doc
 *            the target document.
 * @param update
 *            the changes to apply.
 * @param comparator
 *            the revision comparator.
 */
public static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update, @Nonnull Comparator<Revision> comparator) {
    for (Entry<Key, Operation> e : checkNotNull(update).getChanges().entrySet()) {
        Key k = e.getKey();
        Operation op = e.getValue();
        switch(op.type) {
            case SET:
                {
                    doc.put(k.toString(), op.value);
                    break;
                }
            case INCREMENT:
                {
                    Object old = doc.get(k.toString());
                    Long x = (Long) op.value;
                    if (old == null) {
                        old = 0L;
                    }
                    doc.put(k.toString(), ((Long) old) + x);
                    break;
                }
            case SET_MAP_ENTRY:
                {
                    Object old = doc.get(k.getName());
                    @SuppressWarnings(""unchecked"")
                    Map<Revision, Object> m = (Map<Revision, Object>) old;
                    if (m == null) {
                        m = new TreeMap<Revision, Object>(comparator);
                        doc.put(k.getName(), m);
                    }
                    if (k.getRevision() == null) {
                        throw new IllegalArgumentException(""Cannot set map entry "" + k.getName() + "" with null revision"");
                    }
                    m.put(k.getRevision(), op.value);
                    break;
                }
            case REMOVE_MAP_ENTRY:
                {
                    Object old = doc.get(k.getName());
                    @SuppressWarnings(""unchecked"")
                    Map<Revision, Object> m = (Map<Revision, Object>) old;
                    if (m != null) {
                        m.remove(k.getRevision());
                    }
                    break;
                }
            case CONTAINS_MAP_ENTRY:
                // no effect
                break;
        }
    }
}","/**
 * Apply the changes to the in-memory document.
 *
 * @param doc
 *            the target document.
 * @param update
 *            the changes to apply.
 * @param comparator
 *            the revision comparator.
 */
","public static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update, @Nonnull Comparator<Revision> comparator) {
    for (Entry<Key, Operation> e : checkNotNull(update).getChanges().entrySet()) {
        Key k = e.getKey();
        Operation op = e.getValue();
        switch(op.type) {
            case SET:
                {
                    doc.put(k.toString(), op.value);
                    break;
                }
            case INCREMENT:
                {
                    Object old = doc.get(k.toString());
                    Long x = (Long) op.value;
                    if (old == null) {
                        old = 0L;
                    }
                    doc.put(k.toString(), ((Long) old) + x);
                    break;
                }
            case SET_MAP_ENTRY:
                {
                    Object old = doc.get(k.getName());
                    @SuppressWarnings(""unchecked"")
                    Map<Revision, Object> m = (Map<Revision, Object>) old;
                    if (m == null) {
                        m = new TreeMap<Revision, Object>(comparator);
                        doc.put(k.getName(), m);
                    }
                    if (k.getRevision() == null) {
                        throw new IllegalArgumentException(""Cannot set map entry "" + k.getName() + "" with null revision"");
                    }
                    m.put(k.getRevision(), op.value);
                    break;
                }
            case REMOVE_MAP_ENTRY:
                {
                    Object old = doc.get(k.getName());
                    @SuppressWarnings(""unchecked"")
                    Map<Revision, Object> m = (Map<Revision, Object>) old;
                    if (m != null) {
                        m.remove(k.getRevision());
                    }
                    break;
                }
            case CONTAINS_MAP_ENTRY:
                                break;
        }
    }
}",1.6363636363636365,1.5306122448979589,2.1666666666666665,1.0,0.6666666666666666,0.6653484923381119,-0.9019214224261546,1.4166666666666667,-0.028571428571428574,1.683276155233188
Closure,136,2,"/**
 * Adds a node that may represent a function signature (if it's a function
 * itself or the name of a function).
 */
private void addPossibleSignature(String name, Node node, NodeTraversal t) {
    boolean signatureAdded = false;
    if (node.getType() == Token.FUNCTION) {
        // The node we're looking at is a function, so we can add it directly
        addSignature(name, node, t.getSourceName());
        signatureAdded = true;
    } else if (node.getType() == Token.NAME) {
        String functionName = node.getString();
        Scope.Var v = t.getScope().getVar(functionName);
        if (v == null) {
            if (compiler.isIdeMode()) {
                return;
            } else {
                throw new IllegalStateException(""VarCheck should have caught this undefined function"");
            }
        }
        Node function = v.getInitialValue();
        if (function != null && function.getType() == Token.FUNCTION) {
            addSignature(name, function, v.getInputName());
            signatureAdded = true;
        }
    }
    if (!signatureAdded) {
        nonMethodProperties.add(name);
    }
}","/**
 * Adds a node that may represent a function signature (if it's a function
 * itself or the name of a function).
 */
","private void addPossibleSignature(String name, Node node, NodeTraversal t) {
    boolean signatureAdded = false;
    if (node.getType() == Token.FUNCTION) {
                addSignature(name, node, t.getSourceName());
        signatureAdded = true;
    } else if (node.getType() == Token.NAME) {
        String functionName = node.getString();
        Scope.Var v = t.getScope().getVar(functionName);
        if (v == null) {
            if (compiler.isIdeMode()) {
                return;
            } else {
                throw new IllegalStateException(""VarCheck should have caught this undefined function"");
            }
        }
        Node function = v.getInitialValue();
        if (function != null && function.getType() == Token.FUNCTION) {
            addSignature(name, function, v.getInputName());
            signatureAdded = true;
        }
    }
    if (!signatureAdded) {
        nonMethodProperties.add(name);
    }
}",0.5,0.5765306122448981,0.6666666666666666,1.0,0.6666666666666666,0.3529411764705883,-0.4149698881560081,0.5833333333333334,-0.028571428571428574,0.47334900912708094
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-178_2f0643a9,3,"protected Key buildDocKey() {
    if (log.isTraceEnabled())
        log.trace(""building doc key for "" + currentPartition + "" "" + currentDocID);
    int zeroIndex = currentDocID.find(""\0"");
    if (zeroIndex < 0)
        throw new IllegalArgumentException(""bad current docID"");
    Text colf = new Text(docColf);
    colf.append(nullByte, 0, 1);
    colf.append(currentDocID.getBytes(), 0, zeroIndex);
    docColfSet = Collections.singleton((ByteSequence) new ArrayByteSequence(colf.getBytes(), 0, colf.getLength()));
    if (log.isTraceEnabled())
        log.trace(zeroIndex + "" "" + currentDocID.getLength());
    Text colq = new Text();
    colq.set(currentDocID.getBytes(), zeroIndex + 1, currentDocID.getLength() - zeroIndex - 2);
    Key k = new Key(currentPartition, colf, colq);
    if (log.isTraceEnabled())
        log.trace(""built doc key for seek: "" + k.toString());
    return k;
}",,"protected Key buildDocKey() {
    if (log.isTraceEnabled())
        log.trace(""building doc key for "" + currentPartition + "" "" + currentDocID);
    int zeroIndex = currentDocID.find(""\0"");
    if (zeroIndex < 0)
        throw new IllegalArgumentException(""bad current docID"");
    Text colf = new Text(docColf);
    colf.append(nullByte, 0, 1);
    colf.append(currentDocID.getBytes(), 0, zeroIndex);
    docColfSet = Collections.singleton((ByteSequence) new ArrayByteSequence(colf.getBytes(), 0, colf.getLength()));
    if (log.isTraceEnabled())
        log.trace(zeroIndex + "" "" + currentDocID.getLength());
    Text colq = new Text();
    colq.set(currentDocID.getBytes(), zeroIndex + 1, currentDocID.getLength() - zeroIndex - 2);
    Key k = new Key(currentPartition, colf, colq);
    if (log.isTraceEnabled())
        log.trace(""built doc key for seek: "" + k.toString());
    return k;
}",0.22727272727272727,-0.413265306122449,0.3333333333333333,-1.0,0.08333333333333333,0.5111220958971825,-0.299684542586751,1.0,-0.028571428571428574,0.7554961645701364
wicket,remotes/origin/bugs-dot-jar_WICKET-5165_0d4d1df7,1,"/**
 *  @param url
 *  @param requestCycle
 */
protected void redirectTo(Url url, RequestCycle requestCycle) {
    WebResponse response = (WebResponse) requestCycle.getResponse();
    String relativeUrl = requestCycle.getUrlRenderer().renderUrl(url);
    response.sendRedirect(relativeUrl);
}","/**
 *  @param url
 *  @param requestCycle
 */
","protected void redirectTo(Url url, RequestCycle requestCycle) {
    WebResponse response = (WebResponse) requestCycle.getResponse();
    String relativeUrl = requestCycle.getUrlRenderer().renderUrl(url);
    response.sendRedirect(relativeUrl);
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.6088328075709782,-0.16666666666666666,2.342857142857143,-0.16422749602751402
Closure,175,2,"/**
 * Determines whether a function can be inlined at a particular call site.
 * There are several criteria that the function and reference must hold in
 * order for the functions to be inlined:
 * 1) If a call's arguments have side effects,
 * the corresponding argument in the function must only be referenced once.
 * For instance, this will not be inlined:
 * <pre>
 *     function foo(a) { return a + a }
 *     x = foo(i++);
 * </pre>
 */
private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
        return CanInlineResult.NO;
    }
    Node block = fnNode.getLastChild();
    // CALL NODE: [ NAME, ARG1, ARG2, ... ]
    Node cArg = callNode.getFirstChild().getNext();
    // parameter list.
    if (!callNode.getFirstChild().isName()) {
        if (NodeUtil.isFunctionObjectCall(callNode)) {
            // TODO(johnlenz): Support replace this with a value.
            if (cArg == null || !cArg.isThis()) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        } else {
            // "".apply"" call should be filtered before this.
            Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
        }
    }
    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
        if (fnParam != null) {
            if (cArg != null) {
                if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {
                    return CanInlineResult.NO;
                }
            }
            fnParam = fnParam.getNext();
        }
        // Limit the inlining
        if (cArg != null) {
            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        }
    }
    return CanInlineResult.YES;
}","/**
 * Determines whether a function can be inlined at a particular call site.
 * There are several criteria that the function and reference must hold in
 * order for the functions to be inlined:
 * 1) If a call's arguments have side effects,
 * the corresponding argument in the function must only be referenced once.
 * For instance, this will not be inlined:
 * <pre>
 *     function foo(a) { return a + a }
 *     x = foo(i++);
 * </pre>
 */
","private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
        return CanInlineResult.NO;
    }
    Node block = fnNode.getLastChild();
        Node cArg = callNode.getFirstChild().getNext();
        if (!callNode.getFirstChild().isName()) {
        if (NodeUtil.isFunctionObjectCall(callNode)) {
                        if (cArg == null || !cArg.isThis()) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        } else {
                        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
        }
    }
    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
        if (fnParam != null) {
            if (cArg != null) {
                if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {
                    return CanInlineResult.NO;
                }
            }
            fnParam = fnParam.getNext();
        }
                if (cArg != null) {
            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
                return CanInlineResult.NO;
            }
            cArg = cArg.getNext();
        }
    }
    return CanInlineResult.YES;
}",0.9545454545454546,0.9387755102040818,1.1666666666666667,1.0,1.8333333333333333,1.240731586752348,-0.6329222827645544,1.0833333333333333,-0.028571428571428574,1.7019586176177075
camel,remotes/origin/bugs-dot-jar_CAMEL-6447_020c451a,1,"private boolean process(final Exchange exchange, final AsyncCallback callback, final Iterator<Processor> processors, final AsyncProcessor asyncProcessor) {
    // this does the actual processing so log at trace level
    LOG.trace(""Processing exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
    // implement asynchronous routing logic in callback so we can have the callback being
    // triggered and then continue routing where we left
    boolean sync = asyncProcessor.process(exchange, new AsyncCallback() {

        public void done(boolean doneSync) {
            // we only have to handle async completion of the pipeline
            if (doneSync) {
                return;
            }
            // continue processing the pipeline asynchronously
            while (continueRouting(processors, exchange)) {
                AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());
                // check for error if so we should break out
                if (!continueProcessing(exchange, ""so breaking out of pipeline"", LOG)) {
                    break;
                }
                doneSync = process(exchange, callback, processors, processor);
                if (!doneSync) {
                    LOG.trace(""Processing exchangeId: {} is continued being processed asynchronously"", exchange.getExchangeId());
                    return;
                }
            }
            LOG.trace(""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
            callback.done(false);
        }
    });
    return sync;
}",,"private boolean process(final Exchange exchange, final AsyncCallback callback, final Iterator<Processor> processors, final AsyncProcessor asyncProcessor) {
        LOG.trace(""Processing exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
            boolean sync = asyncProcessor.process(exchange, new AsyncCallback() {

        public void done(boolean doneSync) {
                        if (doneSync) {
                return;
            }
                        while (continueRouting(processors, exchange)) {
                AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());
                                if (!continueProcessing(exchange, ""so breaking out of pipeline"", LOG)) {
                    break;
                }
                doneSync = process(exchange, callback, processors, processor);
                if (!doneSync) {
                    LOG.trace(""Processing exchangeId: {} is continued being processed asynchronously"", exchange.getExchangeId());
                    return;
                }
            }
            LOG.trace(""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
            callback.done(false);
        }
    });
    return sync;
}",0.45454545454545453,1.5357142857142858,0.3333333333333333,0.5,0.3333333333333333,0.04251112209589725,-0.34843705190708374,0.5833333333333334,-0.028571428571428574,0.12849867869334122
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-93_0be7e8f0,1,"@Override
public void removeProperty(String name) {
    builder.removeProperty(name);
    if (listener != null) {
        listener.removeProperty(this, name);
    }
}",,"@Override
public void removeProperty(String name) {
    builder.removeProperty(name);
    if (listener != null) {
        listener.removeProperty(this, name);
    }
}",-0.3181818181818182,-0.11224489795918377,-0.3333333333333333,-0.5,-0.25,-0.3806228373702422,0.544307427588185,-0.3333333333333333,0.6571428571428571,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1779_9d36bede,0,"private void collectDeletedDocuments(VersionGCStats stats, Revision headRevision, long oldestRevTimeStamp) {
    List<String> docIdsToDelete = new ArrayList<String>();
    Iterable<NodeDocument> itr = versionStore.getPossiblyDeletedDocs(oldestRevTimeStamp);
    try {
        for (NodeDocument doc : itr) {
            // So deleting it is safe
            if (doc.getNodeAtRevision(nodeStore, headRevision, null) == null) {
                docIdsToDelete.add(doc.getId());
                // Collect id of all previous docs also
                for (NodeDocument prevDoc : ImmutableList.copyOf(doc.getAllPreviousDocs())) {
                    docIdsToDelete.add(prevDoc.getId());
                }
            }
        }
    } finally {
        Utils.closeIfCloseable(itr);
    }
    if (log.isDebugEnabled()) {
        StringBuilder sb = new StringBuilder(""Deleted document with following ids were deleted as part of GC \n"");
        Joiner.on(StandardSystemProperty.LINE_SEPARATOR.value()).appendTo(sb, docIdsToDelete);
        log.debug(sb.toString());
    }
    nodeStore.getDocumentStore().remove(Collection.NODES, docIdsToDelete);
    stats.deletedDocGCCount += docIdsToDelete.size();
}",,"private void collectDeletedDocuments(VersionGCStats stats, Revision headRevision, long oldestRevTimeStamp) {
    List<String> docIdsToDelete = new ArrayList<String>();
    Iterable<NodeDocument> itr = versionStore.getPossiblyDeletedDocs(oldestRevTimeStamp);
    try {
        for (NodeDocument doc : itr) {
                        if (doc.getNodeAtRevision(nodeStore, headRevision, null) == null) {
                docIdsToDelete.add(doc.getId());
                                for (NodeDocument prevDoc : ImmutableList.copyOf(doc.getAllPreviousDocs())) {
                    docIdsToDelete.add(prevDoc.getId());
                }
            }
        }
    } finally {
        Utils.closeIfCloseable(itr);
    }
    if (log.isDebugEnabled()) {
        StringBuilder sb = new StringBuilder(""Deleted document with following ids were deleted as part of GC \n"");
        Joiner.on(StandardSystemProperty.LINE_SEPARATOR.value()).appendTo(sb, docIdsToDelete);
        log.debug(sb.toString());
    }
    nodeStore.getDocumentStore().remove(Collection.NODES, docIdsToDelete);
    stats.deletedDocGCCount += docIdsToDelete.size();
}",0.4090909090909091,1.1428571428571428,0.16666666666666666,1.0,0.08333333333333333,-0.07810182896688084,-0.3682248351018069,1.0,-0.028571428571428574,0.12090491303360874
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3028_89317b28,0,"/**
 * Apply the changes to the document store.
 *
 * @param baseBranchRevision the base revision of this commit. Currently only
 *                     used for branch commits.
 */
private void applyToDocumentStore(Revision baseBranchRevision) {
    // the value in _revisions.<revision> property of the commit root node
    // regular commits use ""c"", which makes the commit visible to
    // other readers. branch commits use the base revision to indicate
    // the visibility of the commit
    String commitValue = baseBranchRevision != null ? baseBranchRevision.toString() : ""c"";
    DocumentStore store = nodeStore.getDocumentStore();
    String commitRootPath = null;
    if (baseBranchRevision != null) {
        // branch commits always use root node as commit root
        commitRootPath = ""/"";
    }
    ArrayList<UpdateOp> newNodes = new ArrayList<UpdateOp>();
    ArrayList<UpdateOp> changedNodes = new ArrayList<UpdateOp>();
    // operations are added to this list before they are executed,
    // so that all operations can be rolled back if there is a conflict
    ArrayList<UpdateOp> opLog = new ArrayList<UpdateOp>();
    // Compute the commit root
    for (String p : operations.keySet()) {
        markChanged(p);
        if (commitRootPath == null) {
            commitRootPath = p;
        } else {
            while (!PathUtils.isAncestor(commitRootPath, p)) {
                commitRootPath = PathUtils.getParentPath(commitRootPath);
                if (denotesRoot(commitRootPath)) {
                    break;
                }
            }
        }
    }
    // push branch changes to journal
    if (baseBranchRevision != null) {
        // store as external change
        JournalEntry doc = JOURNAL.newDocument(store);
        doc.modified(modifiedNodes);
        Revision r = revision.asBranchRevision();
        store.create(JOURNAL, singletonList(doc.asUpdateOp(r)));
    }
    int commitRootDepth = PathUtils.getDepth(commitRootPath);
    // check if there are real changes on the commit root
    boolean commitRootHasChanges = operations.containsKey(commitRootPath);
    // create a ""root of the commit"" if there is none
    UpdateOp commitRoot = getUpdateOperationForNode(commitRootPath);
    for (String p : operations.keySet()) {
        UpdateOp op = operations.get(p);
        if (op.isNew()) {
            NodeDocument.setDeleted(op, revision, false);
        }
        if (op == commitRoot) {
            if (!op.isNew() && commitRootHasChanges) {
                // commit root already exists and this is an update
                changedNodes.add(op);
            }
        } else {
            NodeDocument.setCommitRoot(op, revision, commitRootDepth);
            if (op.isNew()) {
                newNodes.add(op);
            } else {
                changedNodes.add(op);
            }
        }
    }
    if (changedNodes.size() == 0 && commitRoot.isNew()) {
        // no updates and root of commit is also new. that is,
        // it is the root of a subtree added in a commit.
        // so we try to add the root like all other nodes
        NodeDocument.setRevision(commitRoot, revision, commitValue);
        newNodes.add(commitRoot);
    }
    try {
        if (newNodes.size() > 0) {
            // set commit root on new nodes
            if (!store.create(NODES, newNodes)) {
                // try to apply all changes one by one
                for (UpdateOp op : newNodes) {
                    if (op == commitRoot) {
                        // don't write the commit root just yet
                        // (because there might be a conflict)
                        NodeDocument.unsetRevision(commitRoot, revision);
                    }
                    changedNodes.add(op);
                }
                newNodes.clear();
            }
        }
        for (UpdateOp op : changedNodes) {
            // set commit root on changed nodes. this may even apply
            // to the commit root. the _commitRoot entry is removed
            // again when the _revisions entry is set at the end
            NodeDocument.setCommitRoot(op, revision, commitRootDepth);
            opLog.add(op);
            createOrUpdateNode(store, op);
        }
        // the revision, with the revision property set)
        if (changedNodes.size() > 0 || !commitRoot.isNew()) {
            // set revision to committed
            NodeDocument.setRevision(commitRoot, revision, commitValue);
            if (commitRootHasChanges) {
                // remove previously added commit root
                NodeDocument.removeCommitRoot(commitRoot, revision);
            }
            opLog.add(commitRoot);
            if (baseBranchRevision == null) {
                // create a clone of the commitRoot in order
                // to set isNew to false. If we get here the
                // commitRoot document already exists and
                // only needs an update
                UpdateOp commit = commitRoot.shallowCopy(commitRoot.getId());
                commit.setNew(false);
                // only set revision on commit root when there is
                // no collision for this commit revision
                commit.containsMapEntry(COLLISIONS, revision, false);
                NodeDocument before = nodeStore.updateCommitRoot(commit);
                if (before == null) {
                    String msg = ""Conflicting concurrent change. "" + ""Update operation failed: "" + commitRoot;
                    throw new DocumentStoreException(msg);
                } else {
                    // if we get here the commit was successful and
                    // the commit revision is set on the commitRoot
                    // document for this commit.
                    // now check for conflicts/collisions by other commits.
                    // use original commitRoot operation with
                    // correct isNew flag.
                    checkConflicts(commitRoot, before);
                    checkSplitCandidate(before);
                }
            } else {
                // this is a branch commit, do not fail on collisions now
                // trying to merge the branch will fail later
                createOrUpdateNode(store, commitRoot);
            }
            operations.put(commitRootPath, commitRoot);
        }
    } catch (DocumentStoreException e) {
        rollback(newNodes, opLog, commitRoot);
        throw e;
    }
}","/**
 * Apply the changes to the document store.
 *
 * @param baseBranchRevision the base revision of this commit. Currently only
 *                     used for branch commits.
 */
","private void applyToDocumentStore(Revision baseBranchRevision) {
                    String commitValue = baseBranchRevision != null ? baseBranchRevision.toString() : ""c"";
    DocumentStore store = nodeStore.getDocumentStore();
    String commitRootPath = null;
    if (baseBranchRevision != null) {
                commitRootPath = ""/"";
    }
    ArrayList<UpdateOp> newNodes = new ArrayList<UpdateOp>();
    ArrayList<UpdateOp> changedNodes = new ArrayList<UpdateOp>();
            ArrayList<UpdateOp> opLog = new ArrayList<UpdateOp>();
        for (String p : operations.keySet()) {
        markChanged(p);
        if (commitRootPath == null) {
            commitRootPath = p;
        } else {
            while (!PathUtils.isAncestor(commitRootPath, p)) {
                commitRootPath = PathUtils.getParentPath(commitRootPath);
                if (denotesRoot(commitRootPath)) {
                    break;
                }
            }
        }
    }
        if (baseBranchRevision != null) {
                JournalEntry doc = JOURNAL.newDocument(store);
        doc.modified(modifiedNodes);
        Revision r = revision.asBranchRevision();
        store.create(JOURNAL, singletonList(doc.asUpdateOp(r)));
    }
    int commitRootDepth = PathUtils.getDepth(commitRootPath);
        boolean commitRootHasChanges = operations.containsKey(commitRootPath);
        UpdateOp commitRoot = getUpdateOperationForNode(commitRootPath);
    for (String p : operations.keySet()) {
        UpdateOp op = operations.get(p);
        if (op.isNew()) {
            NodeDocument.setDeleted(op, revision, false);
        }
        if (op == commitRoot) {
            if (!op.isNew() && commitRootHasChanges) {
                                changedNodes.add(op);
            }
        } else {
            NodeDocument.setCommitRoot(op, revision, commitRootDepth);
            if (op.isNew()) {
                newNodes.add(op);
            } else {
                changedNodes.add(op);
            }
        }
    }
    if (changedNodes.size() == 0 && commitRoot.isNew()) {
                                NodeDocument.setRevision(commitRoot, revision, commitValue);
        newNodes.add(commitRoot);
    }
    try {
        if (newNodes.size() > 0) {
                        if (!store.create(NODES, newNodes)) {
                                for (UpdateOp op : newNodes) {
                    if (op == commitRoot) {
                                                                        NodeDocument.unsetRevision(commitRoot, revision);
                    }
                    changedNodes.add(op);
                }
                newNodes.clear();
            }
        }
        for (UpdateOp op : changedNodes) {
                                                NodeDocument.setCommitRoot(op, revision, commitRootDepth);
            opLog.add(op);
            createOrUpdateNode(store, op);
        }
                if (changedNodes.size() > 0 || !commitRoot.isNew()) {
                        NodeDocument.setRevision(commitRoot, revision, commitValue);
            if (commitRootHasChanges) {
                                NodeDocument.removeCommitRoot(commitRoot, revision);
            }
            opLog.add(commitRoot);
            if (baseBranchRevision == null) {
                                                                                UpdateOp commit = commitRoot.shallowCopy(commitRoot.getId());
                commit.setNew(false);
                                                commit.containsMapEntry(COLLISIONS, revision, false);
                NodeDocument before = nodeStore.updateCommitRoot(commit);
                if (before == null) {
                    String msg = ""Conflicting concurrent change. "" + ""Update operation failed: "" + commitRoot;
                    throw new DocumentStoreException(msg);
                } else {
                                                                                                                                            checkConflicts(commitRoot, before);
                    checkSplitCandidate(before);
                }
            } else {
                                                createOrUpdateNode(store, commitRoot);
            }
            operations.put(commitRootPath, commitRoot);
        }
    } catch (DocumentStoreException e) {
        rollback(newNodes, opLog, commitRoot);
        throw e;
    }
}",3.8636363636363638,1.1734693877551021,3.8333333333333335,1.5,2.5833333333333335,2.041522491349481,-1.4032119300258106,3.9166666666666665,-0.028571428571428574,9.269542275388577
wicket,remotes/origin/bugs-dot-jar_WICKET-2621_c849f986,1,"private boolean isMultiPart() {
    if (multiPart) {
        return true;
    } else {
        final boolean[] anyEmbeddedMultipart = new boolean[] { false };
        visitChildren(Form.class, new IVisitor<Form<?>>() {

            public Object component(Form<?> form) {
                if (form.multiPart) {
                    anyEmbeddedMultipart[0] = true;
                    return STOP_TRAVERSAL;
                } else {
                    return CONTINUE_TRAVERSAL;
                }
            }
        });
        return anyEmbeddedMultipart[0];
    }
}",,"private boolean isMultiPart() {
    if (multiPart) {
        return true;
    } else {
        final boolean[] anyEmbeddedMultipart = new boolean[] { false };
        visitChildren(Form.class, new IVisitor<Form<?>>() {

            public Object component(Form<?> form) {
                if (form.multiPart) {
                    anyEmbeddedMultipart[0] = true;
                    return STOP_TRAVERSAL;
                } else {
                    return CONTINUE_TRAVERSAL;
                }
            }
        });
        return anyEmbeddedMultipart[0];
    }
}",0.18181818181818182,1.7397959183673468,-0.16666666666666666,0.5,-0.08333333333333333,-0.3806228373702422,-0.022082018927444685,-0.4166666666666667,0.37142857142857144,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-278_db19e70f,1,"@Override
public boolean remove() {
    if (isRemoved()) {
        throw new IllegalStateException(""Cannot remove removed tree"");
    }
    if (!isRoot() && parent.hasChild(name)) {
        NodeBuilder builder = parent.getNodeBuilder();
        builder.removeNode(name);
        parent.children.remove(name);
        parent = this;
        root.purge();
        return true;
    } else {
        return false;
    }
}",,"@Override
public boolean remove() {
    if (isRemoved()) {
        throw new IllegalStateException(""Cannot remove removed tree"");
    }
    if (!isRoot() && parent.hasChild(name)) {
        NodeBuilder builder = parent.getNodeBuilder();
        builder.removeNode(name);
        parent.children.remove(name);
        parent = this;
        root.purge();
        return true;
    } else {
        return false;
    }
}",0.09090909090909091,0.025510204081632563,0.0,-0.5,0.16666666666666666,-0.10973801285219967,-0.01749354746200171,0.08333333333333333,0.2571428571428572,-0.08581854626286507
Math,67,3,"/**
 * {@inheritDoc}
 */
public double getResult() {
    return optimizer.getResult();
}","/**
 * {@inheritDoc}
 */
","public double getResult() {
    return optimizer.getResult();
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.2348723831373678,-0.4166666666666667,2.8000000000000003,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-8964_ea8ee025,1,"/**
 * Suspends each element of the given {@code services} if {@code services} itself is
 * not {@code null}, otherwise this method would return immediately.
 * <p/>
 * If there's any exception being thrown while suspending the elements one after the
 * other this method would rethrow the <b>first</b> such exception being thrown.
 *
 * @see #suspendService(Service)
 */
public static void suspendServices(Collection<?> services) throws Exception {
    if (services == null) {
        return;
    }
    Exception firstException = null;
    for (Object value : services) {
        if (value instanceof Service) {
            Service service = (Service) value;
            try {
                suspendService(service);
            } catch (Exception e) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Caught exception suspending service: "" + service, e);
                }
                if (firstException == null) {
                    firstException = e;
                }
            }
        }
    }
    if (firstException != null) {
        throw firstException;
    }
}","/**
 * Suspends each element of the given {@code services} if {@code services} itself is
 * not {@code null}, otherwise this method would return immediately.
 * <p/>
 * If there's any exception being thrown while suspending the elements one after the
 * other this method would rethrow the <b>first</b> such exception being thrown.
 *
 * @see #suspendService(Service)
 */
","public static void suspendServices(Collection<?> services) throws Exception {
    if (services == null) {
        return;
    }
    Exception firstException = null;
    for (Object value : services) {
        if (value instanceof Service) {
            Service service = (Service) value;
            try {
                suspendService(service);
            } catch (Exception e) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Caught exception suspending service: "" + service, e);
                }
                if (firstException == null) {
                    firstException = e;
                }
            }
        }
    }
    if (firstException != null) {
        throw firstException;
    }
}",0.45454545454545453,1.5102040816326534,0.8333333333333334,1.0,0.3333333333333333,0.47948591201186364,-0.2936621737883571,-0.25,0.028571428571428574,0.1960844779660872
maven,remotes/origin/bugs-dot-jar_MNG-1856_faa5cf27,3,"private void assembleModelInheritance(Model child, Model parent, String childPathAdjustment, boolean appendPaths) {
    // cannot inherit from null parent.
    if (parent == null) {
        return;
    }
    // Group id
    if (child.getGroupId() == null) {
        child.setGroupId(parent.getGroupId());
    }
    // version
    if (child.getVersion() == null) {
        if (child.getParent() != null) {
            child.setVersion(child.getParent().getVersion());
        }
    }
    // inceptionYear
    if (child.getInceptionYear() == null) {
        child.setInceptionYear(parent.getInceptionYear());
    }
    // url
    if (child.getUrl() == null) {
        if (parent.getUrl() != null) {
            child.setUrl(appendPath(parent.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths));
        } else {
            child.setUrl(parent.getUrl());
        }
    }
    // ----------------------------------------------------------------------
    // Distribution
    // ----------------------------------------------------------------------
    assembleDistributionInheritence(child, parent, childPathAdjustment, appendPaths);
    // issueManagement
    if (child.getIssueManagement() == null) {
        child.setIssueManagement(parent.getIssueManagement());
    }
    // description
    if (child.getDescription() == null) {
        child.setDescription(parent.getDescription());
    }
    // Organization
    if (child.getOrganization() == null) {
        child.setOrganization(parent.getOrganization());
    }
    // Scm
    assembleScmInheritance(child, parent, childPathAdjustment, appendPaths);
    // ciManagement
    if (child.getCiManagement() == null) {
        child.setCiManagement(parent.getCiManagement());
    }
    // developers
    if (child.getDevelopers().size() == 0) {
        child.setDevelopers(parent.getDevelopers());
    }
    // licenses
    if (child.getLicenses().size() == 0) {
        child.setLicenses(parent.getLicenses());
    }
    // developers
    if (child.getContributors().size() == 0) {
        child.setContributors(parent.getContributors());
    }
    // mailingLists
    if (child.getMailingLists().size() == 0) {
        child.setMailingLists(parent.getMailingLists());
    }
    // Build
    assembleBuildInheritance(child, parent);
    assembleDependencyInheritance(child, parent);
    child.setRepositories(ModelUtils.mergeRepositoryLists(child.getRepositories(), parent.getRepositories()));
    child.setPluginRepositories(ModelUtils.mergeRepositoryLists(child.getPluginRepositories(), parent.getPluginRepositories()));
    assembleReportingInheritance(child, parent);
    assembleDependencyManagementInheritance(child, parent);
    assembleDistributionManagementInheritance(child, parent);
    Properties props = new Properties();
    props.putAll(parent.getProperties());
    props.putAll(child.getProperties());
    child.setProperties(props);
}",,"private void assembleModelInheritance(Model child, Model parent, String childPathAdjustment, boolean appendPaths) {
        if (parent == null) {
        return;
    }
        if (child.getGroupId() == null) {
        child.setGroupId(parent.getGroupId());
    }
        if (child.getVersion() == null) {
        if (child.getParent() != null) {
            child.setVersion(child.getParent().getVersion());
        }
    }
        if (child.getInceptionYear() == null) {
        child.setInceptionYear(parent.getInceptionYear());
    }
        if (child.getUrl() == null) {
        if (parent.getUrl() != null) {
            child.setUrl(appendPath(parent.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths));
        } else {
            child.setUrl(parent.getUrl());
        }
    }
                assembleDistributionInheritence(child, parent, childPathAdjustment, appendPaths);
        if (child.getIssueManagement() == null) {
        child.setIssueManagement(parent.getIssueManagement());
    }
        if (child.getDescription() == null) {
        child.setDescription(parent.getDescription());
    }
        if (child.getOrganization() == null) {
        child.setOrganization(parent.getOrganization());
    }
        assembleScmInheritance(child, parent, childPathAdjustment, appendPaths);
        if (child.getCiManagement() == null) {
        child.setCiManagement(parent.getCiManagement());
    }
        if (child.getDevelopers().size() == 0) {
        child.setDevelopers(parent.getDevelopers());
    }
        if (child.getLicenses().size() == 0) {
        child.setLicenses(parent.getLicenses());
    }
        if (child.getContributors().size() == 0) {
        child.setContributors(parent.getContributors());
    }
        if (child.getMailingLists().size() == 0) {
        child.setMailingLists(parent.getMailingLists());
    }
        assembleBuildInheritance(child, parent);
    assembleDependencyInheritance(child, parent);
    child.setRepositories(ModelUtils.mergeRepositoryLists(child.getRepositories(), parent.getRepositories()));
    child.setPluginRepositories(ModelUtils.mergeRepositoryLists(child.getPluginRepositories(), parent.getPluginRepositories()));
    assembleReportingInheritance(child, parent);
    assembleDependencyManagementInheritance(child, parent);
    assembleDistributionManagementInheritance(child, parent);
    Properties props = new Properties();
    props.putAll(parent.getProperties());
    props.putAll(child.getProperties());
    child.setProperties(props);
}",2.090909090909091,-0.27040816326530603,2.0,0.0,2.0833333333333335,0.2204646564508157,-1.0240894751935767,5.083333333333333,-0.028571428571428574,1.2584107486262266
Time,16,2,"// -----------------------------------------------------------------------
/**
 * Parses a datetime from the given text, at the given position, saving the
 * result into the fields of the given ReadWritableInstant. If the parse
 * succeeds, the return value is the new text position. Note that the parse
 * may succeed without fully reading the text and in this case those fields
 * that were read will be set.
 * <p>
 * Only those fields present in the string will be changed in the specified
 * instant. All other fields will remain unaltered. Thus if the string only
 * contains a year and a month, then the day and time will be retained from
 * the input instant. If this is not the behaviour you want, then reset the
 * fields before calling this method, or use {@link #parseDateTime(String)}
 * or {@link #parseMutableDateTime(String)}.
 * <p>
 * If it fails, the return value is negative, but the instant may still be
 * modified. To determine the position where the parse failed, apply the
 * one's complement operator (~) on the return value.
 * <p>
 * This parse method ignores the {@link #getDefaultYear() default year} and
 * parses using the year from the supplied instant as the default.
 * <p>
 * The parse will use the chronology of the instant.
 *
 * @param instant  an instant that will be modified, not null
 * @param text  the text to parse
 * @param position  position to start parsing from
 * @return new position, negative value means parse failed -
 *  apply complement operator (~) to get position of failure
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the instant is null
 * @throws IllegalArgumentException if any field is out of range
 */
public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }
    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
    chrono = selectChronology(chrono);
    DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, position);
    instant.setMillis(bucket.computeMillis(false, text));
    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        chrono = chrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        chrono = chrono.withZone(bucket.getZone());
    }
    instant.setChronology(chrono);
    if (iZone != null) {
        instant.setZone(iZone);
    }
    return newPos;
}","/**
 * Parses a datetime from the given text, at the given position, saving the
 * result into the fields of the given ReadWritableInstant. If the parse
 * succeeds, the return value is the new text position. Note that the parse
 * may succeed without fully reading the text and in this case those fields
 * that were read will be set.
 * <p>
 * Only those fields present in the string will be changed in the specified
 * instant. All other fields will remain unaltered. Thus if the string only
 * contains a year and a month, then the day and time will be retained from
 * the input instant. If this is not the behaviour you want, then reset the
 * fields before calling this method, or use {@link #parseDateTime(String)}
 * or {@link #parseMutableDateTime(String)}.
 * <p>
 * If it fails, the return value is negative, but the instant may still be
 * modified. To determine the position where the parse failed, apply the
 * one's complement operator (~) on the return value.
 * <p>
 * This parse method ignores the {@link #getDefaultYear() default year} and
 * parses using the year from the supplied instant as the default.
 * <p>
 * The parse will use the chronology of the instant.
 *
 * @param instant  an instant that will be modified, not null
 * @param text  the text to parse
 * @param position  position to start parsing from
 * @return new position, negative value means parse failed -
 *  apply complement operator (~) to get position of failure
 * @throws UnsupportedOperationException if parsing is not supported
 * @throws IllegalArgumentException if the instant is null
 * @throws IllegalArgumentException if any field is out of range
 */
","public int parseInto(ReadWritableInstant instant, String text, int position) {
    DateTimeParser parser = requireParser();
    if (instant == null) {
        throw new IllegalArgumentException(""Instant must not be null"");
    }
    long instantMillis = instant.getMillis();
    Chronology chrono = instant.getChronology();
    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
    chrono = selectChronology(chrono);
    DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
    int newPos = parser.parseInto(bucket, text, position);
    instant.setMillis(bucket.computeMillis(false, text));
    if (iOffsetParsed && bucket.getOffsetInteger() != null) {
        int parsedOffset = bucket.getOffsetInteger();
        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
        chrono = chrono.withZone(parsedZone);
    } else if (bucket.getZone() != null) {
        chrono = chrono.withZone(bucket.getZone());
    }
    instant.setChronology(chrono);
    if (iZone != null) {
        instant.setZone(iZone);
    }
    return newPos;
}",0.5,-0.43367346938775514,0.3333333333333333,0.0,0.4166666666666667,0.4201680672268908,-0.44938342414683125,1.0,-0.028571428571428574,0.7936106149965093
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-366_db4a291f,1,"void initiateClose(boolean saveState, boolean queueMinC, boolean disableWrites) {
    if (!saveState && queueMinC) {
        throw new IllegalArgumentException(""Not saving state on close and requesting minor compactions queue does not make sense"");
    }
    log.debug(""initiateClose(saveState="" + saveState + "" queueMinC="" + queueMinC + "" disableWrites="" + disableWrites + "") "" + getExtent());
    MinorCompactionTask mct = null;
    synchronized (this) {
        if (closed || closing || closeComplete) {
            String msg = ""Tablet "" + getExtent() + "" already"";
            if (closed)
                msg += "" closed"";
            if (closing)
                msg += "" closing"";
            if (closeComplete)
                msg += "" closeComplete"";
            throw new IllegalStateException(msg);
        }
        // enter the closing state, no splits, minor, or major compactions can start
        // should cause running major compactions to stop
        closing = true;
        this.notifyAll();
        // determines if inserts and queries can still continue while minor compacting
        closed = disableWrites;
        // true should cause any running major compactions to abort
        while (majorCompactionInProgress) {
            try {
                this.wait(50);
            } catch (InterruptedException e) {
                log.error(e.toString());
            }
        }
        if (!saveState || tabletMemory.getMemTable().getNumEntries() == 0) {
            return;
        }
        tabletMemory.waitForMinC();
        mct = prepareForMinC(getFlushID());
        if (queueMinC) {
            tabletResources.executeMinorCompaction(mct);
            return;
        }
    }
    // do minor compaction outside of synch block so that tablet can be read and written to while
    // compaction runs
    mct.run();
}",,"void initiateClose(boolean saveState, boolean queueMinC, boolean disableWrites) {
    if (!saveState && queueMinC) {
        throw new IllegalArgumentException(""Not saving state on close and requesting minor compactions queue does not make sense"");
    }
    log.debug(""initiateClose(saveState="" + saveState + "" queueMinC="" + queueMinC + "" disableWrites="" + disableWrites + "") "" + getExtent());
    MinorCompactionTask mct = null;
    synchronized (this) {
        if (closed || closing || closeComplete) {
            String msg = ""Tablet "" + getExtent() + "" already"";
            if (closed)
                msg += "" closed"";
            if (closing)
                msg += "" closing"";
            if (closeComplete)
                msg += "" closeComplete"";
            throw new IllegalStateException(msg);
        }
                        closing = true;
        this.notifyAll();
                closed = disableWrites;
                while (majorCompactionInProgress) {
            try {
                this.wait(50);
            } catch (InterruptedException e) {
                log.error(e.toString());
            }
        }
        if (!saveState || tabletMemory.getMemTable().getNumEntries() == 0) {
            return;
        }
        tabletMemory.waitForMinC();
        mct = prepareForMinC(getFlushID());
        if (queueMinC) {
            tabletResources.executeMinorCompaction(mct);
            return;
        }
    }
            mct.run();
}",1.1363636363636365,0.6122448979591836,1.3333333333333333,0.5,1.1666666666666667,0.5150766188828474,-0.6808144536851166,0.6666666666666666,-0.028571428571428574,0.8075946222604837
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-3383_97f16db4,3,"private static File computeTopCacheDir() {
    String procName = ManagementFactory.getRuntimeMXBean().getName();
    return new File(System.getProperty(""java.io.tmpdir""), ""accumulo-vfs-cache-"" + procName + ""-"" + System.getProperty(""user.name"", ""nouser""));
}",,"private static File computeTopCacheDir() {
    String procName = ManagementFactory.getRuntimeMXBean().getName();
    return new File(System.getProperty(""java.io.tmpdir""), ""accumulo-vfs-cache-"" + procName + ""-"" + System.getProperty(""user.name"", ""nouser""));
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.12951062778052397,0.7126469744766275,-0.16666666666666666,0.028571428571428574,-0.11765839618641345
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-366_db4a291f,1,"long getCompactionID() {
    try {
        String zTablePath = Constants.ZROOT + ""/"" + HdfsZooInstance.getInstance().getInstanceID() + Constants.ZTABLES + ""/"" + extent.getTableId() + Constants.ZTABLE_COMPACT_ID;
        return Long.parseLong(new String(ZooReaderWriter.getRetryingInstance().getData(zTablePath, null)));
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}",,"long getCompactionID() {
    try {
        String zTablePath = Constants.ZROOT + ""/"" + HdfsZooInstance.getInstance().getInstanceID() + Constants.ZTABLES + ""/"" + extent.getTableId() + Constants.ZTABLE_COMPACT_ID;
        return Long.parseLong(new String(ZooReaderWriter.getRetryingInstance().getData(zTablePath, null)));
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}",-0.2727272727272727,0.051020408163265356,-0.16666666666666666,-0.5,-0.4166666666666667,-0.1314878892733564,0.3002581015199312,0.0,0.17142857142857146,-0.08648669484883138
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1075_79467350,1,"public void restrictProperty(String propertyName, Operator op, PropertyValue v) {
    PropertyRestriction x = addRestricition(propertyName);
    PropertyValue oldFirst = x.first;
    PropertyValue oldLast = x.last;
    switch(op) {
        case EQUAL:
            if (x.first != null && x.last == x.first && x.firstIncluding && x.lastIncluding) {
                // if x is a multi-valued property with value ""{1, 2}"")
                return;
            }
            x.first = maxValue(oldFirst, v);
            x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;
            x.last = minValue(oldLast, v);
            x.lastIncluding = x.last == oldLast ? x.lastIncluding : true;
            break;
        case NOT_EQUAL:
            if (v != null) {
                throw new IllegalArgumentException(""NOT_EQUAL only supported for NOT_EQUAL NULL"");
            }
            break;
        case GREATER_THAN:
            x.first = maxValue(oldFirst, v);
            x.firstIncluding = false;
            break;
        case GREATER_OR_EQUAL:
            x.first = maxValue(oldFirst, v);
            x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;
            break;
        case LESS_THAN:
            x.last = minValue(oldLast, v);
            x.lastIncluding = false;
            break;
        case LESS_OR_EQUAL:
            x.last = minValue(oldLast, v);
            x.lastIncluding = x.last == oldLast ? x.lastIncluding : true;
            break;
        case LIKE:
            // LIKE is handled in the fulltext index
            x.isLike = true;
            x.first = v;
            break;
        case IN:
    }
    if (x.first != null && x.last != null) {
        if (x.first.compareTo(x.last) > 0) {
            setAlwaysFalse();
        } else if (x.first.compareTo(x.last) == 0 && (!x.firstIncluding || !x.lastIncluding)) {
            setAlwaysFalse();
        }
    }
}",,"public void restrictProperty(String propertyName, Operator op, PropertyValue v) {
    PropertyRestriction x = addRestricition(propertyName);
    PropertyValue oldFirst = x.first;
    PropertyValue oldLast = x.last;
    switch(op) {
        case EQUAL:
            if (x.first != null && x.last == x.first && x.firstIncluding && x.lastIncluding) {
                                return;
            }
            x.first = maxValue(oldFirst, v);
            x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;
            x.last = minValue(oldLast, v);
            x.lastIncluding = x.last == oldLast ? x.lastIncluding : true;
            break;
        case NOT_EQUAL:
            if (v != null) {
                throw new IllegalArgumentException(""NOT_EQUAL only supported for NOT_EQUAL NULL"");
            }
            break;
        case GREATER_THAN:
            x.first = maxValue(oldFirst, v);
            x.firstIncluding = false;
            break;
        case GREATER_OR_EQUAL:
            x.first = maxValue(oldFirst, v);
            x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;
            break;
        case LESS_THAN:
            x.last = minValue(oldLast, v);
            x.lastIncluding = false;
            break;
        case LESS_OR_EQUAL:
            x.last = minValue(oldLast, v);
            x.lastIncluding = x.last == oldLast ? x.lastIncluding : true;
            break;
        case LIKE:
                        x.isLike = true;
            x.first = v;
            break;
        case IN:
    }
    if (x.first != null && x.last != null) {
        if (x.first.compareTo(x.last) > 0) {
            setAlwaysFalse();
        } else if (x.first.compareTo(x.last) == 0 && (!x.firstIncluding || !x.lastIncluding)) {
            setAlwaysFalse();
        }
    }
}",1.5909090909090908,0.3469387755102042,3.6666666666666665,0.5,2.25,1.9584775086505195,-0.977344422139375,0.4166666666666667,-0.028571428571428574,4.731040213122267
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-581_bb02fa15,1,"private boolean rollover(final RolloverStrategy strategy) {
    try {
        // Block until the asynchronous operation is completed.
        semaphore.acquire();
    } catch (final InterruptedException ie) {
        LOGGER.error(""Thread interrupted while attempting to check rollover"", ie);
        return false;
    }
    boolean success = false;
    Thread thread = null;
    try {
        final RolloverDescription descriptor = strategy.rollover(this);
        if (descriptor != null) {
            close();
            if (descriptor.getSynchronous() != null) {
                LOGGER.debug(""RollingFileManager executing synchronous {}"", descriptor.getSynchronous());
                try {
                    success = descriptor.getSynchronous().execute();
                } catch (final Exception ex) {
                    LOGGER.error(""Error in synchronous task"", ex);
                }
            }
            if (success && descriptor.getAsynchronous() != null) {
                LOGGER.debug(""RollingFileManager executing async {}"", descriptor.getAsynchronous());
                thread = new Thread(new AsyncAction(descriptor.getAsynchronous(), this));
                thread.start();
            }
            return true;
        }
        return false;
    } finally {
        if (thread == null) {
            semaphore.release();
        }
    }
}",,"private boolean rollover(final RolloverStrategy strategy) {
    try {
                semaphore.acquire();
    } catch (final InterruptedException ie) {
        LOGGER.error(""Thread interrupted while attempting to check rollover"", ie);
        return false;
    }
    boolean success = false;
    Thread thread = null;
    try {
        final RolloverDescription descriptor = strategy.rollover(this);
        if (descriptor != null) {
            close();
            if (descriptor.getSynchronous() != null) {
                LOGGER.debug(""RollingFileManager executing synchronous {}"", descriptor.getSynchronous());
                try {
                    success = descriptor.getSynchronous().execute();
                } catch (final Exception ex) {
                    LOGGER.error(""Error in synchronous task"", ex);
                }
            }
            if (success && descriptor.getAsynchronous() != null) {
                LOGGER.debug(""RollingFileManager executing async {}"", descriptor.getAsynchronous());
                thread = new Thread(new AsyncAction(descriptor.getAsynchronous(), this));
                thread.start();
            }
            return true;
        }
        return false;
    } finally {
        if (thread == null) {
            semaphore.release();
        }
    }
}",0.9545454545454546,1.1887755102040816,0.5,1.0,0.4166666666666667,0.4221453287197232,-0.5595067393174652,0.8333333333333334,-0.028571428571428574,0.5104355386519674
wicket,remotes/origin/bugs-dot-jar_WICKET-428_d906576c,3,"public Object next() {
    index++;
    return new Map.Entry() {

        public Object getKey() {
            return key;
        }

        public Object getValue() {
            return value;
        }

        public Object setValue(final Object value) {
            final Object oldValue = MicroMap.this.value;
            MicroMap.this.value = value;
            return oldValue;
        }
    };
}",,"public Object next() {
    index++;
    return new Map.Entry() {

        public Object getKey() {
            return key;
        }

        public Object getValue() {
            return value;
        }

        public Object setValue(final Object value) {
            final Object oldValue = MicroMap.this.value;
            MicroMap.this.value = value;
            return oldValue;
        }
    };
}",0.09090909090909091,0.4846938775510205,-0.5,-0.5,-0.4166666666666667,-0.014829461196243152,0.037854889589905176,-0.5,1.1714285714285715,-0.08082028087938632
wicket,remotes/origin/bugs-dot-jar_WICKET-4309_b4274415,1,"/**
 *  Convert to object types, returning null if text is null.
 *
 *  @return converted
 *  @throws StringValueConversionException
 */
public final Integer toOptionalInteger() throws StringValueConversionException {
    return (text == null) ? null : toInteger();
}","/**
 *  Convert to object types, returning null if text is null.
 *
 *  @return converted
 *  @throws StringValueConversionException
 */
","public final Integer toOptionalInteger() throws StringValueConversionException {
    return (text == null) ? null : toInteger();
}",-0.5,-0.576530612244898,-0.3333333333333333,-1.0,-0.25,-0.3806228373702422,1.012044737596788,-0.4166666666666667,2.8285714285714287,-0.16422749602751402
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-147_17296089,1,"private Result filter() {
    boolean match = false;
    if (useMap) {
        for (final Map.Entry<String, List<String>> entry : getMap().entrySet()) {
            final String toMatch = ThreadContext.get(entry.getKey());
            if (toMatch != null) {
                match = entry.getValue().contains(toMatch);
            } else {
                match = false;
            }
            if ((!isAnd() && match) || (isAnd() && !match)) {
                break;
            }
        }
    } else {
        match = key.equals(ThreadContext.get(key));
    }
    return match ? onMatch : onMismatch;
}",,"private Result filter() {
    boolean match = false;
    if (useMap) {
        for (final Map.Entry<String, List<String>> entry : getMap().entrySet()) {
            final String toMatch = ThreadContext.get(entry.getKey());
            if (toMatch != null) {
                match = entry.getValue().contains(toMatch);
            } else {
                match = false;
            }
            if ((!isAnd() && match) || (isAnd() && !match)) {
                break;
            }
        }
    } else {
        match = key.equals(ThreadContext.get(key));
    }
    return match ? onMatch : onMismatch;
}",0.22727272727272727,1.045918367346939,0.5,0.5,0.5,0.28373702422145336,-0.2162317178090051,0.3333333333333333,0.028571428571428574,0.21002993819625582
flink,remotes/origin/bugs-dot-jar_FLINK-3314_8fc7e7af,0,"// ------------------------------------------------------------------------
// Core work methods of the Stream Task
// ------------------------------------------------------------------------
@Override
public final void invoke() throws Exception {
    boolean disposed = false;
    try {
        // -------- Initialize ---------
        LOG.debug(""Initializing {}"", getName());
        userClassLoader = getUserCodeClassLoader();
        configuration = new StreamConfig(getTaskConfiguration());
        accumulatorMap = getEnvironment().getAccumulatorRegistry().getUserMap();
        headOperator = configuration.getStreamOperator(userClassLoader);
        operatorChain = new OperatorChain<>(this, headOperator, getEnvironment().getAccumulatorRegistry().getReadWriteReporter());
        if (headOperator != null) {
            headOperator.setup(this, configuration, operatorChain.getChainEntryPoint());
        }
        timerService = Executors.newSingleThreadScheduledExecutor(new DispatcherThreadFactory(TRIGGER_THREAD_GROUP, ""Time Trigger for "" + getName()));
        // task specific initialization
        init();
        // -------- Invoke --------
        LOG.debug(""Invoking {}"", getName());
        // first order of business is to give operators back their state
        stateBackend = createStateBackend();
        stateBackend.initializeForJob(getEnvironment());
        restoreState();
        // executed before all operators are opened
        synchronized (lock) {
            openAllOperators();
        }
        // let the task do its work
        isRunning = true;
        run();
        isRunning = false;
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Finished task {}"", getName());
        }
        // we also need to make sure that no triggers fire concurrently with the close logic
        synchronized (lock) {
            // this is part of the main logic, so if this fails, the task is considered failed
            closeAllOperators();
        }
        // make sure all buffered data is flushed
        operatorChain.flushOutputs();
        // make an attempt to dispose the operators such that failures in the dispose call
        // still let the computation fail
        tryDisposeAllOperators();
        disposed = true;
    } finally {
        // clean up everything we initialized
        isRunning = false;
        // stop all timers and threads
        if (timerService != null) {
            try {
                timerService.shutdownNow();
            } catch (Throwable t) {
                // catch and log the exception to not replace the original exception
                LOG.error(""Could not shut down timer service"", t);
            }
        }
        // stop all asynchronous checkpoint threads
        try {
            for (Thread checkpointThread : asyncCheckpointThreads) {
                checkpointThread.interrupt();
            }
            asyncCheckpointThreads.clear();
        } catch (Throwable t) {
            // catch and log the exception to not replace the original exception
            LOG.error(""Could not shut down async checkpoint threads"", t);
        }
        // release the output resources. this method should never fail.
        if (operatorChain != null) {
            operatorChain.releaseOutputs();
        }
        // we must! perform this cleanup
        try {
            cleanup();
        } catch (Throwable t) {
            // catch and log the exception to not replace the original exception
            LOG.error(""Error during cleanup of stream task"", t);
        }
        // if the operators were not disposed before, do a hard dispose
        if (!disposed) {
            disposeAllOperators();
        }
        try {
            if (stateBackend != null) {
                stateBackend.close();
            }
        } catch (Throwable t) {
            LOG.error(""Error while closing the state backend"", t);
        }
    }
}",,"@Override
public final void invoke() throws Exception {
    boolean disposed = false;
    try {
                LOG.debug(""Initializing {}"", getName());
        userClassLoader = getUserCodeClassLoader();
        configuration = new StreamConfig(getTaskConfiguration());
        accumulatorMap = getEnvironment().getAccumulatorRegistry().getUserMap();
        headOperator = configuration.getStreamOperator(userClassLoader);
        operatorChain = new OperatorChain<>(this, headOperator, getEnvironment().getAccumulatorRegistry().getReadWriteReporter());
        if (headOperator != null) {
            headOperator.setup(this, configuration, operatorChain.getChainEntryPoint());
        }
        timerService = Executors.newSingleThreadScheduledExecutor(new DispatcherThreadFactory(TRIGGER_THREAD_GROUP, ""Time Trigger for "" + getName()));
                init();
                LOG.debug(""Invoking {}"", getName());
                stateBackend = createStateBackend();
        stateBackend.initializeForJob(getEnvironment());
        restoreState();
                synchronized (lock) {
            openAllOperators();
        }
                isRunning = true;
        run();
        isRunning = false;
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Finished task {}"", getName());
        }
                synchronized (lock) {
                        closeAllOperators();
        }
                operatorChain.flushOutputs();
                        tryDisposeAllOperators();
        disposed = true;
    } finally {
                isRunning = false;
                if (timerService != null) {
            try {
                timerService.shutdownNow();
            } catch (Throwable t) {
                                LOG.error(""Could not shut down timer service"", t);
            }
        }
                try {
            for (Thread checkpointThread : asyncCheckpointThreads) {
                checkpointThread.interrupt();
            }
            asyncCheckpointThreads.clear();
        } catch (Throwable t) {
                        LOG.error(""Could not shut down async checkpoint threads"", t);
        }
                if (operatorChain != null) {
            operatorChain.releaseOutputs();
        }
                try {
            cleanup();
        } catch (Throwable t) {
                        LOG.error(""Error during cleanup of stream task"", t);
        }
                if (!disposed) {
            disposeAllOperators();
        }
        try {
            if (stateBackend != null) {
                stateBackend.close();
            }
        } catch (Throwable t) {
            LOG.error(""Error while closing the state backend"", t);
        }
    }
}",2.590909090909091,0.10714285714285712,1.3333333333333333,0.5,0.5833333333333334,0.3509639149777559,-1.0395755663894468,2.9166666666666665,-0.028571428571428574,1.1944997665762953
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-606_f0fbacab,1,"/**
 * Determine whether this item is stale
 * @return  {@code true} iff stale
 */
public boolean isStale() {
    Status status = getLocationOrNull().getStatus();
    return status == Status.DISCONNECTED || status == null;
}","/**
 * Determine whether this item is stale
 * @return  {@code true} iff stale
 */
","public boolean isStale() {
    Status status = getLocationOrNull().getStatus();
    return status == Status.DISCONNECTED || status == null;
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.10776075135936727,0.787783194723258,-0.3333333333333333,2.8285714285714287,-0.13366826422706773
wicket,remotes/origin/bugs-dot-jar_WICKET-5441_8ccb1f6d,1,"/**
 *  set resource caching to maximum and set cache-visibility to 'public'
 *
 *  @param response
 */
@Override
public void decorateResponse(AbstractResource.ResourceResponse response, IStaticCacheableResource resource) {
    response.setCacheDurationToMaximum();
    response.setCacheScope(WebResponse.CacheScope.PUBLIC);
}","/**
 *  set resource caching to maximum and set cache-visibility to 'public'
 *
 *  @param response
 */
","@Override
public void decorateResponse(AbstractResource.ResourceResponse response, IStaticCacheableResource resource) {
    response.setCacheDurationToMaximum();
    response.setCacheScope(WebResponse.CacheScope.PUBLIC);
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.6739317464869518,-0.3333333333333333,2.4571428571428573,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-447_00df38d2,1,"@Override
public NodeBuilder child(String name) {
    // shortcut when dealing with a read-only child node
    read();
    if (baseState != null && baseState.hasChildNode(name) && (writeState == null || !writeState.nodes.containsKey(name))) {
        return createChildBuilder(name);
    }
    // no read-only child node found, switch to write mode
    write();
    // guaranteed by write()
    assert writeState != null;
    NodeState childBase = null;
    if (baseState != null) {
        childBase = baseState.getChildNode(name);
    }
    if (writeState.nodes.get(name) == null) {
        if (writeState.nodes.containsKey(name)) {
            // The child node was removed earlier and we're creating
            // a new child with the same name. Use the null state to
            // prevent the previous child state from re-surfacing.
            childBase = null;
        }
        writeState.nodes.put(name, new MutableNodeState(childBase));
    }
    MemoryNodeBuilder builder = createChildBuilder(name);
    builder.write();
    return builder;
}",,"@Override
public NodeBuilder child(String name) {
        read();
    if (baseState != null && baseState.hasChildNode(name) && (writeState == null || !writeState.nodes.containsKey(name))) {
        return createChildBuilder(name);
    }
        write();
        assert writeState != null;
    NodeState childBase = null;
    if (baseState != null) {
        childBase = baseState.getChildNode(name);
    }
    if (writeState.nodes.get(name) == null) {
        if (writeState.nodes.containsKey(name)) {
                                                childBase = null;
        }
        writeState.nodes.put(name, new MutableNodeState(childBase));
    }
    MemoryNodeBuilder builder = createChildBuilder(name);
    builder.write();
    return builder;
}",0.36363636363636365,-0.08163265306122457,0.16666666666666666,0.0,0.6666666666666666,-0.3806228373702422,0.14941210209348996,0.4166666666666667,-0.028571428571428574,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-373_bfe4623c,1,"/**
 * Returns the sum of the squares of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 *
 * @param values the input array
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the sum of the squares of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the array is null or the array index
 *  parameters are not valid
 */
@Override
public double evaluate(final double[] values, final int begin, final int length) {
    double sumSq = Double.NaN;
    if (test(values, begin, length)) {
        sumSq = 0.0;
        for (int i = begin; i < begin + length; i++) {
            sumSq += values[i] * values[i];
        }
    }
    return sumSq;
}","/**
 * Returns the sum of the squares of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 *
 * @param values the input array
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the sum of the squares of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the array is null or the array index
 *  parameters are not valid
 */
","@Override
public double evaluate(final double[] values, final int begin, final int length) {
    double sumSq = Double.NaN;
    if (test(values, begin, length)) {
        sumSq = 0.0;
        for (int i = begin; i < begin + length; i++) {
            sumSq += values[i] * values[i];
        }
    }
    return sumSq;
}",-0.13636363636363635,0.36734693877551033,-0.16666666666666666,0.0,0.16666666666666666,0.9540286702916463,0.15027244049326058,-0.4166666666666667,-0.028571428571428574,0.2577083360102107
Lang,30,3,"/**
 * <p>Search a String to find the first index of any
 * character not in the given set of characters.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> search string will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOfAnyBut(null, *)            = -1
 * StringUtils.indexOfAnyBut("""", *)              = -1
 * StringUtils.indexOfAnyBut(*, null)            = -1
 * StringUtils.indexOfAnyBut(*, """")              = -1
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", ""za"") = 3
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", """")   = 0
 * StringUtils.indexOfAnyBut(""aba"",""ab"")         = -1
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 */
public static int indexOfAnyBut(String str, String searchChars) {
    if (isEmpty(str) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int strLen = str.length();
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (searchChars.indexOf(ch) < 0) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","/**
 * <p>Search a String to find the first index of any
 * character not in the given set of characters.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> search string will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOfAnyBut(null, *)            = -1
 * StringUtils.indexOfAnyBut("""", *)              = -1
 * StringUtils.indexOfAnyBut(*, null)            = -1
 * StringUtils.indexOfAnyBut(*, """")              = -1
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", ""za"") = 3
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", """")   = 0
 * StringUtils.indexOfAnyBut(""aba"",""ab"")         = -1
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 */
","public static int indexOfAnyBut(String str, String searchChars) {
    if (isEmpty(str) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int strLen = str.length();
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (searchChars.indexOf(ch) < 0) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}",-0.045454545454545456,0.13775510204081634,0.0,0.0,0.5833333333333334,0.43796342066238264,0.06194436478348142,-0.08333333333333333,0.08571428571428572,0.10213679057396532
camel,remotes/origin/bugs-dot-jar_CAMEL-5571_0e87b84f,1,"public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {
    BeanInvocation invocation = new BeanInvocation(method, args);
    MethodInfo methodInfo = methodInfoCache.getMethodInfo(method);
    final ExchangePattern pattern = methodInfo != null ? methodInfo.getPattern() : ExchangePattern.InOut;
    return invokeWithbody(method, invocation, pattern);
}",,"public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {
    BeanInvocation invocation = new BeanInvocation(method, args);
    MethodInfo methodInfo = methodInfoCache.getMethodInfo(method);
    final ExchangePattern pattern = methodInfo != null ? methodInfo.getPattern() : ExchangePattern.InOut;
    return invokeWithbody(method, invocation, pattern);
}",-0.36363636363636365,-0.576530612244898,-0.3333333333333333,-1.0,-0.25,-0.06426099851705384,0.4244336105534844,-0.25,0.05714285714285714,-0.05421426154590737
wicket,remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4,1,"/**
 *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT USE IT.
 *
 *  Adds a child component to this container.
 *
 *  @param child
 *             The child
 *  @throws IllegalArgumentException
 *              Thrown if a child with the same id is replaced by the add
 *              operation.
 */
public void internalAdd(final Component child) {
    if (log.isDebugEnabled()) {
        log.debug(""internalAdd "" + child.getId() + "" to "" + this);
    }
    // Add to map
    addedComponent(child);
    put(child);
}","/**
 *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT USE IT.
 *
 *  Adds a child component to this container.
 *
 *  @param child
 *             The child
 *  @throws IllegalArgumentException
 *              Thrown if a child with the same id is replaced by the add
 *              operation.
 */
","public void internalAdd(final Component child) {
    if (log.isDebugEnabled()) {
        log.debug(""internalAdd "" + child.getId() + "" to "" + this);
    }
        addedComponent(child);
    put(child);
}",-0.3181818181818182,-0.2346938775510204,-0.3333333333333333,-0.5,-0.25,-0.3806228373702422,0.4924003441353601,-0.08333333333333333,2.685714285714286,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-9672_84922699,3,"@SuppressWarnings({ ""deprecation"", ""unchecked"" })
public Object getManagedObjectForProcessor(CamelContext context, Processor processor, ProcessorDefinition<?> definition, Route route) {
    ManagedProcessor answer = null;
    if (definition instanceof RecipientListDefinition) {
        // special for RecipientListDefinition, as the processor is wrapped in a pipeline as last
        Pipeline pipeline = (Pipeline) processor;
        Iterator<Processor> it = pipeline.getProcessors().iterator();
        while (it.hasNext()) {
            processor = it.next();
        }
    } else if (definition instanceof ThreadsDefinition) {
        // special for ThreadsDefinition, as the processor is wrapped in a pipeline as first
        Pipeline pipeline = (Pipeline) processor;
        Iterator<Processor> it = pipeline.getProcessors().iterator();
        processor = it.next();
    }
    // unwrap delegates as we want the real target processor
    Processor target = processor;
    while (target != null) {
        // skip error handlers
        if (target instanceof ErrorHandler) {
            return false;
        }
        if (target instanceof ConvertBodyProcessor) {
            answer = new ManagedConvertBody(context, (ConvertBodyProcessor) target, definition);
        } else if (target instanceof ChoiceProcessor) {
            answer = new ManagedChoice(context, (ChoiceProcessor) target, definition);
        } else if (target instanceof Delayer) {
            answer = new ManagedDelayer(context, (Delayer) target, definition);
        } else if (target instanceof Throttler) {
            answer = new ManagedThrottler(context, (Throttler) target, definition);
        } else if (target instanceof DynamicRouter) {
            answer = new ManagedDynamicRouter(context, (DynamicRouter) target, (org.apache.camel.model.DynamicRouterDefinition) definition);
        } else if (target instanceof RoutingSlip) {
            answer = new ManagedRoutingSlip(context, (RoutingSlip) target, (org.apache.camel.model.RoutingSlipDefinition) definition);
        } else if (target instanceof FilterProcessor) {
            answer = new ManagedFilter(context, (FilterProcessor) target, (org.apache.camel.model.FilterDefinition) definition);
        } else if (target instanceof LogProcessor) {
            answer = new ManagedLog(context, (LogProcessor) target, definition);
        } else if (target instanceof LoopProcessor) {
            answer = new ManagedLoop(context, (LoopProcessor) target, (org.apache.camel.model.LoopDefinition) definition);
        } else if (target instanceof MarshalProcessor) {
            answer = new ManagedMarshal(context, (MarshalProcessor) target, (org.apache.camel.model.MarshalDefinition) definition);
        } else if (target instanceof UnmarshalProcessor) {
            answer = new ManagedUnmarshal(context, (UnmarshalProcessor) target, (org.apache.camel.model.UnmarshalDefinition) definition);
        } else if (target instanceof CircuitBreakerLoadBalancer) {
            answer = new ManagedCircuitBreakerLoadBalancer(context, (CircuitBreakerLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);
        } else if (target instanceof FailOverLoadBalancer) {
            answer = new ManagedFailoverLoadBalancer(context, (FailOverLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);
        } else if (target instanceof RandomLoadBalancer) {
            answer = new ManagedRandomLoadBalancer(context, (RandomLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);
        } else if (target instanceof RoundRobinLoadBalancer) {
            answer = new ManagedRoundRobinLoadBalancer(context, (RoundRobinLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);
        } else if (target instanceof StickyLoadBalancer) {
            answer = new ManagedStickyLoadBalancer(context, (StickyLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);
        } else if (target instanceof TopicLoadBalancer) {
            answer = new ManagedTopicLoadBalancer(context, (TopicLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);
        } else if (target instanceof WeightedLoadBalancer) {
            answer = new ManagedWeightedLoadBalancer(context, (WeightedLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);
        } else if (target instanceof RecipientList) {
            answer = new ManagedRecipientList(context, (RecipientList) target, (RecipientListDefinition) definition);
        } else if (target instanceof Splitter) {
            answer = new ManagedSplitter(context, (Splitter) target, (org.apache.camel.model.SplitDefinition) definition);
        } else if (target instanceof MulticastProcessor) {
            answer = new ManagedMulticast(context, (MulticastProcessor) target, definition);
        } else if (target instanceof SamplingThrottler) {
            answer = new ManagedSamplingThrottler(context, (SamplingThrottler) target, definition);
        } else if (target instanceof Resequencer) {
            answer = new ManagedResequencer(context, (Resequencer) target, definition);
        } else if (target instanceof RollbackProcessor) {
            answer = new ManagedRollback(context, (RollbackProcessor) target, definition);
        } else if (target instanceof StreamResequencer) {
            answer = new ManagedResequencer(context, (StreamResequencer) target, definition);
        } else if (target instanceof SetBodyProcessor) {
            answer = new ManagedSetBody(context, (SetBodyProcessor) target, (org.apache.camel.model.SetBodyDefinition) definition);
        } else if (target instanceof RemoveHeaderProcessor) {
            answer = new ManagedRemoveHeader(context, (RemoveHeaderProcessor) target, definition);
        } else if (target instanceof RemoveHeadersProcessor) {
            answer = new ManagedRemoveHeaders(context, (RemoveHeadersProcessor) target, definition);
        } else if (target instanceof SetHeaderProcessor) {
            answer = new ManagedSetHeader(context, (SetHeaderProcessor) target, (org.apache.camel.model.SetHeaderDefinition) definition);
        } else if (target instanceof RemovePropertyProcessor) {
            answer = new ManagedRemoveProperty(context, (RemovePropertyProcessor) target, definition);
        } else if (target instanceof RemovePropertiesProcessor) {
            answer = new ManagedRemoveProperties(context, (RemovePropertiesProcessor) target, definition);
        } else if (target instanceof SetPropertyProcessor) {
            answer = new ManagedSetProperty(context, (SetPropertyProcessor) target, (org.apache.camel.model.SetPropertyDefinition) definition);
        } else if (target instanceof ExchangePatternProcessor) {
            answer = new ManagedSetExchangePattern(context, (ExchangePatternProcessor) target, definition);
        } else if (target instanceof ScriptProcessor) {
            answer = new ManagedScript(context, (ScriptProcessor) target, (org.apache.camel.model.ScriptDefinition) definition);
        } else if (target instanceof StopProcessor) {
            answer = new ManagedStop(context, (StopProcessor) target, definition);
        } else if (target instanceof ThreadsProcessor) {
            answer = new ManagedThreads(context, (ThreadsProcessor) target, definition);
        } else if (target instanceof ThrowExceptionProcessor) {
            answer = new ManagedThrowException(context, (ThrowExceptionProcessor) target, definition);
        } else if (target instanceof TransformProcessor) {
            answer = new ManagedTransformer(context, (TransformProcessor) target, (org.apache.camel.model.TransformDefinition) definition);
        } else if (target instanceof PredicateValidatingProcessor) {
            answer = new ManagedValidate(context, (PredicateValidatingProcessor) target, (org.apache.camel.model.ValidateDefinition) definition);
        } else if (target instanceof WireTapProcessor) {
            answer = new ManagedWireTapProcessor(context, (WireTapProcessor) target, definition);
        } else if (target instanceof SendDynamicProcessor) {
            answer = new ManagedSendDynamicProcessor(context, (SendDynamicProcessor) target, definition);
        } else if (target instanceof SendProcessor) {
            SendProcessor sp = (SendProcessor) target;
            // special for sending to throughput logger
            if (sp.getDestination() instanceof LogEndpoint) {
                LogEndpoint le = (LogEndpoint) sp.getDestination();
                if (le.getLogger() instanceof ThroughputLogger) {
                    ThroughputLogger tl = (ThroughputLogger) le.getLogger();
                    answer = new ManagedThroughputLogger(context, tl, definition);
                }
            }
            // regular send processor
            if (answer == null) {
                answer = new ManagedSendProcessor(context, (SendProcessor) target, definition);
            }
        } else if (target instanceof BeanProcessor) {
            answer = new ManagedBeanProcessor(context, (BeanProcessor) target, definition);
        } else if (target instanceof IdempotentConsumer) {
            answer = new ManagedIdempotentConsumer(context, (IdempotentConsumer) target, (org.apache.camel.model.IdempotentConsumerDefinition) definition);
        } else if (target instanceof AggregateProcessor) {
            answer = new ManagedAggregateProcessor(context, (AggregateProcessor) target, (org.apache.camel.model.AggregateDefinition) definition);
        } else if (target instanceof Enricher) {
            answer = new ManagedEnricher(context, (Enricher) target, (org.apache.camel.model.EnrichDefinition) definition);
        } else if (target instanceof PollEnricher) {
            answer = new ManagedPollEnricher(context, (PollEnricher) target, (org.apache.camel.model.PollEnrichDefinition) definition);
        } else if (target instanceof org.apache.camel.spi.ManagementAware) {
            return ((org.apache.camel.spi.ManagementAware<Processor>) target).getManagedObject(processor);
        }
        // special for custom load balancer
        if (definition instanceof LoadBalanceDefinition) {
            LoadBalanceDefinition lb = (LoadBalanceDefinition) definition;
            if (lb.getLoadBalancerType() instanceof CustomLoadBalancerDefinition) {
                answer = new ManagedCustomLoadBalancer(context, (LoadBalancer) target, (LoadBalanceDefinition) definition);
            }
        }
        if (answer != null) {
            // break out as we found an answer
            break;
        }
        // no answer yet, so unwrap any delegates and try again
        if (target instanceof DelegateProcessor) {
            target = ((DelegateProcessor) target).getProcessor();
        } else {
            // no delegate so we dont have any target to try next
            break;
        }
    }
    if (answer == null && definition instanceof ProcessDefinition) {
        answer = new ManagedProcess(context, target, (ProcessDefinition) definition);
    } else if (answer == null) {
        // fallback to a generic processor
        answer = new ManagedProcessor(context, target, definition);
    }
    answer.setRoute(route);
    answer.init(context.getManagementStrategy());
    return answer;
}",,"@SuppressWarnings({ ""deprecation"", ""unchecked"" })
public Object getManagedObjectForProcessor(CamelContext context, Processor processor, ProcessorDefinition<?> definition, Route route) {
    ManagedProcessor answer = null;
    if (definition instanceof RecipientListDefinition) {
                Pipeline pipeline = (Pipeline) processor;
        Iterator<Processor> it = pipeline.getProcessors().iterator();
        while (it.hasNext()) {
            processor = it.next();
        }
    } else if (definition instanceof ThreadsDefinition) {
                Pipeline pipeline = (Pipeline) processor;
        Iterator<Processor> it = pipeline.getProcessors().iterator();
        processor = it.next();
    }
        Processor target = processor;
    while (target != null) {
                if (target instanceof ErrorHandler) {
            return false;
        }
        if (target instanceof ConvertBodyProcessor) {
            answer = new ManagedConvertBody(context, (ConvertBodyProcessor) target, definition);
        } else if (target instanceof ChoiceProcessor) {
            answer = new ManagedChoice(context, (ChoiceProcessor) target, definition);
        } else if (target instanceof Delayer) {
            answer = new ManagedDelayer(context, (Delayer) target, definition);
        } else if (target instanceof Throttler) {
            answer = new ManagedThrottler(context, (Throttler) target, definition);
        } else if (target instanceof DynamicRouter) {
            answer = new ManagedDynamicRouter(context, (DynamicRouter) target, (org.apache.camel.model.DynamicRouterDefinition) definition);
        } else if (target instanceof RoutingSlip) {
            answer = new ManagedRoutingSlip(context, (RoutingSlip) target, (org.apache.camel.model.RoutingSlipDefinition) definition);
        } else if (target instanceof FilterProcessor) {
            answer = new ManagedFilter(context, (FilterProcessor) target, (org.apache.camel.model.FilterDefinition) definition);
        } else if (target instanceof LogProcessor) {
            answer = new ManagedLog(context, (LogProcessor) target, definition);
        } else if (target instanceof LoopProcessor) {
            answer = new ManagedLoop(context, (LoopProcessor) target, (org.apache.camel.model.LoopDefinition) definition);
        } else if (target instanceof MarshalProcessor) {
            answer = new ManagedMarshal(context, (MarshalProcessor) target, (org.apache.camel.model.MarshalDefinition) definition);
        } else if (target instanceof UnmarshalProcessor) {
            answer = new ManagedUnmarshal(context, (UnmarshalProcessor) target, (org.apache.camel.model.UnmarshalDefinition) definition);
        } else if (target instanceof CircuitBreakerLoadBalancer) {
            answer = new ManagedCircuitBreakerLoadBalancer(context, (CircuitBreakerLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);
        } else if (target instanceof FailOverLoadBalancer) {
            answer = new ManagedFailoverLoadBalancer(context, (FailOverLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);
        } else if (target instanceof RandomLoadBalancer) {
            answer = new ManagedRandomLoadBalancer(context, (RandomLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);
        } else if (target instanceof RoundRobinLoadBalancer) {
            answer = new ManagedRoundRobinLoadBalancer(context, (RoundRobinLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);
        } else if (target instanceof StickyLoadBalancer) {
            answer = new ManagedStickyLoadBalancer(context, (StickyLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);
        } else if (target instanceof TopicLoadBalancer) {
            answer = new ManagedTopicLoadBalancer(context, (TopicLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);
        } else if (target instanceof WeightedLoadBalancer) {
            answer = new ManagedWeightedLoadBalancer(context, (WeightedLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);
        } else if (target instanceof RecipientList) {
            answer = new ManagedRecipientList(context, (RecipientList) target, (RecipientListDefinition) definition);
        } else if (target instanceof Splitter) {
            answer = new ManagedSplitter(context, (Splitter) target, (org.apache.camel.model.SplitDefinition) definition);
        } else if (target instanceof MulticastProcessor) {
            answer = new ManagedMulticast(context, (MulticastProcessor) target, definition);
        } else if (target instanceof SamplingThrottler) {
            answer = new ManagedSamplingThrottler(context, (SamplingThrottler) target, definition);
        } else if (target instanceof Resequencer) {
            answer = new ManagedResequencer(context, (Resequencer) target, definition);
        } else if (target instanceof RollbackProcessor) {
            answer = new ManagedRollback(context, (RollbackProcessor) target, definition);
        } else if (target instanceof StreamResequencer) {
            answer = new ManagedResequencer(context, (StreamResequencer) target, definition);
        } else if (target instanceof SetBodyProcessor) {
            answer = new ManagedSetBody(context, (SetBodyProcessor) target, (org.apache.camel.model.SetBodyDefinition) definition);
        } else if (target instanceof RemoveHeaderProcessor) {
            answer = new ManagedRemoveHeader(context, (RemoveHeaderProcessor) target, definition);
        } else if (target instanceof RemoveHeadersProcessor) {
            answer = new ManagedRemoveHeaders(context, (RemoveHeadersProcessor) target, definition);
        } else if (target instanceof SetHeaderProcessor) {
            answer = new ManagedSetHeader(context, (SetHeaderProcessor) target, (org.apache.camel.model.SetHeaderDefinition) definition);
        } else if (target instanceof RemovePropertyProcessor) {
            answer = new ManagedRemoveProperty(context, (RemovePropertyProcessor) target, definition);
        } else if (target instanceof RemovePropertiesProcessor) {
            answer = new ManagedRemoveProperties(context, (RemovePropertiesProcessor) target, definition);
        } else if (target instanceof SetPropertyProcessor) {
            answer = new ManagedSetProperty(context, (SetPropertyProcessor) target, (org.apache.camel.model.SetPropertyDefinition) definition);
        } else if (target instanceof ExchangePatternProcessor) {
            answer = new ManagedSetExchangePattern(context, (ExchangePatternProcessor) target, definition);
        } else if (target instanceof ScriptProcessor) {
            answer = new ManagedScript(context, (ScriptProcessor) target, (org.apache.camel.model.ScriptDefinition) definition);
        } else if (target instanceof StopProcessor) {
            answer = new ManagedStop(context, (StopProcessor) target, definition);
        } else if (target instanceof ThreadsProcessor) {
            answer = new ManagedThreads(context, (ThreadsProcessor) target, definition);
        } else if (target instanceof ThrowExceptionProcessor) {
            answer = new ManagedThrowException(context, (ThrowExceptionProcessor) target, definition);
        } else if (target instanceof TransformProcessor) {
            answer = new ManagedTransformer(context, (TransformProcessor) target, (org.apache.camel.model.TransformDefinition) definition);
        } else if (target instanceof PredicateValidatingProcessor) {
            answer = new ManagedValidate(context, (PredicateValidatingProcessor) target, (org.apache.camel.model.ValidateDefinition) definition);
        } else if (target instanceof WireTapProcessor) {
            answer = new ManagedWireTapProcessor(context, (WireTapProcessor) target, definition);
        } else if (target instanceof SendDynamicProcessor) {
            answer = new ManagedSendDynamicProcessor(context, (SendDynamicProcessor) target, definition);
        } else if (target instanceof SendProcessor) {
            SendProcessor sp = (SendProcessor) target;
                        if (sp.getDestination() instanceof LogEndpoint) {
                LogEndpoint le = (LogEndpoint) sp.getDestination();
                if (le.getLogger() instanceof ThroughputLogger) {
                    ThroughputLogger tl = (ThroughputLogger) le.getLogger();
                    answer = new ManagedThroughputLogger(context, tl, definition);
                }
            }
                        if (answer == null) {
                answer = new ManagedSendProcessor(context, (SendProcessor) target, definition);
            }
        } else if (target instanceof BeanProcessor) {
            answer = new ManagedBeanProcessor(context, (BeanProcessor) target, definition);
        } else if (target instanceof IdempotentConsumer) {
            answer = new ManagedIdempotentConsumer(context, (IdempotentConsumer) target, (org.apache.camel.model.IdempotentConsumerDefinition) definition);
        } else if (target instanceof AggregateProcessor) {
            answer = new ManagedAggregateProcessor(context, (AggregateProcessor) target, (org.apache.camel.model.AggregateDefinition) definition);
        } else if (target instanceof Enricher) {
            answer = new ManagedEnricher(context, (Enricher) target, (org.apache.camel.model.EnrichDefinition) definition);
        } else if (target instanceof PollEnricher) {
            answer = new ManagedPollEnricher(context, (PollEnricher) target, (org.apache.camel.model.PollEnrichDefinition) definition);
        } else if (target instanceof org.apache.camel.spi.ManagementAware) {
            return ((org.apache.camel.spi.ManagementAware<Processor>) target).getManagedObject(processor);
        }
                if (definition instanceof LoadBalanceDefinition) {
            LoadBalanceDefinition lb = (LoadBalanceDefinition) definition;
            if (lb.getLoadBalancerType() instanceof CustomLoadBalancerDefinition) {
                answer = new ManagedCustomLoadBalancer(context, (LoadBalancer) target, (LoadBalanceDefinition) definition);
            }
        }
        if (answer != null) {
                        break;
        }
                if (target instanceof DelegateProcessor) {
            target = ((DelegateProcessor) target).getProcessor();
        } else {
                        break;
        }
    }
    if (answer == null && definition instanceof ProcessDefinition) {
        answer = new ManagedProcess(context, target, (ProcessDefinition) definition);
    } else if (answer == null) {
                answer = new ManagedProcessor(context, target, definition);
    }
    answer.setRoute(route);
    answer.init(context.getManagementStrategy());
    return answer;
}",6.181818181818182,0.13775510204081634,10.166666666666666,23.5,5.416666666666667,1.137913989125062,-2.008316604531116,0.9166666666666666,-0.028571428571428574,17.298229834547563
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-843_65390f8c,3,"@Override
public void setLocalityGroups(String tableName, Map<String, Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {
    throw new NotImplementedException();
}",,"@Override
public void setLocalityGroups(String tableName, Map<String, Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {
    throw new NotImplementedException();
}",-0.45454545454545453,-0.6581632653061225,-0.3333333333333333,-1.0,-0.4166666666666667,-0.3806228373702422,0.7811872669916835,-0.5,0.0,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-757_76b7413d,1,"/**
 * Provides <em>direct</em> access to the internal storage array.
 * Please note that this method returns a reference to this object's
 * storage array, not a copy.
 * <br/>
 * To correctly address elements of the array, the ""start index"" is
 * required (available via the {@link #getStartIndex() getStartIndex}
 * method.
 * <br/>
 * This method should only be used to avoid copying the internal array.
 * The returned value <em>must</em> be used for reading only; other
 * uses could lead to this object becoming inconsistent.
 * <br/>
 * The {@link #getElements} method has no such limitation since it
 * returns a copy of this array's addressable elements.
 *
 * @return the internal storage array used by this object.
 * @since 3.1
 */
protected double[] getArrayRef() {
    return internalArray;
}","/**
 * Provides <em>direct</em> access to the internal storage array.
 * Please note that this method returns a reference to this object's
 * storage array, not a copy.
 * <br/>
 * To correctly address elements of the array, the ""start index"" is
 * required (available via the {@link #getStartIndex() getStartIndex}
 * method.
 * <br/>
 * This method should only be used to avoid copying the internal array.
 * The returned value <em>must</em> be used for reading only; other
 * uses could lead to this object becoming inconsistent.
 * <br/>
 * The {@link #getElements} method has no such limitation since it
 * returns a copy of this array's addressable elements.
 *
 * @return the internal storage array used by this object.
 * @since 3.1
 */
","protected double[] getArrayRef() {
    return internalArray;
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.2776025236593067,-0.5,1.6857142857142857,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1369_ce0b0955,1,"@Override
public String toString() {
    StringBuilder buff = new StringBuilder(""contains"").append('(').append(left).append("", "").append(right).append(')');
    return buff.toString();
}",,"@Override
public String toString() {
    StringBuilder buff = new StringBuilder(""contains"").append('(').append(left).append("", "").append(right).append(')');
    return buff.toString();
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.619443647834815,0.0,0.028571428571428574,-0.16422749602751402
Closure,19,2,"/**
 * Declares a refined type in {@code scope} for the name represented by
 * {@code node}. It must be possible to refine the type of the given node in
 * the given scope, as determined by {@link #getTypeIfRefinable}.
 */
protected void declareNameInScope(FlowScope scope, Node node, JSType type) {
    switch(node.getType()) {
        case Token.NAME:
            scope.inferSlotType(node.getString(), type);
            break;
        case Token.GETPROP:
            String qualifiedName = node.getQualifiedName();
            Preconditions.checkNotNull(qualifiedName);
            JSType origType = node.getJSType();
            origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;
            scope.inferQualifiedSlot(node, qualifiedName, origType, type);
            break;
        default:
            throw new IllegalArgumentException(""Node cannot be refined. \n"" + node.toStringTree());
    }
}","/**
 * Declares a refined type in {@code scope} for the name represented by
 * {@code node}. It must be possible to refine the type of the given node in
 * the given scope, as determined by {@link #getTypeIfRefinable}.
 */
","protected void declareNameInScope(FlowScope scope, Node node, JSType type) {
    switch(node.getType()) {
        case Token.NAME:
            scope.inferSlotType(node.getString(), type);
            break;
        case Token.GETPROP:
            String qualifiedName = node.getQualifiedName();
            Preconditions.checkNotNull(qualifiedName);
            JSType origType = node.getJSType();
            origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;
            scope.inferQualifiedSlot(node, qualifiedName, origType, type);
            break;
        default:
            throw new IllegalArgumentException(""Node cannot be refined. \n"" + node.toStringTree());
    }
}",0.09090909090909091,0.6479591836734694,0.6666666666666666,0.0,0.0,-0.056351952545724164,-0.1385144823630628,0.25,-0.028571428571428574,0.013555706888354932
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1270_70564c7c,1,"/**
 * Get the Lucene query for the given filter.
 *
 * @param filter the filter, including full-text constraint
 * @param reader the Lucene reader
 * @param nonFullTextConstraints whether non-full-text constraints (such a
 *            path, node type, and so on) should be added to the Lucene
 *            query
 * @param analyzer the Lucene analyzer used for building the fulltext query
 * @return the Lucene query
 */
private static Query getQuery(Filter filter, IndexReader reader, boolean nonFullTextConstraints, Analyzer analyzer) {
    List<Query> qs = new ArrayList<Query>();
    FullTextExpression ft = filter.getFullTextConstraint();
    if (ft == null) {
    // there might be no full-text constraint
    // when using the LowCostLuceneIndexProvider
    // which is used for testing
    } else {
        qs.add(getFullTextQuery(ft, analyzer));
    }
    if (nonFullTextConstraints) {
        addNonFullTextConstraints(qs, filter, reader);
    }
    if (qs.size() == 0) {
        return new MatchAllDocsQuery();
    }
    if (qs.size() == 1) {
        return qs.get(0);
    }
    BooleanQuery bq = new BooleanQuery();
    for (Query q : qs) {
        bq.add(q, MUST);
    }
    return bq;
}","/**
 * Get the Lucene query for the given filter.
 *
 * @param filter the filter, including full-text constraint
 * @param reader the Lucene reader
 * @param nonFullTextConstraints whether non-full-text constraints (such a
 *            path, node type, and so on) should be added to the Lucene
 *            query
 * @param analyzer the Lucene analyzer used for building the fulltext query
 * @return the Lucene query
 */
","private static Query getQuery(Filter filter, IndexReader reader, boolean nonFullTextConstraints, Analyzer analyzer) {
    List<Query> qs = new ArrayList<Query>();
    FullTextExpression ft = filter.getFullTextConstraint();
    if (ft == null) {
                } else {
        qs.add(getFullTextQuery(ft, analyzer));
    }
    if (nonFullTextConstraints) {
        addNonFullTextConstraints(qs, filter, reader);
    }
    if (qs.size() == 0) {
        return new MatchAllDocsQuery();
    }
    if (qs.size() == 1) {
        return qs.get(0);
    }
    BooleanQuery bq = new BooleanQuery();
    for (Query q : qs) {
        bq.add(q, MUST);
    }
    return bq;
}",0.36363636363636365,-0.42346938775510207,0.3333333333333333,-0.5,0.16666666666666666,-0.026693030153237728,-0.29251505592199617,0.16666666666666666,-0.028571428571428574,0.056449989506640805
wicket,remotes/origin/bugs-dot-jar_WICKET-4594_5e1bf8d8,1,"/**
 *  Creates a {@code IRequestHandler} that processes a listener request.
 *
 *  @param pageComponentInfo
 *  @param pageClass
 *  @param pageParameters
 *  @return a {@code IRequestHandler} that invokes the listener interface
 */
protected IRequestHandler processListener(PageComponentInfo pageComponentInfo, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters) {
    PageInfo pageInfo = pageComponentInfo.getPageInfo();
    ComponentInfo componentInfo = pageComponentInfo.getComponentInfo();
    Integer renderCount = null;
    RequestListenerInterface listenerInterface = null;
    if (componentInfo != null) {
        renderCount = componentInfo.getRenderCount();
        listenerInterface = requestListenerInterfaceFromString(componentInfo.getListenerInterface());
    }
    if (listenerInterface != null) {
        // WICKET-4594 - ignore the parsed parameters as they have nothing to do with the page
        PageAndComponentProvider provider = new PageAndComponentProvider(pageInfo.getPageId(), pageClass, null, renderCount, componentInfo.getComponentPath());
        provider.setPageSource(getContext());
        return new ListenerInterfaceRequestHandler(provider, listenerInterface, componentInfo.getBehaviorId());
    } else {
        if (logger.isWarnEnabled()) {
            if (componentInfo != null) {
                logger.warn(""Unknown listener interface '{}'"", componentInfo.getListenerInterface());
            } else {
                logger.warn(""Cannot extract the listener interface for PageComponentInfo: '{}'"" + pageComponentInfo);
            }
        }
        return null;
    }
}","/**
 *  Creates a {@code IRequestHandler} that processes a listener request.
 *
 *  @param pageComponentInfo
 *  @param pageClass
 *  @param pageParameters
 *  @return a {@code IRequestHandler} that invokes the listener interface
 */
","protected IRequestHandler processListener(PageComponentInfo pageComponentInfo, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters) {
    PageInfo pageInfo = pageComponentInfo.getPageInfo();
    ComponentInfo componentInfo = pageComponentInfo.getComponentInfo();
    Integer renderCount = null;
    RequestListenerInterface listenerInterface = null;
    if (componentInfo != null) {
        renderCount = componentInfo.getRenderCount();
        listenerInterface = requestListenerInterfaceFromString(componentInfo.getListenerInterface());
    }
    if (listenerInterface != null) {
                PageAndComponentProvider provider = new PageAndComponentProvider(pageInfo.getPageId(), pageClass, null, renderCount, componentInfo.getComponentPath());
        provider.setPageSource(getContext());
        return new ListenerInterfaceRequestHandler(provider, listenerInterface, componentInfo.getBehaviorId());
    } else {
        if (logger.isWarnEnabled()) {
            if (componentInfo != null) {
                logger.warn(""Unknown listener interface '{}'"", componentInfo.getListenerInterface());
            } else {
                logger.warn(""Cannot extract the listener interface for PageComponentInfo: '{}'"" + pageComponentInfo);
            }
        }
        return null;
    }
}",0.45454545454545453,0.6020408163265307,0.16666666666666666,0.5,0.16666666666666666,-0.02273850716757287,-0.38112991109836564,0.6666666666666666,-0.028571428571428574,0.15772161332185491
wicket,remotes/origin/bugs-dot-jar_WICKET-4520_ccb8fc9e,1,"@Override
public Component resolve(final MarkupContainer container, final MarkupStream markupStream, final ComponentTag tag) {
    String inlineEnclosureChildId = getInlineEnclosureAttribute(tag);
    if (Strings.isEmpty(inlineEnclosureChildId) == false) {
        String id = tag.getId();
        if (id.equals(INLINE_ENCLOSURE_ID_PREFIX)) {
            id = id + container.getPage().getAutoIndex();
        }
        // Yes, we handled the tag
        return new InlineEnclosure(id, inlineEnclosureChildId);
    }
    // We were not able to handle the tag
    return null;
}",,"@Override
public Component resolve(final MarkupContainer container, final MarkupStream markupStream, final ComponentTag tag) {
    String inlineEnclosureChildId = getInlineEnclosureAttribute(tag);
    if (Strings.isEmpty(inlineEnclosureChildId) == false) {
        String id = tag.getId();
        if (id.equals(INLINE_ENCLOSURE_ID_PREFIX)) {
            id = id + container.getPage().getAutoIndex();
        }
                return new InlineEnclosure(id, inlineEnclosureChildId);
    }
        return null;
}",-0.09090909090909091,0.3469387755102042,-0.16666666666666666,0.0,0.0,-0.09985170538803756,0.07427588184685989,0.0,0.39999999999999997,-0.051708704348533724
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1668_63070cf9,1,"@Override
public Cursor query(Filter filter, NodeState root) {
    if (!isLive(root)) {
        throw new IllegalStateException(""Lucene index is not live"");
    }
    FullTextExpression ft = filter.getFullTextConstraint();
    Set<String> relPaths = getRelativePaths(ft);
    if (relPaths.size() > 1) {
        return new MultiLuceneIndex(filter, root, relPaths).query();
    }
    String parent = relPaths.size() == 0 ? """" : relPaths.iterator().next();
    // we only restrict non-full-text conditions if there is
    // no relative property in the full-text constraint
    boolean nonFullTextConstraints = parent.isEmpty();
    Directory directory = newDirectory(root);
    QueryEngineSettings settings = filter.getQueryEngineSettings();
    if (directory == null) {
        return newPathCursor(Collections.<String>emptySet(), settings);
    }
    long s = System.currentTimeMillis();
    try {
        try {
            IndexReader reader = DirectoryReader.open(directory);
            try {
                IndexSearcher searcher = new IndexSearcher(reader);
                List<LuceneResultRow> rows = new ArrayList<LuceneResultRow>();
                Query query = getQuery(filter, reader, nonFullTextConstraints, analyzer);
                // TODO OAK-828
                HashSet<String> seenPaths = new HashSet<String>();
                int parentDepth = getDepth(parent);
                if (query != null) {
                    // OAK-925
                    // TODO how to best avoid loading all entries in memory?
                    // (memory problem and performance problem)
                    TopDocs docs = searcher.search(query, Integer.MAX_VALUE);
                    for (ScoreDoc doc : docs.scoreDocs) {
                        String path = reader.document(doc.doc, PATH_SELECTOR).get(PATH);
                        if (path != null) {
                            if ("""".equals(path)) {
                                path = ""/"";
                            }
                            if (!parent.isEmpty()) {
                                // TODO OAK-828 this breaks node aggregation
                                // get the base path
                                // ensure the path ends with the given
                                // relative path
                                // if (!path.endsWith(""/"" + parent)) {
                                // continue;
                                // }
                                path = getAncestorPath(path, parentDepth);
                                // avoid duplicate entries
                                if (seenPaths.contains(path)) {
                                    continue;
                                }
                                seenPaths.add(path);
                            }
                            LuceneResultRow r = new LuceneResultRow();
                            r.path = path;
                            r.score = doc.score;
                            rows.add(r);
                        }
                    }
                }
                LOG.debug(""query via {} took {} ms."", this, System.currentTimeMillis() - s);
                return new LucenePathCursor(rows, settings);
            } finally {
                reader.close();
            }
        } finally {
            directory.close();
        }
    } catch (IOException e) {
        LOG.warn(""query via {} failed."", this, e);
        return newPathCursor(Collections.<String>emptySet(), settings);
    }
}",,"@Override
public Cursor query(Filter filter, NodeState root) {
    if (!isLive(root)) {
        throw new IllegalStateException(""Lucene index is not live"");
    }
    FullTextExpression ft = filter.getFullTextConstraint();
    Set<String> relPaths = getRelativePaths(ft);
    if (relPaths.size() > 1) {
        return new MultiLuceneIndex(filter, root, relPaths).query();
    }
    String parent = relPaths.size() == 0 ? """" : relPaths.iterator().next();
            boolean nonFullTextConstraints = parent.isEmpty();
    Directory directory = newDirectory(root);
    QueryEngineSettings settings = filter.getQueryEngineSettings();
    if (directory == null) {
        return newPathCursor(Collections.<String>emptySet(), settings);
    }
    long s = System.currentTimeMillis();
    try {
        try {
            IndexReader reader = DirectoryReader.open(directory);
            try {
                IndexSearcher searcher = new IndexSearcher(reader);
                List<LuceneResultRow> rows = new ArrayList<LuceneResultRow>();
                Query query = getQuery(filter, reader, nonFullTextConstraints, analyzer);
                                HashSet<String> seenPaths = new HashSet<String>();
                int parentDepth = getDepth(parent);
                if (query != null) {
                                                                                TopDocs docs = searcher.search(query, Integer.MAX_VALUE);
                    for (ScoreDoc doc : docs.scoreDocs) {
                        String path = reader.document(doc.doc, PATH_SELECTOR).get(PATH);
                        if (path != null) {
                            if ("""".equals(path)) {
                                path = ""/"";
                            }
                            if (!parent.isEmpty()) {
                                                                                                                                                                                                                                                                path = getAncestorPath(path, parentDepth);
                                                                if (seenPaths.contains(path)) {
                                    continue;
                                }
                                seenPaths.add(path);
                            }
                            LuceneResultRow r = new LuceneResultRow();
                            r.path = path;
                            r.score = doc.score;
                            rows.add(r);
                        }
                    }
                }
                LOG.debug(""query via {} took {} ms."", this, System.currentTimeMillis() - s);
                return new LucenePathCursor(rows, settings);
            } finally {
                reader.close();
            }
        } finally {
            directory.close();
        }
    } catch (IOException e) {
        LOG.warn(""query via {} failed."", this, e);
        return newPathCursor(Collections.<String>emptySet(), settings);
    }
}",2.1818181818181817,3.724489795918368,1.6666666666666667,3.0,1.0833333333333333,0.7503707365299062,-1.0481789503871526,2.25,-0.028571428571428574,2.9459270775780473
Time,26,2,"public long addWrapField(long instant, int value) {
    if (iTimeField) {
        int offset = getOffsetToAdd(instant);
        long localInstant = iField.addWrapField(instant + offset, value);
        return localInstant - offset;
    } else {
        long localInstant = iZone.convertUTCToLocal(instant);
        localInstant = iField.addWrapField(localInstant, value);
        return iZone.convertLocalToUTC(localInstant, false);
    }
}",,"public long addWrapField(long instant, int value) {
    if (iTimeField) {
        int offset = getOffsetToAdd(instant);
        long localInstant = iField.addWrapField(instant + offset, value);
        return localInstant - offset;
    } else {
        long localInstant = iZone.convertUTCToLocal(instant);
        localInstant = iField.addWrapField(localInstant, value);
        return iZone.convertLocalToUTC(localInstant, false);
    }
}",-0.13636363636363635,0.035714285714285636,-0.3333333333333333,-0.5,-0.25,0.06030647553138907,0.16317751648981932,-0.08333333333333333,0.028571428571428574,-0.030465005717810013
commons-math,remotes/origin/bugs-dot-jar_MATH-699_b2e24119,3,"public double value(double x) {
    return cumulativeProbability(x) - p;
}",,"public double value(double x) {
    return cumulativeProbability(x) - p;
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.0785775738457126,-0.4166666666666667,2.657142857142857,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-757_76b7413d,1,"/**
 * Adds several element to the end of this expandable array.
 *
 * @param values Values to be added to end of array.
 * @since 2.2
 */
@Override
public synchronized void addElements(double[] values) {
    final double[] tempArray = new double[numElements + values.length + 1];
    System.arraycopy(internalArray, startIndex, tempArray, 0, numElements);
    System.arraycopy(values, 0, tempArray, numElements, values.length);
    internalArray = tempArray;
    startIndex = 0;
    numElements += values.length;
}","/**
 * Adds several element to the end of this expandable array.
 *
 * @param values Values to be added to end of array.
 * @since 2.2
 */
","@Override
public synchronized void addElements(double[] values) {
    final double[] tempArray = new double[numElements + values.length + 1];
    System.arraycopy(internalArray, startIndex, tempArray, 0, numElements);
    System.arraycopy(values, 0, tempArray, numElements, values.length);
    internalArray = tempArray;
    startIndex = 0;
    numElements += values.length;
}",-0.22727272727272727,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,0.08996539792387546,0.25867507886435326,-0.3333333333333333,0.05714285714285714,-0.017157713047314345
wicket,remotes/origin/bugs-dot-jar_WICKET-5898_b00920f3,1,"/**
 *  Get the markup for the child component, which is assumed to be a child of 'container'.
 */
@Override
public IMarkupFragment getMarkup(final MarkupContainer container, final Component child) {
    // If the sourcing strategy did not provide one, than ask the component.
    // Get the markup for the container
    IMarkupFragment markup = container.getMarkup();
    if (markup == null) {
        return null;
    }
    if (child == null) {
        return markup;
    }
    // Find the child's markup
    markup = markup.find(child.getId());
    if (markup != null) {
        return markup;
    }
    markup = searchMarkupInTransparentResolvers(container, child);
    return markup;
}","/**
 *  Get the markup for the child component, which is assumed to be a child of 'container'.
 */
","@Override
public IMarkupFragment getMarkup(final MarkupContainer container, final Component child) {
            IMarkupFragment markup = container.getMarkup();
    if (markup == null) {
        return null;
    }
    if (child == null) {
        return markup;
    }
        markup = markup.find(child.getId());
    if (markup != null) {
        return markup;
    }
    markup = searchMarkupInTransparentResolvers(container, child);
    return markup;
}",0.09090909090909091,-0.2908163265306122,0.0,-0.5,0.0,0.08996539792387546,-0.03240607972469159,-0.16666666666666666,0.0,-0.013071727463904979
wicket,remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4,1,"/**
 *  Adds a child component to this container.
 *  <p>
 *  Be careful when overriding this method, if not implemented properly it
 *  may lead to a java component hierarchy which no longer matches the
 *  template hierarchy, which in turn will lead to an error.
 *
 *  @param child
 *             The child
 *
 *  @throws IllegalArgumentException
 *              Thrown if a child with the same id is replaced by the add
 *              operation.
 *  @return This
 */
final MarkupContainer add(final Component<?> child) {
    if (child == null) {
        throw new IllegalArgumentException(""argument child may not be null"");
    }
    if (log.isDebugEnabled()) {
        log.debug(""Add "" + child.getId() + "" to component "" + this.getClass().getName() + "" with path "" + getPath());
    }
    // Add to map
    addedComponent(child);
    Component replaced = put(child);
    child.setFlag(FLAG_REMOVED_FROM_PARENT, false);
    if (replaced != null) {
        replaced.setFlag(FLAG_REMOVED_FROM_PARENT, true);
        removedComponent(replaced);
        // The position of the associated markup remains the same
        child.markupIndex = replaced.markupIndex;
        // The generated markup id remains the same
        String replacedId = (replaced.hasMarkupIdMetaData()) ? replaced.getMarkupId() : null;
        child.setMarkupIdMetaData(replacedId);
    }
    return this;
}","/**
 *  Adds a child component to this container.
 *  <p>
 *  Be careful when overriding this method, if not implemented properly it
 *  may lead to a java component hierarchy which no longer matches the
 *  template hierarchy, which in turn will lead to an error.
 *
 *  @param child
 *             The child
 *
 *  @throws IllegalArgumentException
 *              Thrown if a child with the same id is replaced by the add
 *              operation.
 *  @return This
 */
","final MarkupContainer add(final Component<?> child) {
    if (child == null) {
        throw new IllegalArgumentException(""argument child may not be null"");
    }
    if (log.isDebugEnabled()) {
        log.debug(""Add "" + child.getId() + "" to component "" + this.getClass().getName() + "" with path "" + getPath());
    }
        addedComponent(child);
    Component replaced = put(child);
    child.setFlag(FLAG_REMOVED_FROM_PARENT, false);
    if (replaced != null) {
        replaced.setFlag(FLAG_REMOVED_FROM_PARENT, true);
        removedComponent(replaced);
                child.markupIndex = replaced.markupIndex;
                String replacedId = (replaced.hasMarkupIdMetaData()) ? replaced.getMarkupId() : null;
        child.setMarkupIdMetaData(replacedId);
    }
    return this;
}",0.22727272727272727,-0.24489795918367346,0.3333333333333333,-0.5,0.25,0.2738507167572912,-0.23343848580441648,0.6666666666666666,-0.028571428571428574,0.2685272034983575
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-843_65390f8c,3,"@Override
public void online(String tableName) throws AccumuloSecurityException, AccumuloException {
}",,"@Override
public void online(String tableName) throws AccumuloSecurityException, AccumuloException {
}",-0.5,-1.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.0662460567823349,-0.5,1.8,-0.16422749602751402
Lang,51,1,"// String to boolean methods
// -----------------------------------------------------------------------
/**
 * <p>Converts a String to a boolean (optimised for performance).</p>
 *
 * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>
 * (case insensitive) will return <code>true</code>. Otherwise,
 * <code>false</code> is returned.</p>
 *
 * <p>This method performs 4 times faster (JDK1.4) than
 * <code>Boolean.valueOf(String)</code>. However, this method accepts
 * 'on' and 'yes' as true values.
 *
 * <pre>
 *   BooleanUtils.toBoolean(null)    = false
 *   BooleanUtils.toBoolean(""true"")  = true
 *   BooleanUtils.toBoolean(""TRUE"")  = true
 *   BooleanUtils.toBoolean(""tRUe"")  = true
 *   BooleanUtils.toBoolean(""on"")    = true
 *   BooleanUtils.toBoolean(""yes"")   = true
 *   BooleanUtils.toBoolean(""false"") = false
 *   BooleanUtils.toBoolean(""x gti"") = false
 * </pre>
 *
 * @param str  the String to check
 * @return the boolean value of the string, <code>false</code> if no match
 */
public static boolean toBoolean(String str) {
    // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.
    if (str == ""true"") {
        return true;
    }
    if (str == null) {
        return false;
    }
    switch(str.length()) {
        case 2:
            {
                char ch0 = str.charAt(0);
                char ch1 = str.charAt(1);
                return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N');
            }
        case 3:
            {
                char ch = str.charAt(0);
                if (ch == 'y') {
                    return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S');
                }
                if (ch == 'Y') {
                    return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's');
                }
            }
        case 4:
            {
                char ch = str.charAt(0);
                if (ch == 't') {
                    return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E');
                }
                if (ch == 'T') {
                    return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e');
                }
            }
    }
    return false;
}","/**
 * <p>Converts a String to a boolean (optimised for performance).</p>
 *
 * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>
 * (case insensitive) will return <code>true</code>. Otherwise,
 * <code>false</code> is returned.</p>
 *
 * <p>This method performs 4 times faster (JDK1.4) than
 * <code>Boolean.valueOf(String)</code>. However, this method accepts
 * 'on' and 'yes' as true values.
 *
 * <pre>
 *   BooleanUtils.toBoolean(null)    = false
 *   BooleanUtils.toBoolean(""true"")  = true
 *   BooleanUtils.toBoolean(""TRUE"")  = true
 *   BooleanUtils.toBoolean(""tRUe"")  = true
 *   BooleanUtils.toBoolean(""on"")    = true
 *   BooleanUtils.toBoolean(""yes"")   = true
 *   BooleanUtils.toBoolean(""false"") = false
 *   BooleanUtils.toBoolean(""x gti"") = false
 * </pre>
 *
 * @param str  the String to check
 * @return the boolean value of the string, <code>false</code> if no match
 */
","public static boolean toBoolean(String str) {
        if (str == ""true"") {
        return true;
    }
    if (str == null) {
        return false;
    }
    switch(str.length()) {
        case 2:
            {
                char ch0 = str.charAt(0);
                char ch1 = str.charAt(1);
                return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N');
            }
        case 3:
            {
                char ch = str.charAt(0);
                if (ch == 'y') {
                    return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S');
                }
                if (ch == 'Y') {
                    return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's');
                }
            }
        case 4:
            {
                char ch = str.charAt(0);
                if (ch == 't') {
                    return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E');
                }
                if (ch == 'T') {
                    return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e');
                }
            }
    }
    return false;
}",1.0454545454545454,1.4540816326530612,1.0,0.5,0.5833333333333334,1.1537320810677214,-0.7358761112704332,1.5833333333333333,-0.028571428571428574,2.934046025158364
camel,remotes/origin/bugs-dot-jar_CAMEL-3757_c1b2f2f8,3,"public Endpoint registerEndpoint(String uri, Endpoint endpoint) {
    if (endpoint instanceof InterceptSendToEndpoint) {
        // endpoint already decorated
        return endpoint;
    } else if (endpoint instanceof MockEndpoint) {
        // we should not intercept mock endpoints
        return endpoint;
    } else if (uri == null || pattern == null || EndpointHelper.matchEndpoint(uri, pattern)) {
        // if pattern is null then it mean to match all
        // only proxy if the uri is matched decorate endpoint with our proxy
        // should be false by default
        InterceptSendToEndpoint proxy = new InterceptSendToEndpoint(endpoint, false);
        // create mock endpoint which we will use as interceptor
        // replace :// from scheme to make it easy to lookup the mock endpoint without having double :// in uri
        String key = ""mock:"" + endpoint.getEndpointKey().replaceFirst(""://"", "":"");
        LOG.info(""Adviced endpoint ["" + uri + ""] with mock endpoint ["" + key + ""]"");
        MockEndpoint mock = endpoint.getCamelContext().getEndpoint(key, MockEndpoint.class);
        Processor producer;
        try {
            producer = mock.createProducer();
        } catch (Exception e) {
            throw wrapRuntimeCamelException(e);
        }
        proxy.setDetour(producer);
        return proxy;
    } else {
        // no proxy so return regular endpoint
        return endpoint;
    }
}",,"public Endpoint registerEndpoint(String uri, Endpoint endpoint) {
    if (endpoint instanceof InterceptSendToEndpoint) {
                return endpoint;
    } else if (endpoint instanceof MockEndpoint) {
                return endpoint;
    } else if (uri == null || pattern == null || EndpointHelper.matchEndpoint(uri, pattern)) {
                                InterceptSendToEndpoint proxy = new InterceptSendToEndpoint(endpoint, false);
                        String key = ""mock:"" + endpoint.getEndpointKey().replaceFirst(""://"", "":"");
        LOG.info(""Adviced endpoint ["" + uri + ""] with mock endpoint ["" + key + ""]"");
        MockEndpoint mock = endpoint.getCamelContext().getEndpoint(key, MockEndpoint.class);
        Processor producer;
        try {
            producer = mock.createProducer();
        } catch (Exception e) {
            throw wrapRuntimeCamelException(e);
        }
        proxy.setDetour(producer);
        return proxy;
    } else {
                return endpoint;
    }
}",0.36363636363636365,0.015306122448979493,0.3333333333333333,1.0,0.3333333333333333,0.31932773109243706,-0.334384858044164,0.25,-0.028571428571428574,0.4132199193938693
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1044_9396979b,0,"public String getViolationDescription(short violationCode) {
    switch(violationCode) {
        case 1:
            return ""data file size must be a non-negative integer"";
        case 2:
            return ""Invalid column name given."";
        case 3:
            return ""Prev end row is greater than or equal to end row."";
        case 4:
            return ""Invalid metadata row format"";
        case 5:
            return ""Row can not be less than "" + Constants.METADATA_TABLE_ID;
        case 6:
            return ""Empty values are not allowed for any "" + Constants.METADATA_TABLE_NAME + "" column"";
        case 7:
            return ""Lock not held in zookeeper by writer"";
    }
    return null;
}",,"public String getViolationDescription(short violationCode) {
    switch(violationCode) {
        case 1:
            return ""data file size must be a non-negative integer"";
        case 2:
            return ""Invalid column name given."";
        case 3:
            return ""Prev end row is greater than or equal to end row."";
        case 4:
            return ""Invalid metadata row format"";
        case 5:
            return ""Row can not be less than "" + Constants.METADATA_TABLE_ID;
        case 6:
            return ""Empty values are not allowed for any "" + Constants.METADATA_TABLE_NAME + "" column"";
        case 7:
            return ""Lock not held in zookeeper by writer"";
    }
    return null;
}",0.22727272727272727,0.4438775510204082,0.6666666666666666,0.0,0.25,-0.3806228373702422,-0.11213077143676506,-0.5,0.0,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3053_7552a10b,1,"protected Directory createLocalDirForIndexWriter(IndexDefinition definition) throws IOException {
    String indexPath = definition.getIndexPathFromConfig();
    File indexWriterDir;
    if (indexPath == null) {
        // If indexPath is not known create a unique directory for work
        indexWriterDir = new File(indexWorkDir, String.valueOf(UNIQUE_COUNTER.incrementAndGet()));
    } else {
        File indexDir = getIndexDir(indexPath);
        String newVersion = String.valueOf(definition.getReindexCount());
        indexWriterDir = getVersionedDir(indexPath, indexDir, newVersion);
    }
    Directory dir = FSDirectory.open(indexWriterDir);
    log.debug(""IndexWriter would use {}"", indexWriterDir);
    if (indexPath == null) {
        dir = new DeleteOldDirOnClose(dir, indexWriterDir);
        log.debug(""IndexPath [{}] not configured in index definition {}. Writer would create index "" + ""files in temporary dir {} which would be deleted upon close. For better performance do "" + ""configure the 'indexPath' as part of your index definition"", LuceneIndexConstants.INDEX_PATH, definition, indexWriterDir);
    }
    return dir;
}",,"protected Directory createLocalDirForIndexWriter(IndexDefinition definition) throws IOException {
    String indexPath = definition.getIndexPathFromConfig();
    File indexWriterDir;
    if (indexPath == null) {
                indexWriterDir = new File(indexWorkDir, String.valueOf(UNIQUE_COUNTER.incrementAndGet()));
    } else {
        File indexDir = getIndexDir(indexPath);
        String newVersion = String.valueOf(definition.getReindexCount());
        indexWriterDir = getVersionedDir(indexPath, indexDir, newVersion);
    }
    Directory dir = FSDirectory.open(indexWriterDir);
    log.debug(""IndexWriter would use {}"", indexWriterDir);
    if (indexPath == null) {
        dir = new DeleteOldDirOnClose(dir, indexWriterDir);
        log.debug(""IndexPath [{}] not configured in index definition {}. Writer would create index "" + ""files in temporary dir {} which would be deleted upon close. For better performance do "" + ""configure the 'indexPath' as part of your index definition"", LuceneIndexConstants.INDEX_PATH, definition, indexWriterDir);
    }
    return dir;
}",0.18181818181818182,-0.2602040816326532,-0.16666666666666666,-0.5,-0.16666666666666666,-0.014829461196243152,-0.21594493834241477,0.3333333333333333,-0.028571428571428574,0.12637859183402503
commons-math,remotes/origin/bugs-dot-jar_MATH-724_9c8bb934,1,"/**
 * Generate a random int value uniformly distributed between
 * <code>lower</code> and <code>upper</code>, inclusive. This algorithm uses
 * a secure random number generator.
 *
 * @param lower
 *            the lower bound.
 * @param upper
 *            the upper bound.
 * @return the random integer.
 * @throws NumberIsTooLargeException if {@code lower >= upper}.
 */
public int nextSecureInt(int lower, int upper) {
    if (lower >= upper) {
        throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND, lower, upper, false);
    }
    SecureRandom sec = getSecRan();
    return lower + (int) (sec.nextDouble() * (upper - lower + 1));
}","/**
 * Generate a random int value uniformly distributed between
 * <code>lower</code> and <code>upper</code>, inclusive. This algorithm uses
 * a secure random number generator.
 *
 * @param lower
 *            the lower bound.
 * @param upper
 *            the upper bound.
 * @return the random integer.
 * @throws NumberIsTooLargeException if {@code lower >= upper}.
 */
","public int nextSecureInt(int lower, int upper) {
    if (lower >= upper) {
        throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND, lower, upper, false);
    }
    SecureRandom sec = getSecRan();
    return lower + (int) (sec.nextDouble() * (upper - lower + 1));
}",-0.3181818181818182,-0.2346938775510204,-0.16666666666666666,-0.5,-0.16666666666666666,0.2580326248146318,0.3989102380269573,-0.3333333333333333,0.2571428571428572,-0.008433234395946565
wicket,remotes/origin/bugs-dot-jar_WICKET-5460_a3a5a40f,1,"/**
 *  @param setRenderingFlag
 *             rendering flag
 */
void internalMarkRendering(boolean setRenderingFlag) {
    if (setRenderingFlag) {
        setFlag(FLAG_PREPARED_FOR_RENDER, false);
        setFlag(FLAG_RENDERING, true);
    } else {
        setFlag(FLAG_RENDERING, false);
    }
}","/**
 *  @param setRenderingFlag
 *             rendering flag
 */
","void internalMarkRendering(boolean setRenderingFlag) {
    if (setRenderingFlag) {
        setFlag(FLAG_PREPARED_FOR_RENDER, false);
        setFlag(FLAG_RENDERING, true);
    } else {
        setFlag(FLAG_RENDERING, false);
    }
}",-0.2727272727272727,0.051020408163265356,-0.3333333333333333,-0.5,-0.25,-0.3806228373702422,0.501577287066246,-0.25,2.542857142857143,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-428_d906576c,3,"public Object next() {
    index++;
    return key;
}",,"public Object next() {
    index++;
    return key;
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9678806997418987,-0.5,2.7142857142857144,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-1619_b154d12f,1,"/**
 *  Create a new PagingNavigation. May be subclassed to make us of specialized PagingNavigation.
 *
 *  @param pageable
 *             the pageable component
 *  @param labelProvider
 *             The label provider for the link text.
 *  @return the navigation object
 */
protected PagingNavigation newNavigation(final IPageable pageable, final IPagingLabelProvider labelProvider) {
    return new PagingNavigation(""navigation"", pageable, labelProvider) {

        private static final long serialVersionUID = 1L;

        @Override
        public boolean isEnabled() {
            return PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();
        }
    };
}","/**
 *  Create a new PagingNavigation. May be subclassed to make us of specialized PagingNavigation.
 *
 *  @param pageable
 *             the pageable component
 *  @param labelProvider
 *             The label provider for the link text.
 *  @return the navigation object
 */
","protected PagingNavigation newNavigation(final IPageable pageable, final IPagingLabelProvider labelProvider) {
    return new PagingNavigation(""navigation"", pageable, labelProvider) {

        private static final long serialVersionUID = 1L;

        @Override
        public boolean isEnabled() {
            return PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();
        }
    };
}",-0.22727272727272727,0.40816326530612235,-0.5,-0.5,-0.4166666666666667,-0.11171527434503209,0.338973329509607,-0.3333333333333333,2.314285714285714,-0.11540125320689906
camel,remotes/origin/bugs-dot-jar_CAMEL-8146_17475d80,3,"@Override
protected void doStop() throws Exception {
    if (future != null) {
        LOG.debug(""This consumer is stopping, so cancelling scheduled task: "" + future);
        future.cancel(false);
        future = null;
    }
}",,"@Override
protected void doStop() throws Exception {
    if (future != null) {
        LOG.debug(""This consumer is stopping, so cancelling scheduled task: "" + future);
        future.cancel(false);
        future = null;
    }
}",-0.2727272727272727,0.22448979591836732,-0.3333333333333333,-0.5,-0.25,-0.11171527434503209,0.4175509033553199,-0.3333333333333333,1.1142857142857143,-0.12420282592587835
wicket,remotes/origin/bugs-dot-jar_WICKET-5426_fb45a781,3,"/**
 *  @see org.apache.wicket.Component#onBeforeRender()
 */
@Override
protected void onBeforeRender() {
    // Make sure it is really empty
    renderedComponents = null;
    // if the page is stateless, reset the flag so that it is tested again
    if (Boolean.TRUE.equals(stateless)) {
        stateless = null;
    }
    super.onBeforeRender();
    // for links rendered before first stateful component
    if (getSession().isTemporary() && !peekPageStateless()) {
        getSession().bind();
    }
}","/**
 *  @see org.apache.wicket.Component#onBeforeRender()
 */
","@Override
protected void onBeforeRender() {
        renderedComponents = null;
        if (Boolean.TRUE.equals(stateless)) {
        stateless = null;
    }
    super.onBeforeRender();
        if (getSession().isTemporary() && !peekPageStateless()) {
        getSession().bind();
    }
}",-0.13636363636363635,-0.17857142857142863,-0.16666666666666666,-0.5,0.16666666666666666,-0.12160158180919424,0.23257814740464589,0.08333333333333333,0.4571428571428572,-0.11717869976571971
Codec,13,1,"/**
 * Check if the Double Metaphone values of two <code>String</code> values
 * are equal, optionally using the alternate value.
 *
 * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.
 * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.
 * @param alternate use the alternate value if {@code true}.
 * @return {@code true} if the encoded <code>String</code>s are equal;
 *          {@code false} otherwise.
 */
public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {
    return doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate));
}","/**
 * Check if the Double Metaphone values of two <code>String</code> values
 * are equal, optionally using the alternate value.
 *
 * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.
 * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.
 * @param alternate use the alternate value if {@code true}.
 * @return {@code true} if the encoded <code>String</code>s are equal;
 *          {@code false} otherwise.
 */
","public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {
    return doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate));
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9529681674792084,-0.25,0.5142857142857143,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-1096_faf99727,0,"/**
 * {@inheritDoc}
 */
public EnclosingBall<S, P> enclose(final List<P> points) {
    if (points == null || points.isEmpty()) {
        // return an empty ball
        return generator.ballOnSupport(new ArrayList<P>());
    }
    // Emo Welzl algorithm with Bernd Gärtner and Linus Källberg improvements
    return pivotingBall(points);
}","/**
 * {@inheritDoc}
 */
","public EnclosingBall<S, P> enclose(final List<P> points) {
    if (points == null || points.isEmpty()) {
                return generator.ballOnSupport(new ArrayList<P>());
    }
        return pivotingBall(points);
}",-0.36363636363636365,-0.13775510204081634,-0.3333333333333333,-0.5,-0.08333333333333333,-0.10776075135936727,0.5316891310582161,-0.25,2.657142857142857,-0.11788967838924795
Compress,20,1,"private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException {
    CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY);
    ret.setDevice(readBinaryLong(2, swapHalfWord));
    ret.setInode(readBinaryLong(2, swapHalfWord));
    final long mode = readBinaryLong(2, swapHalfWord);
    if (mode != 0) {
        ret.setMode(mode);
    }
    ret.setUID(readBinaryLong(2, swapHalfWord));
    ret.setGID(readBinaryLong(2, swapHalfWord));
    ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord));
    ret.setRemoteDevice(readBinaryLong(2, swapHalfWord));
    ret.setTime(readBinaryLong(4, swapHalfWord));
    long namesize = readBinaryLong(2, swapHalfWord);
    ret.setSize(readBinaryLong(4, swapHalfWord));
    final String name = readCString((int) namesize);
    ret.setName(name);
    if (mode == 0 && !name.equals(CPIO_TRAILER)) {
        throw new IOException(""Mode 0 only allowed in the trailer. Found entry: "" + name + ""Occured at byte: "" + getBytesRead());
    }
    skip(ret.getHeaderPadCount());
    return ret;
}",,"private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException {
    CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY);
    ret.setDevice(readBinaryLong(2, swapHalfWord));
    ret.setInode(readBinaryLong(2, swapHalfWord));
    final long mode = readBinaryLong(2, swapHalfWord);
    if (mode != 0) {
        ret.setMode(mode);
    }
    ret.setUID(readBinaryLong(2, swapHalfWord));
    ret.setGID(readBinaryLong(2, swapHalfWord));
    ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord));
    ret.setRemoteDevice(readBinaryLong(2, swapHalfWord));
    ret.setTime(readBinaryLong(4, swapHalfWord));
    long namesize = readBinaryLong(2, swapHalfWord);
    ret.setSize(readBinaryLong(4, swapHalfWord));
    final String name = readCString((int) namesize);
    ret.setName(name);
    if (mode == 0 && !name.equals(CPIO_TRAILER)) {
        throw new IOException(""Mode 0 only allowed in the trailer. Found entry: "" + name + ""Occured at byte: "" + getBytesRead());
    }
    skip(ret.getHeaderPadCount());
    return ret;
}",0.4090909090909091,-0.6887755102040817,0.0,-0.5,0.0,1.1122095897182405,-0.3785488958990538,1.5833333333333333,-0.028571428571428574,1.4072194311314412
camel,remotes/origin/bugs-dot-jar_CAMEL-8227_54d7fc59,3,"@Override
protected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) throws Exception {
    // here we iterate the recipient lists and create the exchange pair for each of those
    List<ProcessorExchangePair> result = new ArrayList<ProcessorExchangePair>();
    // at first we must lookup the endpoint and acquire the producer which can send to the endpoint
    int index = 0;
    while (iter.hasNext()) {
        Object recipient = iter.next();
        Endpoint endpoint;
        Producer producer;
        ExchangePattern pattern;
        try {
            endpoint = resolveEndpoint(exchange, recipient);
            pattern = resolveExchangePattern(exchange, recipient);
            producer = producerCache.acquireProducer(endpoint);
        } catch (Exception e) {
            if (isIgnoreInvalidEndpoints()) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Endpoint uri is invalid: "" + recipient + "". This exception will be ignored."", e);
                }
                continue;
            } else {
                // failure so break out
                throw e;
            }
        }
        // then create the exchange pair
        result.add(createProcessorExchangePair(index++, endpoint, producer, exchange, pattern));
    }
    return result;
}",,"@Override
protected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) throws Exception {
        List<ProcessorExchangePair> result = new ArrayList<ProcessorExchangePair>();
        int index = 0;
    while (iter.hasNext()) {
        Object recipient = iter.next();
        Endpoint endpoint;
        Producer producer;
        ExchangePattern pattern;
        try {
            endpoint = resolveEndpoint(exchange, recipient);
            pattern = resolveExchangePattern(exchange, recipient);
            producer = producerCache.acquireProducer(endpoint);
        } catch (Exception e) {
            if (isIgnoreInvalidEndpoints()) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Endpoint uri is invalid: "" + recipient + "". This exception will be ignored."", e);
                }
                continue;
            } else {
                                throw e;
            }
        }
                result.add(createProcessorExchangePair(index++, endpoint, producer, exchange, pattern));
    }
    return result;
}",0.5909090909090909,1.1428571428571428,0.5,1.0,0.08333333333333333,-0.06030647553138898,-0.42873530255233744,0.3333333333333333,-0.028571428571428574,0.08712057940474816
camel,remotes/origin/bugs-dot-jar_CAMEL-8964_ea8ee025,1,"/**
 * Resumes the given {@code service}.
 * <p/>
 * If {@code service} is a {@link org.apache.camel.SuspendableService} then
 * it's {@link org.apache.camel.SuspendableService#resume()} is called but
 * <b>only</b> if {@code service} is already {@link #isSuspended(Object)
 * suspended}.
 * <p/>
 * If {@code service} is <b>not</b> a
 * {@link org.apache.camel.SuspendableService} then it's
 * {@link org.apache.camel.Service#start()} is called.
 * <p/>
 * Calling this method has no effect if {@code service} is {@code null}.
 *
 * @param service the service
 * @return <tt>true</tt> if either <tt>resume</tt> method or
 *         {@link #startService(Service)} was called, <tt>false</tt>
 *         otherwise.
 * @throws Exception is thrown if error occurred
 * @see #startService(Service)
 */
public static boolean resumeService(Service service) throws Exception {
    if (service instanceof SuspendableService) {
        SuspendableService ss = (SuspendableService) service;
        if (ss.isSuspended()) {
            LOG.debug(""Resuming service {}"", service);
            ss.resume();
            return true;
        } else {
            return false;
        }
    } else {
        startService(service);
        return true;
    }
}","/**
 * Resumes the given {@code service}.
 * <p/>
 * If {@code service} is a {@link org.apache.camel.SuspendableService} then
 * it's {@link org.apache.camel.SuspendableService#resume()} is called but
 * <b>only</b> if {@code service} is already {@link #isSuspended(Object)
 * suspended}.
 * <p/>
 * If {@code service} is <b>not</b> a
 * {@link org.apache.camel.SuspendableService} then it's
 * {@link org.apache.camel.Service#start()} is called.
 * <p/>
 * Calling this method has no effect if {@code service} is {@code null}.
 *
 * @param service the service
 * @return <tt>true</tt> if either <tt>resume</tt> method or
 *         {@link #startService(Service)} was called, <tt>false</tt>
 *         otherwise.
 * @throws Exception is thrown if error occurred
 * @see #startService(Service)
 */
","public static boolean resumeService(Service service) throws Exception {
    if (service instanceof SuspendableService) {
        SuspendableService ss = (SuspendableService) service;
        if (ss.isSuspended()) {
            LOG.debug(""Resuming service {}"", service);
            ss.resume();
            return true;
        } else {
            return false;
        }
    } else {
        startService(service);
        return true;
    }
}",0.045454545454545456,0.4591836734693877,-0.16666666666666666,0.0,-0.08333333333333333,-0.3806228373702422,0.06251792371666169,-0.16666666666666666,-0.028571428571428574,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-640_98556fed,1,"/**
 * Returns the next pseudorandom, uniformly distributed {@code int}
 * value from this random number generator's sequence.
 * All 2<font size=""-1""><sup>32</sup></font> possible {@code int} values
 * should be produced with  (approximately) equal probability.
 * <p>
 * The default implementation provided here returns
 * <pre>
 * <code>(int) (nextDouble() * Integer.MAX_VALUE)</code>
 * </pre></p>
 *
 * @return the next pseudorandom, uniformly distributed {@code int}
 *  value from this random number generator's sequence
 */
public int nextInt() {
    return (int) (nextDouble() * Integer.MAX_VALUE);
}","/**
 * Returns the next pseudorandom, uniformly distributed {@code int}
 * value from this random number generator's sequence.
 * All 2<font size=""-1""><sup>32</sup></font> possible {@code int} values
 * should be produced with  (approximately) equal probability.
 * <p>
 * The default implementation provided here returns
 * <pre>
 * <code>(int) (nextDouble() * Integer.MAX_VALUE)</code>
 * </pre></p>
 *
 * @return the next pseudorandom, uniformly distributed {@code int}
 *  value from this random number generator's sequence
 */
","public int nextInt() {
    return (int) (nextDouble() * Integer.MAX_VALUE);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.1015199311729282,-0.4166666666666667,2.0,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-4927_8c827e33,1,"@Override
public void addCookie(Cookie cookie) {
    checkHeader();
    bufferedResponse.addCookie(cookie);
}",,"@Override
public void addCookie(Cookie cookie) {
    checkHeader();
    bufferedResponse.addCookie(cookie);
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7912245483223405,-0.3333333333333333,1.7142857142857144,-0.16422749602751402
Closure,54,2,"/**
 * Declare the symbol for a qualified name in the global scope.
 *
 * @param info The doc info for this property.
 * @param n A top-level GETPROP node (it should not be contained inside
 *     another GETPROP).
 * @param parent The parent of {@code n}.
 * @param rhsValue The node that {@code n} is being initialized to,
 *     or {@code null} if this is a stub declaration.
 */
void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {
    Node ownerNode = n.getFirstChild();
    String ownerName = ownerNode.getQualifiedName();
    String qName = n.getQualifiedName();
    String propName = n.getLastChild().getString();
    Preconditions.checkArgument(qName != null && ownerName != null);
    // Precedence of type information on GETPROPs:
    // 1) @type annnotation / @enum annotation
    // 2) ASSIGN to FUNCTION literal
    // 3) @param/@return annotation (with no function literal)
    // 4) ASSIGN to something marked @const
    // 5) ASSIGN to anything else
    // 
    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff
    // the function has jsdoc or has not been declared before.
    // 
    // FUNCTION literals are special because TypedScopeCreator is very smart
    // about getting as much type information as possible for them.
    // Determining type for #1 + #2 + #3 + #4
    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
    if (valueType == null && rhsValue != null) {
        // Determining type for #5
        valueType = rhsValue.getJSType();
    }
    // allow F.prototype to be redefined arbitrarily.
    if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
            // the @extends tag.
            if (!qVar.isTypeInferred()) {
                // what props are going to be on that prototype.
                return;
            }
            if (qVar.getScope() == scope) {
                scope.undeclare(qVar);
            }
        }
    }
    if (valueType == null) {
        if (parent.getType() == Token.EXPR_RESULT) {
            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));
        }
        return;
    }
    boolean inferred = true;
    if (info != null) {
        // Determining declaration for #1 + #3 + #4
        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
    }
    if (inferred) {
        // Determining declaration for #2
        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));
    }
    if (!inferred) {
        ObjectType ownerType = getObjectSlot(ownerName);
        if (ownerType != null) {
            // Only declare this as an official property if it has not been
            // declared yet.
            boolean isExtern = t.getInput() != null && t.getInput().isExtern();
            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {
                // If the property is undeclared or inferred, declare it now.
                ownerType.defineDeclaredProperty(propName, valueType, n);
            }
        }
        // If the property is already declared, the error will be
        // caught when we try to declare it in the current scope.
        defineSlot(n, parent, valueType, inferred);
    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {
        // We declare these for delegate proxy method properties.
        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerType != null) {
            JSType ownerTypeOfThis = ownerType.getTypeOfThis();
            String delegateName = codingConvention.getDelegateSuperclassName();
            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);
            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {
                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
            }
        }
    }
}","/**
 * Declare the symbol for a qualified name in the global scope.
 *
 * @param info The doc info for this property.
 * @param n A top-level GETPROP node (it should not be contained inside
 *     another GETPROP).
 * @param parent The parent of {@code n}.
 * @param rhsValue The node that {@code n} is being initialized to,
 *     or {@code null} if this is a stub declaration.
 */
","void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {
    Node ownerNode = n.getFirstChild();
    String ownerName = ownerNode.getQualifiedName();
    String qName = n.getQualifiedName();
    String propName = n.getLastChild().getString();
    Preconditions.checkArgument(qName != null && ownerName != null);
                                                        JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
    if (valueType == null && rhsValue != null) {
                valueType = rhsValue.getJSType();
    }
        if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
                        if (!qVar.isTypeInferred()) {
                                return;
            }
            if (qVar.getScope() == scope) {
                scope.undeclare(qVar);
            }
        }
    }
    if (valueType == null) {
        if (parent.getType() == Token.EXPR_RESULT) {
            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));
        }
        return;
    }
    boolean inferred = true;
    if (info != null) {
                inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
    }
    if (inferred) {
                inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));
    }
    if (!inferred) {
        ObjectType ownerType = getObjectSlot(ownerName);
        if (ownerType != null) {
                                    boolean isExtern = t.getInput() != null && t.getInput().isExtern();
            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {
                                ownerType.defineDeclaredProperty(propName, valueType, n);
            }
        }
                        defineSlot(n, parent, valueType, inferred);
    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {
                FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerType != null) {
            JSType ownerTypeOfThis = ownerType.getTypeOfThis();
            String delegateName = codingConvention.getDelegateSuperclassName();
            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);
            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {
                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
            }
        }
    }
}",1.8636363636363635,0.5357142857142858,2.1666666666666665,1.0,3.25,1.106277805239743,-1.0493260682535135,3.25,-0.028571428571428574,5.0712863145180975
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-4113_27300d81,0,"public static ByteBuffer toByteBuffers(ByteSequence bs) {
    if (bs == null)
        return null;
    if (bs.isBackedByArray()) {
        return ByteBuffer.wrap(bs.getBackingArray(), bs.offset(), bs.length());
    } else {
        // TODO create more efficient impl
        return ByteBuffer.wrap(bs.toArray());
    }
}",,"public static ByteBuffer toByteBuffers(ByteSequence bs) {
    if (bs == null)
        return null;
    if (bs.isBackedByArray()) {
        return ByteBuffer.wrap(bs.getBackingArray(), bs.offset(), bs.length());
    } else {
                return ByteBuffer.wrap(bs.toArray());
    }
}",-0.22727272727272727,-0.035714285714285636,-0.16666666666666666,-0.5,-0.08333333333333333,-0.3806228373702422,0.3240607972469171,0.08333333333333333,0.028571428571428574,-0.16422749602751402
Closure,5,1,"/**
 * Counts the number of direct (full) references to an object.
 * Specifically, we check for references of the following type:
 * <pre>
 *   x;
 *   x.fn();
 * </pre>
 */
private boolean isInlinableObject(List<Reference> refs) {
    boolean ret = false;
    Set<String> validProperties = Sets.newHashSet();
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();
        // 
        if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
            // A call target may be using the object as a 'this' value.
            if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }
            // Deleting a property has different semantics from deleting
            // a variable, so deleted properties should not be inlined.
            // NOTE(nicksantos): This pass's object-splitting algorithm has
            // a blind spot. It assumes that if a property isn't defined on an
            // object, then the value is undefined. This is not true, because
            // Object.prototype can have arbitrary properties on it.
            // 
            // We short-circuit this problem by bailing out if we see a reference
            // to a property that isn't defined on the object literal. This
            // isn't a perfect algorithm, but it should catch most cases.
            String propName = parent.getLastChild().getString();
            if (!validProperties.contains(propName)) {
                if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
                    validProperties.add(propName);
                } else {
                    return false;
                }
            }
            continue;
        }
        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
            return false;
        }
        Node val = ref.getAssignedValue();
        if (val == null) {
            // A var with no assignment.
            continue;
        }
        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
            return false;
        }
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                // ES5 get/set not supported.
                return false;
            }
            validProperties.add(child.getString());
            Node childVal = child.getFirstChild();
            // will happen.
            for (Reference t : refs) {
                Node refNode = t.getParent();
                while (!NodeUtil.isStatementBlock(refNode)) {
                    if (refNode == childVal) {
                        // There's a self-referential assignment
                        return false;
                    }
                    refNode = refNode.getParent();
                }
            }
        }
        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
    }
    return ret;
}","/**
 * Counts the number of direct (full) references to an object.
 * Specifically, we check for references of the following type:
 * <pre>
 *   x;
 *   x.fn();
 * </pre>
 */
","private boolean isInlinableObject(List<Reference> refs) {
    boolean ret = false;
    Set<String> validProperties = Sets.newHashSet();
    for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();
                if (parent.isGetProp()) {
            Preconditions.checkState(parent.getFirstChild() == name);
                        if (gramps.isCall() && gramps.getFirstChild() == parent) {
                return false;
            }
                                                                                                                                    String propName = parent.getLastChild().getString();
            if (!validProperties.contains(propName)) {
                if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
                    validProperties.add(propName);
                } else {
                    return false;
                }
            }
            continue;
        }
                if (!isVarOrAssignExprLhs(name)) {
            return false;
        }
        Node val = ref.getAssignedValue();
        if (val == null) {
                        continue;
        }
                if (!val.isObjectLit()) {
            return false;
        }
                for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {
            if (child.isGetterDef() || child.isSetterDef()) {
                                return false;
            }
            validProperties.add(child.getString());
            Node childVal = child.getFirstChild();
                        for (Reference t : refs) {
                Node refNode = t.getParent();
                while (!NodeUtil.isStatementBlock(refNode)) {
                    if (refNode == childVal) {
                                                return false;
                    }
                    refNode = refNode.getParent();
                }
            }
        }
                                ret = true;
    }
    return ret;
}",1.7272727272727273,1.1173469387755102,2.0,1.5,2.1666666666666665,1.0252100840336138,-0.9027817608259252,1.75,-0.028571428571428574,2.1441059443809136
Closure,30,2,"boolean dependsOnOuterScopeVars(String name, Node useNode) {
    Preconditions.checkArgument(getCfg().hasNode(useNode));
    GraphNode<Node, Branch> n = getCfg().getNode(useNode);
    FlowState<MustDef> state = n.getAnnotation();
    Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));
    for (Var s : def.depends) {
        if (s.scope != jsScope) {
            return true;
        }
    }
    return false;
}",,"boolean dependsOnOuterScopeVars(String name, Node useNode) {
    Preconditions.checkArgument(getCfg().hasNode(useNode));
    GraphNode<Node, Branch> n = getCfg().getNode(useNode);
    FlowState<MustDef> state = n.getAnnotation();
    Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));
    for (Var s : def.depends) {
        if (s.scope != jsScope) {
            return true;
        }
    }
    return false;
}",-0.09090909090909091,0.09183673469387764,-0.16666666666666666,0.0,-0.16666666666666666,-0.1196243203163618,0.043877258388299444,0.25,0.0,-0.0356431572590489
wicket,remotes/origin/bugs-dot-jar_WICKET-5131_4b7367ef,1,"/**
 * {@inheritDoc}
 */
public void respond(final IRequestCycle requestCycle) {
    final String location;
    if (redirectUrl.startsWith(""/"")) {
        // context-absolute url
        location = requestCycle.getUrlRenderer().renderContextRelativeUrl(redirectUrl);
    } else {
        // if relative url, servlet container will translate to absolute as
        // per the servlet spec
        // if absolute url still do the same
        location = redirectUrl;
    }
    WebResponse response = (WebResponse) requestCycle.getResponse();
    if (status == HttpServletResponse.SC_MOVED_TEMPORARILY) {
        response.sendRedirect(location);
    } else {
        response.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);
        response.setHeader(""Location"", location);
    }
}","/**
 * {@inheritDoc}
 */
","public void respond(final IRequestCycle requestCycle) {
    final String location;
    if (redirectUrl.startsWith(""/"")) {
                location = requestCycle.getUrlRenderer().renderContextRelativeUrl(redirectUrl);
    } else {
                                location = redirectUrl;
    }
    WebResponse response = (WebResponse) requestCycle.getResponse();
    if (status == HttpServletResponse.SC_MOVED_TEMPORARILY) {
        response.sendRedirect(location);
    } else {
        response.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);
        response.setHeader(""Location"", location);
    }
}",0.045454545454545456,-0.20918367346938782,-0.16666666666666666,-0.5,-0.08333333333333333,-0.06623826000988627,-0.024089475193576244,0.08333333333333333,0.31428571428571433,-0.042384605171298724
Math,81,1,"/**
 * Compute the shift increment as an estimate of the smallest eigenvalue.
 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
 * @param start start index
 * @param end end index
 * @param deflated number of realEigenvalues just deflated
 */
private void computeShiftIncrement(final int start, final int end, final int deflated) {
    final double cnst1 = 0.563;
    final double cnst2 = 1.010;
    final double cnst3 = 1.05;
    // tType records the type of shift.
    if (dMin <= 0.0) {
        tau = -dMin;
        tType = -1;
        return;
    }
    int nn = 4 * end + pingPong - 1;
    switch(deflated) {
        case // no realEigenvalues deflated.
        0:
            if (dMin == dN || dMin == dN1) {
                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);
                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);
                double a2 = work[nn - 7] + work[nn - 5];
                if (dMin == dN && dMin1 == dN1) {
                    // cases 2 and 3.
                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;
                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));
                    if (gap1 > 0.0 && gap1 > b1) {
                        tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);
                        tType = -2;
                    } else {
                        double s = 0.0;
                        if (dN > b1) {
                            s = dN - b1;
                        }
                        if (a2 > (b1 + b2)) {
                            s = Math.min(s, a2 - (b1 + b2));
                        }
                        tau = Math.max(s, 0.333 * dMin);
                        tType = -3;
                    }
                } else {
                    // case 4.
                    tType = -4;
                    double s = 0.25 * dMin;
                    double gam;
                    int np;
                    if (dMin == dN) {
                        gam = dN;
                        a2 = 0.0;
                        if (work[nn - 5] > work[nn - 7]) {
                            return;
                        }
                        b2 = work[nn - 5] / work[nn - 7];
                        np = nn - 9;
                    } else {
                        np = nn - 2 * pingPong;
                        b2 = work[np - 2];
                        gam = dN1;
                        if (work[np - 4] > work[np - 2]) {
                            return;
                        }
                        a2 = work[np - 4] / work[np - 2];
                        if (work[nn - 9] > work[nn - 11]) {
                            return;
                        }
                        b2 = work[nn - 9] / work[nn - 11];
                        np = nn - 13;
                    }
                    // approximate contribution to norm squared from i < nn-1.
                    a2 = a2 + b2;
                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;
                    // rayleigh quotient residual bound.
                    if (a2 < cnst1) {
                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                    }
                    tau = s;
                }
            } else if (dMin == dN2) {
                // case 5.
                tType = -5;
                double s = 0.25 * dMin;
                // compute contribution to norm squared from i > nn-2.
                final int np = nn - 2 * pingPong;
                double b1 = work[np - 2];
                double b2 = work[np - 6];
                final double gam = dN2;
                if (work[np - 8] > b2 || work[np - 4] > b1) {
                    return;
                }
                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);
                // approximate contribution to norm squared from i < nn-2.
                if (end - start > 2) {
                    b2 = work[nn - 13] / work[nn - 15];
                    a2 = a2 + b2;
                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;
                }
                if (a2 < cnst1) {
                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                } else {
                    tau = s;
                }
            } else {
                // case 6, no information to guide us.
                if (tType == -6) {
                    g += 0.333 * (1 - g);
                } else if (tType == -18) {
                    g = 0.25 * 0.333;
                } else {
                    g = 0.25;
                }
                tau = g * dMin;
                tType = -6;
            }
            break;
        case // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.
        1:
            if (dMin1 == dN1 && dMin2 == dN2) {
                // cases 7 and 8.
                tType = -7;
                double s = 0.333 * dMin1;
                if (work[nn - 5] > work[nn - 7]) {
                    return;
                }
                double b1 = work[nn - 5] / work[nn - 7];
                double b2 = b1;
                if (b2 != 0.0) {
                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        final double oldB1 = b1;
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b1 = b1 * (work[i4] / work[i4 - 2]);
                        b2 = b2 + b1;
                        if (100 * Math.max(b1, oldB1) < b2) {
                            break;
                        }
                    }
                }
                b2 = Math.sqrt(cnst3 * b2);
                final double a2 = dMin1 / (1 + b2 * b2);
                final double gap2 = 0.5 * dMin2 - a2;
                if (gap2 > 0.0 && gap2 > b2 * a2) {
                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
                } else {
                    tau = Math.max(s, a2 * (1 - cnst2 * b2));
                    tType = -8;
                }
            } else {
                // case 9.
                tau = 0.25 * dMin1;
                if (dMin1 == dN1) {
                    tau = 0.5 * dMin1;
                }
                tType = -9;
            }
            break;
        case // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.
        2:
            // cases 10 and 11.
            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {
                tType = -10;
                final double s = 0.333 * dMin2;
                if (work[nn - 5] > work[nn - 7]) {
                    return;
                }
                double b1 = work[nn - 5] / work[nn - 7];
                double b2 = b1;
                if (b2 != 0.0) {
                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b1 *= work[i4] / work[i4 - 2];
                        b2 += b1;
                        if (100 * b1 < b2) {
                            break;
                        }
                    }
                }
                b2 = Math.sqrt(cnst3 * b2);
                final double a2 = dMin2 / (1 + b2 * b2);
                final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;
                if (gap2 > 0.0 && gap2 > b2 * a2) {
                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
                } else {
                    tau = Math.max(s, a2 * (1 - cnst2 * b2));
                }
            } else {
                tau = 0.25 * dMin2;
                tType = -11;
            }
            break;
        default:
            // case 12, more than two realEigenvalues deflated. no information.
            tau = 0.0;
            tType = -12;
    }
}","/**
 * Compute the shift increment as an estimate of the smallest eigenvalue.
 * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>
 * @param start start index
 * @param end end index
 * @param deflated number of realEigenvalues just deflated
 */
","private void computeShiftIncrement(final int start, final int end, final int deflated) {
    final double cnst1 = 0.563;
    final double cnst2 = 1.010;
    final double cnst3 = 1.05;
        if (dMin <= 0.0) {
        tau = -dMin;
        tType = -1;
        return;
    }
    int nn = 4 * end + pingPong - 1;
    switch(deflated) {
        case         0:
            if (dMin == dN || dMin == dN1) {
                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);
                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);
                double a2 = work[nn - 7] + work[nn - 5];
                if (dMin == dN && dMin1 == dN1) {
                                        final double gap2 = dMin2 - a2 - dMin2 * 0.25;
                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));
                    if (gap1 > 0.0 && gap1 > b1) {
                        tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);
                        tType = -2;
                    } else {
                        double s = 0.0;
                        if (dN > b1) {
                            s = dN - b1;
                        }
                        if (a2 > (b1 + b2)) {
                            s = Math.min(s, a2 - (b1 + b2));
                        }
                        tau = Math.max(s, 0.333 * dMin);
                        tType = -3;
                    }
                } else {
                                        tType = -4;
                    double s = 0.25 * dMin;
                    double gam;
                    int np;
                    if (dMin == dN) {
                        gam = dN;
                        a2 = 0.0;
                        if (work[nn - 5] > work[nn - 7]) {
                            return;
                        }
                        b2 = work[nn - 5] / work[nn - 7];
                        np = nn - 9;
                    } else {
                        np = nn - 2 * pingPong;
                        b2 = work[np - 2];
                        gam = dN1;
                        if (work[np - 4] > work[np - 2]) {
                            return;
                        }
                        a2 = work[np - 4] / work[np - 2];
                        if (work[nn - 9] > work[nn - 11]) {
                            return;
                        }
                        b2 = work[nn - 9] / work[nn - 11];
                        np = nn - 13;
                    }
                                        a2 = a2 + b2;
                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;
                                        if (a2 < cnst1) {
                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                    }
                    tau = s;
                }
            } else if (dMin == dN2) {
                                tType = -5;
                double s = 0.25 * dMin;
                                final int np = nn - 2 * pingPong;
                double b1 = work[np - 2];
                double b2 = work[np - 6];
                final double gam = dN2;
                if (work[np - 8] > b2 || work[np - 4] > b1) {
                    return;
                }
                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);
                                if (end - start > 2) {
                    b2 = work[nn - 13] / work[nn - 15];
                    a2 = a2 + b2;
                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;
                }
                if (a2 < cnst1) {
                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                } else {
                    tau = s;
                }
            } else {
                                if (tType == -6) {
                    g += 0.333 * (1 - g);
                } else if (tType == -18) {
                    g = 0.25 * 0.333;
                } else {
                    g = 0.25;
                }
                tau = g * dMin;
                tType = -6;
            }
            break;
        case         1:
            if (dMin1 == dN1 && dMin2 == dN2) {
                                tType = -7;
                double s = 0.333 * dMin1;
                if (work[nn - 5] > work[nn - 7]) {
                    return;
                }
                double b1 = work[nn - 5] / work[nn - 7];
                double b2 = b1;
                if (b2 != 0.0) {
                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        final double oldB1 = b1;
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b1 = b1 * (work[i4] / work[i4 - 2]);
                        b2 = b2 + b1;
                        if (100 * Math.max(b1, oldB1) < b2) {
                            break;
                        }
                    }
                }
                b2 = Math.sqrt(cnst3 * b2);
                final double a2 = dMin1 / (1 + b2 * b2);
                final double gap2 = 0.5 * dMin2 - a2;
                if (gap2 > 0.0 && gap2 > b2 * a2) {
                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
                } else {
                    tau = Math.max(s, a2 * (1 - cnst2 * b2));
                    tType = -8;
                }
            } else {
                                tau = 0.25 * dMin1;
                if (dMin1 == dN1) {
                    tau = 0.5 * dMin1;
                }
                tType = -9;
            }
            break;
        case         2:
                        if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {
                tType = -10;
                final double s = 0.333 * dMin2;
                if (work[nn - 5] > work[nn - 7]) {
                    return;
                }
                double b1 = work[nn - 5] / work[nn - 7];
                double b2 = b1;
                if (b2 != 0.0) {
                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b1 *= work[i4] / work[i4 - 2];
                        b2 += b1;
                        if (100 * b1 < b2) {
                            break;
                        }
                    }
                }
                b2 = Math.sqrt(cnst3 * b2);
                final double a2 = dMin2 / (1 + b2 * b2);
                final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;
                if (gap2 > 0.0 && gap2 > b2 * a2) {
                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
                } else {
                    tau = Math.max(s, a2 * (1 - cnst2 * b2));
                }
            } else {
                tau = 0.25 * dMin2;
                tType = -11;
            }
            break;
        default:
                        tau = 0.0;
            tType = -12;
    }
}",8.863636363636363,1.5459183673469388,8.5,2.5,5.916666666666667,15.571922886801785,-2.1115572125035853,1.1666666666666667,-0.028571428571428574,202.80059619412287
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1215_a9efe3c4,0,"@Override
public PropertyValue currentProperty() {
    boolean asterisk = PathUtils.getName(propertyName).equals(""*"");
    if (!asterisk) {
        PropertyValue p = selector.currentProperty(propertyName);
        return matchesPropertyType(p) ? p : null;
    }
    Tree tree = selector.currentTree();
    if (tree == null || !tree.exists()) {
        return null;
    }
    if (!asterisk) {
        String name = PathUtils.getName(propertyName);
        name = normalizePropertyName(name);
        PropertyState p = tree.getProperty(name);
        if (p == null) {
            return null;
        }
        return matchesPropertyType(p) ? PropertyValues.create(p) : null;
    }
    // asterisk - create a multi-value property
    // warning: the returned property state may have a mixed type
    // (not all values may have the same type)
    // TODO currently all property values are converted to strings -
    // this doesn't play well with the idea that the types may be different
    List<String> values = new ArrayList<String>();
    for (PropertyState p : tree.getProperties()) {
        if (matchesPropertyType(p)) {
            Iterables.addAll(values, p.getValue(Type.STRINGS));
        }
    }
    // ""*""
    return PropertyValues.newString(values);
}",,"@Override
public PropertyValue currentProperty() {
    boolean asterisk = PathUtils.getName(propertyName).equals(""*"");
    if (!asterisk) {
        PropertyValue p = selector.currentProperty(propertyName);
        return matchesPropertyType(p) ? p : null;
    }
    Tree tree = selector.currentTree();
    if (tree == null || !tree.exists()) {
        return null;
    }
    if (!asterisk) {
        String name = PathUtils.getName(propertyName);
        name = normalizePropertyName(name);
        PropertyState p = tree.getProperty(name);
        if (p == null) {
            return null;
        }
        return matchesPropertyType(p) ? PropertyValues.create(p) : null;
    }
                        List<String> values = new ArrayList<String>();
    for (PropertyState p : tree.getProperties()) {
        if (matchesPropertyType(p)) {
            Iterables.addAll(values, p.getValue(Type.STRINGS));
        }
    }
        return PropertyValues.newString(values);
}",0.6363636363636364,0.04081632653061228,0.8333333333333334,0.0,0.6666666666666666,0.44389520514088,-0.49268712360195044,0.8333333333333334,-0.028571428571428574,0.647872846184486
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7,3,"public void recv_removeConstraint() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {
    removeConstraint_result result = new removeConstraint_result();
    receiveBase(result, ""removeConstraint"");
    if (result.ouch1 != null) {
        throw result.ouch1;
    }
    if (result.ouch2 != null) {
        throw result.ouch2;
    }
    return;
}",,"public void recv_removeConstraint() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {
    removeConstraint_result result = new removeConstraint_result();
    receiveBase(result, ""removeConstraint"");
    if (result.ouch1 != null) {
        throw result.ouch1;
    }
    if (result.ouch2 != null) {
        throw result.ouch2;
    }
    return;
}",-0.13636363636363635,-0.3112244897959183,0.16666666666666666,-0.5,-0.08333333333333333,-0.06426099851705384,0.17866360768568987,-0.4166666666666667,-0.028571428571428574,-0.08859821570063517
flink,remotes/origin/bugs-dot-jar_FLINK-1311_94c8e3fa,1,"@Override
public void postVisit(Operator<?> c) {
    OptimizerNode n = this.con2node.get(c);
    // first connect to the predecessors
    n.setInput(this.con2node);
    n.setBroadcastInputs(this.con2node);
    // if the node represents a bulk iteration, we recursively translate the data flow now
    if (n instanceof BulkIterationNode) {
        final BulkIterationNode iterNode = (BulkIterationNode) n;
        final BulkIterationBase<?> iter = iterNode.getIterationContract();
        // pass a copy of the no iterative part into the iteration translation,
        // in case the iteration references its closure
        HashMap<Operator<?>, OptimizerNode> closure = new HashMap<Operator<?>, OptimizerNode>(con2node);
        // first, recursively build the data flow for the step function
        final GraphCreatingVisitor recursiveCreator = new GraphCreatingVisitor(this, true, iterNode.getDegreeOfParallelism(), closure);
        BulkPartialSolutionNode partialSolution = null;
        iter.getNextPartialSolution().accept(recursiveCreator);
        partialSolution = (BulkPartialSolutionNode) recursiveCreator.con2node.get(iter.getPartialSolution());
        OptimizerNode rootOfStepFunction = recursiveCreator.con2node.get(iter.getNextPartialSolution());
        if (partialSolution == null) {
            throw new CompilerException(""Error: The step functions result does not depend on the partial solution."");
        }
        OptimizerNode terminationCriterion = null;
        if (iter.getTerminationCriterion() != null) {
            terminationCriterion = recursiveCreator.con2node.get(iter.getTerminationCriterion());
            // no intermediate node yet, traverse from the termination criterion to build the missing parts
            if (terminationCriterion == null) {
                iter.getTerminationCriterion().accept(recursiveCreator);
                terminationCriterion = recursiveCreator.con2node.get(iter.getTerminationCriterion());
            }
        }
        iterNode.setPartialSolution(partialSolution);
        iterNode.setNextPartialSolution(rootOfStepFunction, terminationCriterion);
        // go over the contained data flow and mark the dynamic path nodes
        StaticDynamicPathIdentifier identifier = new StaticDynamicPathIdentifier(iterNode.getCostWeight());
        rootOfStepFunction.accept(identifier);
        if (terminationCriterion != null) {
            terminationCriterion.accept(identifier);
        }
    } else if (n instanceof WorksetIterationNode) {
        final WorksetIterationNode iterNode = (WorksetIterationNode) n;
        final DeltaIterationBase<?, ?> iter = iterNode.getIterationContract();
        // we need to ensure that both the next-workset and the solution-set-delta depend on the workset. One check is for free
        // during the translation, we do the other check here as a pre-condition
        {
            StepFunctionValidator wsf = new StepFunctionValidator();
            iter.getNextWorkset().accept(wsf);
            if (!wsf.foundWorkset) {
                throw new CompilerException(""In the given program, the next workset does not depend on the workset. This is a prerequisite in delta iterations."");
            }
        }
        // calculate the closure of the anonymous function
        HashMap<Operator<?>, OptimizerNode> closure = new HashMap<Operator<?>, OptimizerNode>(con2node);
        // first, recursively build the data flow for the step function
        final GraphCreatingVisitor recursiveCreator = new GraphCreatingVisitor(this, true, iterNode.getDegreeOfParallelism(), closure);
        // descend from the solution set delta. check that it depends on both the workset
        // and the solution set. If it does depend on both, this descend should create both nodes
        iter.getSolutionSetDelta().accept(recursiveCreator);
        final WorksetNode worksetNode = (WorksetNode) recursiveCreator.con2node.get(iter.getWorkset());
        if (worksetNode == null) {
            throw new CompilerException(""In the given program, the solution set delta does not depend on the workset. This is a prerequisite in delta iterations."");
        }
        iter.getNextWorkset().accept(recursiveCreator);
        SolutionSetNode solutionSetNode = (SolutionSetNode) recursiveCreator.con2node.get(iter.getSolutionSet());
        if (solutionSetNode == null || solutionSetNode.getOutgoingConnections() == null || solutionSetNode.getOutgoingConnections().isEmpty()) {
            solutionSetNode = new SolutionSetNode((SolutionSetPlaceHolder<?>) iter.getSolutionSet(), iterNode);
        } else {
            for (PactConnection conn : solutionSetNode.getOutgoingConnections()) {
                OptimizerNode successor = conn.getTarget();
                if (successor.getClass() == JoinNode.class) {
                    // find out which input to the match the solution set is
                    JoinNode mn = (JoinNode) successor;
                    if (mn.getFirstPredecessorNode() == solutionSetNode) {
                        mn.makeJoinWithSolutionSet(0);
                    } else if (mn.getSecondPredecessorNode() == solutionSetNode) {
                        mn.makeJoinWithSolutionSet(1);
                    } else {
                        throw new CompilerException();
                    }
                } else if (successor.getClass() == CoGroupNode.class) {
                    CoGroupNode cg = (CoGroupNode) successor;
                    if (cg.getFirstPredecessorNode() == solutionSetNode) {
                        cg.makeCoGroupWithSolutionSet(0);
                    } else if (cg.getSecondPredecessorNode() == solutionSetNode) {
                        cg.makeCoGroupWithSolutionSet(1);
                    } else {
                        throw new CompilerException();
                    }
                } else {
                    throw new InvalidProgramException(""Error: The only operations allowed on the solution set are Join and CoGroup."");
                }
            }
        }
        final OptimizerNode nextWorksetNode = recursiveCreator.con2node.get(iter.getNextWorkset());
        final OptimizerNode solutionSetDeltaNode = recursiveCreator.con2node.get(iter.getSolutionSetDelta());
        // set the step function nodes to the iteration node
        iterNode.setPartialSolution(solutionSetNode, worksetNode);
        iterNode.setNextPartialSolution(solutionSetDeltaNode, nextWorksetNode);
        // go over the contained data flow and mark the dynamic path nodes
        StaticDynamicPathIdentifier pathIdentifier = new StaticDynamicPathIdentifier(iterNode.getCostWeight());
        nextWorksetNode.accept(pathIdentifier);
        iterNode.getSolutionSetDelta().accept(pathIdentifier);
    }
}",,"@Override
public void postVisit(Operator<?> c) {
    OptimizerNode n = this.con2node.get(c);
        n.setInput(this.con2node);
    n.setBroadcastInputs(this.con2node);
        if (n instanceof BulkIterationNode) {
        final BulkIterationNode iterNode = (BulkIterationNode) n;
        final BulkIterationBase<?> iter = iterNode.getIterationContract();
                        HashMap<Operator<?>, OptimizerNode> closure = new HashMap<Operator<?>, OptimizerNode>(con2node);
                final GraphCreatingVisitor recursiveCreator = new GraphCreatingVisitor(this, true, iterNode.getDegreeOfParallelism(), closure);
        BulkPartialSolutionNode partialSolution = null;
        iter.getNextPartialSolution().accept(recursiveCreator);
        partialSolution = (BulkPartialSolutionNode) recursiveCreator.con2node.get(iter.getPartialSolution());
        OptimizerNode rootOfStepFunction = recursiveCreator.con2node.get(iter.getNextPartialSolution());
        if (partialSolution == null) {
            throw new CompilerException(""Error: The step functions result does not depend on the partial solution."");
        }
        OptimizerNode terminationCriterion = null;
        if (iter.getTerminationCriterion() != null) {
            terminationCriterion = recursiveCreator.con2node.get(iter.getTerminationCriterion());
                        if (terminationCriterion == null) {
                iter.getTerminationCriterion().accept(recursiveCreator);
                terminationCriterion = recursiveCreator.con2node.get(iter.getTerminationCriterion());
            }
        }
        iterNode.setPartialSolution(partialSolution);
        iterNode.setNextPartialSolution(rootOfStepFunction, terminationCriterion);
                StaticDynamicPathIdentifier identifier = new StaticDynamicPathIdentifier(iterNode.getCostWeight());
        rootOfStepFunction.accept(identifier);
        if (terminationCriterion != null) {
            terminationCriterion.accept(identifier);
        }
    } else if (n instanceof WorksetIterationNode) {
        final WorksetIterationNode iterNode = (WorksetIterationNode) n;
        final DeltaIterationBase<?, ?> iter = iterNode.getIterationContract();
                        {
            StepFunctionValidator wsf = new StepFunctionValidator();
            iter.getNextWorkset().accept(wsf);
            if (!wsf.foundWorkset) {
                throw new CompilerException(""In the given program, the next workset does not depend on the workset. This is a prerequisite in delta iterations."");
            }
        }
                HashMap<Operator<?>, OptimizerNode> closure = new HashMap<Operator<?>, OptimizerNode>(con2node);
                final GraphCreatingVisitor recursiveCreator = new GraphCreatingVisitor(this, true, iterNode.getDegreeOfParallelism(), closure);
                        iter.getSolutionSetDelta().accept(recursiveCreator);
        final WorksetNode worksetNode = (WorksetNode) recursiveCreator.con2node.get(iter.getWorkset());
        if (worksetNode == null) {
            throw new CompilerException(""In the given program, the solution set delta does not depend on the workset. This is a prerequisite in delta iterations."");
        }
        iter.getNextWorkset().accept(recursiveCreator);
        SolutionSetNode solutionSetNode = (SolutionSetNode) recursiveCreator.con2node.get(iter.getSolutionSet());
        if (solutionSetNode == null || solutionSetNode.getOutgoingConnections() == null || solutionSetNode.getOutgoingConnections().isEmpty()) {
            solutionSetNode = new SolutionSetNode((SolutionSetPlaceHolder<?>) iter.getSolutionSet(), iterNode);
        } else {
            for (PactConnection conn : solutionSetNode.getOutgoingConnections()) {
                OptimizerNode successor = conn.getTarget();
                if (successor.getClass() == JoinNode.class) {
                                        JoinNode mn = (JoinNode) successor;
                    if (mn.getFirstPredecessorNode() == solutionSetNode) {
                        mn.makeJoinWithSolutionSet(0);
                    } else if (mn.getSecondPredecessorNode() == solutionSetNode) {
                        mn.makeJoinWithSolutionSet(1);
                    } else {
                        throw new CompilerException();
                    }
                } else if (successor.getClass() == CoGroupNode.class) {
                    CoGroupNode cg = (CoGroupNode) successor;
                    if (cg.getFirstPredecessorNode() == solutionSetNode) {
                        cg.makeCoGroupWithSolutionSet(0);
                    } else if (cg.getSecondPredecessorNode() == solutionSetNode) {
                        cg.makeCoGroupWithSolutionSet(1);
                    } else {
                        throw new CompilerException();
                    }
                } else {
                    throw new InvalidProgramException(""Error: The only operations allowed on the solution set are Join and CoGroup."");
                }
            }
        }
        final OptimizerNode nextWorksetNode = recursiveCreator.con2node.get(iter.getNextWorkset());
        final OptimizerNode solutionSetDeltaNode = recursiveCreator.con2node.get(iter.getSolutionSetDelta());
                iterNode.setPartialSolution(solutionSetNode, worksetNode);
        iterNode.setNextPartialSolution(solutionSetDeltaNode, nextWorksetNode);
                StaticDynamicPathIdentifier pathIdentifier = new StaticDynamicPathIdentifier(iterNode.getCostWeight());
        nextWorksetNode.accept(pathIdentifier);
        iterNode.getSolutionSetDelta().accept(pathIdentifier);
    }
}",3.3636363636363638,1.5051020408163265,3.1666666666666665,3.0,2.1666666666666665,1.0350963914977758,-1.3372526527100663,4.583333333333333,-0.028571428571428574,5.938757329290177
flink,remotes/origin/bugs-dot-jar_FLINK-1437_fb7ce0e3,1,"@Override
public T copy(T from) {
    T target;
    try {
        target = clazz.newInstance();
    } catch (Throwable t) {
        throw new RuntimeException(""Cannot instantiate class."", t);
    }
    try {
        for (int i = 0; i < numFields; i++) {
            Object copy = fieldSerializers[i].copy(fields[i].get(from));
            fields[i].set(target, copy);
        }
    } catch (IllegalAccessException e) {
        throw new RuntimeException(""Error during POJO copy, this should not happen since we check the fields before."");
    }
    return target;
}",,"@Override
public T copy(T from) {
    T target;
    try {
        target = clazz.newInstance();
    } catch (Throwable t) {
        throw new RuntimeException(""Cannot instantiate class."", t);
    }
    try {
        for (int i = 0; i < numFields; i++) {
            Object copy = fieldSerializers[i].copy(fields[i].get(from));
            fields[i].set(target, copy);
        }
    } catch (IllegalAccessException e) {
        throw new RuntimeException(""Error during POJO copy, this should not happen since we check the fields before."");
    }
    return target;
}",0.18181818181818182,0.26020408163265296,0.3333333333333333,0.0,-0.16666666666666666,-0.03657933761739987,-0.153713794092343,-0.16666666666666666,0.05714285714285714,-0.0066729198521507035
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1008_0c20bfd8,1,"/**
 * Provides access to the classes discovered so far. If no calls have been made to
 * any of the {@code find()} methods, this set will be empty.
 *
 * @return the set of classes that have been discovered.
 */
public Set<Class<?>> getClasses() {
    return classMatches;
}","/**
 * Provides access to the classes discovered so far. If no calls have been made to
 * any of the {@code find()} methods, this set will be empty.
 *
 * @return the set of classes that have been discovered.
 */
","public Set<Class<?>> getClasses() {
    return classMatches;
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.144536851161457,-0.5,2.7714285714285714,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5,3,"@Override
public String createWriter(ByteBuffer login, String tableName, WriterOptions opts) throws TException {
    try {
        BatchWriter writer = getWriter(login, tableName, opts);
        UUID uuid = UUID.randomUUID();
        writerCache.put(uuid, writer);
        return uuid.toString();
    } catch (Exception e) {
        throw translateException(e);
    }
}",,"@Override
public String createWriter(ByteBuffer login, String tableName, WriterOptions opts) throws TException {
    try {
        BatchWriter writer = getWriter(login, tableName, opts);
        UUID uuid = UUID.randomUUID();
        writerCache.put(uuid, writer);
        return uuid.toString();
    } catch (Exception e) {
        throw translateException(e);
    }
}",-0.13636363636363635,0.15816326530612249,-0.16666666666666666,-0.5,-0.4166666666666667,-0.3806228373702422,0.14683108689417854,-0.08333333333333333,0.17142857142857146,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-3281_f7dd2fff,1,"/**
 * Adds a route for an interceptor that intercepts incoming messages on the given endpoint.
 *
 * @param uri  endpoint uri
 * @return the builder
 */
public InterceptFromDefinition interceptFrom(String uri) {
    routeCollection.setCamelContext(getContext());
    return routeCollection.interceptFrom(uri);
}","/**
 * Adds a route for an interceptor that intercepts incoming messages on the given endpoint.
 *
 * @param uri  endpoint uri
 * @return the builder
 */
","public InterceptFromDefinition interceptFrom(String uri) {
    routeCollection.setCamelContext(getContext());
    return routeCollection.interceptFrom(uri);
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.855176369371953,-0.25,2.7714285714285714,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2047_a0a495f0,0,"private PrivilegeBits resolvePrivilegeBits(NodeBuilder privileges, String name) {
    NodeBuilder def = privileges.getChildNode(name);
    PropertyState b = def.getProperty(REP_BITS);
    if (b != null) {
        return PrivilegeBits.getInstance(b);
    }
    PrivilegeBits bits = PrivilegeBits.getInstance();
    for (String n : def.getNames(REP_AGGREGATES)) {
        bits.add(resolvePrivilegeBits(privileges, n));
    }
    def.setProperty(bits.asPropertyState(REP_BITS));
    return bits;
}",,"private PrivilegeBits resolvePrivilegeBits(NodeBuilder privileges, String name) {
    NodeBuilder def = privileges.getChildNode(name);
    PropertyState b = def.getProperty(REP_BITS);
    if (b != null) {
        return PrivilegeBits.getInstance(b);
    }
    PrivilegeBits bits = PrivilegeBits.getInstance();
    for (String n : def.getNames(REP_AGGREGATES)) {
        bits.add(resolvePrivilegeBits(privileges, n));
    }
    def.setProperty(bits.asPropertyState(REP_BITS));
    return bits;
}",-0.045454545454545456,-0.40816326530612235,-0.16666666666666666,-0.5,-0.25,-0.0029658922392486217,0.01778032692859205,0.25,0.028571428571428574,0.00822336721189304
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-554_3f51fb09,1,"/**
 * Create a multi valued {@code PropertyState} based on a list of
 * {@link Value} instances. The {@link Type} of the property is determined
 * by the type of the first value in the list or {@link Type#STRING} if the
 * list is empty.
 *
 * @param name  The name of the property state
 * @param values  The values of the property state
 * @return  The new property state
 * @throws RepositoryException forwarded from {@code value}
 */
@Nonnull
public static PropertyState createProperty(String name, Iterable<Value> values) throws RepositoryException {
    Value first = Iterables.getFirst(values, null);
    if (first == null) {
        return EmptyPropertyState.emptyProperty(name, STRINGS);
    }
    int type = first.getType();
    switch(type) {
        case PropertyType.STRING:
            List<String> strings = Lists.newArrayList();
            for (Value value : values) {
                strings.add(value.getString());
            }
            return MultiStringPropertyState.stringProperty(name, strings);
        case PropertyType.BINARY:
            List<Blob> blobs = Lists.newArrayList();
            for (Value value : values) {
                blobs.add(new ValueBasedBlob(value));
            }
            return MultiBinaryPropertyState.binaryPropertyFromBlob(name, blobs);
        case PropertyType.LONG:
            List<Long> longs = Lists.newArrayList();
            for (Value value : values) {
                longs.add(value.getLong());
            }
            return MultiLongPropertyState.createLongProperty(name, longs);
        case PropertyType.DOUBLE:
            List<Double> doubles = Lists.newArrayList();
            for (Value value : values) {
                doubles.add(value.getDouble());
            }
            return MultiDoublePropertyState.doubleProperty(name, doubles);
        case PropertyType.DATE:
            List<Long> dates = Lists.newArrayList();
            for (Value value : values) {
                dates.add(value.getLong());
            }
            return MultiLongPropertyState.createDatePropertyFromLong(name, dates);
        case PropertyType.BOOLEAN:
            List<Boolean> booleans = Lists.newArrayList();
            for (Value value : values) {
                booleans.add(value.getBoolean());
            }
            return MultiBooleanPropertyState.booleanProperty(name, booleans);
        case PropertyType.DECIMAL:
            List<BigDecimal> decimals = Lists.newArrayList();
            for (Value value : values) {
                decimals.add(value.getDecimal());
            }
            return MultiDecimalPropertyState.decimalProperty(name, decimals);
        default:
            List<String> vals = Lists.newArrayList();
            for (Value value : values) {
                vals.add(value.getString());
            }
            return new MultiGenericPropertyState(name, vals, Type.fromTag(type, true));
    }
}","/**
 * Create a multi valued {@code PropertyState} based on a list of
 * {@link Value} instances. The {@link Type} of the property is determined
 * by the type of the first value in the list or {@link Type#STRING} if the
 * list is empty.
 *
 * @param name  The name of the property state
 * @param values  The values of the property state
 * @return  The new property state
 * @throws RepositoryException forwarded from {@code value}
 */
","@Nonnull
public static PropertyState createProperty(String name, Iterable<Value> values) throws RepositoryException {
    Value first = Iterables.getFirst(values, null);
    if (first == null) {
        return EmptyPropertyState.emptyProperty(name, STRINGS);
    }
    int type = first.getType();
    switch(type) {
        case PropertyType.STRING:
            List<String> strings = Lists.newArrayList();
            for (Value value : values) {
                strings.add(value.getString());
            }
            return MultiStringPropertyState.stringProperty(name, strings);
        case PropertyType.BINARY:
            List<Blob> blobs = Lists.newArrayList();
            for (Value value : values) {
                blobs.add(new ValueBasedBlob(value));
            }
            return MultiBinaryPropertyState.binaryPropertyFromBlob(name, blobs);
        case PropertyType.LONG:
            List<Long> longs = Lists.newArrayList();
            for (Value value : values) {
                longs.add(value.getLong());
            }
            return MultiLongPropertyState.createLongProperty(name, longs);
        case PropertyType.DOUBLE:
            List<Double> doubles = Lists.newArrayList();
            for (Value value : values) {
                doubles.add(value.getDouble());
            }
            return MultiDoublePropertyState.doubleProperty(name, doubles);
        case PropertyType.DATE:
            List<Long> dates = Lists.newArrayList();
            for (Value value : values) {
                dates.add(value.getLong());
            }
            return MultiLongPropertyState.createDatePropertyFromLong(name, dates);
        case PropertyType.BOOLEAN:
            List<Boolean> booleans = Lists.newArrayList();
            for (Value value : values) {
                booleans.add(value.getBoolean());
            }
            return MultiBooleanPropertyState.booleanProperty(name, booleans);
        case PropertyType.DECIMAL:
            List<BigDecimal> decimals = Lists.newArrayList();
            for (Value value : values) {
                decimals.add(value.getDecimal());
            }
            return MultiDecimalPropertyState.decimalProperty(name, decimals);
        default:
            List<String> vals = Lists.newArrayList();
            for (Value value : values) {
                vals.add(value.getString());
            }
            return new MultiGenericPropertyState(name, vals, Type.fromTag(type, true));
    }
}",2.0,0.530612244897959,2.3333333333333335,0.5,0.4166666666666667,0.115669797330697,-1.0243762546601667,2.3333333333333335,-0.028571428571428574,1.037253566671378
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443,1,"@Override
public void offline(String tableName) throws AccumuloSecurityException, AccumuloException {
}",,"@Override
public void offline(String tableName) throws AccumuloSecurityException, AccumuloException {
}",-0.5,-1.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.0662460567823349,-0.5,1.8,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-4072_7d5b8645,1,"/**
 *  return path for current url in original encoding
 *
 *  @return path string
 */
public String getPath() {
    return getPath(getCharset());
}","/**
 *  return path for current url in original encoding
 *
 *  @return path string
 */
","public String getPath() {
    return getPath(getCharset());
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.1669056495554921,-0.3333333333333333,2.8285714285714287,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-757_76b7413d,1,"/**
 * Discards the <code>i</code> first or last elements of the array,
 * depending on the value of <code>front</code>.
 * For example, if the array contains the elements 1,2,3,4, invoking
 * <code>discardExtremeElements(2,false)</code> will cause the last two elements
 * to be discarded, leaving 1,2 in the array.
 * For example, if the array contains the elements 1,2,3,4, invoking
 * <code>discardExtremeElements(2,true)</code> will cause the first two elements
 * to be discarded, leaving 3,4 in the array.
 * Throws illegalArgumentException
 * if i exceeds numElements.
 *
 * @param i  the number of elements to discard from the front/end of the array
 * @param front true if elements are to be discarded from the front
 * of the array, false if elements are to be discarded from the end
 * of the array
 * @throws MathIllegalArgumentException if i is greater than numElements.
 * @since 2.0
 */
private synchronized void discardExtremeElements(int i, boolean front) throws MathIllegalArgumentException {
    if (i > numElements) {
        throw new MathIllegalArgumentException(LocalizedFormats.TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY, i, numElements);
    } else if (i < 0) {
        throw new MathIllegalArgumentException(LocalizedFormats.CANNOT_DISCARD_NEGATIVE_NUMBER_OF_ELEMENTS, i);
    } else {
        // ""Subtract"" this number of discarded from numElements
        numElements -= i;
        if (front) {
            startIndex += i;
        }
    }
    if (shouldContract()) {
        contract();
    }
}","/**
 * Discards the <code>i</code> first or last elements of the array,
 * depending on the value of <code>front</code>.
 * For example, if the array contains the elements 1,2,3,4, invoking
 * <code>discardExtremeElements(2,false)</code> will cause the last two elements
 * to be discarded, leaving 1,2 in the array.
 * For example, if the array contains the elements 1,2,3,4, invoking
 * <code>discardExtremeElements(2,true)</code> will cause the first two elements
 * to be discarded, leaving 3,4 in the array.
 * Throws illegalArgumentException
 * if i exceeds numElements.
 *
 * @param i  the number of elements to discard from the front/end of the array
 * @param front true if elements are to be discarded from the front
 * of the array, false if elements are to be discarded from the end
 * of the array
 * @throws MathIllegalArgumentException if i is greater than numElements.
 * @since 2.0
 */
","private synchronized void discardExtremeElements(int i, boolean front) throws MathIllegalArgumentException {
    if (i > numElements) {
        throw new MathIllegalArgumentException(LocalizedFormats.TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY, i, numElements);
    } else if (i < 0) {
        throw new MathIllegalArgumentException(LocalizedFormats.CANNOT_DISCARD_NEGATIVE_NUMBER_OF_ELEMENTS, i);
    } else {
                numElements -= i;
        if (front) {
            startIndex += i;
        }
    }
    if (shouldContract()) {
        contract();
    }
}",0.045454545454545456,0.09183673469387764,0.5,0.5,0.25,0.38062283737024233,0.010897619730427174,-0.3333333333333333,-0.028571428571428574,0.03103892822114006
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-3077_17654199,0,"/**
 * Write replication ingest entries for each provided file with the given {@link Status}.
 */
public static void updateFiles(Credentials creds, KeyExtent extent, Collection<String> files, Status stat) {
    if (log.isDebugEnabled()) {
        log.debug(""Updating replication for "" + extent + "" with "" + files + "" using "" + ProtobufUtil.toString(stat));
    }
    // TODO could use batch writer, would need to handle failure and retry like update does - ACCUMULO-1294
    if (files.isEmpty()) {
        return;
    }
    Value v = ProtobufUtil.toValue(stat);
    for (String file : files) {
        // TODO Can preclude this addition if the extent is for a table we don't need to replicate
        update(creds, createUpdateMutation(new Path(file), v, extent), extent);
    }
}","/**
 * Write replication ingest entries for each provided file with the given {@link Status}.
 */
","public static void updateFiles(Credentials creds, KeyExtent extent, Collection<String> files, Status stat) {
    if (log.isDebugEnabled()) {
        log.debug(""Updating replication for "" + extent + "" with "" + files + "" using "" + ProtobufUtil.toString(stat));
    }
        if (files.isEmpty()) {
        return;
    }
    Value v = ProtobufUtil.toValue(stat);
    for (String file : files) {
                update(creds, createUpdateMutation(new Path(file), v, extent), extent);
    }
}",-0.09090909090909091,-0.2346938775510204,0.0,-0.5,-0.08333333333333333,-0.08007909045971327,0.0498996271866933,0.08333333333333333,0.0,-0.02836633387727482
Time,23,2,"// -----------------------------------------------------------------------
/**
 * Converts an old style id to a new style id.
 *
 * @param id  the old style id
 * @return the new style id, null if not found
 */
private static synchronized String getConvertedId(String id) {
    Map<String, String> map = cZoneIdConversion;
    if (map == null) {
        // Backwards compatibility with TimeZone.
        map = new HashMap<String, String>();
        map.put(""GMT"", ""UTC"");
        map.put(""MIT"", ""Pacific/Apia"");
        // JDK 1.1 compatible
        map.put(""HST"", ""Pacific/Honolulu"");
        map.put(""AST"", ""America/Anchorage"");
        map.put(""PST"", ""America/Los_Angeles"");
        // JDK 1.1 compatible
        map.put(""MST"", ""America/Denver"");
        map.put(""PNT"", ""America/Phoenix"");
        map.put(""CST"", ""America/Chicago"");
        // JDK 1.1 compatible
        map.put(""EST"", ""America/New_York"");
        map.put(""IET"", ""America/Indianapolis"");
        map.put(""PRT"", ""America/Puerto_Rico"");
        map.put(""CNT"", ""America/St_Johns"");
        map.put(""AGT"", ""America/Buenos_Aires"");
        map.put(""BET"", ""America/Sao_Paulo"");
        map.put(""WET"", ""Europe/London"");
        map.put(""ECT"", ""Europe/Paris"");
        map.put(""ART"", ""Africa/Cairo"");
        map.put(""CAT"", ""Africa/Harare"");
        map.put(""EET"", ""Europe/Bucharest"");
        map.put(""EAT"", ""Africa/Addis_Ababa"");
        map.put(""MET"", ""Asia/Tehran"");
        map.put(""NET"", ""Asia/Yerevan"");
        map.put(""PLT"", ""Asia/Karachi"");
        map.put(""IST"", ""Asia/Calcutta"");
        map.put(""BST"", ""Asia/Dhaka"");
        map.put(""VST"", ""Asia/Saigon"");
        map.put(""CTT"", ""Asia/Shanghai"");
        map.put(""JST"", ""Asia/Tokyo"");
        map.put(""ACT"", ""Australia/Darwin"");
        map.put(""AET"", ""Australia/Sydney"");
        map.put(""SST"", ""Pacific/Guadalcanal"");
        map.put(""NST"", ""Pacific/Auckland"");
        cZoneIdConversion = map;
    }
    return map.get(id);
}","/**
 * Converts an old style id to a new style id.
 *
 * @param id  the old style id
 * @return the new style id, null if not found
 */
","private static synchronized String getConvertedId(String id) {
    Map<String, String> map = cZoneIdConversion;
    if (map == null) {
                map = new HashMap<String, String>();
        map.put(""GMT"", ""UTC"");
        map.put(""MIT"", ""Pacific/Apia"");
                map.put(""HST"", ""Pacific/Honolulu"");
        map.put(""AST"", ""America/Anchorage"");
        map.put(""PST"", ""America/Los_Angeles"");
                map.put(""MST"", ""America/Denver"");
        map.put(""PNT"", ""America/Phoenix"");
        map.put(""CST"", ""America/Chicago"");
                map.put(""EST"", ""America/New_York"");
        map.put(""IET"", ""America/Indianapolis"");
        map.put(""PRT"", ""America/Puerto_Rico"");
        map.put(""CNT"", ""America/St_Johns"");
        map.put(""AGT"", ""America/Buenos_Aires"");
        map.put(""BET"", ""America/Sao_Paulo"");
        map.put(""WET"", ""Europe/London"");
        map.put(""ECT"", ""Europe/Paris"");
        map.put(""ART"", ""Africa/Cairo"");
        map.put(""CAT"", ""Africa/Harare"");
        map.put(""EET"", ""Europe/Bucharest"");
        map.put(""EAT"", ""Africa/Addis_Ababa"");
        map.put(""MET"", ""Asia/Tehran"");
        map.put(""NET"", ""Asia/Yerevan"");
        map.put(""PLT"", ""Asia/Karachi"");
        map.put(""IST"", ""Asia/Calcutta"");
        map.put(""BST"", ""Asia/Dhaka"");
        map.put(""VST"", ""Asia/Saigon"");
        map.put(""CTT"", ""Asia/Shanghai"");
        map.put(""JST"", ""Asia/Tokyo"");
        map.put(""ACT"", ""Australia/Darwin"");
        map.put(""AET"", ""Australia/Sydney"");
        map.put(""SST"", ""Pacific/Guadalcanal"");
        map.put(""NST"", ""Pacific/Auckland"");
        cZoneIdConversion = map;
    }
    return map.get(id);
}",1.1818181818181819,-0.5,-0.3333333333333333,-0.5,-0.25,0.012852199703410812,-0.7235445942070551,2.25,-0.028571428571428574,0.6516204744711561
maven,remotes/origin/bugs-dot-jar_MNG-2174_778f044e,1,"public List<ModelProperty> getModelProperties() throws IOException {
    if (modelProperties == null) {
        Set<String> s = new HashSet<String>();
        // TODO: Should add all collections from ProjectUri
        s.addAll(PomTransformer.URIS);
        s.add(ProjectUri.Build.PluginManagement.Plugins.Plugin.Executions.xUri);
        s.add(ProjectUri.DependencyManagement.Dependencies.Dependency.Exclusions.xUri);
        s.add(ProjectUri.Dependencies.Dependency.Exclusions.xUri);
        s.add(ProjectUri.Build.Plugins.Plugin.Executions.xUri);
        s.add(ProjectUri.Build.Plugins.Plugin.Executions.Execution.Goals.xURI);
        s.add(ProjectUri.Reporting.Plugins.Plugin.ReportSets.xUri);
        s.add(ProjectUri.Reporting.Plugins.Plugin.ReportSets.ReportSet.configuration);
        s.add(ProjectUri.Build.Plugins.Plugin.Executions.Execution.configuration);
        modelProperties = ModelMarshaller.marshallXmlToModelProperties(getInputStream(), ProjectUri.baseUri, s);
    }
    return new ArrayList<ModelProperty>(modelProperties);
}",,"public List<ModelProperty> getModelProperties() throws IOException {
    if (modelProperties == null) {
        Set<String> s = new HashSet<String>();
                s.addAll(PomTransformer.URIS);
        s.add(ProjectUri.Build.PluginManagement.Plugins.Plugin.Executions.xUri);
        s.add(ProjectUri.DependencyManagement.Dependencies.Dependency.Exclusions.xUri);
        s.add(ProjectUri.Dependencies.Dependency.Exclusions.xUri);
        s.add(ProjectUri.Build.Plugins.Plugin.Executions.xUri);
        s.add(ProjectUri.Build.Plugins.Plugin.Executions.Execution.Goals.xURI);
        s.add(ProjectUri.Reporting.Plugins.Plugin.ReportSets.xUri);
        s.add(ProjectUri.Reporting.Plugins.Plugin.ReportSets.ReportSet.configuration);
        s.add(ProjectUri.Build.Plugins.Plugin.Executions.Execution.configuration);
        modelProperties = ModelMarshaller.marshallXmlToModelProperties(getInputStream(), ProjectUri.baseUri, s);
    }
    return new ArrayList<ModelProperty>(modelProperties);
}",0.09090909090909091,-0.10204081632653071,-0.3333333333333333,-0.5,-0.25,0.10776075135936737,-0.20562087754516786,0.4166666666666667,-0.028571428571428574,0.382703517630985
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-621_00b4b8a0,1,"private PropertyState internalGetProperty(String propertyName) {
    return getNodeBuilder().getProperty(propertyName);
}",,"private PropertyState internalGetProperty(String propertyName) {
    return getNodeBuilder().getProperty(propertyName);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.046171494121021,-0.3333333333333333,1.8571428571428574,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-7456_02da984a,3,"public void setPropertyPrefix(String propertyPrefix) {
    this.propertyPrefix = propertyPrefix;
}",,"public void setPropertyPrefix(String propertyPrefix) {
    this.propertyPrefix = propertyPrefix;
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.0943504445081733,-0.5,1.2857142857142858,-0.16422749602751402
Closure,102,2,"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, root, this);
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }
    removeDuplicateDeclarations(root);
    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);
}",,"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, root, this);
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }
    removeDuplicateDeclarations(root);
    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);
}",-0.13636363636363635,-0.035714285714285636,-0.3333333333333333,-0.5,-0.3333333333333333,-0.3806228373702422,0.16117006022368816,-0.16666666666666666,-0.028571428571428574,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1094_2e20589f,1,"synchronized void refresh(K key, int hash, CacheLoader<K, V> loader) throws ExecutionException {
    V value;
    V old = get(key, hash);
    long start = System.nanoTime();
    try {
        ListenableFuture<V> future = loader.reload(key, old);
        value = future.get();
        loadSuccessCount++;
    } catch (Exception e) {
        loadExceptionCount++;
        throw new ExecutionException(e);
    } finally {
        long time = System.nanoTime() - start;
        totalLoadTime += time;
    }
    put(key, hash, value, cache.sizeOf(key, value));
}",,"synchronized void refresh(K key, int hash, CacheLoader<K, V> loader) throws ExecutionException {
    V value;
    V old = get(key, hash);
    long start = System.nanoTime();
    try {
        ListenableFuture<V> future = loader.reload(key, old);
        value = future.get();
        loadSuccessCount++;
    } catch (Exception e) {
        loadExceptionCount++;
        throw new ExecutionException(e);
    } finally {
        long time = System.nanoTime() - start;
        totalLoadTime += time;
    }
    put(key, hash, value, cache.sizeOf(key, value));
}",0.13636363636363635,-0.18367346938775503,-0.16666666666666666,-0.5,-0.4166666666666667,0.3509639149777559,-0.15543447089188422,0.08333333333333333,0.0,0.29944192461056784
Closure,148,2,"/**
 * Appends the source map in LavaBug format to the given buffer.
 *
 * @param out The stream to which the map will be appended.
 * @param name The name of the generated source file that this source map
 *   represents.
 */
public void appendTo(Appendable out, String name) throws IOException {
    // Write the mappings out to the file. The format of the generated
    // source map is three sections, each deliminated by a magic comment.
    // 
    // The first section contains an array for each line of the generated
    // code, where each element in the array is the ID of the mapping which
    // best represents the index-th character found on that line of the
    // generated source code.
    // 
    // The second section contains an array per generated line. Unused.
    // 
    // The third and final section contains an array per line, each of which
    // represents a mapping with a unique ID. The mappings are added in order.
    // The array itself contains a tuple representing
    // ['source file', line, col (, 'original name')]
    // 
    // Example for 2 lines of generated code (with line numbers added for
    // readability):
    // 
    // 1)  /** Begin line maps. **/{ ""count"": 2 }
    // 2)  [0,0,0,0,0,0,1,1,1,1,2]
    // 3)  [2,2,2,2,2,2,3,4,4,4,4,4]
    // 4)  /** Begin file information. **/
    // 5)  []
    // 6)  []
    // 7)  /** Begin mapping definitions. **/
    // 8)  [""a.js"", 1, 34]
    // 9)  [""a.js"", 5, 2]
    // 10) [""b.js"", 1, 3, ""event""]
    // 11) [""c.js"", 1, 4]
    // 12) [""d.js"", 3, 78, ""foo""]
    int maxLine = findLastLine();
    // Add the line character maps.
    out.append(""/** Begin line maps. **/{ \""file\"" : "");
    out.append(escapeString(name));
    out.append("", \""count\"": "");
    out.append(String.valueOf(maxLine + 1));
    out.append("" }\n"");
    (new LineMapper(out)).appendLineMappings();
    // Add the source file maps.
    out.append(""/** Begin file information. **/\n"");
    // prevent changing the format.
    for (int i = 0; i <= maxLine; ++i) {
        out.append(""[]\n"");
    }
    // Add the mappings themselves.
    out.append(""/** Begin mapping definitions. **/\n"");
    for (Mapping mapping : mappings) {
        mapping.appendTo(out);
        out.append(""\n"");
    }
}","/**
 * Appends the source map in LavaBug format to the given buffer.
 *
 * @param out The stream to which the map will be appended.
 * @param name The name of the generated source file that this source map
 *   represents.
 */
","public void appendTo(Appendable out, String name) throws IOException {
                                                                                                                            int maxLine = findLastLine();
        out.append(""/** Begin line maps. **/{ \""file\"" : "");
    out.append(escapeString(name));
    out.append("", \""count\"": "");
    out.append(String.valueOf(maxLine + 1));
    out.append("" }\n"");
    (new LineMapper(out)).appendLineMappings();
        out.append(""/** Begin file information. **/\n"");
        for (int i = 0; i <= maxLine; ++i) {
        out.append(""[]\n"");
    }
        out.append(""/** Begin mapping definitions. **/\n"");
    for (Mapping mapping : mappings) {
        mapping.appendTo(out);
        out.append(""\n"");
    }
}",0.18181818181818182,-0.4693877551020408,-0.16666666666666666,-0.5,-0.16666666666666666,0.41028175976272874,-0.1821049612847723,0.6666666666666666,-0.028571428571428574,0.33653702014296666
commons-math,remotes/origin/bugs-dot-jar_MATH-434_133cbc2d,1,"/**
 * {@inheritDoc}
 */
@Override
public RealPointValuePair doOptimize() throws OptimizationException {
    final SimplexTableau tableau = new SimplexTableau(function, linearConstraints, goal, nonNegative, epsilon);
    solvePhase1(tableau);
    tableau.dropPhase1Objective();
    while (!tableau.isOptimal()) {
        doIteration(tableau);
    }
    return tableau.getSolution();
}","/**
 * {@inheritDoc}
 */
","@Override
public RealPointValuePair doOptimize() throws OptimizationException {
    final SimplexTableau tableau = new SimplexTableau(function, linearConstraints, goal, nonNegative, epsilon);
    solvePhase1(tableau);
    tableau.dropPhase1Objective();
    while (!tableau.isOptimal()) {
        doIteration(tableau);
    }
    return tableau.getSolution();
}",-0.18181818181818182,-0.31632653061224497,-0.3333333333333333,-0.5,-0.25,-0.11369253583786453,0.2486377975336967,-0.08333333333333333,0.2285714285714286,-0.1026892980585144
camel,remotes/origin/bugs-dot-jar_CAMEL-5570_a57830ed,3,"/**
 * Allows an exception handler to create a new redelivery policy for this exception type
 *
 * @param context      the camel context
 * @param parentPolicy the current redelivery policy, is newer <tt>null</tt>
 * @return a newly created redelivery policy, or return the original policy if no customization is required
 *         for this exception handler.
 */
public RedeliveryPolicy createRedeliveryPolicy(CamelContext context, RedeliveryPolicy parentPolicy) {
    if (redeliveryPolicyRef != null) {
        return CamelContextHelper.mandatoryLookup(context, redeliveryPolicyRef, RedeliveryPolicy.class);
    } else if (redeliveryPolicy != null) {
        return redeliveryPolicy.createRedeliveryPolicy(context, parentPolicy);
    } else if (!outputs.isEmpty() && parentPolicy.getMaximumRedeliveries() > 0) {
        // if we have outputs, then do not inherit parent maximumRedeliveries
        // as you would have to explicit configure maximumRedeliveries on this onException to use it
        // this is the behavior Camel has always had
        RedeliveryPolicy answer = parentPolicy.copy();
        answer.setMaximumRedeliveries(0);
        return answer;
    } else {
        return parentPolicy;
    }
}","/**
 * Allows an exception handler to create a new redelivery policy for this exception type
 *
 * @param context      the camel context
 * @param parentPolicy the current redelivery policy, is newer <tt>null</tt>
 * @return a newly created redelivery policy, or return the original policy if no customization is required
 *         for this exception handler.
 */
","public RedeliveryPolicy createRedeliveryPolicy(CamelContext context, RedeliveryPolicy parentPolicy) {
    if (redeliveryPolicyRef != null) {
        return CamelContextHelper.mandatoryLookup(context, redeliveryPolicyRef, RedeliveryPolicy.class);
    } else if (redeliveryPolicy != null) {
        return redeliveryPolicy.createRedeliveryPolicy(context, parentPolicy);
    } else if (!outputs.isEmpty() && parentPolicy.getMaximumRedeliveries() > 0) {
                                RedeliveryPolicy answer = parentPolicy.copy();
        answer.setMaximumRedeliveries(0);
        return answer;
    } else {
        return parentPolicy;
    }
}",-0.045454545454545456,-0.06632653061224485,0.0,0.5,0.25,0.3667820069204153,0.03412675652423281,0.0,-0.028571428571428574,0.12854150873090314
flink,remotes/origin/bugs-dot-jar_FLINK-3011_5a86a0a1,0,"public void restart() {
    try {
        synchronized (progressLock) {
            if (state != JobStatus.RESTARTING) {
                throw new IllegalStateException(""Can only restart job from state restarting."");
            }
            if (scheduler == null) {
                throw new IllegalStateException(""The execution graph has not been scheduled before - scheduler is null."");
            }
            this.currentExecutions.clear();
            for (ExecutionJobVertex jv : this.verticesInCreationOrder) {
                jv.resetForNewExecution();
            }
            for (int i = 0; i < stateTimestamps.length; i++) {
                stateTimestamps[i] = 0;
            }
            numFinishedJobVertices = 0;
            transitionState(JobStatus.RESTARTING, JobStatus.CREATED);
            // if we have checkpointed state, reload it into the executions
            if (checkpointCoordinator != null) {
                checkpointCoordinator.restoreLatestCheckpointedState(getAllVertices(), false, false);
            }
        }
        scheduleForExecution(scheduler);
    } catch (Throwable t) {
        fail(t);
    }
}",,"public void restart() {
    try {
        synchronized (progressLock) {
            if (state != JobStatus.RESTARTING) {
                throw new IllegalStateException(""Can only restart job from state restarting."");
            }
            if (scheduler == null) {
                throw new IllegalStateException(""The execution graph has not been scheduled before - scheduler is null."");
            }
            this.currentExecutions.clear();
            for (ExecutionJobVertex jv : this.verticesInCreationOrder) {
                jv.resetForNewExecution();
            }
            for (int i = 0; i < stateTimestamps.length; i++) {
                stateTimestamps[i] = 0;
            }
            numFinishedJobVertices = 0;
            transitionState(JobStatus.RESTARTING, JobStatus.CREATED);
                        if (checkpointCoordinator != null) {
                checkpointCoordinator.restoreLatestCheckpointedState(getAllVertices(), false, false);
            }
        }
        scheduleForExecution(scheduler);
    } catch (Throwable t) {
        fail(t);
    }
}",0.5909090909090909,0.7653061224489793,0.8333333333333334,0.5,0.3333333333333333,0.21255561047948598,-0.4098078577573849,0.08333333333333333,0.0,0.21061670971085444
Compress,29,1,"/**
 * Create an archive input stream from an input stream, autodetecting
 * the archive type from the first few bytes of the stream. The InputStream
 * must support marks, like BufferedInputStream.
 *
 * @param in the input stream
 * @return the archive input stream
 * @throws ArchiveException if the archiver name is not known
 * @throws StreamingNotSupportedException if the format cannot be
 * read from a stream
 * @throws IllegalArgumentException if the stream is null or does not support mark
 */
public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {
    if (in == null) {
        throw new IllegalArgumentException(""Stream must not be null."");
    }
    if (!in.markSupported()) {
        throw new IllegalArgumentException(""Mark is not supported."");
    }
    final byte[] signature = new byte[12];
    in.mark(signature.length);
    try {
        int signatureLength = IOUtils.readFully(in, signature);
        in.reset();
        if (ZipArchiveInputStream.matches(signature, signatureLength)) {
            if (entryEncoding != null) {
                return new ZipArchiveInputStream(in, entryEncoding);
            } else {
                return new ZipArchiveInputStream(in);
            }
        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {
            if (entryEncoding != null) {
                return new JarArchiveInputStream(in, entryEncoding);
            } else {
                return new JarArchiveInputStream(in);
            }
        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {
            return new ArArchiveInputStream(in);
        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {
            if (entryEncoding != null) {
                return new CpioArchiveInputStream(in, entryEncoding);
            } else {
                return new CpioArchiveInputStream(in);
            }
        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {
            return new ArjArchiveInputStream(in);
        } else if (SevenZFile.matches(signature, signatureLength)) {
            throw new StreamingNotSupportedException(SEVEN_Z);
        }
        // Dump needs a bigger buffer to check the signature;
        final byte[] dumpsig = new byte[32];
        in.mark(dumpsig.length);
        signatureLength = IOUtils.readFully(in, dumpsig);
        in.reset();
        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {
            return new DumpArchiveInputStream(in, entryEncoding);
        }
        // Tar needs an even bigger buffer to check the signature; read the first block
        final byte[] tarheader = new byte[512];
        in.mark(tarheader.length);
        signatureLength = IOUtils.readFully(in, tarheader);
        in.reset();
        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {
            return new TarArchiveInputStream(in, entryEncoding);
        }
        // COMPRESS-117 - improve auto-recognition
        if (signatureLength >= 512) {
            TarArchiveInputStream tais = null;
            try {
                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));
                // COMPRESS-191 - verify the header checksum
                if (tais.getNextTarEntry().isCheckSumOK()) {
                    return new TarArchiveInputStream(in, encoding);
                }
            } catch (Exception e) {
            // NOPMD
            // can generate IllegalArgumentException as well
            // as IOException
            // autodetection, simply not a TAR
            // ignored
            } finally {
                IOUtils.closeQuietly(tais);
            }
        }
    } catch (IOException e) {
        throw new ArchiveException(""Could not use reset and mark operations."", e);
    }
    throw new ArchiveException(""No Archiver found for the stream signature"");
}","/**
 * Create an archive input stream from an input stream, autodetecting
 * the archive type from the first few bytes of the stream. The InputStream
 * must support marks, like BufferedInputStream.
 *
 * @param in the input stream
 * @return the archive input stream
 * @throws ArchiveException if the archiver name is not known
 * @throws StreamingNotSupportedException if the format cannot be
 * read from a stream
 * @throws IllegalArgumentException if the stream is null or does not support mark
 */
","public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {
    if (in == null) {
        throw new IllegalArgumentException(""Stream must not be null."");
    }
    if (!in.markSupported()) {
        throw new IllegalArgumentException(""Mark is not supported."");
    }
    final byte[] signature = new byte[12];
    in.mark(signature.length);
    try {
        int signatureLength = IOUtils.readFully(in, signature);
        in.reset();
        if (ZipArchiveInputStream.matches(signature, signatureLength)) {
            if (entryEncoding != null) {
                return new ZipArchiveInputStream(in, entryEncoding);
            } else {
                return new ZipArchiveInputStream(in);
            }
        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {
            if (entryEncoding != null) {
                return new JarArchiveInputStream(in, entryEncoding);
            } else {
                return new JarArchiveInputStream(in);
            }
        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {
            return new ArArchiveInputStream(in);
        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {
            if (entryEncoding != null) {
                return new CpioArchiveInputStream(in, entryEncoding);
            } else {
                return new CpioArchiveInputStream(in);
            }
        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {
            return new ArjArchiveInputStream(in);
        } else if (SevenZFile.matches(signature, signatureLength)) {
            throw new StreamingNotSupportedException(SEVEN_Z);
        }
                final byte[] dumpsig = new byte[32];
        in.mark(dumpsig.length);
        signatureLength = IOUtils.readFully(in, dumpsig);
        in.reset();
        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {
            return new DumpArchiveInputStream(in, entryEncoding);
        }
                final byte[] tarheader = new byte[512];
        in.mark(tarheader.length);
        signatureLength = IOUtils.readFully(in, tarheader);
        in.reset();
        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {
            return new TarArchiveInputStream(in, entryEncoding);
        }
                if (signatureLength >= 512) {
            TarArchiveInputStream tais = null;
            try {
                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));
                                if (tais.getNextTarEntry().isCheckSumOK()) {
                    return new TarArchiveInputStream(in, encoding);
                }
            } catch (Exception e) {
                                                                        } finally {
                IOUtils.closeQuietly(tais);
            }
        }
    } catch (IOException e) {
        throw new ArchiveException(""Could not use reset and mark operations."", e);
    }
    throw new ArchiveException(""No Archiver found for the stream signature"");
}",2.4545454545454546,0.5969387755102042,3.1666666666666665,2.5,2.1666666666666665,0.865051903114187,-1.099512474906797,1.25,-0.028571428571428574,2.2710841567408058
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-843_65390f8c,3,"@Override
public void flush(String tableName, Text start, Text end, boolean wait) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {
    throw new NotImplementedException();
}",,"@Override
public void flush(String tableName, Text start, Text end, boolean wait) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {
    throw new NotImplementedException();
}",-0.45454545454545453,-0.6581632653061225,-0.3333333333333333,-1.0,-0.4166666666666667,-0.3806228373702422,0.7811872669916835,-0.5,0.0,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1076_9238264d,3,"private PropertyValue currentOakProperty(String oakPropertyName, Integer propertyType) {
    boolean asterisk = oakPropertyName.indexOf('*') >= 0;
    if (asterisk) {
        Tree t = currentTree();
        ArrayList<PropertyValue> list = new ArrayList<PropertyValue>();
        readOakProperties(list, t, oakPropertyName, propertyType);
        if (list.size() == 0) {
            return null;
        }
        ArrayList<String> strings = new ArrayList<String>();
        for (PropertyValue p : list) {
            Iterables.addAll(strings, p.getValue(Type.STRINGS));
        }
        return PropertyValues.newString(strings);
    }
    boolean relative = oakPropertyName.indexOf('/') >= 0;
    Tree t = currentTree();
    if (relative) {
        for (String p : PathUtils.elements(PathUtils.getParentPath(oakPropertyName))) {
            if (t == null) {
                return null;
            }
            if (p.equals("".."")) {
                t = t.isRoot() ? null : t.getParent();
            } else if (p.equals(""."")) {
            // same node
            } else {
                t = t.getChild(p);
            }
        }
        oakPropertyName = PathUtils.getName(oakPropertyName);
    }
    return currentOakProperty(t, oakPropertyName, propertyType);
}",,"private PropertyValue currentOakProperty(String oakPropertyName, Integer propertyType) {
    boolean asterisk = oakPropertyName.indexOf('*') >= 0;
    if (asterisk) {
        Tree t = currentTree();
        ArrayList<PropertyValue> list = new ArrayList<PropertyValue>();
        readOakProperties(list, t, oakPropertyName, propertyType);
        if (list.size() == 0) {
            return null;
        }
        ArrayList<String> strings = new ArrayList<String>();
        for (PropertyValue p : list) {
            Iterables.addAll(strings, p.getValue(Type.STRINGS));
        }
        return PropertyValues.newString(strings);
    }
    boolean relative = oakPropertyName.indexOf('/') >= 0;
    Tree t = currentTree();
    if (relative) {
        for (String p : PathUtils.elements(PathUtils.getParentPath(oakPropertyName))) {
            if (t == null) {
                return null;
            }
            if (p.equals("".."")) {
                t = t.isRoot() ? null : t.getParent();
            } else if (p.equals(""."")) {
                        } else {
                t = t.getChild(p);
            }
        }
        oakPropertyName = PathUtils.getName(oakPropertyName);
    }
    return currentOakProperty(t, oakPropertyName, propertyType);
}",0.8636363636363636,0.586734693877551,1.0,1.0,0.75,0.06821552150271878,-0.6079724691712076,1.0,-0.028571428571428574,0.3856459412114904
Closure,80,1,"/**
 * @param locals A predicate to apply to unknown local values.
 * @return Whether the node is known to be a value that is not a reference
 *     outside the expression scope.
 */
static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch(value.getType()) {
        case Token.ASSIGN:
            // value is immutable.
            return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals));
        case Token.COMMA:
            return evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.AND:
        case Token.OR:
            return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.HOOK:
            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.INC:
        case Token.DEC:
            if (value.getBooleanProp(Node.INCRDECR_PROP)) {
                return evaluatesToLocalValue(value.getFirstChild(), locals);
            } else {
                return true;
            }
        case Token.THIS:
            return locals.apply(value);
        case Token.NAME:
            return isImmutableValue(value) || locals.apply(value);
        case Token.GETELEM:
        case Token.GETPROP:
            // There is no information about the locality of object properties.
            return locals.apply(value);
        case Token.CALL:
            return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value);
        case Token.NEW:
            return newHasLocalResult(value) || locals.apply(value);
        case Token.FUNCTION:
        case Token.REGEXP:
        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
            // Literals objects with non-literal children are allowed.
            return true;
        case Token.IN:
            // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
            return true;
        default:
            // x -= g (x is now an local number)
            if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) {
                return true;
            }
            throw new IllegalStateException(""Unexpected expression node"" + value + ""\n parent:"" + value.getParent());
    }
}","/**
 * @param locals A predicate to apply to unknown local values.
 * @return Whether the node is known to be a value that is not a reference
 *     outside the expression scope.
 */
","static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch(value.getType()) {
        case Token.ASSIGN:
                        return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals));
        case Token.COMMA:
            return evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.AND:
        case Token.OR:
            return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.HOOK:
            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);
        case Token.INC:
        case Token.DEC:
            if (value.getBooleanProp(Node.INCRDECR_PROP)) {
                return evaluatesToLocalValue(value.getFirstChild(), locals);
            } else {
                return true;
            }
        case Token.THIS:
            return locals.apply(value);
        case Token.NAME:
            return isImmutableValue(value) || locals.apply(value);
        case Token.GETELEM:
        case Token.GETPROP:
                        return locals.apply(value);
        case Token.CALL:
            return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value);
        case Token.NEW:
            return newHasLocalResult(value) || locals.apply(value);
        case Token.FUNCTION:
        case Token.REGEXP:
        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
                        return true;
        case Token.IN:
                        return true;
        default:
                        if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) {
                return true;
            }
            throw new IllegalStateException(""Unexpected expression node"" + value + ""\n parent:"" + value.getParent());
    }
}",1.3181818181818181,0.22959183673469397,3.1666666666666665,0.5,1.9166666666666667,0.17696490360850226,-0.8568970461714942,2.25,-0.028571428571428574,0.7274767539971133
camel,remotes/origin/bugs-dot-jar_CAMEL-8081_2e985f9b,1,"private void aggregateOnTheFly() throws InterruptedException, ExecutionException {
    boolean timedOut = false;
    boolean stoppedOnException = false;
    final StopWatch watch = new StopWatch();
    int aggregated = 0;
    boolean done = false;
    // not a for loop as on the fly may still run
    while (!done) {
        // check if we have already aggregate everything
        if (allTasksSubmitted.get() && aggregated >= total.get()) {
            LOG.debug(""Done aggregating {} exchanges on the fly."", aggregated);
            break;
        }
        Future<Exchange> future;
        if (timedOut) {
            // we are timed out but try to grab if some tasks has been completed
            // poll will return null if no tasks is present
            future = completion.poll();
            LOG.trace(""Polled completion task #{} after timeout to grab already completed tasks: {}"", aggregated, future);
        } else if (timeout > 0) {
            long left = timeout - watch.taken();
            if (left < 0) {
                left = 0;
            }
            LOG.trace(""Polling completion task #{} using timeout {} millis."", aggregated, left);
            future = completion.poll(left, TimeUnit.MILLISECONDS);
        } else {
            LOG.trace(""Polling completion task #{}"", aggregated);
            // we must not block so poll every second
            future = completion.poll(1, TimeUnit.SECONDS);
            if (future == null) {
                // and continue loop which will recheck if we are done
                continue;
            }
        }
        if (future == null && timedOut) {
            // we are timed out and no more tasks complete so break out
            break;
        } else if (future == null) {
            // timeout occurred
            AggregationStrategy strategy = getAggregationStrategy(null);
            if (strategy instanceof TimeoutAwareAggregationStrategy) {
                // notify the strategy we timed out
                Exchange oldExchange = result.get();
                if (oldExchange == null) {
                    // if they all timed out the result may not have been set yet, so use the original exchange
                    oldExchange = original;
                }
                ((TimeoutAwareAggregationStrategy) strategy).timeout(oldExchange, aggregated, total.intValue(), timeout);
            } else {
                // log a WARN we timed out since it will not be aggregated and the Exchange will be lost
                LOG.warn(""Parallel processing timed out after {} millis for number {}. This task will be cancelled and will not be aggregated."", timeout, aggregated);
            }
            LOG.debug(""Timeout occurred after {} millis for number {} task."", timeout, aggregated);
            timedOut = true;
            // any already completed tasks in the next loop
            if (completion instanceof SubmitOrderedCompletionService) {
                ((SubmitOrderedCompletionService<?>) completion).timeoutTask();
            }
        } else {
            // there is a result to aggregate
            Exchange subExchange = future.get();
            // Decide whether to continue with the multicast or not; similar logic to the Pipeline
            Integer number = getExchangeIndex(subExchange);
            boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, ""Parallel processing failed for number "" + number, LOG);
            if (stopOnException && !continueProcessing) {
                // we want to stop on exception and an exception or failure occurred
                // this is similar to what the pipeline does, so we should do the same to not surprise end users
                // so we should set the failed exchange as the result and break out
                result.set(subExchange);
                stoppedOnException = true;
                break;
            }
            // we got a result so aggregate it
            AggregationStrategy strategy = getAggregationStrategy(subExchange);
            doAggregate(strategy, result, subExchange);
        }
        aggregated++;
    }
    if (timedOut || stoppedOnException) {
        if (timedOut) {
            LOG.debug(""Cancelling tasks due timeout after {} millis."", timeout);
        }
        if (stoppedOnException) {
            LOG.debug(""Cancelling tasks due stopOnException."");
        }
        // cancel tasks as we timed out (its safe to cancel done tasks)
        running.set(false);
    }
}",,"private void aggregateOnTheFly() throws InterruptedException, ExecutionException {
    boolean timedOut = false;
    boolean stoppedOnException = false;
    final StopWatch watch = new StopWatch();
    int aggregated = 0;
    boolean done = false;
        while (!done) {
                if (allTasksSubmitted.get() && aggregated >= total.get()) {
            LOG.debug(""Done aggregating {} exchanges on the fly."", aggregated);
            break;
        }
        Future<Exchange> future;
        if (timedOut) {
                                    future = completion.poll();
            LOG.trace(""Polled completion task #{} after timeout to grab already completed tasks: {}"", aggregated, future);
        } else if (timeout > 0) {
            long left = timeout - watch.taken();
            if (left < 0) {
                left = 0;
            }
            LOG.trace(""Polling completion task #{} using timeout {} millis."", aggregated, left);
            future = completion.poll(left, TimeUnit.MILLISECONDS);
        } else {
            LOG.trace(""Polling completion task #{}"", aggregated);
                        future = completion.poll(1, TimeUnit.SECONDS);
            if (future == null) {
                                continue;
            }
        }
        if (future == null && timedOut) {
                        break;
        } else if (future == null) {
                        AggregationStrategy strategy = getAggregationStrategy(null);
            if (strategy instanceof TimeoutAwareAggregationStrategy) {
                                Exchange oldExchange = result.get();
                if (oldExchange == null) {
                                        oldExchange = original;
                }
                ((TimeoutAwareAggregationStrategy) strategy).timeout(oldExchange, aggregated, total.intValue(), timeout);
            } else {
                                LOG.warn(""Parallel processing timed out after {} millis for number {}. This task will be cancelled and will not be aggregated."", timeout, aggregated);
            }
            LOG.debug(""Timeout occurred after {} millis for number {} task."", timeout, aggregated);
            timedOut = true;
                        if (completion instanceof SubmitOrderedCompletionService) {
                ((SubmitOrderedCompletionService<?>) completion).timeoutTask();
            }
        } else {
                        Exchange subExchange = future.get();
                        Integer number = getExchangeIndex(subExchange);
            boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, ""Parallel processing failed for number "" + number, LOG);
            if (stopOnException && !continueProcessing) {
                                                                result.set(subExchange);
                stoppedOnException = true;
                break;
            }
                        AggregationStrategy strategy = getAggregationStrategy(subExchange);
            doAggregate(strategy, result, subExchange);
        }
        aggregated++;
    }
    if (timedOut || stoppedOnException) {
        if (timedOut) {
            LOG.debug(""Cancelling tasks due timeout after {} millis."", timeout);
        }
        if (stoppedOnException) {
            LOG.debug(""Cancelling tasks due stopOnException."");
        }
                running.set(false);
    }
}",2.590909090909091,0.556122448979592,2.6666666666666665,1.5,2.3333333333333335,2.1542263964409294,-1.142529394895326,1.6666666666666667,-0.028571428571428574,6.430608914644019
camel,remotes/origin/bugs-dot-jar_CAMEL-6936_4954d573,1,"/**
 * Strategy for validating if the given remote file should be included or not
 *
 * @param file        the file
 * @param isDirectory whether the file is a directory or a file
 * @param files       files in the directory
 * @return <tt>true</tt> to include the file, <tt>false</tt> to skip it
 */
protected boolean isValidFile(GenericFile<T> file, boolean isDirectory, List<T> files) {
    if (!isMatched(file, isDirectory, files)) {
        log.trace(""File did not match. Will skip this file: {}"", file);
        return false;
    }
    // if its a file then check if its already in progress
    if (!isDirectory && isInProgress(file)) {
        if (log.isTraceEnabled()) {
            log.trace(""Skipping as file is already in progress: {}"", file.getFileName());
        }
        return false;
    }
    // if its a file then check we have the file in the idempotent registry already
    if (!isDirectory && endpoint.isIdempotent()) {
        // use absolute file path as default key, but evaluate if an expression key was configured
        String key = file.getAbsoluteFilePath();
        if (endpoint.getIdempotentKey() != null) {
            Exchange dummy = endpoint.createExchange(file);
            key = endpoint.getIdempotentKey().evaluate(dummy, String.class);
        }
        if (key != null && endpoint.getIdempotentRepository().contains(key)) {
            log.trace(""This consumer is idempotent and the file has been consumed before. Will skip this file: {}"", file);
            return false;
        }
    }
    // file matched
    return true;
}","/**
 * Strategy for validating if the given remote file should be included or not
 *
 * @param file        the file
 * @param isDirectory whether the file is a directory or a file
 * @param files       files in the directory
 * @return <tt>true</tt> to include the file, <tt>false</tt> to skip it
 */
","protected boolean isValidFile(GenericFile<T> file, boolean isDirectory, List<T> files) {
    if (!isMatched(file, isDirectory, files)) {
        log.trace(""File did not match. Will skip this file: {}"", file);
        return false;
    }
        if (!isDirectory && isInProgress(file)) {
        if (log.isTraceEnabled()) {
            log.trace(""Skipping as file is already in progress: {}"", file.getFileName());
        }
        return false;
    }
        if (!isDirectory && endpoint.isIdempotent()) {
                String key = file.getAbsoluteFilePath();
        if (endpoint.getIdempotentKey() != null) {
            Exchange dummy = endpoint.createExchange(file);
            key = endpoint.getIdempotentKey().evaluate(dummy, String.class);
        }
        if (key != null && endpoint.getIdempotentRepository().contains(key)) {
            log.trace(""This consumer is idempotent and the file has been consumed before. Will skip this file: {}"", file);
            return false;
        }
    }
        return true;
}",0.45454545454545453,0.2499999999999999,0.5,0.0,1.1666666666666667,0.38655462184873957,-0.380269572698595,0.75,-0.028571428571428574,0.46213610529336435
wicket,remotes/origin/bugs-dot-jar_WICKET-5147_184e51e9,1,"/**
 *  Servlets and Filters are treated essentially the same with Wicket. This is the entry point
 *  for both of them.
 *
 *  @see #init(FilterConfig)
 *
 *  @param isServlet
 *             True if Servlet, false if Filter
 *  @param filterConfig
 *  @throws ServletException
 */
public void init(final boolean isServlet, final FilterConfig filterConfig) throws ServletException {
    this.filterConfig = filterConfig;
    this.isServlet = isServlet;
    initIgnorePaths(filterConfig);
    final ClassLoader previousClassLoader = Thread.currentThread().getContextClassLoader();
    final ClassLoader newClassLoader = getClassLoader();
    try {
        if (previousClassLoader != newClassLoader) {
            Thread.currentThread().setContextClassLoader(newClassLoader);
        }
        // locate application instance unless it was already specified during construction
        if (application == null) {
            applicationFactory = getApplicationFactory();
            application = applicationFactory.createApplication(this);
        }
        application.setName(filterConfig.getFilterName());
        application.setWicketFilter(this);
        // Allow the filterPath to be preset via setFilterPath()
        String configureFilterPath = getFilterPath();
        if (configureFilterPath == null) {
            configureFilterPath = getFilterPathFromConfig(filterConfig);
            if (configureFilterPath == null) {
                configureFilterPath = getFilterPathFromWebXml(isServlet, filterConfig);
                if (configureFilterPath == null) {
                    configureFilterPath = getFilterPathFromAnnotation(isServlet);
                }
            }
            if (configureFilterPath != null) {
                setFilterPath(configureFilterPath);
            }
        }
        if (getFilterPath() == null) {
            log.warn(""Unable to determine filter path from filter init-param, web.xml, "" + ""or servlet 3.0 annotations. Assuming user will set filter path "" + ""manually by calling setFilterPath(String)"");
        }
        ThreadContext.setApplication(application);
        try {
            application.initApplication();
            // Give the application the option to log that it is started
            application.logStarted();
        } finally {
            ThreadContext.detach();
        }
    } finally {
        if (newClassLoader != previousClassLoader) {
            Thread.currentThread().setContextClassLoader(previousClassLoader);
        }
    }
}","/**
 *  Servlets and Filters are treated essentially the same with Wicket. This is the entry point
 *  for both of them.
 *
 *  @see #init(FilterConfig)
 *
 *  @param isServlet
 *             True if Servlet, false if Filter
 *  @param filterConfig
 *  @throws ServletException
 */
","public void init(final boolean isServlet, final FilterConfig filterConfig) throws ServletException {
    this.filterConfig = filterConfig;
    this.isServlet = isServlet;
    initIgnorePaths(filterConfig);
    final ClassLoader previousClassLoader = Thread.currentThread().getContextClassLoader();
    final ClassLoader newClassLoader = getClassLoader();
    try {
        if (previousClassLoader != newClassLoader) {
            Thread.currentThread().setContextClassLoader(newClassLoader);
        }
                if (application == null) {
            applicationFactory = getApplicationFactory();
            application = applicationFactory.createApplication(this);
        }
        application.setName(filterConfig.getFilterName());
        application.setWicketFilter(this);
                String configureFilterPath = getFilterPath();
        if (configureFilterPath == null) {
            configureFilterPath = getFilterPathFromConfig(filterConfig);
            if (configureFilterPath == null) {
                configureFilterPath = getFilterPathFromWebXml(isServlet, filterConfig);
                if (configureFilterPath == null) {
                    configureFilterPath = getFilterPathFromAnnotation(isServlet);
                }
            }
            if (configureFilterPath != null) {
                setFilterPath(configureFilterPath);
            }
        }
        if (getFilterPath() == null) {
            log.warn(""Unable to determine filter path from filter init-param, web.xml, "" + ""or servlet 3.0 annotations. Assuming user will set filter path "" + ""manually by calling setFilterPath(String)"");
        }
        ThreadContext.setApplication(application);
        try {
            application.initApplication();
                        application.logStarted();
        } finally {
            ThreadContext.detach();
        }
    } finally {
        if (newClassLoader != previousClassLoader) {
            Thread.currentThread().setContextClassLoader(previousClassLoader);
        }
    }
}",1.4090909090909092,0.6275510204081632,0.8333333333333334,1.0,0.6666666666666666,0.4498269896193773,-0.7447662747347291,1.5,-0.028571428571428574,0.8473109160916734
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-43_668f08f2,1,"public void setProperties(String nodePath, Map<String, String> properties) throws Exception {
    MutableNode node = getOrCreateStagedNode(nodePath);
    node.getProperties().clear();
    node.getProperties().putAll(properties);
    // update change log
    changeLog.add(new SetProperties(nodePath, properties));
}",,"public void setProperties(String nodePath, Map<String, String> properties) throws Exception {
    MutableNode node = getOrCreateStagedNode(nodePath);
    node.getProperties().clear();
    node.getProperties().putAll(properties);
        changeLog.add(new SetProperties(nodePath, properties));
}",-0.36363636363636365,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.4924003441353601,0.0,0.1142857142857143,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1822_016df669,1,"/**
 * Apply the changes to the in-memory document.
 *
 * @param doc
 *            the target document.
 * @param update
 *            the changes to apply.
 * @param comparator
 *            the revision comparator.
 */
public static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update, @Nonnull Comparator<Revision> comparator) {
    for (Entry<Key, Operation> e : checkNotNull(update).getChanges().entrySet()) {
        Key k = e.getKey();
        Operation op = e.getValue();
        switch(op.type) {
            case SET:
                {
                    doc.put(k.toString(), op.value);
                    break;
                }
            case INCREMENT:
                {
                    Object old = doc.get(k.toString());
                    Long x = (Long) op.value;
                    if (old == null) {
                        old = 0L;
                    }
                    doc.put(k.toString(), ((Long) old) + x);
                    break;
                }
            case SET_MAP_ENTRY:
                {
                    Object old = doc.get(k.getName());
                    @SuppressWarnings(""unchecked"")
                    Map<Revision, Object> m = (Map<Revision, Object>) old;
                    if (m == null) {
                        m = new TreeMap<Revision, Object>(comparator);
                        doc.put(k.getName(), m);
                    }
                    if (k.getRevision() == null) {
                        throw new IllegalArgumentException(""Cannot set map entry "" + k.getName() + "" with null revision"");
                    }
                    m.put(k.getRevision(), op.value);
                    break;
                }
            case REMOVE_MAP_ENTRY:
                {
                    Object old = doc.get(k.getName());
                    @SuppressWarnings(""unchecked"")
                    Map<Revision, Object> m = (Map<Revision, Object>) old;
                    if (m != null) {
                        m.remove(k.getRevision());
                    }
                    break;
                }
            case CONTAINS_MAP_ENTRY:
                // no effect
                break;
        }
    }
}","/**
 * Apply the changes to the in-memory document.
 *
 * @param doc
 *            the target document.
 * @param update
 *            the changes to apply.
 * @param comparator
 *            the revision comparator.
 */
","public static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update, @Nonnull Comparator<Revision> comparator) {
    for (Entry<Key, Operation> e : checkNotNull(update).getChanges().entrySet()) {
        Key k = e.getKey();
        Operation op = e.getValue();
        switch(op.type) {
            case SET:
                {
                    doc.put(k.toString(), op.value);
                    break;
                }
            case INCREMENT:
                {
                    Object old = doc.get(k.toString());
                    Long x = (Long) op.value;
                    if (old == null) {
                        old = 0L;
                    }
                    doc.put(k.toString(), ((Long) old) + x);
                    break;
                }
            case SET_MAP_ENTRY:
                {
                    Object old = doc.get(k.getName());
                    @SuppressWarnings(""unchecked"")
                    Map<Revision, Object> m = (Map<Revision, Object>) old;
                    if (m == null) {
                        m = new TreeMap<Revision, Object>(comparator);
                        doc.put(k.getName(), m);
                    }
                    if (k.getRevision() == null) {
                        throw new IllegalArgumentException(""Cannot set map entry "" + k.getName() + "" with null revision"");
                    }
                    m.put(k.getRevision(), op.value);
                    break;
                }
            case REMOVE_MAP_ENTRY:
                {
                    Object old = doc.get(k.getName());
                    @SuppressWarnings(""unchecked"")
                    Map<Revision, Object> m = (Map<Revision, Object>) old;
                    if (m != null) {
                        m.remove(k.getRevision());
                    }
                    break;
                }
            case CONTAINS_MAP_ENTRY:
                                break;
        }
    }
}",1.6363636363636365,1.5306122448979589,2.1666666666666665,1.0,0.6666666666666666,0.6653484923381119,-0.9019214224261546,1.4166666666666667,-0.028571428571428574,1.683276155233188
wicket,remotes/origin/bugs-dot-jar_WICKET-2368_fae1601b,1,"public Object component(final Component component) {
    // If component never rendered
    if (renderedComponents == null || !renderedComponents.contains(component)) {
        // If auto component ...
        if (!component.isAuto() && component.isVisibleInHierarchy()) {
            // Increase number of unrendered components
            unrenderedComponents.add(component);
            // Add to explanatory string to buffer
            buffer.append(Integer.toString(unrenderedComponents.size()) + "". "" + component + ""\n"");
            String metadata = component.getMetaData(Component.CONSTRUCTED_AT_KEY);
            if (metadata != null) {
                buffer.append(metadata);
            }
            metadata = component.getMetaData(Component.ADDED_AT_KEY);
            if (metadata != null) {
                buffer.append(metadata);
            }
        } else {
            // not visible
            return CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;
        }
    }
    return CONTINUE_TRAVERSAL;
}",,"public Object component(final Component component) {
        if (renderedComponents == null || !renderedComponents.contains(component)) {
                if (!component.isAuto() && component.isVisibleInHierarchy()) {
                        unrenderedComponents.add(component);
                        buffer.append(Integer.toString(unrenderedComponents.size()) + "". "" + component + ""\n"");
            String metadata = component.getMetaData(Component.CONSTRUCTED_AT_KEY);
            if (metadata != null) {
                buffer.append(metadata);
            }
            metadata = component.getMetaData(Component.ADDED_AT_KEY);
            if (metadata != null) {
                buffer.append(metadata);
            }
        } else {
                        return CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;
        }
    }
    return CONTINUE_TRAVERSAL;
}",0.22727272727272727,0.8520408163265308,0.16666666666666666,0.5,0.5833333333333334,0.782006920415225,-0.2216805276742187,0.4166666666666667,-0.028571428571428574,0.5787023355219482
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1822_3e83a4c1,1,"/**
 * Increment the value.
 *
 * @param property the key
 * @param value the increment
 */
public void increment(@Nonnull String property, long value) {
    Operation op = new Operation();
    op.type = Operation.Type.INCREMENT;
    op.value = value;
    changes.put(new Key(property, null), op);
}","/**
 * Increment the value.
 *
 * @param property the key
 * @param value the increment
 */
","public void increment(@Nonnull String property, long value) {
    Operation op = new Operation();
    op.type = Operation.Type.INCREMENT;
    op.value = value;
    changes.put(new Key(property, null), op);
}",-0.36363636363636365,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.4955549182678522,-0.4166666666666667,2.2285714285714286,-0.16422749602751402
Closure,39,2,"@Override
String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
        return getReferenceName();
    } else if (prettyPrint) {
        // Don't pretty print recursively.
        prettyPrint = false;
        // Use a tree set so that the properties are sorted.
        Set<String> propertyNames = Sets.newTreeSet();
        for (ObjectType current = this; current != null && !current.isNativeObjectType() && propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES; current = current.getImplicitPrototype()) {
            propertyNames.addAll(current.getOwnPropertyNames());
        }
        StringBuilder sb = new StringBuilder();
        sb.append(""{"");
        int i = 0;
        for (String property : propertyNames) {
            if (i > 0) {
                sb.append("", "");
            }
            sb.append(property);
            sb.append("": "");
            sb.append(getPropertyType(property).toString());
            ++i;
            if (i == MAX_PRETTY_PRINTED_PROPERTIES) {
                sb.append("", ..."");
                break;
            }
        }
        sb.append(""}"");
        prettyPrint = true;
        return sb.toString();
    } else {
        return ""{...}"";
    }
}",,"@Override
String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
        return getReferenceName();
    } else if (prettyPrint) {
                prettyPrint = false;
                Set<String> propertyNames = Sets.newTreeSet();
        for (ObjectType current = this; current != null && !current.isNativeObjectType() && propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES; current = current.getImplicitPrototype()) {
            propertyNames.addAll(current.getOwnPropertyNames());
        }
        StringBuilder sb = new StringBuilder();
        sb.append(""{"");
        int i = 0;
        for (String property : propertyNames) {
            if (i > 0) {
                sb.append("", "");
            }
            sb.append(property);
            sb.append("": "");
            sb.append(getPropertyType(property).toString());
            ++i;
            if (i == MAX_PRETTY_PRINTED_PROPERTIES) {
                sb.append("", ..."");
                break;
            }
        }
        sb.append(""}"");
        prettyPrint = true;
        return sb.toString();
    } else {
        return ""{...}"";
    }
}",0.8636363636363636,0.5969387755102042,0.6666666666666666,1.0,0.6666666666666666,1.1576866040533864,-0.5698308001147121,1.0,-0.028571428571428574,1.4286301669086563
Cli,29,1,"/**
 * Remove the leading and trailing quotes from <code>str</code>.
 * E.g. if str is '""one two""', then 'one two' is returned.
 *
 * @param str The string from which the leading and trailing quotes
 * should be removed.
 *
 * @return The string without the leading and trailing quotes.
 */
static String stripLeadingAndTrailingQuotes(String str) {
    if (str.startsWith(""\"""")) {
        str = str.substring(1, str.length());
    }
    int length = str.length();
    if (str.endsWith(""\"""")) {
        str = str.substring(0, length - 1);
    }
    return str;
}","/**
 * Remove the leading and trailing quotes from <code>str</code>.
 * E.g. if str is '""one two""', then 'one two' is returned.
 *
 * @param str The string from which the leading and trailing quotes
 * should be removed.
 *
 * @return The string without the leading and trailing quotes.
 */
","static String stripLeadingAndTrailingQuotes(String str) {
    if (str.startsWith(""\"""")) {
        str = str.substring(1, str.length());
    }
    int length = str.length();
    if (str.endsWith(""\"""")) {
        str = str.substring(0, length - 1);
    }
    return str;
}",-0.18181818181818182,-0.2500000000000001,-0.16666666666666666,-0.5,-0.08333333333333333,0.10380622837370251,0.2305706911385143,0.0,0.0,-0.04363095926435128
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1505_b082fc1e,1,"@Override
public void addMutations(Iterable<Mutation> iterable) throws MutationsRejectedException {
    for (Mutation m : iterable) {
        acu.addMutation(tablename, m);
    }
}",,"@Override
public void addMutations(Iterable<Mutation> iterable) throws MutationsRejectedException {
    for (Mutation m : iterable) {
        acu.addMutation(tablename, m);
    }
}",-0.36363636363636365,-0.02040816326530614,-0.3333333333333333,-0.5,-0.4166666666666667,-0.3806228373702422,0.6030972182391743,-0.4166666666666667,0.5428571428571429,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-9143_08077733,1,"protected void doStop() throws Exception {
    // when stopping we intend to shutdown
    ServiceHelper.stopAndShutdownServices(statistics, pool);
    try {
        ServiceHelper.stopAndShutdownServices(producers.values());
    } finally {
        // ensure producers are removed, and also from JMX
        for (Producer producer : producers.values()) {
            getCamelContext().removeService(producer);
        }
    }
    producers.clear();
    if (statistics != null) {
        statistics.clear();
    }
}",,"protected void doStop() throws Exception {
        ServiceHelper.stopAndShutdownServices(statistics, pool);
    try {
        ServiceHelper.stopAndShutdownServices(producers.values());
    } finally {
                for (Producer producer : producers.values()) {
            getCamelContext().removeService(producer);
        }
    }
    producers.clear();
    if (statistics != null) {
        statistics.clear();
    }
}",0.0,0.08163265306122457,-0.16666666666666666,0.0,-0.25,-0.3806228373702422,0.09463722397476335,0.16666666666666666,0.31428571428571433,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-3433_e76d23b0,3,"@Override
public String toString() {
    return """" + expression + "".convertTo("" + type.getCanonicalName() + "".class)"";
}",,"@Override
public String toString() {
    return """" + expression + "".convertTo("" + type.getCanonicalName() + "".class)"";
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8339546888442785,-0.4166666666666667,2.0,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-4397_e33516d5,0,"/**
 * Recursively sync the memberships of an authorizable up-to the specified depth. If the given depth
 * is equal or less than 0, no syncing is performed.
 *
 * @param external the external identity
 * @param auth the authorizable
 * @param depth recursion depth.
 * @throws RepositoryException
 */
protected void syncMembership(@Nonnull ExternalIdentity external, @Nonnull Authorizable auth, long depth) throws RepositoryException {
    if (depth <= 0) {
        return;
    }
    if (log.isDebugEnabled()) {
        log.debug(""Syncing membership '{}' -> '{}'"", external.getExternalId().getString(), auth.getID());
    }
    final DebugTimer timer = new DebugTimer();
    Iterable<ExternalIdentityRef> externalGroups;
    try {
        externalGroups = external.getDeclaredGroups();
    } catch (ExternalIdentityException e) {
        log.error(""Error while retrieving external declared groups for '{}'"", external.getId(), e);
        return;
    }
    timer.mark(""fetching"");
    // first get the set of the existing groups that are synced ones
    Map<String, Group> declaredExternalGroups = new HashMap<String, Group>();
    Iterator<Group> grpIter = auth.declaredMemberOf();
    while (grpIter.hasNext()) {
        Group grp = grpIter.next();
        if (isSameIDP(grp)) {
            declaredExternalGroups.put(grp.getID(), grp);
        }
    }
    timer.mark(""reading"");
    for (ExternalIdentityRef ref : externalGroups) {
        log.debug(""- processing membership {}"", ref.getId());
        // get group
        ExternalGroup extGroup;
        try {
            ExternalIdentity extId = idp.getIdentity(ref);
            if (extId instanceof ExternalGroup) {
                extGroup = (ExternalGroup) extId;
            } else {
                log.warn(""No external group found for ref '{}'."", ref.getString());
                continue;
            }
        } catch (ExternalIdentityException e) {
            log.warn(""Unable to retrieve external group '{}' from provider."", ref.getString(), e);
            continue;
        }
        log.debug(""- idp returned '{}'"", extGroup.getId());
        Group grp;
        Authorizable a = userManager.getAuthorizable(extGroup.getId());
        if (a == null) {
            grp = createGroup(extGroup);
            log.debug(""- created new group"");
        } else if (a.isGroup()) {
            grp = (Group) a;
        } else {
            log.warn(""Authorizable '{}' is not a group, but should be one."", extGroup.getId());
            continue;
        }
        log.debug(""- user manager returned '{}'"", grp);
        syncGroup(extGroup, grp);
        // ensure membership
        grp.addMember(auth);
        log.debug(""- added '{}' as member to '{}'"", auth, grp);
        // remember the declared group
        declaredExternalGroups.remove(grp.getID());
        // recursively apply further membership
        if (depth > 1) {
            log.debug(""- recursively sync group membership of '{}' (depth = {})."", grp.getID(), depth);
            syncMembership(extGroup, grp, depth - 1);
        } else {
            log.debug(""- group nesting level for '{}' reached"", grp.getID());
        }
    }
    timer.mark(""adding"");
    // remove us from the lost membership groups
    for (Group grp : declaredExternalGroups.values()) {
        grp.removeMember(auth);
        log.debug(""- removing member '{}' for group '{}'"", auth.getID(), grp.getID());
    }
    if (log.isDebugEnabled()) {
        timer.mark(""removing"");
        log.debug(""syncMembership({}) {}"", external.getId(), timer.getString());
    }
}","/**
 * Recursively sync the memberships of an authorizable up-to the specified depth. If the given depth
 * is equal or less than 0, no syncing is performed.
 *
 * @param external the external identity
 * @param auth the authorizable
 * @param depth recursion depth.
 * @throws RepositoryException
 */
","protected void syncMembership(@Nonnull ExternalIdentity external, @Nonnull Authorizable auth, long depth) throws RepositoryException {
    if (depth <= 0) {
        return;
    }
    if (log.isDebugEnabled()) {
        log.debug(""Syncing membership '{}' -> '{}'"", external.getExternalId().getString(), auth.getID());
    }
    final DebugTimer timer = new DebugTimer();
    Iterable<ExternalIdentityRef> externalGroups;
    try {
        externalGroups = external.getDeclaredGroups();
    } catch (ExternalIdentityException e) {
        log.error(""Error while retrieving external declared groups for '{}'"", external.getId(), e);
        return;
    }
    timer.mark(""fetching"");
        Map<String, Group> declaredExternalGroups = new HashMap<String, Group>();
    Iterator<Group> grpIter = auth.declaredMemberOf();
    while (grpIter.hasNext()) {
        Group grp = grpIter.next();
        if (isSameIDP(grp)) {
            declaredExternalGroups.put(grp.getID(), grp);
        }
    }
    timer.mark(""reading"");
    for (ExternalIdentityRef ref : externalGroups) {
        log.debug(""- processing membership {}"", ref.getId());
                ExternalGroup extGroup;
        try {
            ExternalIdentity extId = idp.getIdentity(ref);
            if (extId instanceof ExternalGroup) {
                extGroup = (ExternalGroup) extId;
            } else {
                log.warn(""No external group found for ref '{}'."", ref.getString());
                continue;
            }
        } catch (ExternalIdentityException e) {
            log.warn(""Unable to retrieve external group '{}' from provider."", ref.getString(), e);
            continue;
        }
        log.debug(""- idp returned '{}'"", extGroup.getId());
        Group grp;
        Authorizable a = userManager.getAuthorizable(extGroup.getId());
        if (a == null) {
            grp = createGroup(extGroup);
            log.debug(""- created new group"");
        } else if (a.isGroup()) {
            grp = (Group) a;
        } else {
            log.warn(""Authorizable '{}' is not a group, but should be one."", extGroup.getId());
            continue;
        }
        log.debug(""- user manager returned '{}'"", grp);
        syncGroup(extGroup, grp);
                grp.addMember(auth);
        log.debug(""- added '{}' as member to '{}'"", auth, grp);
                declaredExternalGroups.remove(grp.getID());
                if (depth > 1) {
            log.debug(""- recursively sync group membership of '{}' (depth = {})."", grp.getID(), depth);
            syncMembership(extGroup, grp, depth - 1);
        } else {
            log.debug(""- group nesting level for '{}' reached"", grp.getID());
        }
    }
    timer.mark(""adding"");
        for (Group grp : declaredExternalGroups.values()) {
        grp.removeMember(auth);
        log.debug(""- removing member '{}' for group '{}'"", auth.getID(), grp.getID());
    }
    if (log.isDebugEnabled()) {
        timer.mark(""removing"");
        log.debug(""syncMembership({}) {}"", external.getId(), timer.getString());
    }
}",2.727272727272727,0.24489795918367346,2.1666666666666665,0.5,1.0,0.6455758774097876,-1.160596501290508,4.0,-0.028571428571428574,2.862836804707878
Time,26,2,"public long set(long instant, String text, Locale locale) {
    // cannot verify that new value stuck because set may be lenient
    long localInstant = iZone.convertUTCToLocal(instant);
    localInstant = iField.set(localInstant, text, locale);
    return iZone.convertLocalToUTC(localInstant, false);
}",,"public long set(long instant, String text, Locale locale) {
        long localInstant = iZone.convertUTCToLocal(instant);
    localInstant = iField.set(localInstant, text, locale);
    return iZone.convertLocalToUTC(localInstant, false);
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.605965012905076,-0.25,0.05714285714285714,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-93_0be7e8f0,1,"/**
 * Copy this tree to the parent at {@code destParent} with the name {@code destName}.
 *
 * @param destParent  parent for the copied tree
 * @param destName  name for the copied tree
 * @return  {@code true} if successful, {@code false otherwise}. I.e.
 * when {@code destName} already exists at {@code destParent}
 */
public boolean copy(TreeImpl destParent, String destName) {
    boolean result = builder.copyTo(destParent.builder, destName);
    if (result) {
        if (listener != null) {
            listener.copy(parent, name, destParent.getChild(destName));
        }
        return true;
    }
    return result;
}","/**
 * Copy this tree to the parent at {@code destParent} with the name {@code destName}.
 *
 * @param destParent  parent for the copied tree
 * @param destName  name for the copied tree
 * @return  {@code true} if successful, {@code false otherwise}. I.e.
 * when {@code destName} already exists at {@code destParent}
 */
","public boolean copy(TreeImpl destParent, String destName) {
    boolean result = builder.copyTo(destParent.builder, destName);
    if (result) {
        if (listener != null) {
            listener.copy(parent, name, destParent.getChild(destName));
        }
        return true;
    }
    return result;
}",-0.18181818181818182,0.2959183673469388,-0.16666666666666666,0.0,-0.08333333333333333,-0.06426099851705384,0.24175509033553183,-0.25,0.08571428571428572,-0.09139930015718624
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2435_7e250001,3,"@Override
public boolean equals(Object obj) {
    if (obj instanceof Key) {
        Key other = (Key) obj;
        return name.equals(other.name) && revision != null ? revision.equals(other.revision) : other.revision == null;
    }
    return false;
}",,"@Override
public boolean equals(Object obj) {
    if (obj instanceof Key) {
        Key other = (Key) obj;
        return name.equals(other.name) && revision != null ? revision.equals(other.revision) : other.revision == null;
    }
    return false;
}",-0.2727272727272727,0.051020408163265356,-0.16666666666666666,-0.5,0.16666666666666666,0.5190311418685122,0.33610553484370526,-0.3333333333333333,0.7142857142857143,0.056347197416492134
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_add180fb,1,"@Override
public void removeIterator(String tableName, String name, EnumSet<IteratorScope> scopes) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {
    Map<String, String> copy = new HashMap<String, String>();
    for (Entry<String, String> property : this.getProperties(tableName)) {
        copy.put(property.getKey(), property.getValue());
    }
    for (IteratorScope scope : scopes) {
        String root = String.format(""%s%s.%s"", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase(), name);
        for (Entry<String, String> property : copy.entrySet()) {
            if (property.getKey().equals(root) || property.getKey().startsWith(root + "".opt.""))
                this.removeProperty(tableName, property.getKey());
        }
    }
}",,"@Override
public void removeIterator(String tableName, String name, EnumSet<IteratorScope> scopes) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {
    Map<String, String> copy = new HashMap<String, String>();
    for (Entry<String, String> property : this.getProperties(tableName)) {
        copy.put(property.getKey(), property.getValue());
    }
    for (IteratorScope scope : scopes) {
        String root = String.format(""%s%s.%s"", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase(), name);
        for (Entry<String, String> property : copy.entrySet()) {
            if (property.getKey().equals(root) || property.getKey().startsWith(root + "".opt.""))
                this.removeProperty(tableName, property.getKey());
        }
    }
}",0.0,0.7346938775510204,0.16666666666666666,0.0,0.0,0.008897676717745953,-0.10811585890450236,0.6666666666666666,-0.028571428571428574,0.13671347989772187
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1178_f2bb1a17,1,"@Override
public boolean isNew() {
    return exists() && !base.exists();
}",,"@Override
public boolean isNew() {
    return exists() && !base.exists();
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.14335145823035095,0.9125322626899914,-0.3333333333333333,2.2571428571428576,-0.1526848009045704
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-834_d3989b40,1,"/**
 * Loads classes not located via Reflection.getCallerClass.
 *
 * @param lastLoader
 *        The ClassLoader that loaded the Class that called this Class.
 * @param className
 *        The name of the Class.
 * @return The Class object for the Class or null if it could not be located.
 */
private Class<?> loadClass(final ClassLoader lastLoader, final String className) {
    // XXX: this is overly complicated
    Class<?> clazz;
    if (lastLoader != null) {
        try {
            clazz = Loader.initializeClass(className, lastLoader);
            if (clazz != null) {
                return clazz;
            }
        } catch (final Throwable ignore) {
        // Ignore exception.
        }
    }
    try {
        clazz = Loader.loadClass(className);
    } catch (final ClassNotFoundException ignored) {
        try {
            clazz = Loader.initializeClass(className, this.getClass().getClassLoader());
        } catch (final ClassNotFoundException ignore) {
            return null;
        }
    }
    return clazz;
}","/**
 * Loads classes not located via Reflection.getCallerClass.
 *
 * @param lastLoader
 *        The ClassLoader that loaded the Class that called this Class.
 * @param className
 *        The name of the Class.
 * @return The Class object for the Class or null if it could not be located.
 */
","private Class<?> loadClass(final ClassLoader lastLoader, final String className) {
        Class<?> clazz;
    if (lastLoader != null) {
        try {
            clazz = Loader.initializeClass(className, lastLoader);
            if (clazz != null) {
                return clazz;
            }
        } catch (final Throwable ignore) {
                }
    }
    try {
        clazz = Loader.loadClass(className);
    } catch (final ClassNotFoundException ignored) {
        try {
            clazz = Loader.initializeClass(className, this.getClass().getClassLoader());
        } catch (final ClassNotFoundException ignore) {
            return null;
        }
    }
    return clazz;
}",0.36363636363636365,0.556122448979592,0.3333333333333333,0.5,-0.08333333333333333,0.05042016806722697,-0.22139374820762836,-0.08333333333333333,0.1142857142857143,0.0020858228292666234
flink,remotes/origin/bugs-dot-jar_FLINK-2074_6bc6dbec,0,"@Override
public void evict(int n) {
    toRemove += n;
    Integer lastPreAggregateSize = elementsPerPreAggregate.peek();
    while (lastPreAggregateSize != null && lastPreAggregateSize <= toRemove) {
        toRemove = max(toRemove - elementsPerPreAggregate.removeFirst(), 0);
        reduced.removeFirst();
        lastPreAggregateSize = elementsPerPreAggregate.peek();
    }
    if (toRemove > 0 && lastPreAggregateSize == null) {
        currentReduced = null;
        toRemove = 0;
    }
}",,"@Override
public void evict(int n) {
    toRemove += n;
    Integer lastPreAggregateSize = elementsPerPreAggregate.peek();
    while (lastPreAggregateSize != null && lastPreAggregateSize <= toRemove) {
        toRemove = max(toRemove - elementsPerPreAggregate.removeFirst(), 0);
        reduced.removeFirst();
        lastPreAggregateSize = elementsPerPreAggregate.peek();
    }
    if (toRemove > 0 && lastPreAggregateSize == null) {
        currentReduced = null;
        toRemove = 0;
    }
}",0.0,-0.025510204081632563,-0.16666666666666666,-0.5,0.08333333333333333,1.359367276322294,-0.01462575279609995,-0.08333333333333333,0.0,0.6200504537842481
Closure,169,2,"private boolean hasAlternate(JSType type, boolean tolerateUnknowns) {
    for (JSType alternate : alternates) {
        if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) {
            return true;
        }
    }
    return false;
}",,"private boolean hasAlternate(JSType type, boolean tolerateUnknowns) {
    for (JSType alternate : alternates) {
        if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) {
            return true;
        }
    }
    return false;
}",-0.2727272727272727,0.43367346938775514,-0.16666666666666666,0.0,-0.08333333333333333,-0.3806228373702422,0.4688844278749641,-0.4166666666666667,0.2571428571428572,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2695_0598498e,0,"private boolean dispatch(@Nonnull String jsonDiff, @Nonnull DocumentNodeState node, @Nonnull DocumentNodeState base, @Nonnull NodeStateDiff diff, boolean useReadRevision) {
    if (jsonDiff.trim().isEmpty()) {
        return true;
    }
    Revision nodeRev = useReadRevision ? node.getRevision() : node.getLastRevision();
    Revision baseRev = useReadRevision ? base.getRevision() : base.getLastRevision();
    JsopTokenizer t = new JsopTokenizer(jsonDiff);
    boolean continueComparison = true;
    while (continueComparison) {
        int r = t.read();
        if (r == JsopReader.END) {
            break;
        }
        switch(r) {
            case '+':
                {
                    String name = unshareString(t.readString());
                    t.read(':');
                    t.read('{');
                    while (t.read() != '}') {
                    // skip properties
                    }
                    NodeState child = getNode(concat(node.getPath(), name), nodeRev);
                    continueComparison = diff.childNodeAdded(name, child);
                    break;
                }
            case '-':
                {
                    String name = unshareString(t.readString());
                    NodeState child = getNode(concat(base.getPath(), name), baseRev);
                    continueComparison = diff.childNodeDeleted(name, child);
                    break;
                }
            case '^':
                {
                    String name = unshareString(t.readString());
                    t.read(':');
                    if (t.matches('{')) {
                        t.read('}');
                        NodeState nodeChild = getNode(concat(node.getPath(), name), nodeRev);
                        NodeState baseChild = getNode(concat(base.getPath(), name), baseRev);
                        continueComparison = diff.childNodeChanged(name, baseChild, nodeChild);
                    } else if (t.matches('[')) {
                        // ignore multi valued property
                        while (t.read() != ']') {
                        // skip values
                        }
                    } else {
                        // ignore single valued property
                        t.read();
                    }
                    break;
                }
            default:
                throw new IllegalArgumentException(""jsonDiff: illegal token '"" + t.getToken() + ""' at pos: "" + t.getLastPos() + ' ' + jsonDiff);
        }
    }
    return continueComparison;
}",,"private boolean dispatch(@Nonnull String jsonDiff, @Nonnull DocumentNodeState node, @Nonnull DocumentNodeState base, @Nonnull NodeStateDiff diff, boolean useReadRevision) {
    if (jsonDiff.trim().isEmpty()) {
        return true;
    }
    Revision nodeRev = useReadRevision ? node.getRevision() : node.getLastRevision();
    Revision baseRev = useReadRevision ? base.getRevision() : base.getLastRevision();
    JsopTokenizer t = new JsopTokenizer(jsonDiff);
    boolean continueComparison = true;
    while (continueComparison) {
        int r = t.read();
        if (r == JsopReader.END) {
            break;
        }
        switch(r) {
            case '+':
                {
                    String name = unshareString(t.readString());
                    t.read(':');
                    t.read('{');
                    while (t.read() != '}') {
                                        }
                    NodeState child = getNode(concat(node.getPath(), name), nodeRev);
                    continueComparison = diff.childNodeAdded(name, child);
                    break;
                }
            case '-':
                {
                    String name = unshareString(t.readString());
                    NodeState child = getNode(concat(base.getPath(), name), baseRev);
                    continueComparison = diff.childNodeDeleted(name, child);
                    break;
                }
            case '^':
                {
                    String name = unshareString(t.readString());
                    t.read(':');
                    if (t.matches('{')) {
                        t.read('}');
                        NodeState nodeChild = getNode(concat(node.getPath(), name), nodeRev);
                        NodeState baseChild = getNode(concat(base.getPath(), name), baseRev);
                        continueComparison = diff.childNodeChanged(name, baseChild, nodeChild);
                    } else if (t.matches('[')) {
                                                while (t.read() != ']') {
                                                }
                    } else {
                                                t.read();
                    }
                    break;
                }
            default:
                throw new IllegalArgumentException(""jsonDiff: illegal token '"" + t.getToken() + ""' at pos: "" + t.getLastPos() + ' ' + jsonDiff);
        }
    }
    return continueComparison;
}",1.8636363636363635,2.1785714285714284,2.5,2.0,1.1666666666666667,0.7108255066732576,-0.9876684829366219,2.75,-0.028571428571428574,2.1618718439616074
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-846_7acb091a,3,"/**
 * Get the revision of the latest change made to this node.
 *
 * @param nodeMap the document
 * @param changeRev the revision of the current change
 * @param handler the conflict handler, which is called for un-committed revisions
 *                preceding <code>before</code>.
 * @return the revision, or null if deleted
 */
@SuppressWarnings(""unchecked"")
@Nullable
Revision getNewestRevision(Map<String, Object> nodeMap, Revision changeRev, CollisionHandler handler) {
    if (nodeMap == null) {
        return null;
    }
    SortedSet<String> revisions = new TreeSet<String>(Collections.reverseOrder());
    if (nodeMap.containsKey(UpdateOp.REVISIONS)) {
        revisions.addAll(((Map<String, String>) nodeMap.get(UpdateOp.REVISIONS)).keySet());
    }
    if (nodeMap.containsKey(UpdateOp.COMMIT_ROOT)) {
        revisions.addAll(((Map<String, Integer>) nodeMap.get(UpdateOp.COMMIT_ROOT)).keySet());
    }
    Map<String, String> deletedMap = (Map<String, String>) nodeMap.get(UpdateOp.DELETED);
    if (deletedMap != null) {
        revisions.addAll(deletedMap.keySet());
    }
    Revision newestRev = null;
    for (String r : revisions) {
        Revision propRev = Revision.fromString(r);
        if (isRevisionNewer(propRev, changeRev)) {
            // we have seen a previous change from another cluster node
            // (which might be conflicting or not) - we need to make
            // sure this change is visible from now on
            publishRevision(propRev, changeRev);
        }
        if (newestRev == null || isRevisionNewer(propRev, newestRev)) {
            if (!propRev.equals(changeRev)) {
                if (!isValidRevision(propRev, changeRev, nodeMap, new HashSet<Revision>())) {
                    handler.uncommittedModification(propRev);
                } else {
                    newestRev = propRev;
                }
            }
        }
    }
    if (newestRev == null) {
        return null;
    }
    if (deletedMap != null) {
        String value = deletedMap.get(newestRev.toString());
        if (""true"".equals(value)) {
            // deleted in the newest revision
            return null;
        }
    }
    return newestRev;
}","/**
 * Get the revision of the latest change made to this node.
 *
 * @param nodeMap the document
 * @param changeRev the revision of the current change
 * @param handler the conflict handler, which is called for un-committed revisions
 *                preceding <code>before</code>.
 * @return the revision, or null if deleted
 */
","@SuppressWarnings(""unchecked"")
@Nullable
Revision getNewestRevision(Map<String, Object> nodeMap, Revision changeRev, CollisionHandler handler) {
    if (nodeMap == null) {
        return null;
    }
    SortedSet<String> revisions = new TreeSet<String>(Collections.reverseOrder());
    if (nodeMap.containsKey(UpdateOp.REVISIONS)) {
        revisions.addAll(((Map<String, String>) nodeMap.get(UpdateOp.REVISIONS)).keySet());
    }
    if (nodeMap.containsKey(UpdateOp.COMMIT_ROOT)) {
        revisions.addAll(((Map<String, Integer>) nodeMap.get(UpdateOp.COMMIT_ROOT)).keySet());
    }
    Map<String, String> deletedMap = (Map<String, String>) nodeMap.get(UpdateOp.DELETED);
    if (deletedMap != null) {
        revisions.addAll(deletedMap.keySet());
    }
    Revision newestRev = null;
    for (String r : revisions) {
        Revision propRev = Revision.fromString(r);
        if (isRevisionNewer(propRev, changeRev)) {
                                                publishRevision(propRev, changeRev);
        }
        if (newestRev == null || isRevisionNewer(propRev, newestRev)) {
            if (!propRev.equals(changeRev)) {
                if (!isValidRevision(propRev, changeRev, nodeMap, new HashSet<Revision>())) {
                    handler.uncommittedModification(propRev);
                } else {
                    newestRev = propRev;
                }
            }
        }
    }
    if (newestRev == null) {
        return null;
    }
    if (deletedMap != null) {
        String value = deletedMap.get(newestRev.toString());
        if (""true"".equals(value)) {
                        return null;
        }
    }
    return newestRev;
}",1.3636363636363635,0.9540816326530611,1.5,1.0,1.6666666666666667,0.7582797825012358,-0.8038428448523088,1.3333333333333333,-0.028571428571428574,1.6863213709038425
commons-math,remotes/origin/bugs-dot-jar_MATH-413_51aa6e6c,1,"/**
 * {@inheritDoc}
 */
public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max) throws FunctionEvaluationException {
    optima = new UnivariateRealPointValuePair[starts];
    totalEvaluations = 0;
    // Multi-start loop.
    for (int i = 0; i < starts; ++i) {
        try {
            final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);
            final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);
            optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));
        } catch (FunctionEvaluationException fee) {
            optima[i] = null;
        } catch (ConvergenceException ce) {
            optima[i] = null;
        }
        final int usedEvaluations = optimizer.getEvaluations();
        optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);
        totalEvaluations += usedEvaluations;
    }
    sortPairs(goal);
    if (optima[0] == null) {
        throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT, starts);
    }
    // Return the point with the best objective function value.
    return optima[0];
}","/**
 * {@inheritDoc}
 */
","public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max) throws FunctionEvaluationException {
    optima = new UnivariateRealPointValuePair[starts];
    totalEvaluations = 0;
        for (int i = 0; i < starts; ++i) {
        try {
            final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);
            final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);
            optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));
        } catch (FunctionEvaluationException fee) {
            optima[i] = null;
        } catch (ConvergenceException ce) {
            optima[i] = null;
        }
        final int usedEvaluations = optimizer.getEvaluations();
        optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);
        totalEvaluations += usedEvaluations;
    }
    sortPairs(goal);
    if (optima[0] == null) {
        throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT, starts);
    }
        return optima[0];
}",0.4090909090909091,0.3061224489795919,0.6666666666666666,0.0,0.08333333333333333,1.6717745921898177,-0.42558072841984534,0.25,0.0,2.3188781956561777
wicket,remotes/origin/bugs-dot-jar_WICKET-5881_8c83c5c5,1,"/**
 *  Update the model of a {@link FormComponent} containing a {@link Collection}.
 *
 *  If the model object does not yet exists, a new {@link ArrayList} is filled with the converted
 *  input and used as the new model object. Otherwise the existing collection is modified
 *  in-place, then {@link Model#setObject(Object)} is called with the same instance: it allows
 *  the Model to be notified of changes even when {@link Model#getObject()} returns a different
 *  {@link Collection} at every invocation.
 *
 *  @param <S>
 *             collection type
 *  @param formComponent
 *             the form component to update
 *  @see FormComponent#updateModel()
 *  @throws WicketRuntimeException
 *              if the existing model object collection is unmodifiable and no setter exists
 */
public static <S> void updateCollectionModel(FormComponent<Collection<S>> formComponent) {
    Collection<S> convertedInput = formComponent.getConvertedInput();
    Collection<S> collection = formComponent.getModelObject();
    if (collection == null) {
        collection = new ArrayList<>(convertedInput);
        formComponent.setModelObject(collection);
    } else {
        boolean modified = false;
        formComponent.modelChanging();
        try {
            collection.clear();
            if (convertedInput != null) {
                collection.addAll(convertedInput);
            }
            modified = true;
        } catch (UnsupportedOperationException unmodifiable) {
            if (logger.isDebugEnabled()) {
                logger.debug(""An error occurred while trying to modify the collection attached to "" + formComponent, unmodifiable);
            }
            collection = new ArrayList<>(convertedInput);
        }
        try {
            formComponent.getModel().setObject(collection);
        } catch (Exception noSetter) {
            if (!modified) {
                throw new WicketRuntimeException(""An error occurred while trying to set the collection attached to "" + formComponent, noSetter);
            } else if (logger.isDebugEnabled()) {
                logger.debug(""An error occurred while trying to set the collection attached to "" + formComponent, noSetter);
            }
        }
        formComponent.modelChanged();
    }
}","/**
 *  Update the model of a {@link FormComponent} containing a {@link Collection}.
 *
 *  If the model object does not yet exists, a new {@link ArrayList} is filled with the converted
 *  input and used as the new model object. Otherwise the existing collection is modified
 *  in-place, then {@link Model#setObject(Object)} is called with the same instance: it allows
 *  the Model to be notified of changes even when {@link Model#getObject()} returns a different
 *  {@link Collection} at every invocation.
 *
 *  @param <S>
 *             collection type
 *  @param formComponent
 *             the form component to update
 *  @see FormComponent#updateModel()
 *  @throws WicketRuntimeException
 *              if the existing model object collection is unmodifiable and no setter exists
 */
","public static <S> void updateCollectionModel(FormComponent<Collection<S>> formComponent) {
    Collection<S> convertedInput = formComponent.getConvertedInput();
    Collection<S> collection = formComponent.getModelObject();
    if (collection == null) {
        collection = new ArrayList<>(convertedInput);
        formComponent.setModelObject(collection);
    } else {
        boolean modified = false;
        formComponent.modelChanging();
        try {
            collection.clear();
            if (convertedInput != null) {
                collection.addAll(convertedInput);
            }
            modified = true;
        } catch (UnsupportedOperationException unmodifiable) {
            if (logger.isDebugEnabled()) {
                logger.debug(""An error occurred while trying to modify the collection attached to "" + formComponent, unmodifiable);
            }
            collection = new ArrayList<>(convertedInput);
        }
        try {
            formComponent.getModel().setObject(collection);
        } catch (Exception noSetter) {
            if (!modified) {
                throw new WicketRuntimeException(""An error occurred while trying to set the collection attached to "" + formComponent, noSetter);
            } else if (logger.isDebugEnabled()) {
                logger.debug(""An error occurred while trying to set the collection attached to "" + formComponent, noSetter);
            }
        }
        formComponent.modelChanged();
    }
}",0.8636363636363636,0.6173469387755104,0.8333333333333334,1.0,0.3333333333333333,0.48541769649036093,-0.5597935187840551,0.5833333333333334,-0.028571428571428574,0.6362187929638815
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-4351_59a83d23,3,"@Override
public IndexRow next() {
    final IndexRow pathRow = pathCursor.next();
    return new IndexRow() {

        @Override
        public boolean isVirtualRow() {
            return currentRow.isVirutal;
        }

        @Override
        public String getPath() {
            String sub = pathRow.getPath();
            if (isVirtualRow()) {
                return sub;
            } else if (PathUtils.isAbsolute(sub)) {
                return pathPrefix + sub;
            } else {
                return PathUtils.concat(pathPrefix, sub);
            }
        }

        @Override
        public PropertyValue getValue(String columnName) {
            // overlay the score
            if (QueryImpl.JCR_SCORE.equals(columnName)) {
                return PropertyValues.newDouble(currentRow.score);
            }
            if (QueryImpl.REP_SPELLCHECK.equals(columnName) || QueryImpl.REP_SUGGEST.equals(columnName)) {
                return PropertyValues.newString(currentRow.suggestion);
            }
            if (QueryImpl.OAK_SCORE_EXPLANATION.equals(columnName)) {
                return PropertyValues.newString(currentRow.explanation);
            }
            if (QueryImpl.REP_EXCERPT.equals(columnName)) {
                return PropertyValues.newString(currentRow.excerpt);
            }
            if (columnName.startsWith(QueryImpl.REP_FACET)) {
                String facetFieldName = FacetHelper.parseFacetField(columnName);
                Facets facets = currentRow.facets;
                try {
                    if (facets != null) {
                        FacetResult topChildren = facets.getTopChildren(10, facetFieldName);
                        if (topChildren != null) {
                            JsopWriter writer = new JsopBuilder();
                            writer.object();
                            for (LabelAndValue lav : topChildren.labelValues) {
                                writer.key(lav.label).value(lav.value.intValue());
                            }
                            writer.endObject();
                            return PropertyValues.newString(writer.toString());
                        } else {
                            return null;
                        }
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
            return pathRow.getValue(columnName);
        }
    };
}",,"@Override
public IndexRow next() {
    final IndexRow pathRow = pathCursor.next();
    return new IndexRow() {

        @Override
        public boolean isVirtualRow() {
            return currentRow.isVirutal;
        }

        @Override
        public String getPath() {
            String sub = pathRow.getPath();
            if (isVirtualRow()) {
                return sub;
            } else if (PathUtils.isAbsolute(sub)) {
                return pathPrefix + sub;
            } else {
                return PathUtils.concat(pathPrefix, sub);
            }
        }

        @Override
        public PropertyValue getValue(String columnName) {
                        if (QueryImpl.JCR_SCORE.equals(columnName)) {
                return PropertyValues.newDouble(currentRow.score);
            }
            if (QueryImpl.REP_SPELLCHECK.equals(columnName) || QueryImpl.REP_SUGGEST.equals(columnName)) {
                return PropertyValues.newString(currentRow.suggestion);
            }
            if (QueryImpl.OAK_SCORE_EXPLANATION.equals(columnName)) {
                return PropertyValues.newString(currentRow.explanation);
            }
            if (QueryImpl.REP_EXCERPT.equals(columnName)) {
                return PropertyValues.newString(currentRow.excerpt);
            }
            if (columnName.startsWith(QueryImpl.REP_FACET)) {
                String facetFieldName = FacetHelper.parseFacetField(columnName);
                Facets facets = currentRow.facets;
                try {
                    if (facets != null) {
                        FacetResult topChildren = facets.getTopChildren(10, facetFieldName);
                        if (topChildren != null) {
                            JsopWriter writer = new JsopBuilder();
                            writer.object();
                            for (LabelAndValue lav : topChildren.labelValues) {
                                writer.key(lav.label).value(lav.value.intValue());
                            }
                            writer.endObject();
                            return PropertyValues.newString(writer.toString());
                        } else {
                            return null;
                        }
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
            return pathRow.getValue(columnName);
        }
    };
}",2.0454545454545454,2.392857142857143,1.5,2.0,1.4166666666666667,0.43598615916955025,-0.9532549469457992,1.5833333333333333,-0.028571428571428574,1.284961088910875
wicket,remotes/origin/bugs-dot-jar_WICKET-4184_a0150366,1,"/**
 *  Inserts the string into this string buffer.
 *  <p>
 *  The characters of the <code>String</code> argument are inserted, in order, into this string
 *  buffer at the indicated offset, moving up any characters originally above that position and
 *  increasing the length of this string buffer by the length of the argument. If
 *  <code>str</code> is <code>null</code>, then the four characters <code>""null""</code> are
 *  inserted into this string buffer.
 *  <p>
 *  The character at index <i>k</i> in the new character sequence is equal to:
 *  <ul>
 *  <li>the character at index <i>k</i> in the old character sequence, if <i>k</i> is less than
 *  <code>offset</code>
 *  <li>the character at index <i>k</i><code>-offset</code> in the argument <code>str</code>, if
 *  <i>k</i> is not less than <code>offset</code> but is less than
 *  <code>offset+str.length()</code>
 *  <li>the character at index <i>k</i><code>-str.length()</code> in the old character sequence,
 *  if <i>k</i> is not less than <code>offset+str.length()</code>
 *  </ul>
 *  <p>
 *  The offset argument must be greater than or equal to <code>0</code>, and less than or equal
 *  to the length of this string buffer.
 *
 *  @param offset
 *             the offset.
 *  @param str
 *             a string.
 *  @return a reference to this <code>AppendingStringBuffer</code> object.
 *  @exception StringIndexOutOfBoundsException
 *                 if the offset is invalid.
 *  @see java.lang.StringBuffer#length()
 */
public AppendingStringBuffer insert(final int offset, StringBuilder str) {
    if ((offset < 0) || (offset > count)) {
        throw new StringIndexOutOfBoundsException();
    }
    if (str == null) {
        str = SB_NULL;
    }
    int len = str.length();
    int newcount = count + len;
    if (newcount > value.length) {
        expandCapacity(newcount);
    }
    System.arraycopy(value, offset, value, offset + len, count - offset);
    str.getChars(0, len, value, offset);
    count = newcount;
    return this;
}","/**
 *  Inserts the string into this string buffer.
 *  <p>
 *  The characters of the <code>String</code> argument are inserted, in order, into this string
 *  buffer at the indicated offset, moving up any characters originally above that position and
 *  increasing the length of this string buffer by the length of the argument. If
 *  <code>str</code> is <code>null</code>, then the four characters <code>""null""</code> are
 *  inserted into this string buffer.
 *  <p>
 *  The character at index <i>k</i> in the new character sequence is equal to:
 *  <ul>
 *  <li>the character at index <i>k</i> in the old character sequence, if <i>k</i> is less than
 *  <code>offset</code>
 *  <li>the character at index <i>k</i><code>-offset</code> in the argument <code>str</code>, if
 *  <i>k</i> is not less than <code>offset</code> but is less than
 *  <code>offset+str.length()</code>
 *  <li>the character at index <i>k</i><code>-str.length()</code> in the old character sequence,
 *  if <i>k</i> is not less than <code>offset+str.length()</code>
 *  </ul>
 *  <p>
 *  The offset argument must be greater than or equal to <code>0</code>, and less than or equal
 *  to the length of this string buffer.
 *
 *  @param offset
 *             the offset.
 *  @param str
 *             a string.
 *  @return a reference to this <code>AppendingStringBuffer</code> object.
 *  @exception StringIndexOutOfBoundsException
 *                 if the offset is invalid.
 *  @see java.lang.StringBuffer#length()
 */
","public AppendingStringBuffer insert(final int offset, StringBuilder str) {
    if ((offset < 0) || (offset > count)) {
        throw new StringIndexOutOfBoundsException();
    }
    if (str == null) {
        str = SB_NULL;
    }
    int len = str.length();
    int newcount = count + len;
    if (newcount > value.length) {
        expandCapacity(newcount);
    }
    System.arraycopy(value, offset, value, offset + len, count - offset);
    str.getChars(0, len, value, offset);
    count = newcount;
    return this;
}",0.13636363636363635,-0.43877551020408156,0.16666666666666666,-0.5,0.3333333333333333,0.961937716262976,-0.150272440493261,-0.16666666666666666,-0.028571428571428574,0.5875424552747333
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7,3,"public void recv_setTableProperty() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {
    setTableProperty_result result = new setTableProperty_result();
    receiveBase(result, ""setTableProperty"");
    if (result.ouch1 != null) {
        throw result.ouch1;
    }
    if (result.ouch2 != null) {
        throw result.ouch2;
    }
    return;
}",,"public void recv_setTableProperty() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {
    setTableProperty_result result = new setTableProperty_result();
    receiveBase(result, ""setTableProperty"");
    if (result.ouch1 != null) {
        throw result.ouch1;
    }
    if (result.ouch2 != null) {
        throw result.ouch2;
    }
    return;
}",-0.13636363636363635,-0.3112244897959183,0.16666666666666666,-0.5,-0.08333333333333333,-0.06426099851705384,0.17866360768568987,-0.4166666666666667,-0.028571428571428574,-0.08859821570063517
flink,remotes/origin/bugs-dot-jar_FLINK-2447_5546a1ef,1,"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoWithTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {
    // check if type is a subclass of tuple
    if (isClassType(t) && Tuple.class.isAssignableFrom(typeToClass(t))) {
        Type curT = t;
        // do not allow usage of Tuple as type
        if (typeToClass(t).equals(Tuple.class)) {
            throw new InvalidTypesException(""Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead."");
        }
        // collect the types while moving up for a later top-down
        while (!(isClassType(curT) && typeToClass(curT).getSuperclass().equals(Tuple.class))) {
            typeHierarchy.add(curT);
            curT = typeToClass(curT).getGenericSuperclass();
        }
        // check if immediate child of Tuple has generics
        if (curT instanceof Class<?>) {
            throw new InvalidTypesException(""Tuple needs to be parameterized by using generics."");
        }
        typeHierarchy.add(curT);
        ParameterizedType tupleChild = (ParameterizedType) curT;
        Type[] subtypes = new Type[tupleChild.getActualTypeArguments().length];
        // materialize possible type variables
        for (int i = 0; i < subtypes.length; i++) {
            // materialize immediate TypeVariables
            if (tupleChild.getActualTypeArguments()[i] instanceof TypeVariable<?>) {
                subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) tupleChild.getActualTypeArguments()[i]);
            } else // class or parameterized type
            {
                subtypes[i] = tupleChild.getActualTypeArguments()[i];
            }
        }
        TypeInformation<?>[] tupleSubTypes = new TypeInformation<?>[subtypes.length];
        for (int i = 0; i < subtypes.length; i++) {
            // try to derive the type info of the TypeVariable from the immediate base child input as a last attempt
            if (subtypes[i] instanceof TypeVariable<?>) {
                tupleSubTypes[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], typeHierarchy, in1Type, in2Type);
                // variable could not be determined
                if (tupleSubTypes[i] == null) {
                    throw new InvalidTypesException(""Type of TypeVariable '"" + ((TypeVariable<?>) subtypes[i]).getName() + ""' in '"" + ((TypeVariable<?>) subtypes[i]).getGenericDeclaration() + ""' could not be determined. This is most likely a type erasure problem. "" + ""The type extraction currently supports types with generic variables only in cases where "" + ""all variables in the return type can be deduced from the input type(s)."");
                }
            } else {
                tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new ArrayList<Type>(typeHierarchy), subtypes[i], in1Type, in2Type);
            }
        }
        Class<?> tAsClass = null;
        if (isClassType(t)) {
            tAsClass = typeToClass(t);
        }
        Preconditions.checkNotNull(tAsClass, ""t has a unexpected type"");
        // check if the class we assumed to be a Tuple so far is actually a pojo because it contains additional fields.
        // check for additional fields.
        int fieldCount = countFieldsInClass(tAsClass);
        if (fieldCount != tupleSubTypes.length) {
            // the class is not a real tuple because it contains additional fields. treat as a pojo
            if (t instanceof ParameterizedType) {
                return (TypeInformation<OUT>) analyzePojo(tAsClass, new ArrayList<Type>(typeHierarchy), (ParameterizedType) t, in1Type, in2Type);
            } else {
                return (TypeInformation<OUT>) analyzePojo(tAsClass, new ArrayList<Type>(typeHierarchy), null, in1Type, in2Type);
            }
        }
        return new TupleTypeInfo(tAsClass, tupleSubTypes);
    } else // e.g. class MyMapper<E> extends MapFunction<String, E>
    if (t instanceof TypeVariable) {
        Type typeVar = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) t);
        if (!(typeVar instanceof TypeVariable)) {
            return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);
        } else // try to derive the type info of the TypeVariable from the immediate base child input as a last attempt
        {
            TypeInformation<OUT> typeInfo = (TypeInformation<OUT>) createTypeInfoFromInputs((TypeVariable<?>) t, typeHierarchy, in1Type, in2Type);
            if (typeInfo != null) {
                return typeInfo;
            } else {
                throw new InvalidTypesException(""Type of TypeVariable '"" + ((TypeVariable<?>) t).getName() + ""' in '"" + ((TypeVariable<?>) t).getGenericDeclaration() + ""' could not be determined. This is most likely a type erasure problem. "" + ""The type extraction currently supports types with generic variables only in cases where "" + ""all variables in the return type can be deduced from the input type(s)."");
            }
        }
    } else // arrays with generics
    if (t instanceof GenericArrayType) {
        GenericArrayType genericArray = (GenericArrayType) t;
        Type componentType = genericArray.getGenericComponentType();
        // due to a Java 6 bug, it is possible that the JVM classifies e.g. String[] or int[] as GenericArrayType instead of Class
        if (componentType instanceof Class) {
            Class<?> componentClass = (Class<?>) componentType;
            String className;
            // for int[], double[] etc.
            if (componentClass.isPrimitive()) {
                className = encodePrimitiveClass(componentClass);
            } else // for String[], Integer[] etc.
            {
                className = ""L"" + componentClass.getName() + "";"";
            }
            Class<OUT> classArray;
            try {
                classArray = (Class<OUT>) Class.forName(""["" + className);
            } catch (ClassNotFoundException e) {
                throw new InvalidTypesException(""Could not convert GenericArrayType to Class."");
            }
            return getForClass(classArray);
        }
        TypeInformation<?> componentInfo = createTypeInfoWithTypeHierarchy(typeHierarchy, genericArray.getGenericComponentType(), in1Type, in2Type);
        return ObjectArrayTypeInfo.getInfoFor(t, componentInfo);
    } else // objects with generics are treated as Class first
    if (t instanceof ParameterizedType) {
        return (TypeInformation<OUT>) privateGetForClass(typeToClass(t), typeHierarchy, (ParameterizedType) t, in1Type, in2Type);
    } else // no tuple, no TypeVariable, no generic type
    if (t instanceof Class) {
        return privateGetForClass((Class<OUT>) t, typeHierarchy);
    }
    throw new InvalidTypesException(""Type Information could not be created."");
}",,"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoWithTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {
        if (isClassType(t) && Tuple.class.isAssignableFrom(typeToClass(t))) {
        Type curT = t;
                if (typeToClass(t).equals(Tuple.class)) {
            throw new InvalidTypesException(""Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead."");
        }
                while (!(isClassType(curT) && typeToClass(curT).getSuperclass().equals(Tuple.class))) {
            typeHierarchy.add(curT);
            curT = typeToClass(curT).getGenericSuperclass();
        }
                if (curT instanceof Class<?>) {
            throw new InvalidTypesException(""Tuple needs to be parameterized by using generics."");
        }
        typeHierarchy.add(curT);
        ParameterizedType tupleChild = (ParameterizedType) curT;
        Type[] subtypes = new Type[tupleChild.getActualTypeArguments().length];
                for (int i = 0; i < subtypes.length; i++) {
                        if (tupleChild.getActualTypeArguments()[i] instanceof TypeVariable<?>) {
                subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) tupleChild.getActualTypeArguments()[i]);
            } else             {
                subtypes[i] = tupleChild.getActualTypeArguments()[i];
            }
        }
        TypeInformation<?>[] tupleSubTypes = new TypeInformation<?>[subtypes.length];
        for (int i = 0; i < subtypes.length; i++) {
                        if (subtypes[i] instanceof TypeVariable<?>) {
                tupleSubTypes[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], typeHierarchy, in1Type, in2Type);
                                if (tupleSubTypes[i] == null) {
                    throw new InvalidTypesException(""Type of TypeVariable '"" + ((TypeVariable<?>) subtypes[i]).getName() + ""' in '"" + ((TypeVariable<?>) subtypes[i]).getGenericDeclaration() + ""' could not be determined. This is most likely a type erasure problem. "" + ""The type extraction currently supports types with generic variables only in cases where "" + ""all variables in the return type can be deduced from the input type(s)."");
                }
            } else {
                tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new ArrayList<Type>(typeHierarchy), subtypes[i], in1Type, in2Type);
            }
        }
        Class<?> tAsClass = null;
        if (isClassType(t)) {
            tAsClass = typeToClass(t);
        }
        Preconditions.checkNotNull(tAsClass, ""t has a unexpected type"");
                        int fieldCount = countFieldsInClass(tAsClass);
        if (fieldCount != tupleSubTypes.length) {
                        if (t instanceof ParameterizedType) {
                return (TypeInformation<OUT>) analyzePojo(tAsClass, new ArrayList<Type>(typeHierarchy), (ParameterizedType) t, in1Type, in2Type);
            } else {
                return (TypeInformation<OUT>) analyzePojo(tAsClass, new ArrayList<Type>(typeHierarchy), null, in1Type, in2Type);
            }
        }
        return new TupleTypeInfo(tAsClass, tupleSubTypes);
    } else     if (t instanceof TypeVariable) {
        Type typeVar = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) t);
        if (!(typeVar instanceof TypeVariable)) {
            return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);
        } else         {
            TypeInformation<OUT> typeInfo = (TypeInformation<OUT>) createTypeInfoFromInputs((TypeVariable<?>) t, typeHierarchy, in1Type, in2Type);
            if (typeInfo != null) {
                return typeInfo;
            } else {
                throw new InvalidTypesException(""Type of TypeVariable '"" + ((TypeVariable<?>) t).getName() + ""' in '"" + ((TypeVariable<?>) t).getGenericDeclaration() + ""' could not be determined. This is most likely a type erasure problem. "" + ""The type extraction currently supports types with generic variables only in cases where "" + ""all variables in the return type can be deduced from the input type(s)."");
            }
        }
    } else     if (t instanceof GenericArrayType) {
        GenericArrayType genericArray = (GenericArrayType) t;
        Type componentType = genericArray.getGenericComponentType();
                if (componentType instanceof Class) {
            Class<?> componentClass = (Class<?>) componentType;
            String className;
                        if (componentClass.isPrimitive()) {
                className = encodePrimitiveClass(componentClass);
            } else             {
                className = ""L"" + componentClass.getName() + "";"";
            }
            Class<OUT> classArray;
            try {
                classArray = (Class<OUT>) Class.forName(""["" + className);
            } catch (ClassNotFoundException e) {
                throw new InvalidTypesException(""Could not convert GenericArrayType to Class."");
            }
            return getForClass(classArray);
        }
        TypeInformation<?> componentInfo = createTypeInfoWithTypeHierarchy(typeHierarchy, genericArray.getGenericComponentType(), in1Type, in2Type);
        return ObjectArrayTypeInfo.getInfoFor(t, componentInfo);
    } else     if (t instanceof ParameterizedType) {
        return (TypeInformation<OUT>) privateGetForClass(typeToClass(t), typeHierarchy, (ParameterizedType) t, in1Type, in2Type);
    } else     if (t instanceof Class) {
        return privateGetForClass((Class<OUT>) t, typeHierarchy);
    }
    throw new InvalidTypesException(""Type Information could not be created."");
}",3.727272727272727,0.5204081632653061,4.0,1.5,2.75,2.605042016806723,-1.4252939489532555,3.25,-0.028571428571428574,14.03937793653445
maven,remotes/origin/bugs-dot-jar_MNG-2712_06090da4,1,"public void resolve(RepositoryMetadata metadata, List remoteRepositories, ArtifactRepository localRepository) throws RepositoryMetadataResolutionException {
    boolean alreadyResolved = alreadyResolved(metadata);
    if (!alreadyResolved) {
        for (Iterator i = remoteRepositories.iterator(); i.hasNext(); ) {
            ArtifactRepository repository = (ArtifactRepository) i.next();
            ArtifactRepositoryPolicy policy = metadata.isSnapshot() ? repository.getSnapshots() : repository.getReleases();
            if (!policy.isEnabled()) {
                getLogger().debug(""Skipping disabled repository "" + repository.getId());
            } else if (repository.isBlacklisted()) {
                getLogger().debug(""Skipping blacklisted repository "" + repository.getId());
            } else {
                File file = new File(localRepository.getBasedir(), localRepository.pathOfLocalRepositoryMetadata(metadata, repository));
                boolean checkForUpdates = policy.checkOutOfDate(new Date(file.lastModified())) || !file.exists();
                boolean metadataIsEmpty = true;
                if (checkForUpdates) {
                    getLogger().info(metadata.getKey() + "": checking for updates from "" + repository.getId());
                    try {
                        resolveAlways(metadata, repository, file, policy.getChecksumPolicy(), true);
                        metadataIsEmpty = false;
                    } catch (TransferFailedException e) {
                        // TODO: [jc; 08-Nov-2005] revisit this for 2.1
                        // suppressing logging to avoid logging this error twice.
                        metadataIsEmpty = true;
                    }
                }
                // touch file so that this is not checked again until interval has passed
                if (file.exists()) {
                    file.setLastModified(System.currentTimeMillis());
                } else if (!metadataIsEmpty) {
                    // this ensures that files are not continuously checked when they don't exist remotely
                    try {
                        metadata.storeInLocalRepository(localRepository, repository);
                    } catch (RepositoryMetadataStoreException e) {
                        throw new RepositoryMetadataResolutionException(""Unable to store local copy of metadata: "" + e.getMessage(), e);
                    }
                }
            }
        }
        cachedMetadata.add(metadata.getKey());
    }
    try {
        mergeMetadata(metadata, remoteRepositories, localRepository);
    } catch (RepositoryMetadataStoreException e) {
        throw new RepositoryMetadataResolutionException(""Unable to store local copy of metadata: "" + e.getMessage(), e);
    } catch (RepositoryMetadataReadException e) {
        throw new RepositoryMetadataResolutionException(""Unable to read local copy of metadata: "" + e.getMessage(), e);
    }
}",,"public void resolve(RepositoryMetadata metadata, List remoteRepositories, ArtifactRepository localRepository) throws RepositoryMetadataResolutionException {
    boolean alreadyResolved = alreadyResolved(metadata);
    if (!alreadyResolved) {
        for (Iterator i = remoteRepositories.iterator(); i.hasNext(); ) {
            ArtifactRepository repository = (ArtifactRepository) i.next();
            ArtifactRepositoryPolicy policy = metadata.isSnapshot() ? repository.getSnapshots() : repository.getReleases();
            if (!policy.isEnabled()) {
                getLogger().debug(""Skipping disabled repository "" + repository.getId());
            } else if (repository.isBlacklisted()) {
                getLogger().debug(""Skipping blacklisted repository "" + repository.getId());
            } else {
                File file = new File(localRepository.getBasedir(), localRepository.pathOfLocalRepositoryMetadata(metadata, repository));
                boolean checkForUpdates = policy.checkOutOfDate(new Date(file.lastModified())) || !file.exists();
                boolean metadataIsEmpty = true;
                if (checkForUpdates) {
                    getLogger().info(metadata.getKey() + "": checking for updates from "" + repository.getId());
                    try {
                        resolveAlways(metadata, repository, file, policy.getChecksumPolicy(), true);
                        metadataIsEmpty = false;
                    } catch (TransferFailedException e) {
                                                                        metadataIsEmpty = true;
                    }
                }
                                if (file.exists()) {
                    file.setLastModified(System.currentTimeMillis());
                } else if (!metadataIsEmpty) {
                                        try {
                        metadata.storeInLocalRepository(localRepository, repository);
                    } catch (RepositoryMetadataStoreException e) {
                        throw new RepositoryMetadataResolutionException(""Unable to store local copy of metadata: "" + e.getMessage(), e);
                    }
                }
            }
        }
        cachedMetadata.add(metadata.getKey());
    }
    try {
        mergeMetadata(metadata, remoteRepositories, localRepository);
    } catch (RepositoryMetadataStoreException e) {
        throw new RepositoryMetadataResolutionException(""Unable to store local copy of metadata: "" + e.getMessage(), e);
    } catch (RepositoryMetadataReadException e) {
        throw new RepositoryMetadataResolutionException(""Unable to read local copy of metadata: "" + e.getMessage(), e);
    }
}",1.3636363636363635,2.0204081632653064,2.0,2.5,0.9166666666666666,0.46366782006920415,-0.8462862059076574,2.5,-0.028571428571428574,1.432215041052591
Closure,82,2,"public final boolean isEmptyType() {
    return isNoType() || isNoObjectType() || isNoResolvedType();
}",,"public final boolean isEmptyType() {
    return isNoType() || isNoObjectType() || isNoResolvedType();
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.1015199311729282,-0.25,2.5714285714285716,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-43_668f08f2,1,"public void moveNode(String srcPath, String destPath) throws NotFoundException, Exception {
    if (PathUtils.isAncestor(srcPath, destPath)) {
        throw new Exception(""target path cannot be descendant of source path: "" + destPath);
    }
    String srcParentPath = PathUtils.getParentPath(srcPath);
    String srcNodeName = PathUtils.getName(srcPath);
    String destParentPath = PathUtils.getParentPath(destPath);
    String destNodeName = PathUtils.getName(destPath);
    MutableNode srcParent = getOrCreateStagedNode(srcParentPath);
    if (srcParentPath.equals(destParentPath)) {
        if (srcParent.getChildNodeEntry(destNodeName) != null) {
            throw new Exception(""node already exists at move destination path: "" + destPath);
        }
        if (srcParent.rename(srcNodeName, destNodeName) == null) {
            throw new NotFoundException(srcPath);
        }
    } else {
        ChildNode srcCNE = srcParent.remove(srcNodeName);
        if (srcCNE == null) {
            throw new NotFoundException(srcPath);
        }
        MutableNode destParent = getOrCreateStagedNode(destParentPath);
        if (destParent.getChildNodeEntry(destNodeName) != null) {
            throw new Exception(""node already exists at move destination path: "" + destPath);
        }
        destParent.add(new ChildNode(destNodeName, srcCNE.getId()));
    }
    // update staging area
    moveStagedNodes(srcPath, destPath);
    // update change log
    changeLog.add(new MoveNode(srcPath, destPath));
}",,"public void moveNode(String srcPath, String destPath) throws NotFoundException, Exception {
    if (PathUtils.isAncestor(srcPath, destPath)) {
        throw new Exception(""target path cannot be descendant of source path: "" + destPath);
    }
    String srcParentPath = PathUtils.getParentPath(srcPath);
    String srcNodeName = PathUtils.getName(srcPath);
    String destParentPath = PathUtils.getParentPath(destPath);
    String destNodeName = PathUtils.getName(destPath);
    MutableNode srcParent = getOrCreateStagedNode(srcParentPath);
    if (srcParentPath.equals(destParentPath)) {
        if (srcParent.getChildNodeEntry(destNodeName) != null) {
            throw new Exception(""node already exists at move destination path: "" + destPath);
        }
        if (srcParent.rename(srcNodeName, destNodeName) == null) {
            throw new NotFoundException(srcPath);
        }
    } else {
        ChildNode srcCNE = srcParent.remove(srcNodeName);
        if (srcCNE == null) {
            throw new NotFoundException(srcPath);
        }
        MutableNode destParent = getOrCreateStagedNode(destParentPath);
        if (destParent.getChildNodeEntry(destNodeName) != null) {
            throw new Exception(""node already exists at move destination path: "" + destPath);
        }
        destParent.add(new ChildNode(destNodeName, srcCNE.getId()));
    }
        moveStagedNodes(srcPath, destPath);
        changeLog.add(new MoveNode(srcPath, destPath));
}",0.7272727272727273,0.09183673469387764,1.3333333333333333,0.0,1.0,0.6969846762234307,-0.5706911385144827,0.8333333333333334,-0.028571428571428574,1.1014772079955113
wicket,remotes/origin/bugs-dot-jar_WICKET-5500_825da305,1,"/**
 *  Loads page class with given name.
 *
 *  @param name
 *  @return class
 */
protected Class<? extends IRequestablePage> getPageClass(String name) {
    Args.notEmpty(name, ""name"");
    return WicketObjects.resolveClass(name);
}","/**
 *  Loads page class with given name.
 *
 *  @param name
 *  @return class
 */
","protected Class<? extends IRequestablePage> getPageClass(String name) {
    Args.notEmpty(name, ""name"");
    return WicketObjects.resolveClass(name);
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8150272440493259,-0.3333333333333333,2.685714285714286,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-3077_17654199,0,"/**
 * Gets this class's ZooKeeper reader/writer.
 *
 * @return reader/writer
 */
static IZooReaderWriter getZooReaderWriter() {
    return zoo;
}","/**
 * Gets this class's ZooKeeper reader/writer.
 *
 * @return reader/writer
 */
","static IZooReaderWriter getZooReaderWriter() {
    return zoo;
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.2001720676799543,-0.5,2.8285714285714287,-0.16422749602751402
Compress,12,1,"/**
 * Get the next entry in this tar archive. This will skip
 * over any remaining data in the current entry, if there
 * is one, and place the input stream at the header of the
 * next entry, and read the header and instantiate a new
 * TarEntry from the header bytes and return that entry.
 * If there are no more entries in the archive, null will
 * be returned to indicate that the end of the archive has
 * been reached.
 *
 * @return The next TarEntry in the archive, or null.
 * @throws IOException on error
 */
public TarArchiveEntry getNextTarEntry() throws IOException {
    if (hasHitEOF) {
        return null;
    }
    if (currEntry != null) {
        long numToSkip = entrySize - entryOffset;
        while (numToSkip > 0) {
            long skipped = skip(numToSkip);
            if (skipped <= 0) {
                throw new RuntimeException(""failed to skip current tar entry"");
            }
            numToSkip -= skipped;
        }
        readBuf = null;
    }
    byte[] headerBuf = getRecord();
    if (hasHitEOF) {
        currEntry = null;
        return null;
    }
    currEntry = new TarArchiveEntry(headerBuf);
    entryOffset = 0;
    entrySize = currEntry.getSize();
    if (currEntry.isGNULongNameEntry()) {
        // read in the name
        StringBuffer longName = new StringBuffer();
        byte[] buf = new byte[SMALL_BUFFER_SIZE];
        int length = 0;
        while ((length = read(buf)) >= 0) {
            longName.append(new String(buf, 0, length));
        }
        getNextEntry();
        if (currEntry == null) {
            // Malformed tar file - long entry name not followed by entry
            return null;
        }
        // remove trailing null terminator
        if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {
            longName.deleteCharAt(longName.length() - 1);
        }
        currEntry.setName(longName.toString());
    }
    if (currEntry.isPaxHeader()) {
        // Process Pax headers
        paxHeaders();
    }
    if (currEntry.isGNUSparse()) {
        // Process sparse files
        readGNUSparse();
    }
    // If the size of the next element in the archive has changed
    // due to a new size being reported in the posix header
    // information, we update entrySize here so that it contains
    // the correct value.
    entrySize = currEntry.getSize();
    return currEntry;
}","/**
 * Get the next entry in this tar archive. This will skip
 * over any remaining data in the current entry, if there
 * is one, and place the input stream at the header of the
 * next entry, and read the header and instantiate a new
 * TarEntry from the header bytes and return that entry.
 * If there are no more entries in the archive, null will
 * be returned to indicate that the end of the archive has
 * been reached.
 *
 * @return The next TarEntry in the archive, or null.
 * @throws IOException on error
 */
","public TarArchiveEntry getNextTarEntry() throws IOException {
    if (hasHitEOF) {
        return null;
    }
    if (currEntry != null) {
        long numToSkip = entrySize - entryOffset;
        while (numToSkip > 0) {
            long skipped = skip(numToSkip);
            if (skipped <= 0) {
                throw new RuntimeException(""failed to skip current tar entry"");
            }
            numToSkip -= skipped;
        }
        readBuf = null;
    }
    byte[] headerBuf = getRecord();
    if (hasHitEOF) {
        currEntry = null;
        return null;
    }
    currEntry = new TarArchiveEntry(headerBuf);
    entryOffset = 0;
    entrySize = currEntry.getSize();
    if (currEntry.isGNULongNameEntry()) {
                StringBuffer longName = new StringBuffer();
        byte[] buf = new byte[SMALL_BUFFER_SIZE];
        int length = 0;
        while ((length = read(buf)) >= 0) {
            longName.append(new String(buf, 0, length));
        }
        getNextEntry();
        if (currEntry == null) {
                        return null;
        }
                if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {
            longName.deleteCharAt(longName.length() - 1);
        }
        currEntry.setName(longName.toString());
    }
    if (currEntry.isPaxHeader()) {
                paxHeaders();
    }
    if (currEntry.isGNUSparse()) {
                readGNUSparse();
    }
                    entrySize = currEntry.getSize();
    return currEntry;
}",1.5454545454545454,0.1632653061224489,1.5,0.5,1.3333333333333333,1.4720711814137422,-0.8190421565815891,1.0833333333333333,-0.028571428571428574,2.3765788222596274
Math,13,0,"/**
 * Computes the square-root of the weight matrix.
 *
 * @param m Symmetric, positive-definite (weight) matrix.
 * @return the square-root of the weight matrix.
 */
private RealMatrix squareRoot(RealMatrix m) {
    final EigenDecomposition dec = new EigenDecomposition(m);
    return dec.getSquareRoot();
}","/**
 * Computes the square-root of the weight matrix.
 *
 * @param m Symmetric, positive-definite (weight) matrix.
 * @return the square-root of the weight matrix.
 */
","private RealMatrix squareRoot(RealMatrix m) {
    final EigenDecomposition dec = new EigenDecomposition(m);
    return dec.getSquareRoot();
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8422712933753946,-0.4166666666666667,2.7714285714285714,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-5071_d3d42d42,1,"private boolean matches(final Request request) {
    boolean matches = false;
    Url url = request.getUrl();
    Url baseUrl = request.getClientUrl();
    String namespace = getContext().getNamespace();
    String bookmarkableIdentifier = getContext().getBookmarkableIdentifier();
    String pageIdentifier = getContext().getPageIdentifier();
    if (url.getSegments().size() >= 3 && urlStartsWith(url, namespace, bookmarkableIdentifier)) {
        matches = true;
    } else // baseUrl = 'wicket/bookmarkable/com.example.SomePage[?...]', requestUrl = 'bookmarkable/com.example.SomePage'
    if (baseUrl.getSegments().size() == 3 && urlStartsWith(baseUrl, namespace, bookmarkableIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier)) {
        matches = true;
    } else // baseUrl = 'wicket/page[?...]', requestUrl = 'bookmarkable/com.example.SomePage'
    if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, namespace, pageIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier)) {
        matches = true;
    }
    return matches;
}",,"private boolean matches(final Request request) {
    boolean matches = false;
    Url url = request.getUrl();
    Url baseUrl = request.getClientUrl();
    String namespace = getContext().getNamespace();
    String bookmarkableIdentifier = getContext().getBookmarkableIdentifier();
    String pageIdentifier = getContext().getPageIdentifier();
    if (url.getSegments().size() >= 3 && urlStartsWith(url, namespace, bookmarkableIdentifier)) {
        matches = true;
    } else     if (baseUrl.getSegments().size() == 3 && urlStartsWith(baseUrl, namespace, bookmarkableIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier)) {
        matches = true;
    } else     if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, namespace, pageIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier)) {
        matches = true;
    }
    return matches;
}",0.18181818181818182,-0.4693877551020408,0.0,0.5,1.3333333333333333,0.7899159663865548,-0.25035847433323793,1.4166666666666667,-0.028571428571428574,0.956548926893409
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-447_0343e9c7,1,"/**
 * Formats a {@link org.apache.logging.log4j.core.LogEvent} in conformance with the log4j.dtd.
 *
 * @param event The LogEvent.
 * @return The XML representation of the LogEvent.
 */
@Override
public String toSerializable(final LogEvent event) {
    final StringBuilder buf = new StringBuilder(DEFAULT_SIZE);
    buf.append(this.indent1);
    buf.append('<');
    if (!complete) {
        buf.append(this.namespacePrefix);
    }
    buf.append(""Event logger=\"""");
    String name = event.getLoggerName();
    if (name.isEmpty()) {
        name = ""root"";
    }
    buf.append(Transform.escapeHtmlTags(name));
    buf.append(""\"" timestamp=\"""");
    buf.append(event.getMillis());
    buf.append(""\"" level=\"""");
    buf.append(Transform.escapeHtmlTags(String.valueOf(event.getLevel())));
    buf.append(""\"" thread=\"""");
    buf.append(Transform.escapeHtmlTags(event.getThreadName()));
    buf.append(""\"">"");
    buf.append(this.eol);
    final Message msg = event.getMessage();
    if (msg != null) {
        boolean xmlSupported = false;
        if (msg instanceof MultiformatMessage) {
            final String[] formats = ((MultiformatMessage) msg).getFormats();
            for (final String format : formats) {
                if (format.equalsIgnoreCase(""XML"")) {
                    xmlSupported = true;
                    break;
                }
            }
        }
        buf.append(this.indent2);
        buf.append('<');
        if (!complete) {
            buf.append(this.namespacePrefix);
        }
        buf.append(""Message>"");
        if (xmlSupported) {
            buf.append(((MultiformatMessage) msg).getFormattedMessage(FORMATS));
        } else {
            buf.append(""<![CDATA["");
            // Append the rendered message. Also make sure to escape any
            // existing CDATA sections.
            Transform.appendEscapingCDATA(buf, event.getMessage().getFormattedMessage());
            buf.append(""]]>"");
        }
        buf.append(""</"");
        if (!complete) {
            buf.append(this.namespacePrefix);
        }
        buf.append(""Message>"");
        buf.append(this.eol);
    }
    if (event.getContextStack().getDepth() > 0) {
        buf.append(this.indent2);
        buf.append('<');
        if (!complete) {
            buf.append(this.namespacePrefix);
        }
        buf.append(""NDC><![CDATA["");
        Transform.appendEscapingCDATA(buf, event.getContextStack().toString());
        buf.append(""]]></"");
        if (!complete) {
            buf.append(this.namespacePrefix);
        }
        buf.append(""NDC>"");
        buf.append(this.eol);
    }
    final Throwable throwable = event.getThrown();
    if (throwable != null) {
        final List<String> s = Throwables.toStringList(throwable);
        buf.append(this.indent2);
        buf.append('<');
        if (!complete) {
            buf.append(this.namespacePrefix);
        }
        buf.append(""Throwable><![CDATA["");
        for (final String str : s) {
            Transform.appendEscapingCDATA(buf, str);
            buf.append(this.eol);
        }
        buf.append(""]]></"");
        if (!complete) {
            buf.append(this.namespacePrefix);
        }
        buf.append(""Throwable>"");
        buf.append(this.eol);
    }
    if (locationInfo) {
        final StackTraceElement element = event.getSource();
        buf.append(this.indent2);
        buf.append('<');
        if (!complete) {
            buf.append(this.namespacePrefix);
        }
        buf.append(""LocationInfo class=\"""");
        buf.append(Transform.escapeHtmlTags(element.getClassName()));
        buf.append(""\"" method=\"""");
        buf.append(Transform.escapeHtmlTags(element.getMethodName()));
        buf.append(""\"" file=\"""");
        buf.append(Transform.escapeHtmlTags(element.getFileName()));
        buf.append(""\"" line=\"""");
        buf.append(element.getLineNumber());
        buf.append(""\""/>"");
        buf.append(this.eol);
    }
    if (properties && event.getContextMap().size() > 0) {
        buf.append(this.indent2);
        buf.append('<');
        if (!complete) {
            buf.append(this.namespacePrefix);
        }
        buf.append(""Properties>"");
        buf.append(this.eol);
        for (final Map.Entry<String, String> entry : event.getContextMap().entrySet()) {
            buf.append(this.indent3);
            buf.append('<');
            if (!complete) {
                buf.append(this.namespacePrefix);
            }
            buf.append(""Data name=\"""");
            buf.append(Transform.escapeHtmlTags(entry.getKey()));
            buf.append(""\"" value=\"""");
            buf.append(Transform.escapeHtmlTags(String.valueOf(entry.getValue())));
            buf.append(""\""/>"");
            buf.append(this.eol);
        }
        buf.append(this.indent2);
        buf.append(""</"");
        if (!complete) {
            buf.append(this.namespacePrefix);
        }
        buf.append(""Properties>"");
        buf.append(this.eol);
    }
    buf.append(this.indent1);
    buf.append(""</"");
    if (!complete) {
        buf.append(this.namespacePrefix);
    }
    buf.append(""Event>"");
    buf.append(this.eol);
    return buf.toString();
}","/**
 * Formats a {@link org.apache.logging.log4j.core.LogEvent} in conformance with the log4j.dtd.
 *
 * @param event The LogEvent.
 * @return The XML representation of the LogEvent.
 */
","@Override
public String toSerializable(final LogEvent event) {
    final StringBuilder buf = new StringBuilder(DEFAULT_SIZE);
    buf.append(this.indent1);
    buf.append('<');
    if (!complete) {
        buf.append(this.namespacePrefix);
    }
    buf.append(""Event logger=\"""");
    String name = event.getLoggerName();
    if (name.isEmpty()) {
        name = ""root"";
    }
    buf.append(Transform.escapeHtmlTags(name));
    buf.append(""\"" timestamp=\"""");
    buf.append(event.getMillis());
    buf.append(""\"" level=\"""");
    buf.append(Transform.escapeHtmlTags(String.valueOf(event.getLevel())));
    buf.append(""\"" thread=\"""");
    buf.append(Transform.escapeHtmlTags(event.getThreadName()));
    buf.append(""\"">"");
    buf.append(this.eol);
    final Message msg = event.getMessage();
    if (msg != null) {
        boolean xmlSupported = false;
        if (msg instanceof MultiformatMessage) {
            final String[] formats = ((MultiformatMessage) msg).getFormats();
            for (final String format : formats) {
                if (format.equalsIgnoreCase(""XML"")) {
                    xmlSupported = true;
                    break;
                }
            }
        }
        buf.append(this.indent2);
        buf.append('<');
        if (!complete) {
            buf.append(this.namespacePrefix);
        }
        buf.append(""Message>"");
        if (xmlSupported) {
            buf.append(((MultiformatMessage) msg).getFormattedMessage(FORMATS));
        } else {
            buf.append(""<![CDATA["");
                                    Transform.appendEscapingCDATA(buf, event.getMessage().getFormattedMessage());
            buf.append(""]]>"");
        }
        buf.append(""</"");
        if (!complete) {
            buf.append(this.namespacePrefix);
        }
        buf.append(""Message>"");
        buf.append(this.eol);
    }
    if (event.getContextStack().getDepth() > 0) {
        buf.append(this.indent2);
        buf.append('<');
        if (!complete) {
            buf.append(this.namespacePrefix);
        }
        buf.append(""NDC><![CDATA["");
        Transform.appendEscapingCDATA(buf, event.getContextStack().toString());
        buf.append(""]]></"");
        if (!complete) {
            buf.append(this.namespacePrefix);
        }
        buf.append(""NDC>"");
        buf.append(this.eol);
    }
    final Throwable throwable = event.getThrown();
    if (throwable != null) {
        final List<String> s = Throwables.toStringList(throwable);
        buf.append(this.indent2);
        buf.append('<');
        if (!complete) {
            buf.append(this.namespacePrefix);
        }
        buf.append(""Throwable><![CDATA["");
        for (final String str : s) {
            Transform.appendEscapingCDATA(buf, str);
            buf.append(this.eol);
        }
        buf.append(""]]></"");
        if (!complete) {
            buf.append(this.namespacePrefix);
        }
        buf.append(""Throwable>"");
        buf.append(this.eol);
    }
    if (locationInfo) {
        final StackTraceElement element = event.getSource();
        buf.append(this.indent2);
        buf.append('<');
        if (!complete) {
            buf.append(this.namespacePrefix);
        }
        buf.append(""LocationInfo class=\"""");
        buf.append(Transform.escapeHtmlTags(element.getClassName()));
        buf.append(""\"" method=\"""");
        buf.append(Transform.escapeHtmlTags(element.getMethodName()));
        buf.append(""\"" file=\"""");
        buf.append(Transform.escapeHtmlTags(element.getFileName()));
        buf.append(""\"" line=\"""");
        buf.append(element.getLineNumber());
        buf.append(""\""/>"");
        buf.append(this.eol);
    }
    if (properties && event.getContextMap().size() > 0) {
        buf.append(this.indent2);
        buf.append('<');
        if (!complete) {
            buf.append(this.namespacePrefix);
        }
        buf.append(""Properties>"");
        buf.append(this.eol);
        for (final Map.Entry<String, String> entry : event.getContextMap().entrySet()) {
            buf.append(this.indent3);
            buf.append('<');
            if (!complete) {
                buf.append(this.namespacePrefix);
            }
            buf.append(""Data name=\"""");
            buf.append(Transform.escapeHtmlTags(entry.getKey()));
            buf.append(""\"" value=\"""");
            buf.append(Transform.escapeHtmlTags(String.valueOf(entry.getValue())));
            buf.append(""\""/>"");
            buf.append(this.eol);
        }
        buf.append(this.indent2);
        buf.append(""</"");
        if (!complete) {
            buf.append(this.namespacePrefix);
        }
        buf.append(""Properties>"");
        buf.append(this.eol);
    }
    buf.append(this.indent1);
    buf.append(""</"");
    if (!complete) {
        buf.append(this.namespacePrefix);
    }
    buf.append(""Event>"");
    buf.append(this.eol);
    return buf.toString();
}",5.954545454545454,0.21428571428571425,3.6666666666666665,1.0,2.25,1.179436480474543,-1.6329222827645546,9.5,-0.028571428571428574,8.866700074095966
Closure,57,2,"private static String extractClassNameIfGoog(Node node, Node parent, String functionName) {
    String className = null;
    if (NodeUtil.isExprCall(parent)) {
        Node callee = node.getFirstChild();
        if (callee != null && callee.getType() == Token.GETPROP) {
            String qualifiedName = callee.getQualifiedName();
            if (functionName.equals(qualifiedName)) {
                Node target = callee.getNext();
                if (target != null) {
                    className = target.getString();
                }
            }
        }
    }
    return className;
}",,"private static String extractClassNameIfGoog(Node node, Node parent, String functionName) {
    String className = null;
    if (NodeUtil.isExprCall(parent)) {
        Node callee = node.getFirstChild();
        if (callee != null && callee.getType() == Token.GETPROP) {
            String qualifiedName = callee.getQualifiedName();
            if (functionName.equals(qualifiedName)) {
                Node target = callee.getNext();
                if (target != null) {
                    className = target.getString();
                }
            }
        }
    }
    return className;
}",0.09090909090909091,1.4795918367346939,0.16666666666666666,1.0,0.5833333333333334,0.374691052891745,-0.11098365357040452,0.08333333333333333,0.1142857142857143,0.2277958377769497
Closure,157,2,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }
    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();
    // Handle all binary operators
    if (opstr != null && first != last) {
        Preconditions.checkState(childCount == 2, ""Bad binary operator \""%s\"": expected 2 arguments but got %s"", opstr, childCount);
        int p = NodeUtil.precedence(type);
        addLeftExpr(first, p, context);
        cc.addOp(opstr, true);
        // For right-hand-side of operations, only pass context if it's
        // the IN_FOR_INIT_CLAUSE one.
        Context rhsContext = getContextForNoInOperator(context);
        // we can simply generate a * b * c.
        if (last.getType() == type && NodeUtil.isAssociative(type)) {
            addExpr(last, p, rhsContext);
        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
            // Assignments are the only right-associative binary operators
            addExpr(last, p, rhsContext);
        } else {
            addExpr(last, p + 1, rhsContext);
        }
        return;
    }
    cc.startSourceMapping(n);
    switch(type) {
        case Token.TRY:
            {
                Preconditions.checkState(first.getNext().getType() == Token.BLOCK && !first.getNext().hasMoreThanOneChild());
                Preconditions.checkState(childCount >= 2 && childCount <= 3);
                add(""try"");
                add(first, Context.PRESERVE_BLOCK);
                // second child contains the catch block, or nothing if there
                // isn't a catch block
                Node catchblock = first.getNext().getFirstChild();
                if (catchblock != null) {
                    add(catchblock);
                }
                if (childCount == 3) {
                    add(""finally"");
                    add(last, Context.PRESERVE_BLOCK);
                }
                break;
            }
        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;
        case Token.THROW:
            Preconditions.checkState(childCount == 1);
            add(""throw"");
            add(first);
            // Must have a ';' after a throw statement, otherwise safari can't
            // parse this.
            cc.endStatement(true);
            break;
        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            } else {
                Preconditions.checkState(childCount == 0);
            }
            cc.endStatement();
            break;
        case Token.VAR:
            if (first != null) {
                add(""var "");
                addList(first, false, getContextForNoInOperator(context));
            }
            break;
        case Token.LABEL_NAME:
            Preconditions.checkState(!n.getString().isEmpty());
            addIdentifier(n.getString());
            break;
        case Token.NAME:
            if (first == null || first.getType() == Token.EMPTY) {
                addIdentifier(n.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                addIdentifier(n.getString());
                cc.addOp(""="", true);
                if (first.getType() == Token.COMMA) {
                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));
                } else {
                    // Add expression, consider nearby code at lowest level of
                    // precedence.
                    addExpr(first, 0, getContextForNoInOperator(context));
                }
            }
            break;
        case Token.ARRAYLIT:
            add(""["");
            addArrayList(first);
            add(""]"");
            break;
        case Token.LP:
            add(""("");
            addList(first);
            add("")"");
            break;
        case Token.COMMA:
            Preconditions.checkState(childCount == 2);
            addList(first, false, context);
            break;
        case Token.NUMBER:
            Preconditions.checkState(childCount == ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));
            cc.addNumber(n.getDouble());
            break;
        case Token.TYPEOF:
        case Token.VOID:
        case Token.NOT:
        case Token.BITNOT:
        case Token.POS:
            {
                // All of these unary operators are right-associative
                Preconditions.checkState(childCount == 1);
                cc.addOp(NodeUtil.opToStrNoFail(type), false);
                addExpr(first, NodeUtil.precedence(type));
                break;
            }
        case Token.NEG:
            {
                Preconditions.checkState(childCount == 1);
                // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
                if (n.getFirstChild().getType() == Token.NUMBER) {
                    cc.addNumber(-n.getFirstChild().getDouble());
                } else {
                    cc.addOp(NodeUtil.opToStrNoFail(type), false);
                    addExpr(first, NodeUtil.precedence(type));
                }
                break;
            }
        case Token.HOOK:
            {
                Preconditions.checkState(childCount == 3);
                int p = NodeUtil.precedence(type);
                addLeftExpr(first, p + 1, context);
                cc.addOp(""?"", true);
                addExpr(first.getNext(), 1);
                cc.addOp("":"", true);
                addExpr(last, 1);
                break;
            }
        case Token.REGEXP:
            if (first.getType() != Token.STRING || last.getType() != Token.STRING) {
                throw new Error(""Expected children to be strings"");
            }
            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);
            // I only use one .add because whitespace matters
            if (childCount == 2) {
                add(regexp + last.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                add(regexp);
            }
            break;
        case Token.GET_REF:
            add(first);
            break;
        case Token.REF_SPECIAL:
            Preconditions.checkState(childCount == 1);
            add(first);
            add(""."");
            add((String) n.getProp(Node.NAME_PROP));
            break;
        case Token.FUNCTION:
            if (n.getClass() != Node.class) {
                throw new Error(""Unexpected Node subclass."");
            }
            Preconditions.checkState(childCount == 3);
            boolean funcNeedsParens = (context == Context.START_OF_EXPR);
            if (funcNeedsParens) {
                add(""("");
            }
            add(""function"");
            add(first);
            add(first.getNext());
            add(last, Context.PRESERVE_BLOCK);
            cc.endFunction(context == Context.STATEMENT);
            if (funcNeedsParens) {
                add("")"");
            }
            break;
        case Token.GET:
        case Token.SET:
            Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);
            Preconditions.checkState(childCount == 1);
            Preconditions.checkState(first.getType() == Token.FUNCTION);
            // Get methods are unnamed
            Preconditions.checkState(first.getFirstChild().getString().isEmpty());
            if (type == Token.GET) {
                // Get methods have no parameters.
                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
                add(""get "");
            } else {
                // Set methods have one parameter.
                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
                add(""set "");
            }
            // The name is on the GET or SET node.
            String name = n.getString();
            Node fn = first;
            Node parameters = fn.getChildAtIndex(1);
            Node body = fn.getLastChild();
            // Add the property name.
            if (TokenStream.isJSIdentifier(name) && // unicode escaped.
            NodeUtil.isLatin(name)) {
                add(name);
            } else {
                // Determine if the string is a simple number.
                add(jsString(n.getString(), outputCharsetEncoder));
            }
            add(parameters);
            add(body, Context.PRESERVE_BLOCK);
            break;
        case Token.SCRIPT:
        case Token.BLOCK:
            {
                if (n.getClass() != Node.class) {
                    throw new Error(""Unexpected Node subclass."");
                }
                boolean preserveBlock = context == Context.PRESERVE_BLOCK;
                if (preserveBlock) {
                    cc.beginBlock();
                }
                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().getType() == Token.SCRIPT);
                for (Node c = first; c != null; c = c.getNext()) {
                    add(c, Context.STATEMENT);
                    // VAR doesn't include ';' since it gets used in expressions
                    if (c.getType() == Token.VAR) {
                        cc.endStatement();
                    }
                    if (c.getType() == Token.FUNCTION) {
                        cc.maybeLineBreak();
                    }
                    // because top level statements are more homogeneous.
                    if (preferLineBreaks) {
                        cc.notePreferredLineBreak();
                    }
                }
                if (preserveBlock) {
                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
                }
                break;
            }
        case Token.FOR:
            if (childCount == 4) {
                add(""for("");
                if (first.getType() == Token.VAR) {
                    add(first, Context.IN_FOR_INIT_CLAUSE);
                } else {
                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
                }
                add("";"");
                add(first.getNext());
                add("";"");
                add(first.getNext().getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                Preconditions.checkState(childCount == 3);
                add(""for("");
                add(first);
                add(""in"");
                add(first.getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            }
            break;
        case Token.DO:
            Preconditions.checkState(childCount == 2);
            add(""do"");
            addNonEmptyStatement(first, Context.OTHER, false);
            add(""while("");
            add(last);
            add("")"");
            cc.endStatement();
            break;
        case Token.WHILE:
            Preconditions.checkState(childCount == 2);
            add(""while("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.EMPTY:
            Preconditions.checkState(childCount == 0);
            break;
        case Token.GETPROP:
            {
                Preconditions.checkState(childCount == 2, ""Bad GETPROP: expected 2 children, but got %s"", childCount);
                Preconditions.checkState(last.getType() == Token.STRING, ""Bad GETPROP: RHS should be STRING"");
                boolean needsParens = (first.getType() == Token.NUMBER);
                if (needsParens) {
                    add(""("");
                }
                addLeftExpr(first, NodeUtil.precedence(type), context);
                if (needsParens) {
                    add("")"");
                }
                add(""."");
                addIdentifier(last.getString());
                break;
            }
        case Token.GETELEM:
            Preconditions.checkState(childCount == 2, ""Bad GETELEM: expected 2 children but got %s"", childCount);
            addLeftExpr(first, NodeUtil.precedence(type), context);
            add(""["");
            add(first.getNext());
            add(""]"");
            break;
        case Token.WITH:
            Preconditions.checkState(childCount == 2);
            add(""with("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.INC:
        case Token.DEC:
            {
                Preconditions.checkState(childCount == 1);
                String o = type == Token.INC ? ""++"" : ""--"";
                int postProp = n.getIntProp(Node.INCRDECR_PROP);
                // is a pre-inc/dec.
                if (postProp != 0) {
                    addLeftExpr(first, NodeUtil.precedence(type), context);
                    cc.addOp(o, false);
                } else {
                    cc.addOp(o, false);
                    add(first);
                }
                break;
            }
        case Token.CALL:
            // that must be preserved.
            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
                add(""(0,"");
                addExpr(first, NodeUtil.precedence(Token.COMMA));
                add("")"");
            } else {
                addLeftExpr(first, NodeUtil.precedence(type), context);
            }
            add(""("");
            addList(first.getNext());
            add("")"");
            break;
        case Token.IF:
            boolean hasElse = childCount == 3;
            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;
            if (ambiguousElseClause) {
                cc.beginBlock();
            }
            add(""if("");
            add(first);
            add("")"");
            if (hasElse) {
                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
                add(""else"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                addNonEmptyStatement(first.getNext(), Context.OTHER, false);
                Preconditions.checkState(childCount == 2);
            }
            if (ambiguousElseClause) {
                cc.endBlock();
            }
            break;
        case Token.NULL:
        case Token.THIS:
        case Token.FALSE:
        case Token.TRUE:
            Preconditions.checkState(childCount == 0);
            add(Node.tokenToName(type));
            break;
        case Token.CONTINUE:
            Preconditions.checkState(childCount <= 1);
            add(""continue"");
            if (childCount == 1) {
                if (first.getType() != Token.LABEL_NAME) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.DEBUGGER:
            Preconditions.checkState(childCount == 0);
            add(""debugger"");
            cc.endStatement();
            break;
        case Token.BREAK:
            Preconditions.checkState(childCount <= 1);
            add(""break"");
            if (childCount == 1) {
                if (first.getType() != Token.LABEL_NAME) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.EXPR_VOID:
            throw new Error(""Unexpected EXPR_VOID. Should be EXPR_RESULT."");
        case Token.EXPR_RESULT:
            Preconditions.checkState(childCount == 1);
            add(first, Context.START_OF_EXPR);
            cc.endStatement();
            break;
        case Token.NEW:
            add(""new "");
            int precedence = NodeUtil.precedence(type);
            // first viable parentheses (don't traverse into functions).
            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {
                precedence = NodeUtil.precedence(first.getType()) + 1;
            }
            addExpr(first, precedence);
            // '()' is optional when no arguments are present
            Node next = first.getNext();
            if (next != null) {
                add(""("");
                addList(next);
                add("")"");
            }
            break;
        case Token.STRING:
            if (childCount != ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {
                throw new IllegalStateException(""Unexpected String children: "" + n.getParent().toStringTree());
            }
            add(jsString(n.getString(), outputCharsetEncoder));
            break;
        case Token.DELPROP:
            Preconditions.checkState(childCount == 1);
            add(""delete "");
            add(first);
            break;
        case Token.OBJECTLIT:
            {
                boolean needsParens = (context == Context.START_OF_EXPR);
                if (needsParens) {
                    add(""("");
                }
                add(""{"");
                for (Node c = first; c != null; c = c.getNext()) {
                    if (c != first) {
                        cc.listSeparator();
                    }
                    if (c.getType() == Token.GET || c.getType() == Token.SET) {
                        add(c);
                    } else {
                        // are not JavaScript keywords
                        if (c.getType() == Token.STRING && !c.isQuotedString() && !TokenStream.isKeyword(c.getString()) && TokenStream.isJSIdentifier(c.getString()) && // were unicode escaped.
                        NodeUtil.isLatin(c.getString())) {
                            add(c.getString());
                        } else {
                            // Determine if the string is a simple number.
                            addExpr(c, 1);
                        }
                        add("":"");
                        addExpr(c.getFirstChild(), 1);
                    }
                }
                add(""}"");
                if (needsParens) {
                    add("")"");
                }
                break;
            }
        case Token.SWITCH:
            add(""switch("");
            add(first);
            add("")"");
            cc.beginBlock();
            addAllSiblings(first.getNext());
            cc.endBlock(context == Context.STATEMENT);
            break;
        case Token.CASE:
            Preconditions.checkState(childCount == 2);
            add(""case "");
            add(first);
            addCaseBody(last);
            break;
        case Token.DEFAULT:
            Preconditions.checkState(childCount == 1);
            add(""default"");
            addCaseBody(first);
            break;
        case Token.LABEL:
            Preconditions.checkState(childCount == 2);
            if (first.getType() != Token.LABEL_NAME) {
                throw new Error(""Unexpected token type. Should be LABEL_NAME."");
            }
            add(first);
            add("":"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);
            break;
        // ignored for our purposes.
        case Token.SETNAME:
            break;
        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }
    cc.endSourceMapping(n);
}",,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
        return;
    }
    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();
        if (opstr != null && first != last) {
        Preconditions.checkState(childCount == 2, ""Bad binary operator \""%s\"": expected 2 arguments but got %s"", opstr, childCount);
        int p = NodeUtil.precedence(type);
        addLeftExpr(first, p, context);
        cc.addOp(opstr, true);
                        Context rhsContext = getContextForNoInOperator(context);
                if (last.getType() == type && NodeUtil.isAssociative(type)) {
            addExpr(last, p, rhsContext);
        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
                        addExpr(last, p, rhsContext);
        } else {
            addExpr(last, p + 1, rhsContext);
        }
        return;
    }
    cc.startSourceMapping(n);
    switch(type) {
        case Token.TRY:
            {
                Preconditions.checkState(first.getNext().getType() == Token.BLOCK && !first.getNext().hasMoreThanOneChild());
                Preconditions.checkState(childCount >= 2 && childCount <= 3);
                add(""try"");
                add(first, Context.PRESERVE_BLOCK);
                                                Node catchblock = first.getNext().getFirstChild();
                if (catchblock != null) {
                    add(catchblock);
                }
                if (childCount == 3) {
                    add(""finally"");
                    add(last, Context.PRESERVE_BLOCK);
                }
                break;
            }
        case Token.CATCH:
            Preconditions.checkState(childCount == 2);
            add(""catch("");
            add(first);
            add("")"");
            add(last, Context.PRESERVE_BLOCK);
            break;
        case Token.THROW:
            Preconditions.checkState(childCount == 1);
            add(""throw"");
            add(first);
                                    cc.endStatement(true);
            break;
        case Token.RETURN:
            add(""return"");
            if (childCount == 1) {
                add(first);
            } else {
                Preconditions.checkState(childCount == 0);
            }
            cc.endStatement();
            break;
        case Token.VAR:
            if (first != null) {
                add(""var "");
                addList(first, false, getContextForNoInOperator(context));
            }
            break;
        case Token.LABEL_NAME:
            Preconditions.checkState(!n.getString().isEmpty());
            addIdentifier(n.getString());
            break;
        case Token.NAME:
            if (first == null || first.getType() == Token.EMPTY) {
                addIdentifier(n.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                addIdentifier(n.getString());
                cc.addOp(""="", true);
                if (first.getType() == Token.COMMA) {
                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));
                } else {
                                                            addExpr(first, 0, getContextForNoInOperator(context));
                }
            }
            break;
        case Token.ARRAYLIT:
            add(""["");
            addArrayList(first);
            add(""]"");
            break;
        case Token.LP:
            add(""("");
            addList(first);
            add("")"");
            break;
        case Token.COMMA:
            Preconditions.checkState(childCount == 2);
            addList(first, false, context);
            break;
        case Token.NUMBER:
            Preconditions.checkState(childCount == ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));
            cc.addNumber(n.getDouble());
            break;
        case Token.TYPEOF:
        case Token.VOID:
        case Token.NOT:
        case Token.BITNOT:
        case Token.POS:
            {
                                Preconditions.checkState(childCount == 1);
                cc.addOp(NodeUtil.opToStrNoFail(type), false);
                addExpr(first, NodeUtil.precedence(type));
                break;
            }
        case Token.NEG:
            {
                Preconditions.checkState(childCount == 1);
                                if (n.getFirstChild().getType() == Token.NUMBER) {
                    cc.addNumber(-n.getFirstChild().getDouble());
                } else {
                    cc.addOp(NodeUtil.opToStrNoFail(type), false);
                    addExpr(first, NodeUtil.precedence(type));
                }
                break;
            }
        case Token.HOOK:
            {
                Preconditions.checkState(childCount == 3);
                int p = NodeUtil.precedence(type);
                addLeftExpr(first, p + 1, context);
                cc.addOp(""?"", true);
                addExpr(first.getNext(), 1);
                cc.addOp("":"", true);
                addExpr(last, 1);
                break;
            }
        case Token.REGEXP:
            if (first.getType() != Token.STRING || last.getType() != Token.STRING) {
                throw new Error(""Expected children to be strings"");
            }
            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);
                        if (childCount == 2) {
                add(regexp + last.getString());
            } else {
                Preconditions.checkState(childCount == 1);
                add(regexp);
            }
            break;
        case Token.GET_REF:
            add(first);
            break;
        case Token.REF_SPECIAL:
            Preconditions.checkState(childCount == 1);
            add(first);
            add(""."");
            add((String) n.getProp(Node.NAME_PROP));
            break;
        case Token.FUNCTION:
            if (n.getClass() != Node.class) {
                throw new Error(""Unexpected Node subclass."");
            }
            Preconditions.checkState(childCount == 3);
            boolean funcNeedsParens = (context == Context.START_OF_EXPR);
            if (funcNeedsParens) {
                add(""("");
            }
            add(""function"");
            add(first);
            add(first.getNext());
            add(last, Context.PRESERVE_BLOCK);
            cc.endFunction(context == Context.STATEMENT);
            if (funcNeedsParens) {
                add("")"");
            }
            break;
        case Token.GET:
        case Token.SET:
            Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);
            Preconditions.checkState(childCount == 1);
            Preconditions.checkState(first.getType() == Token.FUNCTION);
                        Preconditions.checkState(first.getFirstChild().getString().isEmpty());
            if (type == Token.GET) {
                                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
                add(""get "");
            } else {
                                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
                add(""set "");
            }
                        String name = n.getString();
            Node fn = first;
            Node parameters = fn.getChildAtIndex(1);
            Node body = fn.getLastChild();
                        if (TokenStream.isJSIdentifier(name) &&             NodeUtil.isLatin(name)) {
                add(name);
            } else {
                                add(jsString(n.getString(), outputCharsetEncoder));
            }
            add(parameters);
            add(body, Context.PRESERVE_BLOCK);
            break;
        case Token.SCRIPT:
        case Token.BLOCK:
            {
                if (n.getClass() != Node.class) {
                    throw new Error(""Unexpected Node subclass."");
                }
                boolean preserveBlock = context == Context.PRESERVE_BLOCK;
                if (preserveBlock) {
                    cc.beginBlock();
                }
                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().getType() == Token.SCRIPT);
                for (Node c = first; c != null; c = c.getNext()) {
                    add(c, Context.STATEMENT);
                                        if (c.getType() == Token.VAR) {
                        cc.endStatement();
                    }
                    if (c.getType() == Token.FUNCTION) {
                        cc.maybeLineBreak();
                    }
                                        if (preferLineBreaks) {
                        cc.notePreferredLineBreak();
                    }
                }
                if (preserveBlock) {
                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
                }
                break;
            }
        case Token.FOR:
            if (childCount == 4) {
                add(""for("");
                if (first.getType() == Token.VAR) {
                    add(first, Context.IN_FOR_INIT_CLAUSE);
                } else {
                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
                }
                add("";"");
                add(first.getNext());
                add("";"");
                add(first.getNext().getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                Preconditions.checkState(childCount == 3);
                add(""for("");
                add(first);
                add(""in"");
                add(first.getNext());
                add("")"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            }
            break;
        case Token.DO:
            Preconditions.checkState(childCount == 2);
            add(""do"");
            addNonEmptyStatement(first, Context.OTHER, false);
            add(""while("");
            add(last);
            add("")"");
            cc.endStatement();
            break;
        case Token.WHILE:
            Preconditions.checkState(childCount == 2);
            add(""while("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.EMPTY:
            Preconditions.checkState(childCount == 0);
            break;
        case Token.GETPROP:
            {
                Preconditions.checkState(childCount == 2, ""Bad GETPROP: expected 2 children, but got %s"", childCount);
                Preconditions.checkState(last.getType() == Token.STRING, ""Bad GETPROP: RHS should be STRING"");
                boolean needsParens = (first.getType() == Token.NUMBER);
                if (needsParens) {
                    add(""("");
                }
                addLeftExpr(first, NodeUtil.precedence(type), context);
                if (needsParens) {
                    add("")"");
                }
                add(""."");
                addIdentifier(last.getString());
                break;
            }
        case Token.GETELEM:
            Preconditions.checkState(childCount == 2, ""Bad GETELEM: expected 2 children but got %s"", childCount);
            addLeftExpr(first, NodeUtil.precedence(type), context);
            add(""["");
            add(first.getNext());
            add(""]"");
            break;
        case Token.WITH:
            Preconditions.checkState(childCount == 2);
            add(""with("");
            add(first);
            add("")"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            break;
        case Token.INC:
        case Token.DEC:
            {
                Preconditions.checkState(childCount == 1);
                String o = type == Token.INC ? ""++"" : ""--"";
                int postProp = n.getIntProp(Node.INCRDECR_PROP);
                                if (postProp != 0) {
                    addLeftExpr(first, NodeUtil.precedence(type), context);
                    cc.addOp(o, false);
                } else {
                    cc.addOp(o, false);
                    add(first);
                }
                break;
            }
        case Token.CALL:
                        if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
                add(""(0,"");
                addExpr(first, NodeUtil.precedence(Token.COMMA));
                add("")"");
            } else {
                addLeftExpr(first, NodeUtil.precedence(type), context);
            }
            add(""("");
            addList(first.getNext());
            add("")"");
            break;
        case Token.IF:
            boolean hasElse = childCount == 3;
            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;
            if (ambiguousElseClause) {
                cc.beginBlock();
            }
            add(""if("");
            add(first);
            add("")"");
            if (hasElse) {
                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
                add(""else"");
                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);
            } else {
                addNonEmptyStatement(first.getNext(), Context.OTHER, false);
                Preconditions.checkState(childCount == 2);
            }
            if (ambiguousElseClause) {
                cc.endBlock();
            }
            break;
        case Token.NULL:
        case Token.THIS:
        case Token.FALSE:
        case Token.TRUE:
            Preconditions.checkState(childCount == 0);
            add(Node.tokenToName(type));
            break;
        case Token.CONTINUE:
            Preconditions.checkState(childCount <= 1);
            add(""continue"");
            if (childCount == 1) {
                if (first.getType() != Token.LABEL_NAME) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.DEBUGGER:
            Preconditions.checkState(childCount == 0);
            add(""debugger"");
            cc.endStatement();
            break;
        case Token.BREAK:
            Preconditions.checkState(childCount <= 1);
            add(""break"");
            if (childCount == 1) {
                if (first.getType() != Token.LABEL_NAME) {
                    throw new Error(""Unexpected token type. Should be LABEL_NAME."");
                }
                add("" "");
                add(first);
            }
            cc.endStatement();
            break;
        case Token.EXPR_VOID:
            throw new Error(""Unexpected EXPR_VOID. Should be EXPR_RESULT."");
        case Token.EXPR_RESULT:
            Preconditions.checkState(childCount == 1);
            add(first, Context.START_OF_EXPR);
            cc.endStatement();
            break;
        case Token.NEW:
            add(""new "");
            int precedence = NodeUtil.precedence(type);
                        if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {
                precedence = NodeUtil.precedence(first.getType()) + 1;
            }
            addExpr(first, precedence);
                        Node next = first.getNext();
            if (next != null) {
                add(""("");
                addList(next);
                add("")"");
            }
            break;
        case Token.STRING:
            if (childCount != ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {
                throw new IllegalStateException(""Unexpected String children: "" + n.getParent().toStringTree());
            }
            add(jsString(n.getString(), outputCharsetEncoder));
            break;
        case Token.DELPROP:
            Preconditions.checkState(childCount == 1);
            add(""delete "");
            add(first);
            break;
        case Token.OBJECTLIT:
            {
                boolean needsParens = (context == Context.START_OF_EXPR);
                if (needsParens) {
                    add(""("");
                }
                add(""{"");
                for (Node c = first; c != null; c = c.getNext()) {
                    if (c != first) {
                        cc.listSeparator();
                    }
                    if (c.getType() == Token.GET || c.getType() == Token.SET) {
                        add(c);
                    } else {
                                                if (c.getType() == Token.STRING && !c.isQuotedString() && !TokenStream.isKeyword(c.getString()) && TokenStream.isJSIdentifier(c.getString()) &&                         NodeUtil.isLatin(c.getString())) {
                            add(c.getString());
                        } else {
                                                        addExpr(c, 1);
                        }
                        add("":"");
                        addExpr(c.getFirstChild(), 1);
                    }
                }
                add(""}"");
                if (needsParens) {
                    add("")"");
                }
                break;
            }
        case Token.SWITCH:
            add(""switch("");
            add(first);
            add("")"");
            cc.beginBlock();
            addAllSiblings(first.getNext());
            cc.endBlock(context == Context.STATEMENT);
            break;
        case Token.CASE:
            Preconditions.checkState(childCount == 2);
            add(""case "");
            add(first);
            addCaseBody(last);
            break;
        case Token.DEFAULT:
            Preconditions.checkState(childCount == 1);
            add(""default"");
            addCaseBody(first);
            break;
        case Token.LABEL:
            Preconditions.checkState(childCount == 2);
            if (first.getType() != Token.LABEL_NAME) {
                throw new Error(""Unexpected token type. Should be LABEL_NAME."");
            }
            add(first);
            add("":"");
            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);
            break;
                case Token.SETNAME:
            break;
        default:
            throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }
    cc.endSourceMapping(n);
}",21.454545454545453,0.5255102040816325,26.166666666666668,1.5,13.0,4.928324270884826,-3.2887869228563247,28.666666666666668,-0.028571428571428574,120.09251716413756
wicket,remotes/origin/bugs-dot-jar_WICKET-5082_217fbb3b,1,"@Override
public void renderHead(final Component component, final IHeaderResponse response) {
    super.renderHead(component, response);
    if (component.isEnabledInHierarchy()) {
        CharSequence js = getCallbackScript(component);
        AjaxRequestTarget target = component.getRequestCycle().find(AjaxRequestTarget.class);
        if (target == null) {
            response.render(OnDomReadyHeaderItem.forScript(js.toString()));
        } else {
            target.appendJavaScript(js);
        }
    }
}",,"@Override
public void renderHead(final Component component, final IHeaderResponse response) {
    super.renderHead(component, response);
    if (component.isEnabledInHierarchy()) {
        CharSequence js = getCallbackScript(component);
        AjaxRequestTarget target = component.getRequestCycle().find(AjaxRequestTarget.class);
        if (target == null) {
            response.render(OnDomReadyHeaderItem.forScript(js.toString()));
        } else {
            target.appendJavaScript(js);
        }
    }
}",-0.045454545454545456,0.5204081632653061,-0.16666666666666666,0.0,-0.08333333333333333,-0.07019278299555112,0.05649555491826783,0.25,0.0,-0.05462542990650202
Closure,168,2,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (t.inGlobalScope()) {
        return;
    }
    if (n.isReturn() && n.getFirstChild() != null) {
        data.get(t.getScopeRoot()).recordNonEmptyReturn();
    }
    if (t.getScopeDepth() <= 2) {
        // no reason to do this extra computation for them.
        return;
    }
    if (n.isName() && NodeUtil.isLValue(n) && // in the inner scope, not the scope where the name appears.
    !NodeUtil.isBleedingFunctionName(n)) {
        String name = n.getString();
        Scope scope = t.getScope();
        Var var = scope.getVar(name);
        if (var != null) {
            Scope ownerScope = var.getScope();
            if (ownerScope.isLocal()) {
                data.get(ownerScope.getRootNode()).recordAssignedName(name);
            }
            if (scope != ownerScope && ownerScope.isLocal()) {
                data.get(ownerScope.getRootNode()).recordEscapedVarName(name);
            }
        }
    } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) {
        String name = NodeUtil.getRootOfQualifiedName(n).getString();
        Scope scope = t.getScope();
        Var var = scope.getVar(name);
        if (var != null) {
            Scope ownerScope = var.getScope();
            if (scope != ownerScope && ownerScope.isLocal()) {
                data.get(ownerScope.getRootNode()).recordEscapedQualifiedName(n.getQualifiedName());
            }
        }
    }
}",,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (t.inGlobalScope()) {
        return;
    }
    if (n.isReturn() && n.getFirstChild() != null) {
        data.get(t.getScopeRoot()).recordNonEmptyReturn();
    }
    if (t.getScopeDepth() <= 2) {
                return;
    }
    if (n.isName() && NodeUtil.isLValue(n) &&     !NodeUtil.isBleedingFunctionName(n)) {
        String name = n.getString();
        Scope scope = t.getScope();
        Var var = scope.getVar(name);
        if (var != null) {
            Scope ownerScope = var.getScope();
            if (ownerScope.isLocal()) {
                data.get(ownerScope.getRootNode()).recordAssignedName(name);
            }
            if (scope != ownerScope && ownerScope.isLocal()) {
                data.get(ownerScope.getRootNode()).recordEscapedVarName(name);
            }
        }
    } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) {
        String name = NodeUtil.getRootOfQualifiedName(n).getString();
        Scope scope = t.getScope();
        Var var = scope.getVar(name);
        if (var != null) {
            Scope ownerScope = var.getScope();
            if (scope != ownerScope && ownerScope.isLocal()) {
                data.get(ownerScope.getRootNode()).recordEscapedQualifiedName(n.getQualifiedName());
            }
        }
    }
}",1.0454545454545454,0.6326530612244897,1.1666666666666667,1.0,2.1666666666666665,0.6613939693524469,-0.70117579581302,2.4166666666666665,-0.028571428571428574,1.4310928940684682
wicket,remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4,1,"/**
 *  Traverses all child components of the given class in this container,
 *  calling the visitor's visit method at each one.
 *
 *  @param clazz
 *             The class of child to visit, or null to visit all children
 *  @param visitor
 *             The visitor to call back to
 *  @return The return value from a visitor which halted the traversal, or
 *          null if the entire traversal occurred
 */
public final Object visitChildren(final Class clazz, final IVisitor visitor) {
    if (visitor == null) {
        throw new IllegalArgumentException(""argument visitor may not be null"");
    }
    // Iterate through children of this container
    for (int i = 0; i < children_size(); i++) {
        // Get next child component
        final Component child = children_get(i);
        Object value = null;
        // Is the child of the correct class (or was no class specified)?
        if (clazz == null || clazz.isInstance(child)) {
            // Call visitor
            value = visitor.component(child);
            // If visitor returns a non-null value, it halts the traversal
            if ((value != IVisitor.CONTINUE_TRAVERSAL) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {
                return value;
            }
        }
        // If child is a container
        if ((child instanceof MarkupContainer) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {
            // visit the children in the container
            value = ((MarkupContainer<?>) child).visitChildren(clazz, visitor);
            // If visitor returns a non-null value, it halts the traversal
            if ((value != IVisitor.CONTINUE_TRAVERSAL) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {
                return value;
            }
        }
    }
    return null;
}","/**
 *  Traverses all child components of the given class in this container,
 *  calling the visitor's visit method at each one.
 *
 *  @param clazz
 *             The class of child to visit, or null to visit all children
 *  @param visitor
 *             The visitor to call back to
 *  @return The return value from a visitor which halted the traversal, or
 *          null if the entire traversal occurred
 */
","public final Object visitChildren(final Class clazz, final IVisitor visitor) {
    if (visitor == null) {
        throw new IllegalArgumentException(""argument visitor may not be null"");
    }
        for (int i = 0; i < children_size(); i++) {
                final Component child = children_get(i);
        Object value = null;
                if (clazz == null || clazz.isInstance(child)) {
                        value = visitor.component(child);
                        if ((value != IVisitor.CONTINUE_TRAVERSAL) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {
                return value;
            }
        }
                if ((child instanceof MarkupContainer) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {
                        value = ((MarkupContainer<?>) child).visitChildren(clazz, visitor);
                        if ((value != IVisitor.CONTINUE_TRAVERSAL) && (value != IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER)) {
                return value;
            }
        }
    }
    return null;
}",0.36363636363636365,0.7193877551020407,0.6666666666666666,0.5,1.0,1.1833910034602078,-0.3429882420418701,-0.08333333333333333,-0.028571428571428574,1.0864481478150256
wicket,remotes/origin/bugs-dot-jar_WICKET-2506_0f8a2990,1,"private void applyEnclosureVisibilityToChildren(final MarkupContainer container, final MarkupStream markupStream, ComponentTag enclosureOpenTag) {
    DirectChildTagIterator it = new DirectChildTagIterator(markupStream, enclosureOpenTag);
    while (it.hasNext()) {
        final ComponentTag tag = it.next();
        final Component child = container.get(tag.getId());
        // record original visiblity allowed value, will restore later
        changes.put(child, child.isVisibilityAllowed());
        child.setVisibilityAllowed(isVisible());
    }
    it.rewind();
}",,"private void applyEnclosureVisibilityToChildren(final MarkupContainer container, final MarkupStream markupStream, ComponentTag enclosureOpenTag) {
    DirectChildTagIterator it = new DirectChildTagIterator(markupStream, enclosureOpenTag);
    while (it.hasNext()) {
        final ComponentTag tag = it.next();
        final Component child = container.get(tag.getId());
                changes.put(child, child.isVisibilityAllowed());
        child.setVisibilityAllowed(isVisible());
    }
    it.rewind();
}",-0.18181818181818182,-0.015306122448979493,-0.3333333333333333,-0.5,-0.25,-0.3806228373702422,0.17464869515342715,0.25,0.028571428571428574,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-320_c06cc933,1,"/**
 * Solve the linear equation A &times; X = B in least square sense.
 * <p>The m&times;n matrix A may not be square, the solution X is
 * such that ||A &times; X - B|| is minimal.</p>
 * @param b right-hand side of the equation A &times; X = B
 * @return a matrix X that minimizes the two norm of A &times; X - B
 * @exception IllegalArgumentException if matrices dimensions don't match
 * @exception InvalidMatrixException if decomposed matrix is singular
 */
public RealMatrix solve(final RealMatrix b) throws IllegalArgumentException, InvalidMatrixException {
    if (b.getRowDimension() != singularValues.length) {
        throw MathRuntimeException.createIllegalArgumentException(""dimensions mismatch: got {0}x{1} but expected {2}x{3}"", b.getRowDimension(), b.getColumnDimension(), singularValues.length, ""n"");
    }
    final RealMatrix w = uT.multiply(b);
    for (int i = 0; i < singularValues.length; ++i) {
        final double si = singularValues[i];
        if (si == 0) {
            throw new SingularMatrixException();
        }
        final double inv = 1.0 / si;
        for (int j = 0; j < b.getColumnDimension(); ++j) {
            w.multiplyEntry(i, j, inv);
        }
    }
    return v.multiply(w);
}","/**
 * Solve the linear equation A &times; X = B in least square sense.
 * <p>The m&times;n matrix A may not be square, the solution X is
 * such that ||A &times; X - B|| is minimal.</p>
 * @param b right-hand side of the equation A &times; X = B
 * @return a matrix X that minimizes the two norm of A &times; X - B
 * @exception IllegalArgumentException if matrices dimensions don't match
 * @exception InvalidMatrixException if decomposed matrix is singular
 */
","public RealMatrix solve(final RealMatrix b) throws IllegalArgumentException, InvalidMatrixException {
    if (b.getRowDimension() != singularValues.length) {
        throw MathRuntimeException.createIllegalArgumentException(""dimensions mismatch: got {0}x{1} but expected {2}x{3}"", b.getRowDimension(), b.getColumnDimension(), singularValues.length, ""n"");
    }
    final RealMatrix w = uT.multiply(b);
    for (int i = 0; i < singularValues.length; ++i) {
        final double si = singularValues[i];
        if (si == 0) {
            throw new SingularMatrixException();
        }
        final double inv = 1.0 / si;
        for (int j = 0; j < b.getColumnDimension(); ++j) {
            w.multiplyEntry(i, j, inv);
        }
    }
    return v.multiply(w);
}",0.13636363636363635,0.1887755102040817,0.5,0.0,0.4166666666666667,0.8749382105783491,-0.20217952394608543,0.16666666666666666,0.0,0.7463219705243681
flink,remotes/origin/bugs-dot-jar_FLINK-2460_a17d4e82,1,"@Override
public boolean isReleased() {
    return isReleased.get();
}",,"@Override
public boolean isReleased() {
    return isReleased.get();
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.0332664181244626,-0.4166666666666667,1.7714285714285716,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-428_4a6a573b,3,"/**
 *  @see java.util.Map#values()
 */
public Collection values() {
    return new AbstractList() {

        public Object get(final int index) {
            int keyIndex = nextKey(0);
            for (int i = 0; i < index; i++) {
                keyIndex = nextKey(keyIndex + 1);
            }
            return values[keyIndex];
        }

        public int size() {
            return size;
        }
    };
}","/**
 *  @see java.util.Map#values()
 */
","public Collection values() {
    return new AbstractList() {

        public Object get(final int index) {
            int keyIndex = nextKey(0);
            for (int i = 0; i < index; i++) {
                keyIndex = nextKey(keyIndex + 1);
            }
            return values[keyIndex];
        }

        public int size() {
            return size;
        }
    };
}",0.0,0.8316326530612247,-0.3333333333333333,0.0,-0.16666666666666666,0.31932773109243706,0.07599655864640069,-0.3333333333333333,2.428571428571429,0.015418813522299459
Closure,98,1,"/**
 * @return Whether the variable is only assigned a value once for its
 *     lifetime.
 */
boolean isAssignedOnceInLifetime() {
    Reference ref = getOneAndOnlyAssignment();
    if (ref == null) {
        return false;
    }
    return true;
}","/**
 * @return Whether the variable is only assigned a value once for its
 *     lifetime.
 */
","boolean isAssignedOnceInLifetime() {
    Reference ref = getOneAndOnlyAssignment();
    if (ref == null) {
        return false;
    }
    return true;
}",-0.3181818181818182,-0.2346938775510204,-0.3333333333333333,-0.5,-0.25,-0.15916955017301035,0.5732721537137941,-0.4166666666666667,2.7142857142857144,-0.14662006758579926
commons-math,remotes/origin/bugs-dot-jar_MATH-1115_2a6c6409,1,"/**
 * Build a parallellepipedic box boundary.
 * @param xMin low bound along the x direction
 * @param xMax high bound along the x direction
 * @param yMin low bound along the y direction
 * @param yMax high bound along the y direction
 * @param zMin low bound along the z direction
 * @param zMax high bound along the z direction
 * @param tolerance tolerance below which points are considered identical
 * @return boundary tree
 * @since 3.3
 */
private static BSPTree<Euclidean3D> buildBoundary(final double xMin, final double xMax, final double yMin, final double yMax, final double zMin, final double zMax, final double tolerance) {
    final Plane pxMin = new Plane(new Vector3D(xMin, 0, 0), Vector3D.MINUS_I, tolerance);
    final Plane pxMax = new Plane(new Vector3D(xMax, 0, 0), Vector3D.PLUS_I, tolerance);
    final Plane pyMin = new Plane(new Vector3D(0, yMin, 0), Vector3D.MINUS_J, tolerance);
    final Plane pyMax = new Plane(new Vector3D(0, yMax, 0), Vector3D.PLUS_J, tolerance);
    final Plane pzMin = new Plane(new Vector3D(0, 0, zMin), Vector3D.MINUS_K, tolerance);
    final Plane pzMax = new Plane(new Vector3D(0, 0, zMax), Vector3D.PLUS_K, tolerance);
    @SuppressWarnings(""unchecked"")
    final Region<Euclidean3D> boundary = new RegionFactory<Euclidean3D>().buildConvex(pxMin, pxMax, pyMin, pyMax, pzMin, pzMax);
    return boundary.getTree(false);
}","/**
 * Build a parallellepipedic box boundary.
 * @param xMin low bound along the x direction
 * @param xMax high bound along the x direction
 * @param yMin low bound along the y direction
 * @param yMax high bound along the y direction
 * @param zMin low bound along the z direction
 * @param zMax high bound along the z direction
 * @param tolerance tolerance below which points are considered identical
 * @return boundary tree
 * @since 3.3
 */
","private static BSPTree<Euclidean3D> buildBoundary(final double xMin, final double xMax, final double yMin, final double yMax, final double zMin, final double zMax, final double tolerance) {
    final Plane pxMin = new Plane(new Vector3D(xMin, 0, 0), Vector3D.MINUS_I, tolerance);
    final Plane pxMax = new Plane(new Vector3D(xMax, 0, 0), Vector3D.PLUS_I, tolerance);
    final Plane pyMin = new Plane(new Vector3D(0, yMin, 0), Vector3D.MINUS_J, tolerance);
    final Plane pyMax = new Plane(new Vector3D(0, yMax, 0), Vector3D.PLUS_J, tolerance);
    final Plane pzMin = new Plane(new Vector3D(0, 0, zMin), Vector3D.MINUS_K, tolerance);
    final Plane pzMax = new Plane(new Vector3D(0, 0, zMax), Vector3D.PLUS_K, tolerance);
    @SuppressWarnings(""unchecked"")
    final Region<Euclidean3D> boundary = new RegionFactory<Euclidean3D>().buildConvex(pxMin, pxMax, pyMin, pyMax, pzMin, pzMax);
    return boundary.getTree(false);
}",-0.13636363636363635,-0.7551020408163265,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,-0.016346429595641167,-0.3333333333333333,-0.028571428571428574,-0.16422749602751402
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1061_86d8944f,1,"@Override
public boolean remove(final Marker marker) {
    return this.marker.remove(MarkerManager.getMarker(marker.getName()));
}",,"@Override
public boolean remove(final Marker marker) {
    return this.marker.remove(MarkerManager.getMarker(marker.getName()));
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.855176369371953,-0.25,0.2285714285714286,-0.16422749602751402
Lang,65,1,"// -----------------------------------------------------------------------
/**
 * <p>Internal calculation method.</p>
 *
 * @param val  the calendar
 * @param field  the field constant
 * @param round  true to round, false to truncate
 * @throws ArithmeticException if the year is over 280 million
 */
private static void modify(Calendar val, int field, boolean round) {
    if (val.get(Calendar.YEAR) > 280000000) {
        throw new ArithmeticException(""Calendar value too large for accurate calculations"");
    }
    // ----------------- Fix for LANG-59 ---------------------- START ---------------
    // see http://issues.apache.org/jira/browse/LANG-59
    // 
    // Manually truncate milliseconds, seconds and minutes, rather than using
    // Calendar methods.
    // truncate milliseconds
    // truncate seconds
    // truncate minutes
    // reset time
    // ----------------- Fix for LANG-59 ----------------------- END ----------------
    boolean roundUp = false;
    for (int i = 0; i < fields.length; i++) {
        for (int j = 0; j < fields[i].length; j++) {
            if (fields[i][j] == field) {
                // This is our field... we stop looping
                if (round && roundUp) {
                    if (field == DateUtils.SEMI_MONTH) {
                        // we subtract 15 days and add 1 month
                        if (val.get(Calendar.DATE) == 1) {
                            val.add(Calendar.DATE, 15);
                        } else {
                            val.add(Calendar.DATE, -15);
                            val.add(Calendar.MONTH, 1);
                        }
                    } else {
                        // We need at add one to this field since the
                        // last number causes us to round up
                        val.add(fields[i][0], 1);
                    }
                }
                return;
            }
        }
        // We have various fields that are not easy roundings
        int offset = 0;
        boolean offsetSet = false;
        // These are special types of fields that require different rounding rules
        switch(field) {
            case DateUtils.SEMI_MONTH:
                if (fields[i][0] == Calendar.DATE) {
                    // If we're going to drop the DATE field's value,
                    // we want to do this our own way.
                    // We need to subtrace 1 since the date has a minimum of 1
                    offset = val.get(Calendar.DATE) - 1;
                    // bottom half of the month and should stay accordingly.
                    if (offset >= 15) {
                        offset -= 15;
                    }
                    // Record whether we're in the top or bottom half of that range
                    roundUp = offset > 7;
                    offsetSet = true;
                }
                break;
            case Calendar.AM_PM:
                if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                    // If we're going to drop the HOUR field's value,
                    // we want to do this our own way.
                    offset = val.get(Calendar.HOUR_OF_DAY);
                    if (offset >= 12) {
                        offset -= 12;
                    }
                    roundUp = offset > 6;
                    offsetSet = true;
                }
                break;
        }
        if (!offsetSet) {
            int min = val.getActualMinimum(fields[i][0]);
            int max = val.getActualMaximum(fields[i][0]);
            // Calculate the offset from the minimum allowed value
            offset = val.get(fields[i][0]) - min;
            // Set roundUp if this is more than half way between the minimum and maximum
            roundUp = offset > ((max - min) / 2);
        }
        // We need to remove this field
        val.set(fields[i][0], val.get(fields[i][0]) - offset);
    }
    throw new IllegalArgumentException(""The field "" + field + "" is not supported"");
}","/**
 * <p>Internal calculation method.</p>
 *
 * @param val  the calendar
 * @param field  the field constant
 * @param round  true to round, false to truncate
 * @throws ArithmeticException if the year is over 280 million
 */
","private static void modify(Calendar val, int field, boolean round) {
    if (val.get(Calendar.YEAR) > 280000000) {
        throw new ArithmeticException(""Calendar value too large for accurate calculations"");
    }
                                            boolean roundUp = false;
    for (int i = 0; i < fields.length; i++) {
        for (int j = 0; j < fields[i].length; j++) {
            if (fields[i][j] == field) {
                                if (round && roundUp) {
                    if (field == DateUtils.SEMI_MONTH) {
                                                if (val.get(Calendar.DATE) == 1) {
                            val.add(Calendar.DATE, 15);
                        } else {
                            val.add(Calendar.DATE, -15);
                            val.add(Calendar.MONTH, 1);
                        }
                    } else {
                                                                        val.add(fields[i][0], 1);
                    }
                }
                return;
            }
        }
                int offset = 0;
        boolean offsetSet = false;
                switch(field) {
            case DateUtils.SEMI_MONTH:
                if (fields[i][0] == Calendar.DATE) {
                                                                                offset = val.get(Calendar.DATE) - 1;
                                        if (offset >= 15) {
                        offset -= 15;
                    }
                                        roundUp = offset > 7;
                    offsetSet = true;
                }
                break;
            case Calendar.AM_PM:
                if (fields[i][0] == Calendar.HOUR_OF_DAY) {
                                                            offset = val.get(Calendar.HOUR_OF_DAY);
                    if (offset >= 12) {
                        offset -= 12;
                    }
                    roundUp = offset > 6;
                    offsetSet = true;
                }
                break;
        }
        if (!offsetSet) {
            int min = val.getActualMinimum(fields[i][0]);
            int max = val.getActualMaximum(fields[i][0]);
                        offset = val.get(fields[i][0]) - min;
                        roundUp = offset > ((max - min) / 2);
        }
                val.set(fields[i][0], val.get(fields[i][0]) - offset);
    }
    throw new IllegalArgumentException(""The field "" + field + "" is not supported"");
}",1.9545454545454546,2.1938775510204085,2.5,2.0,1.75,3.8843302026693034,-1.0215084599942648,0.5833333333333334,-0.028571428571428574,10.044354786899149
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1069_e9b628ec,3,"@Override
protected int[] getEventIndices(final String text, final int beginIndex) {
    // Scan the text for the end of the next JSON object.
    final int start = text.indexOf(EVENT_START_MARKER, beginIndex);
    if (start == END) {
        return END_PAIR;
    }
    final char[] charArray = text.toCharArray();
    int stack = 0;
    boolean inStr = false;
    boolean inEsc = false;
    for (int i = start; i < charArray.length; i++) {
        final char c = charArray[i];
        if (!inEsc) {
            inEsc = false;
            switch(c) {
                case EVENT_START_MARKER:
                    if (!inStr) {
                        stack++;
                    }
                    break;
                case EVENT_END_MARKER:
                    if (!inStr) {
                        stack--;
                    }
                    break;
                case JSON_STR_DELIM:
                    inStr = !inStr;
                    break;
                case JSON_ESC:
                    inEsc = true;
                    break;
            }
            if (stack == 0) {
                return new int[] { start, i };
            }
        }
    }
    return END_PAIR;
}",,"@Override
protected int[] getEventIndices(final String text, final int beginIndex) {
        final int start = text.indexOf(EVENT_START_MARKER, beginIndex);
    if (start == END) {
        return END_PAIR;
    }
    final char[] charArray = text.toCharArray();
    int stack = 0;
    boolean inStr = false;
    boolean inEsc = false;
    for (int i = start; i < charArray.length; i++) {
        final char c = charArray[i];
        if (!inEsc) {
            inEsc = false;
            switch(c) {
                case EVENT_START_MARKER:
                    if (!inStr) {
                        stack++;
                    }
                    break;
                case EVENT_END_MARKER:
                    if (!inStr) {
                        stack--;
                    }
                    break;
                case JSON_STR_DELIM:
                    inStr = !inStr;
                    break;
                case JSON_ESC:
                    inEsc = true;
                    break;
            }
            if (stack == 0) {
                return new int[] { start, i };
            }
        }
    }
    return END_PAIR;
}",1.1363636363636365,2.2397959183673475,1.8333333333333333,1.5,1.0,0.8769154720711817,-0.6521365070260974,-0.3333333333333333,0.20000000000000004,0.8209190469460043
commons-math,remotes/origin/bugs-dot-jar_MATH-865_b55e0206,1,"/**
 * Checks dimensions and values of boundaries and inputSigma if defined.
 */
private void checkParameters() {
    final double[] init = getStartPoint();
    final double[] lB = getLowerBound();
    final double[] uB = getUpperBound();
    // Checks whether there is at least one finite bound value.
    boolean hasFiniteBounds = false;
    for (int i = 0; i < lB.length; i++) {
        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {
            hasFiniteBounds = true;
            break;
        }
    }
    // Checks whether there is at least one infinite bound value.
    boolean hasInfiniteBounds = false;
    if (hasFiniteBounds) {
        for (int i = 0; i < lB.length; i++) {
            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {
                hasInfiniteBounds = true;
                break;
            }
        }
        if (hasInfiniteBounds) {
            // because mixed cases are not supported by the current code.
            throw new MathUnsupportedOperationException();
        } else {
            // Convert API to internal handling of boundaries.
            boundaries = new double[2][];
            boundaries[0] = lB;
            boundaries[1] = uB;
        }
    } else {
        // Convert API to internal handling of boundaries.
        boundaries = null;
    }
    if (inputSigma != null) {
        if (inputSigma.length != init.length) {
            throw new DimensionMismatchException(inputSigma.length, init.length);
        }
        for (int i = 0; i < init.length; i++) {
            if (inputSigma[i] < 0) {
                throw new NotPositiveException(inputSigma[i]);
            }
            if (boundaries != null) {
                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {
                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);
                }
            }
        }
    }
}","/**
 * Checks dimensions and values of boundaries and inputSigma if defined.
 */
","private void checkParameters() {
    final double[] init = getStartPoint();
    final double[] lB = getLowerBound();
    final double[] uB = getUpperBound();
        boolean hasFiniteBounds = false;
    for (int i = 0; i < lB.length; i++) {
        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {
            hasFiniteBounds = true;
            break;
        }
    }
        boolean hasInfiniteBounds = false;
    if (hasFiniteBounds) {
        for (int i = 0; i < lB.length; i++) {
            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {
                hasInfiniteBounds = true;
                break;
            }
        }
        if (hasInfiniteBounds) {
                        throw new MathUnsupportedOperationException();
        } else {
                        boundaries = new double[2][];
            boundaries[0] = lB;
            boundaries[1] = uB;
        }
    } else {
                boundaries = null;
    }
    if (inputSigma != null) {
        if (inputSigma.length != init.length) {
            throw new DimensionMismatchException(inputSigma.length, init.length);
        }
        for (int i = 0; i < init.length; i++) {
            if (inputSigma[i] < 0) {
                throw new NotPositiveException(inputSigma[i]);
            }
            if (boundaries != null) {
                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {
                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);
                }
            }
        }
    }
}",1.4090909090909092,0.8112244897959185,2.5,1.0,1.5833333333333333,2.6604053386060316,-0.8362489245770004,0.08333333333333333,-0.028571428571428574,4.227217632269864
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2430_be3a9114,1,"@Override
public boolean childNodeAdded(String name, NodeState after) {
    if (!loader.isRunning()) {
        return false;
    }
    NodeBuilder child = EmptyNodeState.EMPTY_NODE.builder();
    boolean success = EmptyNodeState.compareAgainstEmptyState(after, new StandbyApplyDiff(child, store, loader, path + name + ""/""));
    if (success) {
        builder.setChildNode(name, child.getNodeState());
    }
    return success;
}",,"@Override
public boolean childNodeAdded(String name, NodeState after) {
    if (!loader.isRunning()) {
        return false;
    }
    NodeBuilder child = EmptyNodeState.EMPTY_NODE.builder();
    boolean success = EmptyNodeState.compareAgainstEmptyState(after, new StandbyApplyDiff(child, store, loader, path + name + ""/""));
    if (success) {
        builder.setChildNode(name, child.getNodeState());
    }
    return success;
}",-0.09090909090909091,-0.2346938775510204,-0.16666666666666666,-0.5,-0.08333333333333333,-0.09787444389520514,0.08373960424433617,-0.08333333333333333,0.028571428571428574,-0.05735370329919779
commons-math,remotes/origin/bugs-dot-jar_MATH-367_3a15d8ce,3,"/**
 * {@inheritDoc}
 */
public boolean hasNext() {
    return current != null;
}","/**
 * {@inheritDoc}
 */
","public boolean hasNext() {
    return current != null;
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.144536851161457,-0.5,2.8285714285714287,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-9673_7944093f,3,"public void done(boolean doneSync) {
    if (e == null) {
        exchange.removeProperty(Exchange.FAILURE_ENDPOINT);
    } else {
        // set exception back on exchange
        exchange.setException(e);
        exchange.setProperty(Exchange.EXCEPTION_CAUGHT, e);
    }
    if (!doneSync) {
        // signal callback to continue routing async
        ExchangeHelper.prepareOutToIn(exchange);
        LOG.trace(""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
    }
    callback.done(doneSync);
}",,"public void done(boolean doneSync) {
    if (e == null) {
        exchange.removeProperty(Exchange.FAILURE_ENDPOINT);
    } else {
                exchange.setException(e);
        exchange.setProperty(Exchange.EXCEPTION_CAUGHT, e);
    }
    if (!doneSync) {
                ExchangeHelper.prepareOutToIn(exchange);
        LOG.trace(""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
    }
    callback.done(doneSync);
}",-0.045454545454545456,-0.1173469387755102,-0.16666666666666666,-0.5,-0.08333333333333333,-0.0682155215027187,0.07829079437912259,0.08333333333333333,-0.028571428571428574,-0.06917479366629405
flink,remotes/origin/bugs-dot-jar_FLINK-1985_495a5c3c,0,"public JobGraph createJobGraph(String jobName) {
    jobGraph = new JobGraph(jobName);
    // make sure that all vertices start immediately
    jobGraph.setScheduleMode(ScheduleMode.ALL);
    init();
    setChaining();
    setPhysicalEdges();
    setSlotSharing();
    configureCheckpointing();
    return jobGraph;
}",,"public JobGraph createJobGraph(String jobName) {
    jobGraph = new JobGraph(jobName);
        jobGraph.setScheduleMode(ScheduleMode.ALL);
    init();
    setChaining();
    setPhysicalEdges();
    setSlotSharing();
    configureCheckpointing();
    return jobGraph;
}",-0.18181818181818182,-0.7244897959183674,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.3085747060510466,0.0,2.0285714285714285,-0.16422749602751402
Math,77,1,"/**
 * {@inheritDoc}
 */
@Override
public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}","/**
 * {@inheritDoc}
 */
","@Override
public double getLInfNorm() {
    double max = 0;
    for (double a : data) {
        max += Math.max(max, Math.abs(a));
    }
    return max;
}",-0.2727272727272727,-0.1887755102040817,-0.3333333333333333,-0.5,-0.4166666666666667,-0.05042016806722688,0.44049326068253525,-0.3333333333333333,2.3714285714285714,-0.12224549320929755
Math,44,1,"/**
 * Accept a step, triggering events and step handlers.
 * @param interpolator step interpolator
 * @param y state vector at step end time, must be reset if an event
 * asks for resetting or if an events stops integration during the step
 * @param yDot placeholder array where to put the time derivative of the state vector
 * @param tEnd final integration time
 * @return time at end of step
 * @exception MathIllegalStateException if the value of one event state cannot be evaluated
 * @since 2.2
 */
protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MathIllegalStateException {
    double previousT = interpolator.getGlobalPreviousTime();
    final double currentT = interpolator.getGlobalCurrentTime();
    resetOccurred = false;
    // initialize the events states if needed
    if (!statesInitialized) {
        for (EventState state : eventsStates) {
            state.reinitializeBegin(interpolator);
        }
        statesInitialized = true;
    }
    // search for next events that may occur during the step
    final int orderingSign = interpolator.isForward() ? +1 : -1;
    SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {

        /**
         * {@inheritDoc}
         */
        public int compare(EventState es0, EventState es1) {
            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
        }
    });
    for (final EventState state : eventsStates) {
        if (state.evaluateStep(interpolator)) {
            // the event occurs during the current step
            occuringEvents.add(state);
        }
    }
    while (!occuringEvents.isEmpty()) {
        // handle the chronologically first event
        final Iterator<EventState> iterator = occuringEvents.iterator();
        final EventState currentEvent = iterator.next();
        iterator.remove();
        // restrict the interpolator to the first part of the step, up to the event
        final double eventT = currentEvent.getEventTime();
        interpolator.setSoftPreviousTime(previousT);
        interpolator.setSoftCurrentTime(eventT);
        // trigger the event
        interpolator.setInterpolatedTime(eventT);
        final double[] eventY = interpolator.getInterpolatedState();
        currentEvent.stepAccepted(eventT, eventY);
        isLastStep = currentEvent.stop();
        // handle the first part of the step, up to the event
        for (final StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, isLastStep);
        }
        if (isLastStep) {
            // the event asked to stop integration
            System.arraycopy(eventY, 0, y, 0, y.length);
            return eventT;
        }
        if (currentEvent.reset(eventT, eventY)) {
            // some event handler has triggered changes that
            // invalidate the derivatives, we need to recompute them
            System.arraycopy(eventY, 0, y, 0, y.length);
            computeDerivatives(eventT, y, yDot);
            resetOccurred = true;
            return eventT;
        }
        // prepare handling of the remaining part of the step
        previousT = eventT;
        interpolator.setSoftPreviousTime(eventT);
        interpolator.setSoftCurrentTime(currentT);
        // check if the same event occurs again in the remaining part of the step
        if (currentEvent.evaluateStep(interpolator)) {
            // the event occurs during the current step
            occuringEvents.add(currentEvent);
        }
    }
    interpolator.setInterpolatedTime(currentT);
    final double[] currentY = interpolator.getInterpolatedState();
    for (final EventState state : eventsStates) {
        state.stepAccepted(currentT, currentY);
        isLastStep = isLastStep || state.stop();
    }
    isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);
    // handle the remaining part of the step, after all events if any
    for (StepHandler handler : stepHandlers) {
        handler.handleStep(interpolator, isLastStep);
    }
    return currentT;
}","/**
 * Accept a step, triggering events and step handlers.
 * @param interpolator step interpolator
 * @param y state vector at step end time, must be reset if an event
 * asks for resetting or if an events stops integration during the step
 * @param yDot placeholder array where to put the time derivative of the state vector
 * @param tEnd final integration time
 * @return time at end of step
 * @exception MathIllegalStateException if the value of one event state cannot be evaluated
 * @since 2.2
 */
/**
 * {@inheritDoc}
 */
","protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MathIllegalStateException {
    double previousT = interpolator.getGlobalPreviousTime();
    final double currentT = interpolator.getGlobalCurrentTime();
    resetOccurred = false;
        if (!statesInitialized) {
        for (EventState state : eventsStates) {
            state.reinitializeBegin(interpolator);
        }
        statesInitialized = true;
    }
        final int orderingSign = interpolator.isForward() ? +1 : -1;
    SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {

        /**
         * {@inheritDoc}
         */
        public int compare(EventState es0, EventState es1) {
            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());
        }
    });
    for (final EventState state : eventsStates) {
        if (state.evaluateStep(interpolator)) {
                        occuringEvents.add(state);
        }
    }
    while (!occuringEvents.isEmpty()) {
                final Iterator<EventState> iterator = occuringEvents.iterator();
        final EventState currentEvent = iterator.next();
        iterator.remove();
                final double eventT = currentEvent.getEventTime();
        interpolator.setSoftPreviousTime(previousT);
        interpolator.setSoftCurrentTime(eventT);
                interpolator.setInterpolatedTime(eventT);
        final double[] eventY = interpolator.getInterpolatedState();
        currentEvent.stepAccepted(eventT, eventY);
        isLastStep = currentEvent.stop();
                for (final StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, isLastStep);
        }
        if (isLastStep) {
                        System.arraycopy(eventY, 0, y, 0, y.length);
            return eventT;
        }
        if (currentEvent.reset(eventT, eventY)) {
                                    System.arraycopy(eventY, 0, y, 0, y.length);
            computeDerivatives(eventT, y, yDot);
            resetOccurred = true;
            return eventT;
        }
                previousT = eventT;
        interpolator.setSoftPreviousTime(eventT);
        interpolator.setSoftCurrentTime(currentT);
                if (currentEvent.evaluateStep(interpolator)) {
                        occuringEvents.add(currentEvent);
        }
    }
    interpolator.setInterpolatedTime(currentT);
    final double[] currentY = interpolator.getInterpolatedState();
    for (final EventState state : eventsStates) {
        state.stepAccepted(currentT, currentY);
        isLastStep = isLastStep || state.stop();
    }
    isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);
        for (StepHandler handler : stepHandlers) {
        handler.handleStep(interpolator, isLastStep);
    }
    return currentT;
}",2.409090909090909,-0.03061224489795921,1.5,0.0,1.0,1.2941176470588238,-1.0699741898480073,2.4166666666666665,-0.028571428571428574,4.207143193664581
commons-math,remotes/origin/bugs-dot-jar_MATH-939_49444ee6,1,"/**
 * Throws MathIllegalArgumentException if the matrix does not have at least
 * two columns and two rows.
 * @param matrix matrix to check
 * @throws MathIllegalArgumentException if the matrix does not contain sufficient data
 * to compute covariance
 */
private void checkSufficientData(final RealMatrix matrix) throws MathIllegalArgumentException {
    int nRows = matrix.getRowDimension();
    int nCols = matrix.getColumnDimension();
    if (nRows < 2 || nCols < 2) {
        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS, nRows, nCols);
    }
}","/**
 * Throws MathIllegalArgumentException if the matrix does not have at least
 * two columns and two rows.
 * @param matrix matrix to check
 * @throws MathIllegalArgumentException if the matrix does not contain sufficient data
 * to compute covariance
 */
","private void checkSufficientData(final RealMatrix matrix) throws MathIllegalArgumentException {
    int nRows = matrix.getRowDimension();
    int nCols = matrix.getColumnDimension();
    if (nRows < 2 || nCols < 2) {
        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS, nRows, nCols);
    }
}",-0.3181818181818182,-0.2346938775510204,-0.16666666666666666,-0.5,-0.08333333333333333,-0.05042016806722688,0.42013191855463133,-0.3333333333333333,1.8571428571428574,-0.09450447788042711
wicket,remotes/origin/bugs-dot-jar_WICKET-428_d906576c,3,"/**
 *  @see java.util.Map#values()
 */
public Collection values() {
    return new AbstractList() {

        public Object get(final int index) {
            return value;
        }

        public int size() {
            return MicroMap.this.size();
        }
    };
}","/**
 *  @see java.util.Map#values()
 */
","public Collection values() {
    return new AbstractList() {

        public Object get(final int index) {
            return value;
        }

        public int size() {
            return MicroMap.this.size();
        }
    };
}",-0.18181818181818182,0.5408163265306123,-0.5,-0.5,-0.4166666666666667,-0.3806228373702422,0.4143963292228278,-0.4166666666666667,2.742857142857143,-0.16422749602751402
Cli,37,1,"/**
 * Tells if the token looks like a short option.
 *
 * @param token
 */
private boolean isShortOption(String token) {
    // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)
    return token.startsWith(""-"") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));
// remove leading ""-"" and ""=value""
}","/**
 * Tells if the token looks like a short option.
 *
 * @param token
 */
","private boolean isShortOption(String token) {
        return token.startsWith(""-"") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.11764705882352938,0.8718095784341845,-0.16666666666666666,2.4571428571428573,-0.12291792479902006
Math,17,1,"/**
 * Multiply this by a single digit x.
 * @param x multiplicand
 * @return product of this and x
 */
public Dfp multiply(final int x) {
    return multiplyFast(x);
}","/**
 * Multiply this by a single digit x.
 * @param x multiplicand
 * @return product of this and x
 */
","public Dfp multiply(final int x) {
    return multiplyFast(x);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.1172928018353891,-0.4166666666666667,2.8285714285714287,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-366_db4a291f,1,"private synchronized void retry(ZooRunnable op) {
    int sleepTime = 100;
    while (true) {
        ZooKeeper zooKeeper = getZooKeeper();
        try {
            op.run(zooKeeper);
            return;
        } catch (KeeperException e) {
            if (e.code() == Code.NONODE) {
                log.error(""Looked up non existant node in cache "" + e.getPath(), e);
            }
            log.warn(""Zookeeper error, will retry"", e);
        } catch (InterruptedException e) {
            log.warn(""Zookeeper error, will retry"", e);
        } catch (ConcurrentModificationException e) {
            log.debug(""Zookeeper was modified, will retry"");
        }
        try {
            // do not hold lock while sleeping
            wait(sleepTime);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        if (sleepTime < 10000)
            sleepTime = (int) (sleepTime + sleepTime * Math.random());
    }
}",,"private synchronized void retry(ZooRunnable op) {
    int sleepTime = 100;
    while (true) {
        ZooKeeper zooKeeper = getZooKeeper();
        try {
            op.run(zooKeeper);
            return;
        } catch (KeeperException e) {
            if (e.code() == Code.NONODE) {
                log.error(""Looked up non existant node in cache "" + e.getPath(), e);
            }
            log.warn(""Zookeeper error, will retry"", e);
        } catch (InterruptedException e) {
            log.warn(""Zookeeper error, will retry"", e);
        } catch (ConcurrentModificationException e) {
            log.debug(""Zookeeper was modified, will retry"");
        }
        try {
                        wait(sleepTime);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        if (sleepTime < 10000)
            sleepTime = (int) (sleepTime + sleepTime * Math.random());
    }
}",0.5454545454545454,0.42346938775510207,0.6666666666666666,0.5,0.0,0.2956005931784479,-0.3971895612274165,0.4166666666666667,-0.028571428571428574,0.29763021402169765
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-4358_74cbba24,1,"@Override
protected Revision computeNext() {
    while (unfiltered.hasNext()) {
        Revision next = unfiltered.next();
        if (min.isRevisionNewer(next)) {
            return next;
        } else {
            // further revisions with this clusterId
            // are older than min revision
            clusterIds.remove(next.getClusterId());
            // no more revisions to check
            if (clusterIds.isEmpty()) {
                return endOfData();
            }
        }
    }
    return endOfData();
}",,"@Override
protected Revision computeNext() {
    while (unfiltered.hasNext()) {
        Revision next = unfiltered.next();
        if (min.isRevisionNewer(next)) {
            return next;
        } else {
                                    clusterIds.remove(next.getClusterId());
                        if (clusterIds.isEmpty()) {
                return endOfData();
            }
        }
    }
    return endOfData();
}",0.045454545454545456,0.9540816326530611,0.0,0.5,0.16666666666666666,-0.3806228373702422,0.07198164611413799,0.16666666666666666,0.5428571428571429,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-434_133cbc2d,1,"/**
 * {@inheritDoc}
 */
@Override
public int hashCode() {
    return Boolean.valueOf(restrictToNonNegative).hashCode() ^ numDecisionVariables ^ numSlackVariables ^ numArtificialVariables ^ Double.valueOf(epsilon).hashCode() ^ f.hashCode() ^ constraints.hashCode() ^ tableau.hashCode();
}","/**
 * {@inheritDoc}
 */
","@Override
public int hashCode() {
    return Boolean.valueOf(restrictToNonNegative).hashCode() ^ numDecisionVariables ^ numSlackVariables ^ numArtificialVariables ^ Double.valueOf(epsilon).hashCode() ^ f.hashCode() ^ constraints.hashCode() ^ tableau.hashCode();
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7192429022082021,0.08333333333333333,1.885714285714286,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-5853_b80f6640,3,"/**
 *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,Locale)
 */
@Override
public Byte convertToObject(final String value, final Locale locale) {
    final Number number = parse(value, Byte.MIN_VALUE, Byte.MAX_VALUE, locale);
    if (number == null) {
        return null;
    }
    return number.byteValue();
}","/**
 *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,Locale)
 */
","@Override
public Byte convertToObject(final String value, final Locale locale) {
    final Number number = parse(value, Byte.MIN_VALUE, Byte.MAX_VALUE, locale);
    if (number == null) {
        return null;
    }
    return number.byteValue();
}",-0.2727272727272727,-0.1887755102040817,-0.3333333333333333,-0.5,-0.25,-0.08996539792387542,0.3642099225695442,-0.3333333333333333,0.2285714285714286,-0.10260363798339052
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443,1,"@Override
public Collection<Text> getSplits(String tableName, int maxSplits) {
    return Collections.emptyList();
}",,"@Override
public Collection<Text> getSplits(String tableName, int maxSplits) {
    return Collections.emptyList();
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8543160309721824,-0.4166666666666667,0.8285714285714285,-0.16422749602751402
flink,remotes/origin/bugs-dot-jar_FLINK-3740_f2f5bd5b,1,"// ------------------------------------------------------------------------
// Checkpointing
// ------------------------------------------------------------------------
@Override
public StreamTaskState snapshotOperatorState(long checkpointId, long timestamp) throws Exception {
    StreamTaskState taskState = super.snapshotOperatorState(checkpointId, timestamp);
    AbstractStateBackend.CheckpointStateOutputView out = getStateBackend().createCheckpointStateOutputView(checkpointId, timestamp);
    out.writeInt(watermarkTimersQueue.size());
    for (Timer<K, W> timer : watermarkTimersQueue) {
        keySerializer.serialize(timer.key, out);
        windowSerializer.serialize(timer.window, out);
        out.writeLong(timer.timestamp);
    }
    out.writeInt(processingTimeTimers.size());
    for (Timer<K, W> timer : processingTimeTimersQueue) {
        keySerializer.serialize(timer.key, out);
        windowSerializer.serialize(timer.window, out);
        out.writeLong(timer.timestamp);
    }
    taskState.setOperatorState(out.closeAndGetHandle());
    return taskState;
}",,"@Override
public StreamTaskState snapshotOperatorState(long checkpointId, long timestamp) throws Exception {
    StreamTaskState taskState = super.snapshotOperatorState(checkpointId, timestamp);
    AbstractStateBackend.CheckpointStateOutputView out = getStateBackend().createCheckpointStateOutputView(checkpointId, timestamp);
    out.writeInt(watermarkTimersQueue.size());
    for (Timer<K, W> timer : watermarkTimersQueue) {
        keySerializer.serialize(timer.key, out);
        windowSerializer.serialize(timer.window, out);
        out.writeLong(timer.timestamp);
    }
    out.writeInt(processingTimeTimers.size());
    for (Timer<K, W> timer : processingTimeTimersQueue) {
        keySerializer.serialize(timer.key, out);
        windowSerializer.serialize(timer.window, out);
        out.writeLong(timer.timestamp);
    }
    taskState.setOperatorState(out.closeAndGetHandle());
    return taskState;
}",0.22727272727272727,-0.17346938775510198,-0.16666666666666666,-0.5,-0.4166666666666667,-0.3806228373702422,-0.2368798394034989,0.75,-0.028571428571428574,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2659_019edb16,0,"@Override
protected void setupIterators(JobConf job, Scanner scanner, String tableName, org.apache.accumulo.core.client.mapred.RangeInputSplit split) {
    List<IteratorSetting> iterators = null;
    if (null == split) {
        iterators = getIterators(job);
    } else {
        iterators = split.getIterators();
    }
    setupIterators(iterators, scanner);
}",,"@Override
protected void setupIterators(JobConf job, Scanner scanner, String tableName, org.apache.accumulo.core.client.mapred.RangeInputSplit split) {
    List<IteratorSetting> iterators = null;
    if (null == split) {
        iterators = getIterators(job);
    } else {
        iterators = split.getIterators();
    }
    setupIterators(iterators, scanner);
}",-0.18181818181818182,-0.11224489795918377,-0.3333333333333333,-0.5,-0.25,-0.09391992090954028,0.1829652996845425,-0.25,0.0,-0.061396858845045206
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3433_b76b31f7,0,"/**
 * Recover the correct _lastRev updates for the given candidate nodes.
 *
 * @param suspects the potential suspects
 * @param clusterId the cluster id for which _lastRev recovery needed
 * @param dryRun if {@code true}, this method will only perform a check
 *               but not apply the changes to the _lastRev fields.
 * @return the number of documents that required recovery. This method
 *          returns the number of the affected documents even if
 *          {@code dryRun} is set true and no document was changed.
 */
public int recover(Iterator<NodeDocument> suspects, int clusterId, boolean dryRun) {
    UnsavedModifications unsaved = new UnsavedModifications();
    UnsavedModifications unsavedParents = new UnsavedModifications();
    // Map of known last rev of checked paths
    Map<String, Revision> knownLastRevOrModification = MapFactory.getInstance().create();
    final DocumentStore docStore = nodeStore.getDocumentStore();
    final JournalEntry changes = JOURNAL.newDocument(docStore);
    long count = 0;
    while (suspects.hasNext()) {
        NodeDocument doc = suspects.next();
        count++;
        if (count % 100000 == 0) {
            log.info(""Scanned {} suspects so far..."", count);
        }
        Revision currentLastRev = doc.getLastRev().get(clusterId);
        // 1. determine last committed modification on document
        Revision lastModifiedRev = determineLastModification(doc, clusterId);
        Revision lastRevForParents = Utils.max(lastModifiedRev, currentLastRev);
        // _lastRev entry or an explicit modification on the document
        if (lastRevForParents != null) {
            knownLastRevOrModification.put(doc.getPath(), lastRevForParents);
        }
        // 2. Update lastRev for parent paths aka rollup
        if (lastRevForParents != null) {
            String path = doc.getPath();
            // track all changes
            changes.modified(path);
            while (true) {
                if (PathUtils.denotesRoot(path)) {
                    break;
                }
                path = PathUtils.getParentPath(path);
                unsavedParents.put(path, lastRevForParents);
            }
        }
    }
    for (String parentPath : unsavedParents.getPaths()) {
        Revision calcLastRev = unsavedParents.get(parentPath);
        Revision knownLastRev = knownLastRevOrModification.get(parentPath);
        if (knownLastRev == null) {
            // we don't know when the document was last modified with
            // the given clusterId. need to read from store
            String id = Utils.getIdFromPath(parentPath);
            NodeDocument doc = docStore.find(NODES, id);
            if (doc != null) {
                Revision lastRev = doc.getLastRev().get(clusterId);
                Revision lastMod = determineLastModification(doc, clusterId);
                knownLastRev = Utils.max(lastRev, lastMod);
            } else {
                log.warn(""Unable to find document: {}"", id);
                continue;
            }
        }
        // This check ensures that unnecessary updates are not made
        if (knownLastRev == null || calcLastRev.compareRevisionTime(knownLastRev) > 0) {
            unsaved.put(parentPath, calcLastRev);
        }
    }
    // take the root's lastRev
    final Revision lastRootRev = unsaved.get(""/"");
    // Note the size before persist as persist operation
    // would empty the internal state
    int size = unsaved.getPaths().size();
    String updates = unsaved.toString();
    if (dryRun) {
        log.info(""Dry run of lastRev recovery identified [{}] documents for "" + ""cluster node [{}]: {}"", size, clusterId, updates);
    } else {
        // UnsavedModifications is designed to be used in concurrent
        // access mode. For recovery case there is no concurrent access
        // involve so just pass a new lock instance
        // the lock uses to do the persisting is a plain reentrant lock
        // thus it doesn't matter, where exactly the check is done
        // as to whether the recovered lastRev has already been
        // written to the journal.
        unsaved.persist(nodeStore, new UnsavedModifications.Snapshot() {

            @Override
            public void acquiring() {
                if (lastRootRev == null) {
                    // then we cannot and probably don't have to persist anything
                    return;
                }
                // lastRootRev never null at this point
                final String id = JournalEntry.asId(lastRootRev);
                final JournalEntry existingEntry = docStore.find(Collection.JOURNAL, id);
                if (existingEntry != null) {
                    // hence: nothing to be done here. return.
                    return;
                }
                // otherwise store a new journal entry now
                docStore.create(JOURNAL, singletonList(changes.asUpdateOp(lastRootRev)));
            }
        }, new ReentrantLock());
        log.info(""Updated lastRev of [{}] documents while performing lastRev recovery for "" + ""cluster node [{}]: {}"", size, clusterId, updates);
    }
    return size;
}","/**
 * Recover the correct _lastRev updates for the given candidate nodes.
 *
 * @param suspects the potential suspects
 * @param clusterId the cluster id for which _lastRev recovery needed
 * @param dryRun if {@code true}, this method will only perform a check
 *               but not apply the changes to the _lastRev fields.
 * @return the number of documents that required recovery. This method
 *          returns the number of the affected documents even if
 *          {@code dryRun} is set true and no document was changed.
 */
","public int recover(Iterator<NodeDocument> suspects, int clusterId, boolean dryRun) {
    UnsavedModifications unsaved = new UnsavedModifications();
    UnsavedModifications unsavedParents = new UnsavedModifications();
        Map<String, Revision> knownLastRevOrModification = MapFactory.getInstance().create();
    final DocumentStore docStore = nodeStore.getDocumentStore();
    final JournalEntry changes = JOURNAL.newDocument(docStore);
    long count = 0;
    while (suspects.hasNext()) {
        NodeDocument doc = suspects.next();
        count++;
        if (count % 100000 == 0) {
            log.info(""Scanned {} suspects so far..."", count);
        }
        Revision currentLastRev = doc.getLastRev().get(clusterId);
                Revision lastModifiedRev = determineLastModification(doc, clusterId);
        Revision lastRevForParents = Utils.max(lastModifiedRev, currentLastRev);
                if (lastRevForParents != null) {
            knownLastRevOrModification.put(doc.getPath(), lastRevForParents);
        }
                if (lastRevForParents != null) {
            String path = doc.getPath();
                        changes.modified(path);
            while (true) {
                if (PathUtils.denotesRoot(path)) {
                    break;
                }
                path = PathUtils.getParentPath(path);
                unsavedParents.put(path, lastRevForParents);
            }
        }
    }
    for (String parentPath : unsavedParents.getPaths()) {
        Revision calcLastRev = unsavedParents.get(parentPath);
        Revision knownLastRev = knownLastRevOrModification.get(parentPath);
        if (knownLastRev == null) {
                                    String id = Utils.getIdFromPath(parentPath);
            NodeDocument doc = docStore.find(NODES, id);
            if (doc != null) {
                Revision lastRev = doc.getLastRev().get(clusterId);
                Revision lastMod = determineLastModification(doc, clusterId);
                knownLastRev = Utils.max(lastRev, lastMod);
            } else {
                log.warn(""Unable to find document: {}"", id);
                continue;
            }
        }
                if (knownLastRev == null || calcLastRev.compareRevisionTime(knownLastRev) > 0) {
            unsaved.put(parentPath, calcLastRev);
        }
    }
        final Revision lastRootRev = unsaved.get(""/"");
            int size = unsaved.getPaths().size();
    String updates = unsaved.toString();
    if (dryRun) {
        log.info(""Dry run of lastRev recovery identified [{}] documents for "" + ""cluster node [{}]: {}"", size, clusterId, updates);
    } else {
                                                                unsaved.persist(nodeStore, new UnsavedModifications.Snapshot() {

            @Override
            public void acquiring() {
                if (lastRootRev == null) {
                                        return;
                }
                                final String id = JournalEntry.asId(lastRootRev);
                final JournalEntry existingEntry = docStore.find(Collection.JOURNAL, id);
                if (existingEntry != null) {
                                        return;
                }
                                docStore.create(JOURNAL, singletonList(changes.asUpdateOp(lastRootRev)));
            }
        }, new ReentrantLock());
        log.info(""Updated lastRev of [{}] documents while performing lastRev recovery for "" + ""cluster node [{}]: {}"", size, clusterId, updates);
    }
    return size;
}",2.727272727272727,0.9948979591836733,2.0,1.0,1.5833333333333333,1.6361838853188333,-1.1783768282190998,3.0,-0.028571428571428574,6.8375199695050135
Cli,33,1,"/**
 * Print the specified text to the specified PrintWriter.
 *
 * @param pw The printWriter to write the help to
 * @param width The number of characters to display per line
 * @param nextLineTabStop The position on the next line for the first tab.
 * @param text The text to be written to the PrintWriter
 */
public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text) {
    StringBuffer sb = new StringBuffer(text.length());
    renderWrappedText(sb, width, nextLineTabStop, text);
    pw.println(sb.toString());
}","/**
 * Print the specified text to the specified PrintWriter.
 *
 * @param pw The printWriter to write the help to
 * @param width The number of characters to display per line
 * @param nextLineTabStop The position on the next line for the first tab.
 * @param text The text to be written to the PrintWriter
 */
","public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text) {
    StringBuffer sb = new StringBuffer(text.length());
    renderWrappedText(sb, width, nextLineTabStop, text);
    pw.println(sb.toString());
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.6022368798394037,-0.16666666666666666,0.4571428571428572,-0.16422749602751402
JxPath,13,1,"/**
 * Get the prefix associated with the specifed namespace URI.
 * @param namespaceURI the ns URI to check.
 * @return String prefix
 */
public synchronized String getPrefix(String namespaceURI) {
    /**
     * Get the nearest prefix found that matches an externally-registered namespace.
     * @param namespaceURI
     * @return String prefix if found.
     * @since JXPath 1.3
     */
    if (reverseMap == null) {
        reverseMap = new HashMap();
        NodeIterator ni = pointer.namespaceIterator();
        if (ni != null) {
            for (int position = 1; ni.setPosition(position); position++) {
                NodePointer nsPointer = ni.getNodePointer();
                String uri = nsPointer.getNamespaceURI();
                String prefix = nsPointer.getName().getName();
                if (!"""".equals(prefix)) {
                    reverseMap.put(uri, prefix);
                }
            }
        }
        Iterator it = namespaceMap.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            reverseMap.put(entry.getValue(), entry.getKey());
        }
    }
    String prefix = (String) reverseMap.get(namespaceURI);
    if (prefix == null && parent != null) {
        return parent.getPrefix(namespaceURI);
    }
    return prefix;
}","/**
 * Get the prefix associated with the specifed namespace URI.
 * @param namespaceURI the ns URI to check.
 * @return String prefix
 */
/**
 * Get the nearest prefix found that matches an externally-registered namespace.
 * @param namespaceURI
 * @return String prefix if found.
 * @since JXPath 1.3
 */
","public synchronized String getPrefix(String namespaceURI) {
    /**
     * Get the nearest prefix found that matches an externally-registered namespace.
     * @param namespaceURI
     * @return String prefix if found.
     * @since JXPath 1.3
     */
    if (reverseMap == null) {
        reverseMap = new HashMap();
        NodeIterator ni = pointer.namespaceIterator();
        if (ni != null) {
            for (int position = 1; ni.setPosition(position); position++) {
                NodePointer nsPointer = ni.getNodePointer();
                String uri = nsPointer.getNamespaceURI();
                String prefix = nsPointer.getName().getName();
                if (!"""".equals(prefix)) {
                    reverseMap.put(uri, prefix);
                }
            }
        }
        Iterator it = namespaceMap.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            reverseMap.put(entry.getValue(), entry.getKey());
        }
    }
    String prefix = (String) reverseMap.get(namespaceURI);
    if (prefix == null && parent != null) {
        return parent.getPrefix(namespaceURI);
    }
    return prefix;
}",0.8181818181818182,1.0255102040816328,0.5,1.0,0.8333333333333334,0.7899159663865548,-0.5549182678520221,0.9166666666666666,-0.028571428571428574,1.095673737905868
wicket,remotes/origin/bugs-dot-jar_WICKET-4102_e743fd7e,1,"@Override
protected void executeInsideBufferedZone() {
    TextLabel.super.onComponentTagBody(markupStream, openTag);
}",,"@Override
protected void executeInsideBufferedZone() {
    TextLabel.super.onComponentTagBody(markupStream, openTag);
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9326068253513053,-0.4166666666666667,0.3428571428571429,-0.16422749602751402
flink,remotes/origin/bugs-dot-jar_FLINK-1471_d033fa8f,1,"private static void validateInputType(Class<?> baseClass, Class<?> clazz, int inputParamPos, TypeInformation<?> inType) {
    ArrayList<Type> typeHierarchy = new ArrayList<Type>();
    try {
        validateInfo(typeHierarchy, getParameterType(baseClass, typeHierarchy, clazz, inputParamPos), inType);
    } catch (InvalidTypesException e) {
        throw new InvalidTypesException(""Input mismatch: "" + e.getMessage());
    }
}",,"private static void validateInputType(Class<?> baseClass, Class<?> clazz, int inputParamPos, TypeInformation<?> inType) {
    ArrayList<Type> typeHierarchy = new ArrayList<Type>();
    try {
        validateInfo(typeHierarchy, getParameterType(baseClass, typeHierarchy, clazz, inputParamPos), inType);
    } catch (InvalidTypesException e) {
        throw new InvalidTypesException(""Input mismatch: "" + e.getMessage());
    }
}",-0.2727272727272727,-0.09693877551020405,-0.16666666666666666,-0.5,-0.4166666666666667,-0.054374691052891735,0.31861198738170354,-0.25,-0.028571428571428574,-0.07432724718499578
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-621_00b4b8a0,1,"@Override
public boolean remove() {
    root.checkLive();
    if (isDisconnected()) {
        throw new IllegalStateException(""Cannot remove a disconnected tree"");
    }
    if (!isRoot() && parent.hasChild(name)) {
        NodeBuilder builder = parent.getNodeBuilder();
        builder.removeNode(name);
        if (parent.hasOrderableChildren()) {
            builder.setProperty(MemoryPropertyBuilder.copy(Type.STRING, parent.internalGetProperty(OAK_CHILD_ORDER)).removeValue(name).getPropertyState());
        }
        root.updated();
        return true;
    } else {
        return false;
    }
}",,"@Override
public boolean remove() {
    root.checkLive();
    if (isDisconnected()) {
        throw new IllegalStateException(""Cannot remove a disconnected tree"");
    }
    if (!isRoot() && parent.hasChild(name)) {
        NodeBuilder builder = parent.getNodeBuilder();
        builder.removeNode(name);
        if (parent.hasOrderableChildren()) {
            builder.setProperty(MemoryPropertyBuilder.copy(Type.STRING, parent.internalGetProperty(OAK_CHILD_ORDER)).removeValue(name).getPropertyState());
        }
        root.updated();
        return true;
    } else {
        return false;
    }
}",0.18181818181818182,0.14285714285714277,0.16666666666666666,0.0,0.3333333333333333,-0.12753336628769152,-0.13880126182965313,0.5833333333333334,0.0,-0.05493808918070422
flink,remotes/origin/bugs-dot-jar_FLINK-1531_21f47d9c,3,"/**
 *  Require makes sure that at least required number of bytes are kept in the buffer. If not, then
 *  it will load exactly the difference between required and currently available number of bytes.
 *  Thus, it will only load the data which is required and never prefetch data.
 *
 *  @param required the number of bytes being available in the buffer
 *  @return the number of bytes remaining, which is equal to required
 *  @throws KryoException
 */
@Override
protected int require(int required) throws KryoException {
    if (required > capacity) {
        throw new KryoException(""Buffer too small: capacity: "" + capacity + "", "" + ""required: "" + required);
    }
    position = 0;
    int bytesRead = 0;
    int count;
    while (true) {
        count = fill(buffer, bytesRead, required - bytesRead);
        if (count == -1) {
            throw new KryoException(""Buffer underflow"");
        }
        bytesRead += count;
        if (bytesRead == required) {
            break;
        }
    }
    limit = required;
    return required;
}","/**
 *  Require makes sure that at least required number of bytes are kept in the buffer. If not, then
 *  it will load exactly the difference between required and currently available number of bytes.
 *  Thus, it will only load the data which is required and never prefetch data.
 *
 *  @param required the number of bytes being available in the buffer
 *  @return the number of bytes remaining, which is equal to required
 *  @throws KryoException
 */
","@Override
protected int require(int required) throws KryoException {
    if (required > capacity) {
        throw new KryoException(""Buffer too small: capacity: "" + capacity + "", "" + ""required: "" + required);
    }
    position = 0;
    int bytesRead = 0;
    int count;
    while (true) {
        count = fill(buffer, bytesRead, required - bytesRead);
        if (count == -1) {
            throw new KryoException(""Buffer underflow"");
        }
        bytesRead += count;
        if (bytesRead == required) {
            break;
        }
    }
    limit = required;
    return required;
}",0.3181818181818182,0.18367346938775503,0.6666666666666666,0.0,0.25,0.7424616905585765,-0.24318898766848313,-0.4166666666666667,-0.028571428571428574,0.36713908198097495
commons-math,remotes/origin/bugs-dot-jar_MATH-781_3c4cb189,1,"/**
 * Removes the phase 1 objective function, positive cost non-artificial variables,
 * and the non-basic artificial variables from this tableau.
 */
protected void dropPhase1Objective() {
    if (getNumObjectiveFunctions() == 1) {
        return;
    }
    List<Integer> columnsToDrop = new ArrayList<Integer>();
    columnsToDrop.add(0);
    // positive cost non-artificial variables
    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
        final double entry = tableau.getEntry(0, i);
        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
            columnsToDrop.add(i);
        }
    }
    // non-basic artificial variables
    for (int i = 0; i < getNumArtificialVariables(); i++) {
        int col = i + getArtificialVariableOffset();
        if (getBasicRow(col) == null) {
            columnsToDrop.add(col);
        }
    }
    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
    for (int i = 1; i < getHeight(); i++) {
        int col = 0;
        for (int j = 0; j < getWidth(); j++) {
            if (!columnsToDrop.contains(j)) {
                matrix[i - 1][col++] = tableau.getEntry(i, j);
            }
        }
    }
    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {
        columnLabels.remove((int) columnsToDrop.get(i));
    }
    this.tableau = new Array2DRowRealMatrix(matrix);
    this.numArtificialVariables = 0;
}","/**
 * Removes the phase 1 objective function, positive cost non-artificial variables,
 * and the non-basic artificial variables from this tableau.
 */
","protected void dropPhase1Objective() {
    if (getNumObjectiveFunctions() == 1) {
        return;
    }
    List<Integer> columnsToDrop = new ArrayList<Integer>();
    columnsToDrop.add(0);
        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
        final double entry = tableau.getEntry(0, i);
        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
            columnsToDrop.add(i);
        }
    }
        for (int i = 0; i < getNumArtificialVariables(); i++) {
        int col = i + getArtificialVariableOffset();
        if (getBasicRow(col) == null) {
            columnsToDrop.add(col);
        }
    }
    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
    for (int i = 1; i < getHeight(); i++) {
        int col = 0;
        for (int j = 0; j < getWidth(); j++) {
            if (!columnsToDrop.contains(j)) {
                matrix[i - 1][col++] = tableau.getEntry(i, j);
            }
        }
    }
    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {
        columnLabels.remove((int) columnsToDrop.get(i));
    }
    this.tableau = new Array2DRowRealMatrix(matrix);
    this.numArtificialVariables = 0;
}",0.8636363636363636,0.2653061224489796,1.0,0.5,1.4166666666666667,2.264953040039546,-0.6352165184972759,1.25,-0.028571428571428574,3.715938341877926
flink,remotes/origin/bugs-dot-jar_FLINK-1820_39d526e6,0,"/**
 *  Static utility to parse a field of type float from a byte sequence that represents text characters
 *  (such as when read from a file stream).
 *
 *  @param bytes The bytes containing the text data that should be parsed.
 *  @param startPos The offset to start the parsing.
 *  @param length The length of the byte sequence (counting from the offset).
 *  @param delimiter The delimiter that terminates the field.
 *
 *  @return The parsed value.
 *
 *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
 */
public static final float parseField(byte[] bytes, int startPos, int length, char delimiter) {
    if (length <= 0) {
        throw new NumberFormatException(""Invalid input: Empty string"");
    }
    int i = 0;
    final byte delByte = (byte) delimiter;
    while (i < length && bytes[i] != delByte) {
        i++;
    }
    String str = new String(bytes, startPos, i);
    return Float.parseFloat(str);
}","/**
 *  Static utility to parse a field of type float from a byte sequence that represents text characters
 *  (such as when read from a file stream).
 *
 *  @param bytes The bytes containing the text data that should be parsed.
 *  @param startPos The offset to start the parsing.
 *  @param length The length of the byte sequence (counting from the offset).
 *  @param delimiter The delimiter that terminates the field.
 *
 *  @return The parsed value.
 *
 *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
 */
","public static final float parseField(byte[] bytes, int startPos, int length, char delimiter) {
    if (length <= 0) {
        throw new NumberFormatException(""Invalid input: Empty string"");
    }
    int i = 0;
    final byte delByte = (byte) delimiter;
    while (i < length && bytes[i] != delByte) {
        i++;
    }
    String str = new String(bytes, startPos, i);
    return Float.parseFloat(str);
}",-0.09090909090909091,-0.3622448979591837,0.0,-0.5,0.08333333333333333,0.7661888284725656,0.08718095784341821,-0.4166666666666667,0.14285714285714285,0.239484155027604
Closure,135,2,"/**
 * Replaces references to ""this"" with references to name.  Do not
 * traverse function boundaries.
 */
private void replaceReferencesToThis(Node node, String name) {
    if (NodeUtil.isFunction(node)) {
        return;
    }
    for (Node child : node.children()) {
        if (NodeUtil.isThis(child)) {
            Node newName = Node.newString(Token.NAME, name);
            node.replaceChild(child, newName);
        } else {
            replaceReferencesToThis(child, name);
        }
    }
}","/**
 * Replaces references to ""this"" with references to name.  Do not
 * traverse function boundaries.
 */
","private void replaceReferencesToThis(Node node, String name) {
    if (NodeUtil.isFunction(node)) {
        return;
    }
    for (Node child : node.children()) {
        if (NodeUtil.isThis(child)) {
            Node newName = Node.newString(Token.NAME, name);
            node.replaceChild(child, newName);
        } else {
            replaceReferencesToThis(child, name);
        }
    }
}",-0.045454545454545456,0.5051020408163264,0.0,0.0,0.08333333333333333,-0.3806228373702422,0.08718095784341821,0.0,0.2285714285714286,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-3861_d1e0e411,3,"@Override
public void onComponentTag(final Component component, final ComponentTag tag) {
    tag.put(""xmlns:wicket"", ""http://wicket.apache.org"");
}",,"@Override
public void onComponentTag(final Component component, final ComponentTag tag) {
    tag.put(""xmlns:wicket"", ""http://wicket.apache.org"");
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8399770576426728,-0.4166666666666667,0.1142857142857143,-0.16422749602751402
JxPath,16,3,"/**
 * Test a Node.
 * @param node to test
 * @param test to execute
 * @return true if node passes test
 */
public static boolean testNode(Node node, NodeTest test) {
    if (test == null) {
        return true;
    }
    if (test instanceof NodeNameTest) {
        if (node.getNodeType() != Node.ELEMENT_NODE) {
            return false;
        }
        NodeNameTest nodeNameTest = (NodeNameTest) test;
        QName testName = nodeNameTest.getNodeName();
        String namespaceURI = nodeNameTest.getNamespaceURI();
        boolean wildcard = nodeNameTest.isWildcard();
        String testPrefix = testName.getPrefix();
        if (wildcard && testPrefix == null) {
            return true;
        }
        if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) {
            String nodeNS = DOMNodePointer.getNamespaceURI(node);
            return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));
        }
        return false;
    }
    if (test instanceof NodeTypeTest) {
        int nodeType = node.getNodeType();
        switch(((NodeTypeTest) test).getNodeType()) {
            case Compiler.NODE_TYPE_NODE:
                return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE;
            case Compiler.NODE_TYPE_TEXT:
                return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;
            case Compiler.NODE_TYPE_COMMENT:
                return nodeType == Node.COMMENT_NODE;
            case Compiler.NODE_TYPE_PI:
                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;
        }
        return false;
    }
    if (test instanceof ProcessingInstructionTest) {
        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {
            String testPI = ((ProcessingInstructionTest) test).getTarget();
            String nodePI = ((ProcessingInstruction) node).getTarget();
            return testPI.equals(nodePI);
        }
    }
    return false;
}","/**
 * Test a Node.
 * @param node to test
 * @param test to execute
 * @return true if node passes test
 */
","public static boolean testNode(Node node, NodeTest test) {
    if (test == null) {
        return true;
    }
    if (test instanceof NodeNameTest) {
        if (node.getNodeType() != Node.ELEMENT_NODE) {
            return false;
        }
        NodeNameTest nodeNameTest = (NodeNameTest) test;
        QName testName = nodeNameTest.getNodeName();
        String namespaceURI = nodeNameTest.getNamespaceURI();
        boolean wildcard = nodeNameTest.isWildcard();
        String testPrefix = testName.getPrefix();
        if (wildcard && testPrefix == null) {
            return true;
        }
        if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) {
            String nodeNS = DOMNodePointer.getNamespaceURI(node);
            return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));
        }
        return false;
    }
    if (test instanceof NodeTypeTest) {
        int nodeType = node.getNodeType();
        switch(((NodeTypeTest) test).getNodeType()) {
            case Compiler.NODE_TYPE_NODE:
                return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE;
            case Compiler.NODE_TYPE_TEXT:
                return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;
            case Compiler.NODE_TYPE_COMMENT:
                return nodeType == Node.COMMENT_NODE;
            case Compiler.NODE_TYPE_PI:
                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;
        }
        return false;
    }
    if (test instanceof ProcessingInstructionTest) {
        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {
            String testPI = ((ProcessingInstructionTest) test).getTarget();
            String nodePI = ((ProcessingInstruction) node).getTarget();
            return testPI.equals(nodePI);
        }
    }
    return false;
}",1.4090909090909092,0.4591836734693877,1.5,0.5,1.4166666666666667,0.6159169550173011,-0.8247777459133929,1.0,-0.028571428571428574,1.5757170819038808
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2899_31aea2ad,0,"public synchronized void open(String address) throws IOException {
    String filename = UUID.randomUUID().toString();
    String logger = StringUtil.join(Arrays.asList(address.split("":"")), ""+"");
    log.debug(""DfsLogger.open() begin"");
    VolumeManager fs = conf.getFileSystem();
    logPath = fs.choose(ServerConstants.getWalDirs()) + ""/"" + logger + ""/"" + filename;
    try {
        short replication = (short) conf.getConfiguration().getCount(Property.TSERV_WAL_REPLICATION);
        if (replication == 0)
            replication = fs.getDefaultReplication(new Path(logPath));
        long blockSize = conf.getConfiguration().getMemoryInBytes(Property.TSERV_WAL_BLOCKSIZE);
        if (blockSize == 0)
            blockSize = (long) (conf.getConfiguration().getMemoryInBytes(Property.TSERV_WALOG_MAX_SIZE) * 1.1);
        if (conf.getConfiguration().getBoolean(Property.TSERV_WAL_SYNC))
            logFile = fs.createSyncable(new Path(logPath), 0, replication, blockSize);
        else
            logFile = fs.create(new Path(logPath), true, 0, replication, blockSize);
        String syncMethod = conf.getConfiguration().get(Property.TSERV_WAL_SYNC_METHOD);
        try {
            // hsync: send data to datanodes and sync the data to disk
            sync = logFile.getClass().getMethod(syncMethod);
        } catch (Exception ex) {
            log.warn(""Could not find configured "" + syncMethod + "" method, trying to fall back to old Hadoop sync method"", ex);
            try {
                // sync: send data to datanodes
                sync = logFile.getClass().getMethod(""sync"");
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
        // Initialize the crypto operations.
        org.apache.accumulo.core.security.crypto.CryptoModule cryptoModule = org.apache.accumulo.core.security.crypto.CryptoModuleFactory.getCryptoModule(conf.getConfiguration().get(Property.CRYPTO_MODULE_CLASS));
        // Initialize the log file with a header and the crypto params used to set up this log file.
        logFile.write(LOG_FILE_HEADER_V3.getBytes(Constants.UTF8));
        CryptoModuleParameters params = CryptoModuleFactory.createParamsObjectFromAccumuloConfiguration(conf.getConfiguration());
        NoFlushOutputStream nfos = new NoFlushOutputStream(logFile);
        params.setPlaintextOutputStream(nfos);
        // In order to bootstrap the reading of this file later, we have to record the CryptoModule that was used to encipher it here,
        // so that that crypto module can re-read its own parameters.
        logFile.writeUTF(conf.getConfiguration().get(Property.CRYPTO_MODULE_CLASS));
        params = cryptoModule.getEncryptingOutputStream(params);
        OutputStream encipheringOutputStream = params.getEncryptedOutputStream();
        // another data OutputStream.
        if (encipheringOutputStream == nfos) {
            log.debug(""No enciphering, using raw output stream"");
            encryptingLogFile = nfos;
        } else {
            log.debug(""Enciphering found, wrapping in DataOutputStream"");
            encryptingLogFile = new DataOutputStream(encipheringOutputStream);
        }
        LogFileKey key = new LogFileKey();
        key.event = OPEN;
        key.tserverSession = filename;
        key.filename = filename;
        write(key, EMPTY);
        sync.invoke(logFile);
        log.debug(""Got new write-ahead log: "" + this);
    } catch (Exception ex) {
        if (logFile != null)
            logFile.close();
        logFile = null;
        encryptingLogFile = null;
        throw new IOException(ex);
    }
    syncThread = new Daemon(new LoggingRunnable(log, new LogSyncingTask()));
    syncThread.setName(""Accumulo WALog thread "" + toString());
    syncThread.start();
}",,"public synchronized void open(String address) throws IOException {
    String filename = UUID.randomUUID().toString();
    String logger = StringUtil.join(Arrays.asList(address.split("":"")), ""+"");
    log.debug(""DfsLogger.open() begin"");
    VolumeManager fs = conf.getFileSystem();
    logPath = fs.choose(ServerConstants.getWalDirs()) + ""/"" + logger + ""/"" + filename;
    try {
        short replication = (short) conf.getConfiguration().getCount(Property.TSERV_WAL_REPLICATION);
        if (replication == 0)
            replication = fs.getDefaultReplication(new Path(logPath));
        long blockSize = conf.getConfiguration().getMemoryInBytes(Property.TSERV_WAL_BLOCKSIZE);
        if (blockSize == 0)
            blockSize = (long) (conf.getConfiguration().getMemoryInBytes(Property.TSERV_WALOG_MAX_SIZE) * 1.1);
        if (conf.getConfiguration().getBoolean(Property.TSERV_WAL_SYNC))
            logFile = fs.createSyncable(new Path(logPath), 0, replication, blockSize);
        else
            logFile = fs.create(new Path(logPath), true, 0, replication, blockSize);
        String syncMethod = conf.getConfiguration().get(Property.TSERV_WAL_SYNC_METHOD);
        try {
                        sync = logFile.getClass().getMethod(syncMethod);
        } catch (Exception ex) {
            log.warn(""Could not find configured "" + syncMethod + "" method, trying to fall back to old Hadoop sync method"", ex);
            try {
                                sync = logFile.getClass().getMethod(""sync"");
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
                org.apache.accumulo.core.security.crypto.CryptoModule cryptoModule = org.apache.accumulo.core.security.crypto.CryptoModuleFactory.getCryptoModule(conf.getConfiguration().get(Property.CRYPTO_MODULE_CLASS));
                logFile.write(LOG_FILE_HEADER_V3.getBytes(Constants.UTF8));
        CryptoModuleParameters params = CryptoModuleFactory.createParamsObjectFromAccumuloConfiguration(conf.getConfiguration());
        NoFlushOutputStream nfos = new NoFlushOutputStream(logFile);
        params.setPlaintextOutputStream(nfos);
                        logFile.writeUTF(conf.getConfiguration().get(Property.CRYPTO_MODULE_CLASS));
        params = cryptoModule.getEncryptingOutputStream(params);
        OutputStream encipheringOutputStream = params.getEncryptedOutputStream();
                if (encipheringOutputStream == nfos) {
            log.debug(""No enciphering, using raw output stream"");
            encryptingLogFile = nfos;
        } else {
            log.debug(""Enciphering found, wrapping in DataOutputStream"");
            encryptingLogFile = new DataOutputStream(encipheringOutputStream);
        }
        LogFileKey key = new LogFileKey();
        key.event = OPEN;
        key.tserverSession = filename;
        key.filename = filename;
        write(key, EMPTY);
        sync.invoke(logFile);
        log.debug(""Got new write-ahead log: "" + this);
    } catch (Exception ex) {
        if (logFile != null)
            logFile.close();
        logFile = null;
        encryptingLogFile = null;
        throw new IOException(ex);
    }
    syncThread = new Daemon(new LoggingRunnable(log, new LogSyncingTask()));
    syncThread.setName(""Accumulo WALog thread "" + toString());
    syncThread.start();
}",2.1363636363636362,0.12755102040816327,1.1666666666666667,0.5,0.5,0.44389520514088,-1.072555205047319,3.5833333333333335,-0.028571428571428574,3.0415836834688905
wicket,remotes/origin/bugs-dot-jar_WICKET-4309_b4274415,1,"/**
 *  Convert to object types, returning null if text is null.
 *
 *  @return converted
 *  @throws StringValueConversionException
 */
public final Double toOptionalDouble() throws StringValueConversionException {
    return (text == null) ? null : toDoubleObject();
}","/**
 *  Convert to object types, returning null if text is null.
 *
 *  @return converted
 *  @throws StringValueConversionException
 */
","public final Double toOptionalDouble() throws StringValueConversionException {
    return (text == null) ? null : toDoubleObject();
}",-0.5,-0.576530612244898,-0.3333333333333333,-1.0,-0.25,-0.3806228373702422,1.012044737596788,-0.4166666666666667,2.8285714285714287,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2974_5eceb10e,0,"@Override
public Path getFullPath(FileType fileType, String path) {
    int colon = path.indexOf(':');
    if (colon > -1) {
        // Check if this is really an absolute path or if this is a 1.4 style relative path for a WAL
        if (fileType == FileType.WAL && path.charAt(colon + 1) != '/') {
            path = path.substring(path.indexOf('/'));
        } else {
            return new Path(path);
        }
    }
    // normalize the path
    Path fullPath = new Path(defaultVolume.getBasePath(), fileType.getDirectory());
    if (path.startsWith(""/""))
        path = path.substring(1);
    fullPath = new Path(fullPath, path);
    FileSystem fs = getVolumeByPath(fullPath).getFileSystem();
    return fs.makeQualified(fullPath);
}",,"@Override
public Path getFullPath(FileType fileType, String path) {
    int colon = path.indexOf(':');
    if (colon > -1) {
                if (fileType == FileType.WAL && path.charAt(colon + 1) != '/') {
            path = path.substring(path.indexOf('/'));
        } else {
            return new Path(path);
        }
    }
        Path fullPath = new Path(defaultVolume.getBasePath(), fileType.getDirectory());
    if (path.startsWith(""/""))
        path = path.substring(1);
    fullPath = new Path(fullPath, path);
    FileSystem fs = getVolumeByPath(fullPath).getFileSystem();
    return fs.makeQualified(fullPath);
}",0.13636363636363635,0.2806122448979591,0.0,0.0,0.25,0.8966880869995059,-0.18583309435044468,0.4166666666666667,-0.028571428571428574,0.7850703055066579
Closure,91,2,"/**
 * Since this pass reports errors only when a global {@code this} keyword
 * is encountered, there is no reason to traverse non global contexts.
 */
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.FUNCTION) {
        // Don't traverse functions that are constructors or have the @this
        // or @override annotation.
        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) {
            return false;
        }
        // Don't traverse functions unless they would normally
        // be able to have a @this annotation associated with them. e.g.,
        // var a = function() { }; // or
        // function a() {} // or
        // a.x = function() {}; // or
        // var a = {x: function() {}};
        int pType = parent.getType();
        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN || // object literal keys
        pType == Token.STRING || pType == Token.NUMBER)) {
            return false;
        }
    // Don't traverse functions that are getting lent to a prototype.
    }
    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();
        if (n == lhs) {
            // assignLhsChild should not be overridden.
            if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
            // property or subproperty.
            if (NodeUtil.isGet(lhs)) {
                if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
                Node llhs = lhs.getFirstChild();
                if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
            }
        }
    }
    return true;
}","/**
 * Since this pass reports errors only when a global {@code this} keyword
 * is encountered, there is no reason to traverse non global contexts.
 */
","public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    if (n.getType() == Token.FUNCTION) {
                        JSDocInfo jsDoc = getFunctionJsDocInfo(n);
        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) {
            return false;
        }
                                                        int pType = parent.getType();
        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN ||         pType == Token.STRING || pType == Token.NUMBER)) {
            return false;
        }
        }
    if (parent != null && parent.getType() == Token.ASSIGN) {
        Node lhs = parent.getFirstChild();
        Node rhs = lhs.getNext();
        if (n == lhs) {
                        if (assignLhsChild == null) {
                assignLhsChild = lhs;
            }
        } else {
                        if (NodeUtil.isGet(lhs)) {
                if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
                Node llhs = lhs.getFirstChild();
                if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals(""prototype"")) {
                    return false;
                }
            }
        }
    }
    return true;
}",0.8636363636363636,1.0765306122448979,1.0,1.0,2.75,1.0568462679189323,-0.6415256667622601,1.1666666666666667,-0.028571428571428574,2.038752617986046
flink,remotes/origin/bugs-dot-jar_FLINK-1761_380ef878,1,"private void notifyAllChannelsOfErrorAndClose(Throwable cause) {
    if (channelError.compareAndSet(false, true)) {
        for (RemoteInputChannel inputChannel : inputChannels.values()) {
            inputChannel.onError(cause);
        }
        inputChannels.clear();
        ctx.close();
    }
}",,"private void notifyAllChannelsOfErrorAndClose(Throwable cause) {
    if (channelError.compareAndSet(false, true)) {
        for (RemoteInputChannel inputChannel : inputChannels.values()) {
            inputChannel.onError(cause);
        }
        inputChannels.clear();
        ctx.close();
    }
}",-0.22727272727272727,0.40816326530612235,-0.16666666666666666,0.0,-0.25,-0.3806228373702422,0.3409807857757386,-0.08333333333333333,0.2571428571428572,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2933_44585b0c,1,"private Validator visibleValidator(@Nonnull Tree source, @Nonnull Tree dest) {
    // TODO improve: avoid calculating the 'before' permissions in case the current parent permissions already point to the correct tree.
    ImmutableTree parent = (ImmutableTree) moveCtx.rootBefore.getTree(""/"");
    TreePermission tp = getPermissionProvider().getTreePermission(parent, TreePermission.EMPTY);
    for (String n : PathUtils.elements(source.getPath())) {
        tp = tp.getChildPermission(n, parent.getChild(n).getNodeState());
    }
    Validator validator = createValidator(source, dest, tp, this);
    return new VisibleValidator(validator, true, false);
}",,"private Validator visibleValidator(@Nonnull Tree source, @Nonnull Tree dest) {
        ImmutableTree parent = (ImmutableTree) moveCtx.rootBefore.getTree(""/"");
    TreePermission tp = getPermissionProvider().getTreePermission(parent, TreePermission.EMPTY);
    for (String n : PathUtils.elements(source.getPath())) {
        tp = tp.getChildPermission(n, parent.getChild(n).getNodeState());
    }
    Validator validator = createValidator(source, dest, tp, this);
    return new VisibleValidator(validator, true, false);
}",-0.22727272727272727,-0.3826530612244898,-0.3333333333333333,-0.5,-0.4166666666666667,-0.3806228373702422,0.16690564955549167,0.25,-0.028571428571428574,-0.16422749602751402
JxPath,19,1,"/**
 * Get relative position of this among like-named siblings.
 * @return 1..n
 */
private int getRelativePositionByQName() {
    int count = 1;
    Node n = node.getPreviousSibling();
    while (n != null) {
        if (n.getNodeType() == Node.ELEMENT_NODE) {
            String nm = n.getNodeName();
            if (nm.equals(node.getNodeName())) {
                count++;
            }
        }
        n = n.getPreviousSibling();
    }
    return count;
}","/**
 * Get relative position of this among like-named siblings.
 * @return 1..n
 */
","private int getRelativePositionByQName() {
    int count = 1;
    Node n = node.getPreviousSibling();
    while (n != null) {
        if (n.getNodeType() == Node.ELEMENT_NODE) {
            String nm = n.getNodeName();
            if (nm.equals(node.getNodeName())) {
                count++;
            }
        }
        n = n.getPreviousSibling();
    }
    return count;
}",0.0,0.8265306122448978,0.0,0.5,0.16666666666666666,0.33119130004943165,0.033266418124462196,0.0,1.9714285714285713,0.05846728427580833
Closure,62,2,"private String format(JSError error, boolean warning) {
    // extract source excerpt
    SourceExcerptProvider source = getSource();
    String sourceExcerpt = source == null ? null : excerpt.get(source, error.sourceName, error.lineNumber, excerptFormatter);
    // formatting the message
    StringBuilder b = new StringBuilder();
    if (error.sourceName != null) {
        b.append(error.sourceName);
        if (error.lineNumber > 0) {
            b.append(':');
            b.append(error.lineNumber);
        }
        b.append("": "");
    }
    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));
    b.append("" - "");
    b.append(error.description);
    b.append('\n');
    if (sourceExcerpt != null) {
        b.append(sourceExcerpt);
        b.append('\n');
        int charno = error.getCharno();
        // at the end of the line
        if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) {
            for (int i = 0; i < charno; i++) {
                char c = sourceExcerpt.charAt(i);
                if (Character.isWhitespace(c)) {
                    b.append(c);
                } else {
                    b.append(' ');
                }
            }
            b.append(""^\n"");
        }
    }
    return b.toString();
}",,"private String format(JSError error, boolean warning) {
        SourceExcerptProvider source = getSource();
    String sourceExcerpt = source == null ? null : excerpt.get(source, error.sourceName, error.lineNumber, excerptFormatter);
        StringBuilder b = new StringBuilder();
    if (error.sourceName != null) {
        b.append(error.sourceName);
        if (error.lineNumber > 0) {
            b.append(':');
            b.append(error.lineNumber);
        }
        b.append("": "");
    }
    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));
    b.append("" - "");
    b.append(error.description);
    b.append('\n');
    if (sourceExcerpt != null) {
        b.append(sourceExcerpt);
        b.append('\n');
        int charno = error.getCharno();
                if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) {
            for (int i = 0; i < charno; i++) {
                char c = sourceExcerpt.charAt(i);
                if (Character.isWhitespace(c)) {
                    b.append(c);
                } else {
                    b.append(' ');
                }
            }
            b.append(""^\n"");
        }
    }
    return b.toString();
}",0.9090909090909091,1.1428571428571428,0.8333333333333334,1.0,1.3333333333333333,1.596638655462185,-0.6435331230283913,1.3333333333333333,-0.028571428571428574,2.760665750103863
flink,remotes/origin/bugs-dot-jar_FLINK-3189_a5b05566,3,"public static InfoOptions parseInfoCommand(String[] args) throws CliArgsException {
    try {
        PosixParser parser = new PosixParser();
        CommandLine line = parser.parse(INFO_OPTIONS, args, false);
        return new InfoOptions(line);
    } catch (ParseException e) {
        throw new CliArgsException(e.getMessage());
    }
}",,"public static InfoOptions parseInfoCommand(String[] args) throws CliArgsException {
    try {
        PosixParser parser = new PosixParser();
        CommandLine line = parser.parse(INFO_OPTIONS, args, false);
        return new InfoOptions(line);
    } catch (ParseException e) {
        throw new CliArgsException(e.getMessage());
    }
}",-0.22727272727272727,0.06122448979591842,-0.16666666666666666,-0.5,-0.4166666666666667,-0.3806228373702422,0.2968167479208488,-0.3333333333333333,0.9714285714285714,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1044_ea2f9856,0,"public List<Short> check(Environment env, Mutation mutation) {
    ArrayList<Short> violations = null;
    Collection<ColumnUpdate> colUpdates = mutation.getUpdates();
    // check the row, it should contains at least one ; or end with <
    boolean containsSemiC = false;
    byte[] row = mutation.getRow();
    // always allow rows that fall within reserved area
    if (row.length > 0 && row[0] == '~')
        return null;
    for (byte b : row) {
        if (b == ';') {
            containsSemiC = true;
        }
        if (b == ';' || b == '<')
            break;
        if (!validTableNameChars[0xff & b]) {
            if (violations == null)
                violations = new ArrayList<Short>();
            if (!violations.contains((short) 4))
                violations.add((short) 4);
        }
    }
    if (!containsSemiC) {
        // see if last row char is <
        if (row.length == 0 || row[row.length - 1] != '<') {
            if (violations == null)
                violations = new ArrayList<Short>();
            if (!violations.contains((short) 4))
                violations.add((short) 4);
        }
    } else {
        if (row.length == 0) {
            if (violations == null)
                violations = new ArrayList<Short>();
            if (!violations.contains((short) 4))
                violations.add((short) 4);
        }
    }
    if (row.length > 0 && row[0] == '!') {
        if (row.length < 3 || row[1] != '0' || (row[2] != '<' && row[2] != ';')) {
            if (violations == null)
                violations = new ArrayList<Short>();
            if (!violations.contains((short) 4))
                violations.add((short) 4);
        }
    }
    // ensure row is not less than Constants.METADATA_TABLE_ID
    if (new Text(row).compareTo(new Text(Constants.METADATA_TABLE_ID)) < 0) {
        if (violations == null)
            violations = new ArrayList<Short>();
        violations.add((short) 5);
    }
    for (ColumnUpdate columnUpdate : colUpdates) {
        Text columnFamily = new Text(columnUpdate.getColumnFamily());
        if (columnUpdate.isDeleted()) {
            if (!isValidColumn(columnUpdate)) {
                if (violations == null)
                    violations = new ArrayList<Short>();
                violations.add((short) 2);
            }
            continue;
        }
        if (columnUpdate.getValue().length == 0 && !columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {
            if (violations == null)
                violations = new ArrayList<Short>();
            violations.add((short) 6);
        }
        if (columnFamily.equals(Constants.METADATA_DATAFILE_COLUMN_FAMILY)) {
            try {
                DataFileValue dfv = new DataFileValue(columnUpdate.getValue());
                if (dfv.getSize() < 0 || dfv.getNumEntries() < 0) {
                    if (violations == null)
                        violations = new ArrayList<Short>();
                    violations.add((short) 1);
                }
            } catch (NumberFormatException nfe) {
                if (violations == null)
                    violations = new ArrayList<Short>();
                violations.add((short) 1);
            } catch (ArrayIndexOutOfBoundsException aiooe) {
                if (violations == null)
                    violations = new ArrayList<Short>();
                violations.add((short) 1);
            }
        } else if (columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {
        } else {
            if (!isValidColumn(columnUpdate)) {
                if (violations == null)
                    violations = new ArrayList<Short>();
                violations.add((short) 2);
            } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_PREV_ROW_COLUMN) && columnUpdate.getValue().length > 0 && (violations == null || !violations.contains((short) 4))) {
                KeyExtent ke = new KeyExtent(new Text(mutation.getRow()), (Text) null);
                Text per = KeyExtent.decodePrevEndRow(new Value(columnUpdate.getValue()));
                boolean prevEndRowLessThanEndRow = per == null || ke.getEndRow() == null || per.compareTo(ke.getEndRow()) < 0;
                if (!prevEndRowLessThanEndRow) {
                    if (violations == null)
                        violations = new ArrayList<Short>();
                    violations.add((short) 3);
                }
            } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_LOCK_COLUMN)) {
                if (zooCache == null) {
                    zooCache = new ZooCache();
                }
                if (zooRoot == null) {
                    zooRoot = ZooUtil.getRoot(HdfsZooInstance.getInstance());
                }
                boolean lockHeld = false;
                String lockId = new String(columnUpdate.getValue());
                try {
                    lockHeld = ZooLock.isLockHeld(zooCache, new ZooUtil.LockID(zooRoot, lockId));
                } catch (Exception e) {
                    log.debug(""Failed to verify lock was held "" + lockId + "" "" + e.getMessage());
                }
                if (!lockHeld) {
                    if (violations == null)
                        violations = new ArrayList<Short>();
                    violations.add((short) 7);
                }
            }
        }
    }
    if (violations != null) {
        log.debug("" violating metadata mutation : "" + mutation);
    }
    return violations;
}",,"public List<Short> check(Environment env, Mutation mutation) {
    ArrayList<Short> violations = null;
    Collection<ColumnUpdate> colUpdates = mutation.getUpdates();
        boolean containsSemiC = false;
    byte[] row = mutation.getRow();
        if (row.length > 0 && row[0] == '~')
        return null;
    for (byte b : row) {
        if (b == ';') {
            containsSemiC = true;
        }
        if (b == ';' || b == '<')
            break;
        if (!validTableNameChars[0xff & b]) {
            if (violations == null)
                violations = new ArrayList<Short>();
            if (!violations.contains((short) 4))
                violations.add((short) 4);
        }
    }
    if (!containsSemiC) {
                if (row.length == 0 || row[row.length - 1] != '<') {
            if (violations == null)
                violations = new ArrayList<Short>();
            if (!violations.contains((short) 4))
                violations.add((short) 4);
        }
    } else {
        if (row.length == 0) {
            if (violations == null)
                violations = new ArrayList<Short>();
            if (!violations.contains((short) 4))
                violations.add((short) 4);
        }
    }
    if (row.length > 0 && row[0] == '!') {
        if (row.length < 3 || row[1] != '0' || (row[2] != '<' && row[2] != ';')) {
            if (violations == null)
                violations = new ArrayList<Short>();
            if (!violations.contains((short) 4))
                violations.add((short) 4);
        }
    }
        if (new Text(row).compareTo(new Text(Constants.METADATA_TABLE_ID)) < 0) {
        if (violations == null)
            violations = new ArrayList<Short>();
        violations.add((short) 5);
    }
    for (ColumnUpdate columnUpdate : colUpdates) {
        Text columnFamily = new Text(columnUpdate.getColumnFamily());
        if (columnUpdate.isDeleted()) {
            if (!isValidColumn(columnUpdate)) {
                if (violations == null)
                    violations = new ArrayList<Short>();
                violations.add((short) 2);
            }
            continue;
        }
        if (columnUpdate.getValue().length == 0 && !columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {
            if (violations == null)
                violations = new ArrayList<Short>();
            violations.add((short) 6);
        }
        if (columnFamily.equals(Constants.METADATA_DATAFILE_COLUMN_FAMILY)) {
            try {
                DataFileValue dfv = new DataFileValue(columnUpdate.getValue());
                if (dfv.getSize() < 0 || dfv.getNumEntries() < 0) {
                    if (violations == null)
                        violations = new ArrayList<Short>();
                    violations.add((short) 1);
                }
            } catch (NumberFormatException nfe) {
                if (violations == null)
                    violations = new ArrayList<Short>();
                violations.add((short) 1);
            } catch (ArrayIndexOutOfBoundsException aiooe) {
                if (violations == null)
                    violations = new ArrayList<Short>();
                violations.add((short) 1);
            }
        } else if (columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {
        } else {
            if (!isValidColumn(columnUpdate)) {
                if (violations == null)
                    violations = new ArrayList<Short>();
                violations.add((short) 2);
            } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_PREV_ROW_COLUMN) && columnUpdate.getValue().length > 0 && (violations == null || !violations.contains((short) 4))) {
                KeyExtent ke = new KeyExtent(new Text(mutation.getRow()), (Text) null);
                Text per = KeyExtent.decodePrevEndRow(new Value(columnUpdate.getValue()));
                boolean prevEndRowLessThanEndRow = per == null || ke.getEndRow() == null || per.compareTo(ke.getEndRow()) < 0;
                if (!prevEndRowLessThanEndRow) {
                    if (violations == null)
                        violations = new ArrayList<Short>();
                    violations.add((short) 3);
                }
            } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_LOCK_COLUMN)) {
                if (zooCache == null) {
                    zooCache = new ZooCache();
                }
                if (zooRoot == null) {
                    zooRoot = ZooUtil.getRoot(HdfsZooInstance.getInstance());
                }
                boolean lockHeld = false;
                String lockId = new String(columnUpdate.getValue());
                try {
                    lockHeld = ZooLock.isLockHeld(zooCache, new ZooUtil.LockID(zooRoot, lockId));
                } catch (Exception e) {
                    log.debug(""Failed to verify lock was held "" + lockId + "" "" + e.getMessage());
                }
                if (!lockHeld) {
                    if (violations == null)
                        violations = new ArrayList<Short>();
                    violations.add((short) 7);
                }
            }
        }
    }
    if (violations != null) {
        log.debug("" violating metadata mutation : "" + mutation);
    }
    return violations;
}",4.909090909090909,1.3010204081632655,7.5,2.5,5.666666666666667,3.233811171527435,-1.7135073128763985,3.5,-0.028571428571428574,22.040170292229348
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1250_0c3b3306,1,"@Override
@Nonnull
public synchronized String checkpoint(long lifetime) {
    checkArgument(lifetime > 0);
    // TODO: Guard the checkpoint from garbage collection
    return head.getRecordId().toString();
}",,"@Override
@Nonnull
public synchronized String checkpoint(long lifetime) {
    checkArgument(lifetime > 0);
        return head.getRecordId().toString();
}",-0.36363636363636365,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.6154287353025524,-0.25,2.285714285714286,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-6447_020c451a,1,"/**
 * Ends the current block and returns back to the {@link ChoiceDefinition choice()} DSL.
 *
 * @return the builder
 */
public ChoiceDefinition endChoice() {
    // are we already a choice?
    ProcessorDefinition<?> def = this;
    if (def instanceof ChoiceDefinition) {
        return (ChoiceDefinition) def;
    }
    // okay end this and get back to the choice
    def = end();
    if (def instanceof WhenDefinition) {
        return (ChoiceDefinition) def.getParent();
    } else if (def instanceof OtherwiseDefinition) {
        return (ChoiceDefinition) def.getParent();
    } else {
        return (ChoiceDefinition) def;
    }
}","/**
 * Ends the current block and returns back to the {@link ChoiceDefinition choice()} DSL.
 *
 * @return the builder
 */
","public ChoiceDefinition endChoice() {
        ProcessorDefinition<?> def = this;
    if (def instanceof ChoiceDefinition) {
        return (ChoiceDefinition) def;
    }
        def = end();
    if (def instanceof WhenDefinition) {
        return (ChoiceDefinition) def.getParent();
    } else if (def instanceof OtherwiseDefinition) {
        return (ChoiceDefinition) def.getParent();
    } else {
        return (ChoiceDefinition) def;
    }
}",0.0,-0.2346938775510204,0.0,0.0,-0.08333333333333333,-0.3806228373702422,0.11585890450243742,-0.25,0.3428571428571429,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1312_d9ab8449,1,"@Override
public Connector getConnector(String principal, AuthenticationToken token) throws AccumuloException, AccumuloSecurityException {
    Connector conn = new MockConnector(principal, acu, this);
    if (!acu.users.containsKey(principal))
        conn.securityOperations().createLocalUser(principal, (PasswordToken) token);
    else if (!acu.users.get(principal).token.equals(token))
        throw new AccumuloSecurityException(principal, SecurityErrorCode.BAD_CREDENTIALS);
    return conn;
}",,"@Override
public Connector getConnector(String principal, AuthenticationToken token) throws AccumuloException, AccumuloSecurityException {
    Connector conn = new MockConnector(principal, acu, this);
    if (!acu.users.containsKey(principal))
        conn.securityOperations().createLocalUser(principal, (PasswordToken) token);
    else if (!acu.users.get(principal).token.equals(token))
        throw new AccumuloSecurityException(principal, SecurityErrorCode.BAD_CREDENTIALS);
    return conn;
}",-0.22727272727272727,-0.035714285714285636,0.0,-1.0,0.08333333333333333,-0.04844290657439445,0.20275308287926572,-0.08333333333333333,-0.028571428571428574,-0.03212252817145721
commons-math,remotes/origin/bugs-dot-jar_MATH-757_76b7413d,1,"/**
 * Expands the internal storage array using the expansion factor.
 * <p>
 * if <code>expansionMode</code> is set to MULTIPLICATIVE_MODE,
 * the new array size will be <code>internalArray.length * expansionFactor.</code>
 * If <code>expansionMode</code> is set to ADDITIVE_MODE,  the length
 * after expansion will be <code>internalArray.length + expansionFactor</code>
 * </p>
 */
protected synchronized void expand() {
    // notice the use of FastMath.ceil(), this guarantees that we will always
    // have an array of at least currentSize + 1.   Assume that the
    // current initial capacity is 1 and the expansion factor
    // is 1.000000000000000001.  The newly calculated size will be
    // rounded up to 2 after the multiplication is performed.
    int newSize = 0;
    if (expansionMode == ExpansionMode.MULTIPLICATIVE) {
        newSize = (int) FastMath.ceil(internalArray.length * expansionFactor);
    } else {
        newSize = (int) (internalArray.length + FastMath.round(expansionFactor));
    }
    final double[] tempArray = new double[newSize];
    // Copy and swap
    System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);
    internalArray = tempArray;
}","/**
 * Expands the internal storage array using the expansion factor.
 * <p>
 * if <code>expansionMode</code> is set to MULTIPLICATIVE_MODE,
 * the new array size will be <code>internalArray.length * expansionFactor.</code>
 * If <code>expansionMode</code> is set to ADDITIVE_MODE,  the length
 * after expansion will be <code>internalArray.length + expansionFactor</code>
 * </p>
 */
","protected synchronized void expand() {
                        int newSize = 0;
    if (expansionMode == ExpansionMode.MULTIPLICATIVE) {
        newSize = (int) FastMath.ceil(internalArray.length * expansionFactor);
    } else {
        newSize = (int) (internalArray.length + FastMath.round(expansionFactor));
    }
    final double[] tempArray = new double[newSize];
        System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);
    internalArray = tempArray;
}",-0.13636363636363635,-0.3112244897959183,-0.3333333333333333,-0.5,-0.25,0.38655462184873957,0.1353599082305707,-0.25,0.0,0.1155168943083163
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-4138_50db442b,1,"/**
 * Starts a full major compaction of the tablets in the range (start, end]. The compaction is preformed even for tablets that have only one file.
 *
 * @param tableName
 *          the table to compact
 * @param start
 *          first tablet to be compacted contains the row after this row, null means the first tablet in table
 * @param end
 *          last tablet to be merged contains this row, null means the last tablet in table
 * @param iterators
 *          A set of iterators that will be applied to each tablet compacted
 * @param flush
 *          when true, table memory is flushed before compaction starts
 * @param wait
 *          when true, the call will not return until compactions are finished
 * @since 1.5.0
 */
void compact(String tableName, Text start, Text end, List<IteratorSetting> iterators, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException;","/**
 * Starts a full major compaction of the tablets in the range (start, end]. The compaction is preformed even for tablets that have only one file.
 *
 * @param tableName
 *          the table to compact
 * @param start
 *          first tablet to be compacted contains the row after this row, null means the first tablet in table
 * @param end
 *          last tablet to be merged contains this row, null means the last tablet in table
 * @param iterators
 *          A set of iterators that will be applied to each tablet compacted
 * @param flush
 *          when true, table memory is flushed before compaction starts
 * @param wait
 *          when true, the call will not return until compactions are finished
 * @since 1.5.0
 */
","void compact(String tableName, Text start, Text end, List<IteratorSetting> iterators, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException;",-0.5909090909090909,-1.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.4040722684255813,-0.5,0.3428571428571429,-0.16422749602751402
flink,remotes/origin/bugs-dot-jar_FLINK-1640_8f321c72,1,"/**
 *  Returns the final component of this path.
 *
 *  @return the final component of the path
 */
public String getName() {
    final String path = uri.getPath();
    if (path.endsWith(SEPARATOR)) {
        final int slash = path.lastIndexOf(SEPARATOR, path.length() - SEPARATOR.length() - 1);
        return path.substring(slash + 1, path.length() - SEPARATOR.length());
    } else {
        final int slash = path.lastIndexOf(SEPARATOR);
        return path.substring(slash + 1);
    }
}","/**
 *  Returns the final component of this path.
 *
 *  @return the final component of the path
 */
","public String getName() {
    final String path = uri.getPath();
    if (path.endsWith(SEPARATOR)) {
        final int slash = path.lastIndexOf(SEPARATOR, path.length() - SEPARATOR.length() - 1);
        return path.substring(slash + 1, path.length() - SEPARATOR.length());
    } else {
        final int slash = path.lastIndexOf(SEPARATOR);
        return path.substring(slash + 1);
    }
}",-0.18181818181818182,-0.015306122448979493,-0.3333333333333333,-0.5,-0.25,0.15126050420168072,0.18009750501864075,0.3333333333333333,0.05714285714285714,0.029497046868910106
wicket,remotes/origin/bugs-dot-jar_WICKET-2172_ea4a3f8a,3,"/**
 *  @see java.util.Map#putAll(java.util.Map)
 */
@Override
public void putAll(final Map map) {
    checkMutability();
    super.putAll(map);
}","/**
 *  @see java.util.Map#putAll(java.util.Map)
 */
","@Override
public void putAll(final Map map) {
    checkMutability();
    super.putAll(map);
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8213363923143101,-0.3333333333333333,2.685714285714286,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-4365_1485a856,1,"/**
 *  Process the form. Though you can override this method to provide your own algorithm, it is
 *  not recommended to do so.
 *
 *  <p>
 *  See the class documentation for further details on the form processing
 *  </p>
 *
 *  @param submittingComponent
 *             component responsible for submitting the form, or <code>null</code> if none (eg
 *             the form has been submitted via the enter key or javascript calling
 *             form.onsubmit())
 *
 *  @see #delegateSubmit(IFormSubmitter) for an easy way to process submitting component in the
 *       default manner
 */
public void process(IFormSubmitter submittingComponent) {
    // save the page in case the component is removed during submit
    final Page page = getPage();
    String hiddenFieldId = getHiddenFieldId();
    if (!isEnabledInHierarchy() || !isVisibleInHierarchy()) {
        // FIXME throw listener exception
        return;
    }
    // run validation
    validate();
    // If a validation error occurred
    if (hasError()) {
        // mark all children as invalid
        markFormComponentsInvalid();
        // let subclass handle error
        callOnError(submittingComponent);
    } else {
        // mark all children as valid
        markFormComponentsValid();
        // before updating, call the interception method for clients
        beforeUpdateFormComponentModels();
        // Update model using form data
        updateFormComponentModels();
        // validate model objects after input values have been bound
        onValidateModelObjects();
        if (hasError()) {
            callOnError(submittingComponent);
            return;
        }
        // Form has no error
        delegateSubmit(submittingComponent);
    }
}","/**
 *  Process the form. Though you can override this method to provide your own algorithm, it is
 *  not recommended to do so.
 *
 *  <p>
 *  See the class documentation for further details on the form processing
 *  </p>
 *
 *  @param submittingComponent
 *             component responsible for submitting the form, or <code>null</code> if none (eg
 *             the form has been submitted via the enter key or javascript calling
 *             form.onsubmit())
 *
 *  @see #delegateSubmit(IFormSubmitter) for an easy way to process submitting component in the
 *       default manner
 */
","public void process(IFormSubmitter submittingComponent) {
        final Page page = getPage();
    String hiddenFieldId = getHiddenFieldId();
    if (!isEnabledInHierarchy() || !isVisibleInHierarchy()) {
                return;
    }
        validate();
        if (hasError()) {
                markFormComponentsInvalid();
                callOnError(submittingComponent);
    } else {
                markFormComponentsValid();
                beforeUpdateFormComponentModels();
                updateFormComponentModels();
                onValidateModelObjects();
        if (hasError()) {
            callOnError(submittingComponent);
            return;
        }
                delegateSubmit(submittingComponent);
    }
}",0.36363636363636365,0.056122448979591774,0.0,0.0,0.16666666666666666,-0.13544241225902123,-0.17436191568683682,0.75,0.0,-0.08885519592600684
commons-math,remotes/origin/bugs-dot-jar_MATH-867_bfbb156d,1,"/**
 * @param x Normalized objective variables.
 * @return the original objective variables.
 */
public double[] decode(final double[] x) {
    if (boundaries == null) {
        return x;
    }
    double[] res = new double[x.length];
    for (int i = 0; i < x.length; i++) {
        double diff = boundaries[1][i] - boundaries[0][i];
        res[i] = diff * x[i];
    }
    return res;
}","/**
 * @param x Normalized objective variables.
 * @return the original objective variables.
 */
","public double[] decode(final double[] x) {
    if (boundaries == null) {
        return x;
    }
    double[] res = new double[x.length];
    for (int i = 0; i < x.length; i++) {
        double diff = boundaries[1][i] - boundaries[0][i];
        res[i] = diff * x[i];
    }
    return res;
}",-0.13636363636363635,-0.17857142857142863,-0.16666666666666666,-0.5,0.0,1.1300049431537322,0.14511041009463732,-0.5,2.1142857142857143,0.33041232477160887
camel,remotes/origin/bugs-dot-jar_CAMEL-3314_4badd9c5,1,"/**
 * Inspects this processor definition and resolves any property placeholders from its properties.
 * <p/>
 * This implementation will check all the getter/setter pairs on this instance and for all the values
 * (which is a String type) will be property placeholder resolved.
 *
 * @param routeContext the route context
 * @throws Exception is thrown if property placeholders was used and there was an error resolving them
 * @see org.apache.camel.CamelContext#resolvePropertyPlaceholders(String)
 * @see org.apache.camel.component.properties.PropertiesComponent
 */
protected void resolvePropertyPlaceholders(RouteContext routeContext) throws Exception {
    if (log.isTraceEnabled()) {
        log.trace(""Resolving property placeholders for: "" + this);
    }
    // find all String getter/setter
    Map<Object, Object> properties = new HashMap<Object, Object>();
    IntrospectionSupport.getProperties(this, properties, null);
    if (!properties.isEmpty()) {
        if (log.isTraceEnabled()) {
            log.trace(""There are "" + properties.size() + "" properties on: "" + this);
        }
        // lookup and resolve properties for String based properties
        for (Map.Entry entry : properties.entrySet()) {
            // the name is always a String
            String name = (String) entry.getKey();
            Object value = entry.getValue();
            if (value instanceof String) {
                // we can only resolve String typed values
                String text = (String) value;
                text = routeContext.getCamelContext().resolvePropertyPlaceholders(text);
                if (text != value) {
                    // invoke setter as the text has changed
                    IntrospectionSupport.setProperty(this, name, text);
                    if (log.isDebugEnabled()) {
                        log.debug(""Changed property ["" + name + ""] from: "" + value + "" to: "" + text);
                    }
                }
            }
        }
    }
}","/**
 * Inspects this processor definition and resolves any property placeholders from its properties.
 * <p/>
 * This implementation will check all the getter/setter pairs on this instance and for all the values
 * (which is a String type) will be property placeholder resolved.
 *
 * @param routeContext the route context
 * @throws Exception is thrown if property placeholders was used and there was an error resolving them
 * @see org.apache.camel.CamelContext#resolvePropertyPlaceholders(String)
 * @see org.apache.camel.component.properties.PropertiesComponent
 */
","protected void resolvePropertyPlaceholders(RouteContext routeContext) throws Exception {
    if (log.isTraceEnabled()) {
        log.trace(""Resolving property placeholders for: "" + this);
    }
        Map<Object, Object> properties = new HashMap<Object, Object>();
    IntrospectionSupport.getProperties(this, properties, null);
    if (!properties.isEmpty()) {
        if (log.isTraceEnabled()) {
            log.trace(""There are "" + properties.size() + "" properties on: "" + this);
        }
                for (Map.Entry entry : properties.entrySet()) {
                        String name = (String) entry.getKey();
            Object value = entry.getValue();
            if (value instanceof String) {
                                String text = (String) value;
                text = routeContext.getCamelContext().resolvePropertyPlaceholders(text);
                if (text != value) {
                                        IntrospectionSupport.setProperty(this, name, text);
                    if (log.isDebugEnabled()) {
                        log.debug(""Changed property ["" + name + ""] from: "" + value + "" to: "" + text);
                    }
                }
            }
        }
    }
}",0.5454545454545454,1.7653061224489799,0.6666666666666666,1.5,0.5,0.41028175976272874,-0.44565529108115887,0.75,-0.028571428571428574,0.5834093566500057
wicket,remotes/origin/bugs-dot-jar_WICKET-5853_b80f6640,3,"/**
 *  Parses a value as a String and returns a Number.
 *
 *  @param value
 *             The object to parse (after converting with toString())
 *  @param min
 *             The minimum allowed value
 *  @param max
 *             The maximum allowed value
 *  @param locale
 *  @return The number
 *  @throws ConversionException
 *              if value is unparsable or out of range
 */
protected N parse(Object value, final double min, final double max, Locale locale) {
    if (locale == null) {
        locale = Locale.getDefault();
    }
    if (value == null) {
        return null;
    } else if (value instanceof String) {
        // Convert spaces to no-break space (U+00A0) as required by Java formats:
        // http://bugs.sun.com/view_bug.do?bug_id=4510618
        value = ((String) value).replaceAll(""(\\d+)\\s(?=\\d)"", ""$1\u00A0"");
    }
    final NumberFormat numberFormat = getNumberFormat(locale);
    final N number = parse(numberFormat, value, locale);
    if (number == null) {
        return null;
    }
    if (number.doubleValue() < min) {
        throw newConversionException(""Value cannot be less than "" + min, value, locale).setFormat(numberFormat);
    }
    if (number.doubleValue() > max) {
        throw newConversionException(""Value cannot be greater than "" + max, value, locale).setFormat(numberFormat);
    }
    return number;
}","/**
 *  Parses a value as a String and returns a Number.
 *
 *  @param value
 *             The object to parse (after converting with toString())
 *  @param min
 *             The minimum allowed value
 *  @param max
 *             The maximum allowed value
 *  @param locale
 *  @return The number
 *  @throws ConversionException
 *              if value is unparsable or out of range
 */
","protected N parse(Object value, final double min, final double max, Locale locale) {
    if (locale == null) {
        locale = Locale.getDefault();
    }
    if (value == null) {
        return null;
    } else if (value instanceof String) {
                        value = ((String) value).replaceAll(""(\\d+)\\s(?=\\d)"", ""$1\u00A0"");
    }
    final NumberFormat numberFormat = getNumberFormat(locale);
    final N number = parse(numberFormat, value, locale);
    if (number == null) {
        return null;
    }
    if (number.doubleValue() < min) {
        throw newConversionException(""Value cannot be less than "" + min, value, locale).setFormat(numberFormat);
    }
    if (number.doubleValue() > max) {
        throw newConversionException(""Value cannot be greater than "" + max, value, locale).setFormat(numberFormat);
    }
    return number;
}",0.36363636363636365,-0.36734693877551033,0.8333333333333334,0.0,0.5833333333333334,0.592189817103312,-0.3375394321766561,0.3333333333333333,-0.028571428571428574,0.5518735999931472
Codec,1,1,"/**
 * Find the metaphone value of a String. This is similar to the
 * soundex algorithm, but better at finding similar sounding words.
 * All input is converted to upper case.
 * Limitations: Input format is expected to be a single ASCII word
 * with only characters in the A - Z range, no punctuation or numbers.
 *
 * @param txt String to find the metaphone code for
 * @return A metaphone code corresponding to the String supplied
 */
public String metaphone(String txt) {
    boolean hard = false;
    if ((txt == null) || (txt.length() == 0)) {
        return """";
    }
    // single character is itself
    if (txt.length() == 1) {
        return txt.toUpperCase();
    }
    char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
    // manipulate
    StringBuffer local = new StringBuffer(40);
    // output
    StringBuffer code = new StringBuffer(10);
    // handle initial 2 characters exceptions
    switch(inwd[0]) {
        case 'K':
        case 'G':
        case 'P':
            /* looking for KN, etc*/
            if (inwd[1] == 'N') {
                local.append(inwd, 1, inwd.length - 1);
            } else {
                local.append(inwd);
            }
            break;
        case 'A':
            /* looking for AE */
            if (inwd[1] == 'E') {
                local.append(inwd, 1, inwd.length - 1);
            } else {
                local.append(inwd);
            }
            break;
        case 'W':
            /* looking for WR or WH */
            if (inwd[1] == 'R') {
                // WR -> R
                local.append(inwd, 1, inwd.length - 1);
                break;
            }
            if (inwd[1] == 'H') {
                local.append(inwd, 1, inwd.length - 1);
                // WH -> W
                local.setCharAt(0, 'W');
            } else {
                local.append(inwd);
            }
            break;
        case 'X':
            /* initial X becomes S */
            inwd[0] = 'S';
            local.append(inwd);
            break;
        default:
            local.append(inwd);
    }
    // now local has working string with initials fixed
    int wdsz = local.length();
    int n = 0;
    while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
        // max code size of 4 works well
        char symb = local.charAt(n);
        // remove duplicate letters except C
        if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
            n++;
        } else {
            // not dup
            switch(symb) {
                case 'A':
                case 'E':
                case 'I':
                case 'O':
                case 'U':
                    if (n == 0) {
                        code.append(symb);
                    }
                    // only use vowel if leading char
                    break;
                case 'B':
                    if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
                        // B is silent if word ends in MB
                        break;
                    }
                    code.append(symb);
                    break;
                case // lots of C special cases
                'C':
                    /* discard if SCI, SCE or SCY */
                    if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
                        break;
                    }
                    if (regionMatch(local, n, ""CIA"")) {
                        // ""CIA"" -> X
                        code.append('X');
                        break;
                    }
                    if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
                        code.append('S');
                        // CI,CE,CY -> S
                        break;
                    }
                    if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
                        // SCH->sk
                        code.append('K');
                        break;
                    }
                    if (isNextChar(local, n, 'H')) {
                        // detect CH
                        if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
                            // CH consonant -> K consonant
                            code.append('K');
                        } else {
                            // CHvowel -> X
                            code.append('X');
                        }
                    } else {
                        code.append('K');
                    }
                    break;
                case 'D':
                    if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
                        // DGE DGI DGY -> J
                        code.append('J');
                        n += 2;
                    } else {
                        code.append('T');
                    }
                    break;
                case // GH silent at end or before consonant
                'G':
                    if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
                        break;
                    }
                    if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
                        break;
                    }
                    if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
                        // silent G
                        break;
                    }
                    if (isPreviousChar(local, n, 'G')) {
                        hard = true;
                    } else {
                        hard = false;
                    }
                    if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
                        code.append('J');
                    } else {
                        code.append('K');
                    }
                    break;
                case 'H':
                    if (isLastChar(wdsz, n)) {
                        // terminal H
                        break;
                    }
                    if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
                        break;
                    }
                    if (isVowel(local, n + 1)) {
                        // Hvowel
                        code.append('H');
                    }
                    break;
                case 'F':
                case 'J':
                case 'L':
                case 'M':
                case 'N':
                case 'R':
                    code.append(symb);
                    break;
                case 'K':
                    if (n > 0) {
                        // not initial
                        if (!isPreviousChar(local, n, 'C')) {
                            code.append(symb);
                        }
                    } else {
                        // initial K
                        code.append(symb);
                    }
                    break;
                case 'P':
                    if (isNextChar(local, n, 'H')) {
                        // PH -> F
                        code.append('F');
                    } else {
                        code.append(symb);
                    }
                    break;
                case 'Q':
                    code.append('K');
                    break;
                case 'S':
                    if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
                        code.append('X');
                    } else {
                        code.append('S');
                    }
                    break;
                case 'T':
                    if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
                        code.append('X');
                        break;
                    }
                    if (regionMatch(local, n, ""TCH"")) {
                        // Silent if in ""TCH""
                        break;
                    }
                    // substitute numeral 0 for TH (resembles theta after all)
                    if (regionMatch(local, n, ""TH"")) {
                        code.append('0');
                    } else {
                        code.append('T');
                    }
                    break;
                case 'V':
                    code.append('F');
                    break;
                case 'W':
                case // silent if not followed by vowel
                'Y':
                    if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
                        code.append(symb);
                    }
                    break;
                case 'X':
                    code.append('K');
                    code.append('S');
                    break;
                case 'Z':
                    code.append('S');
                    break;
            }
            // end switch
            n++;
        }
        // end else from symb != 'C'
        if (code.length() > this.getMaxCodeLen()) {
            code.setLength(this.getMaxCodeLen());
        }
    }
    return code.toString();
}","/**
 * Find the metaphone value of a String. This is similar to the
 * soundex algorithm, but better at finding similar sounding words.
 * All input is converted to upper case.
 * Limitations: Input format is expected to be a single ASCII word
 * with only characters in the A - Z range, no punctuation or numbers.
 *
 * @param txt String to find the metaphone code for
 * @return A metaphone code corresponding to the String supplied
 */
","public String metaphone(String txt) {
    boolean hard = false;
    if ((txt == null) || (txt.length() == 0)) {
        return """";
    }
        if (txt.length() == 1) {
        return txt.toUpperCase();
    }
    char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
        StringBuffer local = new StringBuffer(40);
        StringBuffer code = new StringBuffer(10);
        switch(inwd[0]) {
        case 'K':
        case 'G':
        case 'P':
                        if (inwd[1] == 'N') {
                local.append(inwd, 1, inwd.length - 1);
            } else {
                local.append(inwd);
            }
            break;
        case 'A':
                        if (inwd[1] == 'E') {
                local.append(inwd, 1, inwd.length - 1);
            } else {
                local.append(inwd);
            }
            break;
        case 'W':
                        if (inwd[1] == 'R') {
                                local.append(inwd, 1, inwd.length - 1);
                break;
            }
            if (inwd[1] == 'H') {
                local.append(inwd, 1, inwd.length - 1);
                                local.setCharAt(0, 'W');
            } else {
                local.append(inwd);
            }
            break;
        case 'X':
                        inwd[0] = 'S';
            local.append(inwd);
            break;
        default:
            local.append(inwd);
    }
        int wdsz = local.length();
    int n = 0;
    while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {
                char symb = local.charAt(n);
                if ((symb != 'C') && (isPreviousChar(local, n, symb))) {
            n++;
        } else {
                        switch(symb) {
                case 'A':
                case 'E':
                case 'I':
                case 'O':
                case 'U':
                    if (n == 0) {
                        code.append(symb);
                    }
                                        break;
                case 'B':
                    if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
                                                break;
                    }
                    code.append(symb);
                    break;
                case                 'C':
                                        if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
                        break;
                    }
                    if (regionMatch(local, n, ""CIA"")) {
                                                code.append('X');
                        break;
                    }
                    if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
                        code.append('S');
                                                break;
                    }
                    if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
                                                code.append('K');
                        break;
                    }
                    if (isNextChar(local, n, 'H')) {
                                                if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {
                                                        code.append('K');
                        } else {
                                                        code.append('X');
                        }
                    } else {
                        code.append('K');
                    }
                    break;
                case 'D':
                    if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {
                                                code.append('J');
                        n += 2;
                    } else {
                        code.append('T');
                    }
                    break;
                case                 'G':
                    if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
                        break;
                    }
                    if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
                        break;
                    }
                    if ((n > 0) && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
                                                break;
                    }
                    if (isPreviousChar(local, n, 'G')) {
                        hard = true;
                    } else {
                        hard = false;
                    }
                    if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {
                        code.append('J');
                    } else {
                        code.append('K');
                    }
                    break;
                case 'H':
                    if (isLastChar(wdsz, n)) {
                                                break;
                    }
                    if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
                        break;
                    }
                    if (isVowel(local, n + 1)) {
                                                code.append('H');
                    }
                    break;
                case 'F':
                case 'J':
                case 'L':
                case 'M':
                case 'N':
                case 'R':
                    code.append(symb);
                    break;
                case 'K':
                    if (n > 0) {
                                                if (!isPreviousChar(local, n, 'C')) {
                            code.append(symb);
                        }
                    } else {
                                                code.append(symb);
                    }
                    break;
                case 'P':
                    if (isNextChar(local, n, 'H')) {
                                                code.append('F');
                    } else {
                        code.append(symb);
                    }
                    break;
                case 'Q':
                    code.append('K');
                    break;
                case 'S':
                    if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
                        code.append('X');
                    } else {
                        code.append('S');
                    }
                    break;
                case 'T':
                    if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
                        code.append('X');
                        break;
                    }
                    if (regionMatch(local, n, ""TCH"")) {
                                                break;
                    }
                                        if (regionMatch(local, n, ""TH"")) {
                        code.append('0');
                    } else {
                        code.append('T');
                    }
                    break;
                case 'V':
                    code.append('F');
                    break;
                case 'W':
                case                 'Y':
                    if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
                        code.append(symb);
                    }
                    break;
                case 'X':
                    code.append('K');
                    code.append('S');
                    break;
                case 'Z':
                    code.append('S');
                    break;
            }
                        n++;
        }
                if (code.length() > this.getMaxCodeLen()) {
            code.setLength(this.getMaxCodeLen());
        }
    }
    return code.toString();
}",9.0,1.576530612244898,16.166666666666668,2.0,10.166666666666666,6.090954028670292,-2.336392314310296,7.666666666666667,-0.028571428571428574,46.297822949190724
wicket,remotes/origin/bugs-dot-jar_WICKET-428_4a6a573b,3,"/**
 *  @see java.util.Map#keySet()
 */
public Set keySet() {
    return new AbstractSet() {

        public Iterator iterator() {
            return new Iterator() {

                public boolean hasNext() {
                    return i < size;
                }

                public Object next() {
                    // Find next key
                    i = nextKey(nextIndex(i));
                    // Just in case... (WICKET-428)
                    if (!hasNext()) {
                        throw new NoSuchElementException();
                    }
                    // Get key
                    return keys[i];
                }

                public void remove() {
                    keys[i] = null;
                    values[i] = null;
                    size--;
                }

                int i = -1;
            };
        }

        public int size() {
            return size;
        }
    };
}","/**
 *  @see java.util.Map#keySet()
 */
","public Set keySet() {
    return new AbstractSet() {

        public Iterator iterator() {
            return new Iterator() {

                public boolean hasNext() {
                    return i < size;
                }

                public Object next() {
                                        i = nextKey(nextIndex(i));
                                        if (!hasNext()) {
                        throw new NoSuchElementException();
                    }
                                        return keys[i];
                }

                public void remove() {
                    keys[i] = null;
                    values[i] = null;
                    size--;
                }

                int i = -1;
            };
        }

        public int size() {
            return size;
        }
    };
}",0.5909090909090909,1.8061224489795917,-0.16666666666666666,0.5,-0.25,0.2857142857142858,-0.3008316604531119,-0.25,2.085714285714286,0.1003593440151447
maven,remotes/origin/bugs-dot-jar_MNG-5645_af1ecd5f,3,"private static Integer getNextIntegerToken(StringTokenizer tok) {
    String s = tok.nextToken();
    if ((s.length() > 1) && s.startsWith(""0"")) {
        throw new NumberFormatException(""Number part has a leading 0: '"" + s + ""'"");
    }
    return Integer.valueOf(s);
}",,"private static Integer getNextIntegerToken(StringTokenizer tok) {
    String s = tok.nextToken();
    if ((s.length() > 1) && s.startsWith(""0"")) {
        throw new NumberFormatException(""Number part has a leading 0: '"" + s + ""'"");
    }
    return Integer.valueOf(s);
}",-0.3181818181818182,-0.2346938775510204,-0.16666666666666666,-0.5,-0.08333333333333333,0.1631240731586753,0.39919701749354763,-0.16666666666666666,1.0,-0.031874113953597946
Closure,16,2,"private void fixTypeNode(Node typeNode) {
    if (typeNode.isString()) {
        String name = typeNode.getString();
        int endIndex = name.indexOf('.');
        if (endIndex == -1) {
            endIndex = name.length();
        }
        String baseName = name.substring(0, endIndex);
        Var aliasVar = aliases.get(baseName);
        if (aliasVar != null) {
            Node aliasedNode = aliasVar.getInitialValue();
            aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));
        }
    }
    for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) {
        fixTypeNode(child);
    }
}",,"private void fixTypeNode(Node typeNode) {
    if (typeNode.isString()) {
        String name = typeNode.getString();
        int endIndex = name.indexOf('.');
        if (endIndex == -1) {
            endIndex = name.length();
        }
        String baseName = name.substring(0, endIndex);
        Var aliasVar = aliases.get(baseName);
        if (aliasVar != null) {
            Node aliasedNode = aliasVar.getInitialValue();
            aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));
        }
    }
    for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) {
        fixTypeNode(child);
    }
}",0.18181818181818182,0.2346938775510204,0.16666666666666666,0.0,0.25,0.35689569945625316,-0.22368798394034986,0.5833333333333334,0.0,0.40168579027843804
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-888_6d82cb64,1,"/**
 * Calculate the number of elements in the path. The root path has zero
 * elements.
 *
 * @param path the path
 * @return the number of elements
 */
public static int getDepth(String path) {
    assert isValid(path);
    int count = 1, i = 0;
    if (isAbsolutePath(path)) {
        if (denotesRootPath(path)) {
            return 0;
        }
        i++;
    }
    while (true) {
        i = path.indexOf('/', i) + 1;
        if (i == 0) {
            return count;
        }
        count++;
    }
}","/**
 * Calculate the number of elements in the path. The root path has zero
 * elements.
 *
 * @param path the path
 * @return the number of elements
 */
","public static int getDepth(String path) {
    assert isValid(path);
    int count = 1, i = 0;
    if (isAbsolutePath(path)) {
        if (denotesRootPath(path)) {
            return 0;
        }
        i++;
    }
    while (true) {
        i = path.indexOf('/', i) + 1;
        if (i == 0) {
            return count;
        }
        count++;
    }
}",0.13636363636363635,0.1887755102040817,0.16666666666666666,0.0,0.25,-0.3806228373702422,0.3679380556352166,-0.16666666666666666,0.39999999999999997,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1369_ce0b0955,1,"@Override
public String toString() {
    String leftExpr;
    boolean leftExprIsName;
    if (left == null) {
        leftExprIsName = false;
        leftExpr = """";
    } else {
        leftExprIsName = left.isName();
        leftExpr = left.toString();
        if (left.getPrecedence() < precedence) {
            leftExpr = ""("" + leftExpr + "")"";
        }
    }
    boolean impossible = false;
    String rightExpr;
    if (right == null) {
        rightExpr = """";
    } else {
        if (left != null && left instanceof Property && ((Property) left).implicitAsterisk) {
            throw new IllegalArgumentException(""Missing @ in front of the property name: "" + left);
        }
        if (leftExprIsName && !""like"".equals(operator)) {
            // need to de-escape _x0020_ and so on
            if (!(right instanceof Literal)) {
                throw new IllegalArgumentException(""Can only compare a name against a string literal, not "" + right);
            }
            Literal l = (Literal) right;
            String raw = l.rawText;
            String decoded = ISO9075.decode(raw);
            String encoded = ISO9075.encode(decoded);
            rightExpr = SQL2Parser.escapeStringLiteral(decoded);
            if (!encoded.equalsIgnoreCase(raw)) {
                // nothing can potentially match
                impossible = true;
            }
        } else {
            rightExpr = right.toString();
        }
        if (right.getPrecedence() < precedence) {
            rightExpr = ""("" + right + "")"";
        }
    }
    if (impossible) {
        // a condition that can not possibly be true
        return ""upper("" + leftExpr + "") = 'never matches'"";
    }
    return (leftExpr + "" "" + operator + "" "" + rightExpr).trim();
}",,"@Override
public String toString() {
    String leftExpr;
    boolean leftExprIsName;
    if (left == null) {
        leftExprIsName = false;
        leftExpr = """";
    } else {
        leftExprIsName = left.isName();
        leftExpr = left.toString();
        if (left.getPrecedence() < precedence) {
            leftExpr = ""("" + leftExpr + "")"";
        }
    }
    boolean impossible = false;
    String rightExpr;
    if (right == null) {
        rightExpr = """";
    } else {
        if (left != null && left instanceof Property && ((Property) left).implicitAsterisk) {
            throw new IllegalArgumentException(""Missing @ in front of the property name: "" + left);
        }
        if (leftExprIsName && !""like"".equals(operator)) {
                        if (!(right instanceof Literal)) {
                throw new IllegalArgumentException(""Can only compare a name against a string literal, not "" + right);
            }
            Literal l = (Literal) right;
            String raw = l.rawText;
            String decoded = ISO9075.decode(raw);
            String encoded = ISO9075.encode(decoded);
            rightExpr = SQL2Parser.escapeStringLiteral(decoded);
            if (!encoded.equalsIgnoreCase(raw)) {
                                impossible = true;
            }
        } else {
            rightExpr = right.toString();
        }
        if (right.getPrecedence() < precedence) {
            rightExpr = ""("" + right + "")"";
        }
    }
    if (impossible) {
                return ""upper("" + leftExpr + "") = 'never matches'"";
    }
    return (leftExpr + "" "" + operator + "" "" + rightExpr).trim();
}",1.4545454545454546,0.5,1.3333333333333333,0.5,1.5833333333333333,0.9995056846267921,-0.8167479208488676,0.4166666666666667,-0.028571428571428574,2.0619065362920326
camel,remotes/origin/bugs-dot-jar_CAMEL-3395_8433e6db,3,"@SuppressWarnings(""unchecked"")
private Iterable<ProcessorExchangePair> createProcessorExchangePairsIterable(final Exchange exchange, final Object value) {
    final Iterator iterator = ObjectHelper.createIterator(value);
    return new Iterable() {

        public Iterator iterator() {
            return new Iterator() {

                private int index;

                private boolean closed;

                public boolean hasNext() {
                    if (closed) {
                        return false;
                    }
                    boolean answer = iterator.hasNext();
                    if (!answer) {
                        // we are now closed
                        closed = true;
                        // nothing more so we need to close the expression value in case it needs to be
                        if (value instanceof Closeable) {
                            IOHelper.close((Closeable) value, value.getClass().getName(), LOG);
                        } else if (value instanceof Scanner) {
                            // special for Scanner as it does not implement Closeable
                            ((Scanner) value).close();
                        }
                    }
                    return answer;
                }

                public Object next() {
                    Object part = iterator.next();
                    Exchange newExchange = exchange.copy();
                    if (part instanceof Message) {
                        newExchange.setIn((Message) part);
                    } else {
                        Message in = newExchange.getIn();
                        in.setBody(part);
                    }
                    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);
                }

                public void remove() {
                    throw new UnsupportedOperationException(""Remove is not supported by this iterator"");
                }
            };
        }
    };
}",,"@SuppressWarnings(""unchecked"")
private Iterable<ProcessorExchangePair> createProcessorExchangePairsIterable(final Exchange exchange, final Object value) {
    final Iterator iterator = ObjectHelper.createIterator(value);
    return new Iterable() {

        public Iterator iterator() {
            return new Iterator() {

                private int index;

                private boolean closed;

                public boolean hasNext() {
                    if (closed) {
                        return false;
                    }
                    boolean answer = iterator.hasNext();
                    if (!answer) {
                                                closed = true;
                                                if (value instanceof Closeable) {
                            IOHelper.close((Closeable) value, value.getClass().getName(), LOG);
                        } else if (value instanceof Scanner) {
                                                        ((Scanner) value).close();
                        }
                    }
                    return answer;
                }

                public Object next() {
                    Object part = iterator.next();
                    Exchange newExchange = exchange.copy();
                    if (part instanceof Message) {
                        newExchange.setIn((Message) part);
                    } else {
                        Message in = newExchange.getIn();
                        in.setBody(part);
                    }
                    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);
                }

                public void remove() {
                    throw new UnsupportedOperationException(""Remove is not supported by this iterator"");
                }
            };
        }
    };
}",1.2272727272727273,2.3163265306122445,0.5,1.5,0.3333333333333333,-0.004943153732081051,-0.6616002294235737,0.75,-0.028571428571428574,0.21833896548327275
Math,6,1,"/**
 * {@inheritDoc}
 */
@Override
protected PointValuePair doOptimize() {
    checkParameters();
    final GoalType goal = getGoalType();
    final double[] guess = getStartPoint();
    final int n = guess.length;
    final double[][] direc = new double[n][n];
    for (int i = 0; i < n; i++) {
        direc[i][i] = 1;
    }
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    double[] x = guess;
    double fVal = computeObjectiveValue(x);
    double[] x1 = x.clone();
    int iter = 0;
    while (true) {
        ++iter;
        double fX = fVal;
        double fX2 = 0;
        double delta = 0;
        int bigInd = 0;
        double alphaMin = 0;
        for (int i = 0; i < n; i++) {
            final double[] d = MathArrays.copyOf(direc[i]);
            fX2 = fVal;
            final UnivariatePointValuePair optimum = line.search(x, d);
            fVal = optimum.getValue();
            alphaMin = optimum.getPoint();
            final double[][] result = newPointAndDirection(x, d, alphaMin);
            x = result[0];
            if ((fX2 - fVal) > delta) {
                delta = fX2 - fVal;
                bigInd = i;
            }
        }
        // Default convergence check.
        boolean stop = 2 * (fX - fVal) <= (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) + absoluteThreshold);
        final PointValuePair previous = new PointValuePair(x1, fX);
        final PointValuePair current = new PointValuePair(x, fVal);
        if (!stop) {
            // User-defined stopping criteria.
            if (checker != null) {
                stop = checker.converged(iter, previous, current);
            }
        }
        if (stop) {
            if (goal == GoalType.MINIMIZE) {
                return (fVal < fX) ? current : previous;
            } else {
                return (fVal > fX) ? current : previous;
            }
        }
        final double[] d = new double[n];
        final double[] x2 = new double[n];
        for (int i = 0; i < n; i++) {
            d[i] = x[i] - x1[i];
            x2[i] = 2 * x[i] - x1[i];
        }
        x1 = x.clone();
        fX2 = computeObjectiveValue(x2);
        if (fX > fX2) {
            double t = 2 * (fX + fX2 - 2 * fVal);
            double temp = fX - fVal - delta;
            t *= temp * temp;
            temp = fX - fX2;
            t -= delta * temp * temp;
            if (t < 0.0) {
                final UnivariatePointValuePair optimum = line.search(x, d);
                fVal = optimum.getValue();
                alphaMin = optimum.getPoint();
                final double[][] result = newPointAndDirection(x, d, alphaMin);
                x = result[0];
                final int lastInd = n - 1;
                direc[bigInd] = direc[lastInd];
                direc[lastInd] = result[1];
            }
        }
    }
}","/**
 * {@inheritDoc}
 */
","@Override
protected PointValuePair doOptimize() {
    checkParameters();
    final GoalType goal = getGoalType();
    final double[] guess = getStartPoint();
    final int n = guess.length;
    final double[][] direc = new double[n][n];
    for (int i = 0; i < n; i++) {
        direc[i][i] = 1;
    }
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    double[] x = guess;
    double fVal = computeObjectiveValue(x);
    double[] x1 = x.clone();
    int iter = 0;
    while (true) {
        ++iter;
        double fX = fVal;
        double fX2 = 0;
        double delta = 0;
        int bigInd = 0;
        double alphaMin = 0;
        for (int i = 0; i < n; i++) {
            final double[] d = MathArrays.copyOf(direc[i]);
            fX2 = fVal;
            final UnivariatePointValuePair optimum = line.search(x, d);
            fVal = optimum.getValue();
            alphaMin = optimum.getPoint();
            final double[][] result = newPointAndDirection(x, d, alphaMin);
            x = result[0];
            if ((fX2 - fVal) > delta) {
                delta = fX2 - fVal;
                bigInd = i;
            }
        }
                boolean stop = 2 * (fX - fVal) <= (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) + absoluteThreshold);
        final PointValuePair previous = new PointValuePair(x1, fX);
        final PointValuePair current = new PointValuePair(x, fVal);
        if (!stop) {
                        if (checker != null) {
                stop = checker.converged(iter, previous, current);
            }
        }
        if (stop) {
            if (goal == GoalType.MINIMIZE) {
                return (fVal < fX) ? current : previous;
            } else {
                return (fVal > fX) ? current : previous;
            }
        }
        final double[] d = new double[n];
        final double[] x2 = new double[n];
        for (int i = 0; i < n; i++) {
            d[i] = x[i] - x1[i];
            x2[i] = 2 * x[i] - x1[i];
        }
        x1 = x.clone();
        fX2 = computeObjectiveValue(x2);
        if (fX > fX2) {
            double t = 2 * (fX + fX2 - 2 * fVal);
            double temp = fX - fVal - delta;
            t *= temp * temp;
            temp = fX - fX2;
            t -= delta * temp * temp;
            if (t < 0.0) {
                final UnivariatePointValuePair optimum = line.search(x, d);
                fVal = optimum.getValue();
                alphaMin = optimum.getPoint();
                final double[][] result = newPointAndDirection(x, d, alphaMin);
                x = result[0];
                final int lastInd = n - 1;
                direc[bigInd] = direc[lastInd];
                direc[lastInd] = result[1];
            }
        }
    }
}",2.8636363636363638,0.6683673469387755,1.6666666666666667,0.5,1.5,4.058329214038557,-1.205620877545168,1.1666666666666667,-0.028571428571428574,17.69224476509866
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3324_5f863af6,1,"private boolean hasPermissions(@Nonnull Iterator<PermissionEntry> entries, long permissions, @Nullable String path) {
    // calculate readable paths if the given permissions includes any read permission.
    boolean isReadable = Permissions.diff(Permissions.READ, permissions) != Permissions.READ && readPolicy.isReadablePath(path, false);
    if (!entries.hasNext() && !isReadable) {
        return false;
    }
    boolean respectParent = (path != null) && Permissions.respectParentPermissions(permissions);
    long allows = (isReadable) ? Permissions.READ : Permissions.NO_PERMISSION;
    long denies = Permissions.NO_PERMISSION;
    PrivilegeBits allowBits = PrivilegeBits.getInstance();
    if (isReadable) {
        allowBits.add(bitsProvider.getBits(PrivilegeConstants.JCR_READ));
    }
    PrivilegeBits denyBits = PrivilegeBits.getInstance();
    PrivilegeBits parentAllowBits;
    PrivilegeBits parentDenyBits;
    String parentPath;
    if (respectParent) {
        parentAllowBits = PrivilegeBits.getInstance();
        parentDenyBits = PrivilegeBits.getInstance();
        parentPath = PermissionUtil.getParentPathOrNull(path);
    } else {
        parentAllowBits = PrivilegeBits.EMPTY;
        parentDenyBits = PrivilegeBits.EMPTY;
        parentPath = null;
    }
    while (entries.hasNext()) {
        PermissionEntry entry = entries.next();
        if (respectParent && (parentPath != null)) {
            boolean matchesParent = entry.matchesParent(parentPath);
            if (matchesParent) {
                if (entry.isAllow) {
                    parentAllowBits.addDifference(entry.privilegeBits, parentDenyBits);
                } else {
                    parentDenyBits.addDifference(entry.privilegeBits, parentAllowBits);
                }
            }
        }
        if (entry.isAllow) {
            allowBits.addDifference(entry.privilegeBits, denyBits);
            long ap = PrivilegeBits.calculatePermissions(allowBits, parentAllowBits, true);
            allows |= Permissions.diff(ap, denies);
            if ((allows | ~permissions) == -1) {
                return true;
            }
        } else {
            denyBits.addDifference(entry.privilegeBits, allowBits);
            long dp = PrivilegeBits.calculatePermissions(denyBits, parentDenyBits, false);
            denies |= Permissions.diff(dp, allows);
            if (Permissions.includes(denies, permissions)) {
                return false;
            }
        }
    }
    return (allows | ~permissions) == -1;
}",,"private boolean hasPermissions(@Nonnull Iterator<PermissionEntry> entries, long permissions, @Nullable String path) {
        boolean isReadable = Permissions.diff(Permissions.READ, permissions) != Permissions.READ && readPolicy.isReadablePath(path, false);
    if (!entries.hasNext() && !isReadable) {
        return false;
    }
    boolean respectParent = (path != null) && Permissions.respectParentPermissions(permissions);
    long allows = (isReadable) ? Permissions.READ : Permissions.NO_PERMISSION;
    long denies = Permissions.NO_PERMISSION;
    PrivilegeBits allowBits = PrivilegeBits.getInstance();
    if (isReadable) {
        allowBits.add(bitsProvider.getBits(PrivilegeConstants.JCR_READ));
    }
    PrivilegeBits denyBits = PrivilegeBits.getInstance();
    PrivilegeBits parentAllowBits;
    PrivilegeBits parentDenyBits;
    String parentPath;
    if (respectParent) {
        parentAllowBits = PrivilegeBits.getInstance();
        parentDenyBits = PrivilegeBits.getInstance();
        parentPath = PermissionUtil.getParentPathOrNull(path);
    } else {
        parentAllowBits = PrivilegeBits.EMPTY;
        parentDenyBits = PrivilegeBits.EMPTY;
        parentPath = null;
    }
    while (entries.hasNext()) {
        PermissionEntry entry = entries.next();
        if (respectParent && (parentPath != null)) {
            boolean matchesParent = entry.matchesParent(parentPath);
            if (matchesParent) {
                if (entry.isAllow) {
                    parentAllowBits.addDifference(entry.privilegeBits, parentDenyBits);
                } else {
                    parentDenyBits.addDifference(entry.privilegeBits, parentAllowBits);
                }
            }
        }
        if (entry.isAllow) {
            allowBits.addDifference(entry.privilegeBits, denyBits);
            long ap = PrivilegeBits.calculatePermissions(allowBits, parentAllowBits, true);
            allows |= Permissions.diff(ap, denies);
            if ((allows | ~permissions) == -1) {
                return true;
            }
        } else {
            denyBits.addDifference(entry.privilegeBits, allowBits);
            long dp = PrivilegeBits.calculatePermissions(denyBits, parentDenyBits, false);
            denies |= Permissions.diff(dp, allows);
            if (Permissions.includes(denies, permissions)) {
                return false;
            }
        }
    }
    return (allows | ~permissions) == -1;
}",1.8636363636363635,0.8775510204081634,1.3333333333333333,1.0,1.5,1.9920909540286704,-0.9592773157441931,1.4166666666666667,-0.028571428571428574,5.543281894458222
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443,1,"@Override
public void setLocalityGroups(String tableName, Map<String, Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {
}",,"@Override
public void setLocalityGroups(String tableName, Map<String, Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {
}",-0.5,-1.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9374820762833384,-0.5,-0.028571428571428574,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-934_724795b5,3,"/**
 * {@inheritDoc}
 */
public Complex reciprocal() {
    if (isNaN) {
        return NaN;
    }
    if (real == 0.0 && imaginary == 0.0) {
        return NaN;
    }
    if (isInfinite) {
        return ZERO;
    }
    if (FastMath.abs(real) < FastMath.abs(imaginary)) {
        double q = real / imaginary;
        double scale = 1. / (real * q + imaginary);
        return createComplex(scale * q, -scale);
    } else {
        double q = imaginary / real;
        double scale = 1. / (imaginary * q + real);
        return createComplex(scale, -scale * q);
    }
}","/**
 * {@inheritDoc}
 */
","public Complex reciprocal() {
    if (isNaN) {
        return NaN;
    }
    if (real == 0.0 && imaginary == 0.0) {
        return NaN;
    }
    if (isInfinite) {
        return ZERO;
    }
    if (FastMath.abs(real) < FastMath.abs(imaginary)) {
        double q = real / imaginary;
        double scale = 1. / (real * q + imaginary);
        return createComplex(scale * q, -scale);
    } else {
        double q = imaginary / real;
        double scale = 1. / (imaginary * q + real);
        return createComplex(scale, -scale * q);
    }
}",0.2727272727272727,-0.20408163265306117,0.16666666666666666,-0.5,0.5,1.6955017301038064,-0.24003441353599103,-0.16666666666666666,0.4857142857142857,1.114167748125115
wicket,remotes/origin/bugs-dot-jar_WICKET-5259_a9e56e1e,1,"/**
 *  Parses the given URL string.
 *
 *  @param _url
 *             absolute or relative url with query string
 *  @param charset
 *  @return Url object
 */
public static Url parse(CharSequence _url, Charset charset) {
    Args.notNull(_url, ""_url"");
    final Url result = new Url(charset);
    // the url object resolved the charset, use that
    charset = result.getCharset();
    String url = _url.toString();
    // extract query string part
    final String queryString;
    final String absoluteUrl;
    final int queryAt = url.indexOf('?');
    if (queryAt == -1) {
        queryString = """";
        absoluteUrl = url;
    } else {
        absoluteUrl = url.substring(0, queryAt);
        queryString = url.substring(queryAt + 1);
    }
    // get absolute / relative part of url
    String relativeUrl;
    final int idxOfFirstSlash = absoluteUrl.indexOf('/');
    final int protocolAt = absoluteUrl.indexOf(""://"");
    // full urls start either with a ""scheme://"" or with ""//""
    boolean protocolLess = absoluteUrl.startsWith(""//"");
    final boolean isFull = (protocolAt > 1 && (protocolAt < idxOfFirstSlash)) || protocolLess;
    if (isFull) {
        if (protocolLess == false) {
            result.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);
        }
        final String afterProto = absoluteUrl.substring(protocolAt + 3);
        final String hostAndPort;
        int relativeAt = afterProto.indexOf('/');
        if (relativeAt == -1) {
            relativeAt = afterProto.indexOf(';');
        }
        if (relativeAt == -1) {
            relativeUrl = """";
            hostAndPort = afterProto;
        } else {
            relativeUrl = afterProto.substring(relativeAt);
            hostAndPort = afterProto.substring(0, relativeAt);
        }
        final int portAt = hostAndPort.lastIndexOf(':');
        if (portAt == -1) {
            result.host = hostAndPort;
            result.port = getDefaultPortForProtocol(result.protocol);
        } else {
            result.host = hostAndPort.substring(0, portAt);
            result.port = Integer.parseInt(hostAndPort.substring(portAt + 1));
        }
        if (relativeAt < 0) {
            relativeUrl = ""/"";
        }
    } else {
        relativeUrl = absoluteUrl;
    }
    if (relativeUrl.length() > 0) {
        boolean removeLast = false;
        if (relativeUrl.endsWith(""/"")) {
            // we need to append something and remove it after splitting
            // because otherwise the
            // trailing slashes will be lost
            relativeUrl += ""/x"";
            removeLast = true;
        }
        String[] segmentArray = Strings.split(relativeUrl, '/');
        if (removeLast) {
            segmentArray[segmentArray.length - 1] = null;
        }
        for (String s : segmentArray) {
            if (s != null) {
                result.segments.add(decodeSegment(s, charset));
            }
        }
    }
    if (queryString.length() > 0) {
        String[] queryArray = Strings.split(queryString, '&');
        for (String s : queryArray) {
            if (Strings.isEmpty(s) == false) {
                result.parameters.add(parseQueryParameter(s, charset));
            }
        }
    }
    return result;
}","/**
 *  Parses the given URL string.
 *
 *  @param _url
 *             absolute or relative url with query string
 *  @param charset
 *  @return Url object
 */
","public static Url parse(CharSequence _url, Charset charset) {
    Args.notNull(_url, ""_url"");
    final Url result = new Url(charset);
        charset = result.getCharset();
    String url = _url.toString();
        final String queryString;
    final String absoluteUrl;
    final int queryAt = url.indexOf('?');
    if (queryAt == -1) {
        queryString = """";
        absoluteUrl = url;
    } else {
        absoluteUrl = url.substring(0, queryAt);
        queryString = url.substring(queryAt + 1);
    }
        String relativeUrl;
    final int idxOfFirstSlash = absoluteUrl.indexOf('/');
    final int protocolAt = absoluteUrl.indexOf(""://"");
        boolean protocolLess = absoluteUrl.startsWith(""//"");
    final boolean isFull = (protocolAt > 1 && (protocolAt < idxOfFirstSlash)) || protocolLess;
    if (isFull) {
        if (protocolLess == false) {
            result.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);
        }
        final String afterProto = absoluteUrl.substring(protocolAt + 3);
        final String hostAndPort;
        int relativeAt = afterProto.indexOf('/');
        if (relativeAt == -1) {
            relativeAt = afterProto.indexOf(';');
        }
        if (relativeAt == -1) {
            relativeUrl = """";
            hostAndPort = afterProto;
        } else {
            relativeUrl = afterProto.substring(relativeAt);
            hostAndPort = afterProto.substring(0, relativeAt);
        }
        final int portAt = hostAndPort.lastIndexOf(':');
        if (portAt == -1) {
            result.host = hostAndPort;
            result.port = getDefaultPortForProtocol(result.protocol);
        } else {
            result.host = hostAndPort.substring(0, portAt);
            result.port = Integer.parseInt(hostAndPort.substring(portAt + 1));
        }
        if (relativeAt < 0) {
            relativeUrl = ""/"";
        }
    } else {
        relativeUrl = absoluteUrl;
    }
    if (relativeUrl.length() > 0) {
        boolean removeLast = false;
        if (relativeUrl.endsWith(""/"")) {
                                                relativeUrl += ""/x"";
            removeLast = true;
        }
        String[] segmentArray = Strings.split(relativeUrl, '/');
        if (removeLast) {
            segmentArray[segmentArray.length - 1] = null;
        }
        for (String s : segmentArray) {
            if (s != null) {
                result.segments.add(decodeSegment(s, charset));
            }
        }
    }
    if (queryString.length() > 0) {
        String[] queryArray = Strings.split(queryString, '&');
        for (String s : queryArray) {
            if (Strings.isEmpty(s) == false) {
                result.parameters.add(parseQueryParameter(s, charset));
            }
        }
    }
    return result;
}",2.8636363636363638,0.20918367346938782,2.0,0.5,1.5833333333333333,2.5714285714285716,-1.1984513908804133,2.0833333333333335,-0.028571428571428574,10.202898736942194
flink,remotes/origin/bugs-dot-jar_FLINK-2447_5546a1ef,1,"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
private <OUT, IN1, IN2> TypeInformation<OUT> privateGetForClass(Class<OUT> clazz, ArrayList<Type> typeHierarchy, ParameterizedType parameterizedType, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {
    Preconditions.checkNotNull(clazz);
    if (clazz.equals(Object.class)) {
        return new GenericTypeInfo<OUT>(clazz);
    }
    // check for arrays
    if (clazz.isArray()) {
        // primitive arrays: int[], byte[], ...
        PrimitiveArrayTypeInfo<OUT> primitiveArrayInfo = PrimitiveArrayTypeInfo.getInfoFor(clazz);
        if (primitiveArrayInfo != null) {
            return primitiveArrayInfo;
        }
        // basic type arrays: String[], Integer[], Double[]
        BasicArrayTypeInfo<OUT, ?> basicArrayInfo = BasicArrayTypeInfo.getInfoFor(clazz);
        if (basicArrayInfo != null) {
            return basicArrayInfo;
        } else // object arrays
        {
            return ObjectArrayTypeInfo.getInfoFor(clazz);
        }
    }
    // check for writable types
    if (Writable.class.isAssignableFrom(clazz) && !Writable.class.equals(clazz)) {
        return (TypeInformation<OUT>) WritableTypeInfo.getWritableTypeInfo((Class<? extends Writable>) clazz);
    }
    // check for basic types
    TypeInformation<OUT> basicTypeInfo = BasicTypeInfo.getInfoFor(clazz);
    if (basicTypeInfo != null) {
        return basicTypeInfo;
    }
    // check for subclasses of Value
    if (Value.class.isAssignableFrom(clazz)) {
        Class<? extends Value> valueClass = clazz.asSubclass(Value.class);
        return (TypeInformation<OUT>) ValueTypeInfo.getValueTypeInfo(valueClass);
    }
    // check for subclasses of Tuple
    if (Tuple.class.isAssignableFrom(clazz)) {
        throw new InvalidTypesException(""Type information extraction for tuples cannot be done based on the class."");
    }
    // check for Enums
    if (Enum.class.isAssignableFrom(clazz)) {
        return (TypeInformation<OUT>) new EnumTypeInfo(clazz);
    }
    // special case for POJOs generated by Avro.
    if (SpecificRecordBase.class.isAssignableFrom(clazz)) {
        return (TypeInformation<OUT>) new AvroTypeInfo(clazz);
    }
    if (alreadySeen.contains(clazz)) {
        return new GenericTypeInfo<OUT>(clazz);
    }
    alreadySeen.add(clazz);
    if (Modifier.isInterface(clazz.getModifiers())) {
        // Interface has no members and is therefore not handled as POJO
        return new GenericTypeInfo<OUT>(clazz);
    }
    if (clazz.equals(Class.class)) {
        // special case handling for Class, this should not be handled by the POJO logic
        return new GenericTypeInfo<OUT>(clazz);
    }
    try {
        TypeInformation<OUT> pojoType = analyzePojo(clazz, new ArrayList<Type>(typeHierarchy), parameterizedType, in1Type, in2Type);
        if (pojoType != null) {
            return pojoType;
        }
    } catch (InvalidTypesException e) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Unable to handle type "" + clazz + "" as POJO. Message: "" + e.getMessage(), e);
        }
    // ignore and create generic type info
    }
    // return a generic type
    return new GenericTypeInfo<OUT>(clazz);
}",,"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
private <OUT, IN1, IN2> TypeInformation<OUT> privateGetForClass(Class<OUT> clazz, ArrayList<Type> typeHierarchy, ParameterizedType parameterizedType, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {
    Preconditions.checkNotNull(clazz);
    if (clazz.equals(Object.class)) {
        return new GenericTypeInfo<OUT>(clazz);
    }
        if (clazz.isArray()) {
                PrimitiveArrayTypeInfo<OUT> primitiveArrayInfo = PrimitiveArrayTypeInfo.getInfoFor(clazz);
        if (primitiveArrayInfo != null) {
            return primitiveArrayInfo;
        }
                BasicArrayTypeInfo<OUT, ?> basicArrayInfo = BasicArrayTypeInfo.getInfoFor(clazz);
        if (basicArrayInfo != null) {
            return basicArrayInfo;
        } else         {
            return ObjectArrayTypeInfo.getInfoFor(clazz);
        }
    }
        if (Writable.class.isAssignableFrom(clazz) && !Writable.class.equals(clazz)) {
        return (TypeInformation<OUT>) WritableTypeInfo.getWritableTypeInfo((Class<? extends Writable>) clazz);
    }
        TypeInformation<OUT> basicTypeInfo = BasicTypeInfo.getInfoFor(clazz);
    if (basicTypeInfo != null) {
        return basicTypeInfo;
    }
        if (Value.class.isAssignableFrom(clazz)) {
        Class<? extends Value> valueClass = clazz.asSubclass(Value.class);
        return (TypeInformation<OUT>) ValueTypeInfo.getValueTypeInfo(valueClass);
    }
        if (Tuple.class.isAssignableFrom(clazz)) {
        throw new InvalidTypesException(""Type information extraction for tuples cannot be done based on the class."");
    }
        if (Enum.class.isAssignableFrom(clazz)) {
        return (TypeInformation<OUT>) new EnumTypeInfo(clazz);
    }
        if (SpecificRecordBase.class.isAssignableFrom(clazz)) {
        return (TypeInformation<OUT>) new AvroTypeInfo(clazz);
    }
    if (alreadySeen.contains(clazz)) {
        return new GenericTypeInfo<OUT>(clazz);
    }
    alreadySeen.add(clazz);
    if (Modifier.isInterface(clazz.getModifiers())) {
                return new GenericTypeInfo<OUT>(clazz);
    }
    if (clazz.equals(Class.class)) {
                return new GenericTypeInfo<OUT>(clazz);
    }
    try {
        TypeInformation<OUT> pojoType = analyzePojo(clazz, new ArrayList<Type>(typeHierarchy), parameterizedType, in1Type, in2Type);
        if (pojoType != null) {
            return pojoType;
        }
    } catch (InvalidTypesException e) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Unable to handle type "" + clazz + "" as POJO. Message: "" + e.getMessage(), e);
        }
        }
        return new GenericTypeInfo<OUT>(clazz);
}",2.1363636363636362,-0.08163265306122457,2.3333333333333335,0.0,2.4166666666666665,0.6198714780029659,-1.0404359047892173,1.5833333333333333,-0.028571428571428574,2.1403925801242933
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-107_88641f49,1,"/**
 * Extract options.
 *
 * @param pattern conversion pattern.
 * @param i       start of options.
 * @param options array to receive extracted options
 * @return position in pattern after options.
 */
private static int extractOptions(String pattern, int i, List<String> options) {
    while ((i < pattern.length()) && (pattern.charAt(i) == '{')) {
        int begin = i;
        int end;
        int depth = 0;
        do {
            end = pattern.indexOf('}', i);
            if (end != -1) {
                int next = pattern.indexOf(""{"", i + 1);
                if (next != -1 && next < end) {
                    i = end + 1;
                    ++depth;
                } else if (depth > 0) {
                    --depth;
                }
            }
        } while (depth > 0);
        if (end == -1) {
            break;
        }
        String r = pattern.substring(begin + 1, end);
        options.add(r);
        i = end + 1;
    }
    return i;
}","/**
 * Extract options.
 *
 * @param pattern conversion pattern.
 * @param i       start of options.
 * @param options array to receive extracted options
 * @return position in pattern after options.
 */
","private static int extractOptions(String pattern, int i, List<String> options) {
    while ((i < pattern.length()) && (pattern.charAt(i) == '{')) {
        int begin = i;
        int end;
        int depth = 0;
        do {
            end = pattern.indexOf('}', i);
            if (end != -1) {
                int next = pattern.indexOf(""{"", i + 1);
                if (next != -1 && next < end) {
                    i = end + 1;
                    ++depth;
                } else if (depth > 0) {
                    --depth;
                }
            }
        } while (depth > 0);
        if (end == -1) {
            break;
        }
        String r = pattern.substring(begin + 1, end);
        options.add(r);
        i = end + 1;
    }
    return i;
}",0.5454545454545454,1.3010204081632655,0.6666666666666666,1.5,0.75,2.537815126050421,-0.44536851161456853,0.0,0.0,2.592202363361473
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1270_70564c7c,1,"@Override
public boolean visit(FullTextOr or) {
    BooleanQuery q = new BooleanQuery();
    for (FullTextExpression e : or.list) {
        Query x = getFullTextQuery(e, analyzer);
        q.add(x, SHOULD);
    }
    result.set(q);
    return true;
}",,"@Override
public boolean visit(FullTextOr or) {
    BooleanQuery q = new BooleanQuery();
    for (FullTextExpression e : or.list) {
        Query x = getFullTextQuery(e, analyzer);
        q.add(x, SHOULD);
    }
    result.set(q);
    return true;
}",-0.18181818181818182,-0.11224489795918377,-0.3333333333333333,-0.5,-0.4166666666666667,-0.3806228373702422,0.23458560367077702,-0.25,0.7428571428571429,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2147_a1556c30,1,"/**
 * set the value of the :next at the given position. If the property :next won't be there by the
 * time this method is invoked it won't perform any action
 *
 * @param node
 * @param value
 * @param lane
 */
static void setPropertyNext(@Nonnull final NodeBuilder node, final String value, final int lane) {
    if (node != null && value != null && lane >= 0 && lane < OrderedIndex.LANES) {
        PropertyState next = node.getProperty(NEXT);
        if (next != null) {
            String[] values;
            if (next.isArray()) {
                values = Iterables.toArray(next.getValue(Type.STRINGS), String.class);
                if (values.length < OrderedIndex.LANES) {
                    // it could be we increased the number of lanes and running on some existing
                    // content
                    LOG.debug(""topping-up the number of lanes."");
                    List<String> vv = Lists.newArrayList(values);
                    for (int i = vv.size(); i <= OrderedIndex.LANES; i++) {
                        vv.add("""");
                    }
                    values = vv.toArray(new String[vv.size()]);
                }
            } else {
                values = Iterables.toArray(EMPTY_NEXT, String.class);
                values[0] = next.getValue(Type.STRING);
            }
            values[lane] = value;
            setPropertyNext(node, values);
        }
    }
}","/**
 * set the value of the :next at the given position. If the property :next won't be there by the
 * time this method is invoked it won't perform any action
 *
 * @param node
 * @param value
 * @param lane
 */
","static void setPropertyNext(@Nonnull final NodeBuilder node, final String value, final int lane) {
    if (node != null && value != null && lane >= 0 && lane < OrderedIndex.LANES) {
        PropertyState next = node.getProperty(NEXT);
        if (next != null) {
            String[] values;
            if (next.isArray()) {
                values = Iterables.toArray(next.getValue(Type.STRINGS), String.class);
                if (values.length < OrderedIndex.LANES) {
                                                            LOG.debug(""topping-up the number of lanes."");
                    List<String> vv = Lists.newArrayList(values);
                    for (int i = vv.size(); i <= OrderedIndex.LANES; i++) {
                        vv.add("""");
                    }
                    values = vv.toArray(new String[vv.size()]);
                }
            } else {
                values = Iterables.toArray(EMPTY_NEXT, String.class);
                values[0] = next.getValue(Type.STRING);
            }
            values[lane] = value;
            setPropertyNext(node, values);
        }
    }
}",0.45454545454545453,1.7397959183673468,0.3333333333333333,1.5,0.8333333333333334,0.934256055363322,-0.43016919988528834,0.5833333333333334,-0.028571428571428574,1.4059559450233639
wicket,remotes/origin/bugs-dot-jar_WICKET-3885_beb9086d,1,"@Override
public void sendRedirect(String url) {
    try {
        redirect = true;
        url = getAbsoluteURL(url);
        url = encodeRedirectURL(url);
        // wicket redirects should never be cached
        disableCaching();
        if (webRequest.isAjax()) {
            httpServletResponse.addHeader(""Ajax-Location"", url);
            /*
				 * usually the Ajax-Location header is enough and we do not need to the redirect url
				 * into the response, but sometimes the response is processed via an iframe (eg
				 * using multipart ajax handling) and the headers are not available because XHR is
				 * not used and that is the only way javascript has access to response headers.
				 */
            httpServletResponse.getWriter().write(""<ajax-response><redirect><![CDATA["" + url + ""]]></redirect></ajax-response>"");
            setContentType(""text/xml;charset="" + webRequest.getContainerRequest().getCharacterEncoding());
        } else {
            httpServletResponse.sendRedirect(url);
        }
    } catch (IOException e) {
        throw new WicketRuntimeException(e);
    }
}",,"@Override
public void sendRedirect(String url) {
    try {
        redirect = true;
        url = getAbsoluteURL(url);
        url = encodeRedirectURL(url);
                disableCaching();
        if (webRequest.isAjax()) {
            httpServletResponse.addHeader(""Ajax-Location"", url);
                        httpServletResponse.getWriter().write(""<ajax-response><redirect><![CDATA["" + url + ""]]></redirect></ajax-response>"");
            setContentType(""text/xml;charset="" + webRequest.getContainerRequest().getCharacterEncoding());
        } else {
            httpServletResponse.sendRedirect(url);
        }
    } catch (IOException e) {
        throw new WicketRuntimeException(e);
    }
}",0.18181818181818182,0.47959183673469385,0.0,0.0,-0.25,-0.09194265941670784,-0.13708058503011192,0.4166666666666667,-0.028571428571428574,-0.034829386545372
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-193_c831e44d,3,"public String toString() {
    String labelString = new ColumnVisibility(colVisibility).toString();
    String s = toPrintableString(row, 0, row.length, Constants.MAX_DATA_TO_PRINT) + "" "" + toPrintableString(colFamily, 0, colFamily.length, Constants.MAX_DATA_TO_PRINT) + "":"" + toPrintableString(colQualifier, 0, colQualifier.length, Constants.MAX_DATA_TO_PRINT) + "" "" + labelString + "" "" + Long.toString(timestamp) + "" "" + deleted;
    return s;
}",,"public String toString() {
    String labelString = new ColumnVisibility(colVisibility).toString();
    String s = toPrintableString(row, 0, row.length, Constants.MAX_DATA_TO_PRINT) + "" "" + toPrintableString(colFamily, 0, colFamily.length, Constants.MAX_DATA_TO_PRINT) + "":"" + toPrintableString(colQualifier, 0, colQualifier.length, Constants.MAX_DATA_TO_PRINT) + "" "" + labelString + "" "" + Long.toString(timestamp) + "" "" + deleted;
    return s;
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,0.03460207612456753,0.48236306280470315,-0.08333333333333333,-0.028571428571428574,0.016266848266025938
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1075_79467350,1,"/**
 * ""operand2 always evaluates to a scalar value""
 *
 * for multi-valued properties: if any of the value matches, then return true
 *
 * @param p1
 * @param p2
 * @return
 */
private boolean evaluate(PropertyValue p1, PropertyValue p2) {
    switch(operator) {
        case EQUAL:
            return PropertyValues.match(p1, p2);
        case NOT_EQUAL:
            return !PropertyValues.match(p1, p2);
        case GREATER_OR_EQUAL:
            return p1.compareTo(p2) >= 0;
        case GREATER_THAN:
            return p1.compareTo(p2) > 0;
        case LESS_OR_EQUAL:
            return p1.compareTo(p2) <= 0;
        case LESS_THAN:
            return p1.compareTo(p2) < 0;
        case LIKE:
            return evaluateLike(p1, p2);
    }
    throw new IllegalArgumentException(""Unknown operator: "" + operator);
}","/**
 * ""operand2 always evaluates to a scalar value""
 *
 * for multi-valued properties: if any of the value matches, then return true
 *
 * @param p1
 * @param p2
 * @return
 */
","private boolean evaluate(PropertyValue p1, PropertyValue p2) {
    switch(operator) {
        case EQUAL:
            return PropertyValues.match(p1, p2);
        case NOT_EQUAL:
            return !PropertyValues.match(p1, p2);
        case GREATER_OR_EQUAL:
            return p1.compareTo(p2) >= 0;
        case GREATER_THAN:
            return p1.compareTo(p2) > 0;
        case LESS_OR_EQUAL:
            return p1.compareTo(p2) <= 0;
        case LESS_THAN:
            return p1.compareTo(p2) < 0;
        case LIKE:
            return evaluateLike(p1, p2);
    }
    throw new IllegalArgumentException(""Unknown operator: "" + operator);
}",0.22727272727272727,0.4438775510204082,0.8333333333333334,0.0,0.25,0.9243697478991598,-0.21422426154287355,0.08333333333333333,0.05714285714285714,0.500130631614564
camel,remotes/origin/bugs-dot-jar_CAMEL-5215_033eb6fe,3,"public void process(Exchange exchange) throws Exception {
    endpoint.configureExchange(exchange);
    String target = createFileName(exchange);
    // use lock for same file name to avoid concurrent writes to the same file
    // for example when you concurrently append to the same file
    Lock lock;
    synchronized (locks) {
        lock = locks.get(target);
        if (lock == null) {
            lock = new ReentrantLock();
            locks.put(target, lock);
        }
    }
    lock.lock();
    try {
        processExchange(exchange, target);
    } finally {
        // do not remove as the locks cache has an upper bound
        // this ensure the locks is appropriate reused
        lock.unlock();
    }
}",,"public void process(Exchange exchange) throws Exception {
    endpoint.configureExchange(exchange);
    String target = createFileName(exchange);
            Lock lock;
    synchronized (locks) {
        lock = locks.get(target);
        if (lock == null) {
            lock = new ReentrantLock();
            locks.put(target, lock);
        }
    }
    lock.lock();
    try {
        processExchange(exchange, target);
    } finally {
                        lock.unlock();
    }
}",0.18181818181818182,0.14285714285714277,-0.3333333333333333,0.0,-0.25,-0.026693030153237728,-0.09176942930886159,0.08333333333333333,0.0,-0.03630273983750283
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5,3,"@Override
public String toString() {
    StringBuilder sb = new StringBuilder(""update_result("");
    boolean first = true;
    sb.append(""ouch1:"");
    if (this.ouch1 == null) {
        sb.append(""null"");
    } else {
        sb.append(this.ouch1);
    }
    first = false;
    if (!first)
        sb.append("", "");
    sb.append(""ouch2:"");
    if (this.ouch2 == null) {
        sb.append(""null"");
    } else {
        sb.append(this.ouch2);
    }
    first = false;
    sb.append("")"");
    return sb.toString();
}",,"@Override
public String toString() {
    StringBuilder sb = new StringBuilder(""update_result("");
    boolean first = true;
    sb.append(""ouch1:"");
    if (this.ouch1 == null) {
        sb.append(""null"");
    } else {
        sb.append(this.ouch1);
    }
    first = false;
    if (!first)
        sb.append("", "");
    sb.append(""ouch2:"");
    if (this.ouch2 == null) {
        sb.append(""null"");
    } else {
        sb.append(this.ouch2);
    }
    first = false;
    sb.append("")"");
    return sb.toString();
}",0.4090909090909091,-0.3520408163265306,0.0,-0.5,0.08333333333333333,0.11369253583786461,-0.26584456552910807,0.25,0.0,0.08033201845118018
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-398_2c966ad9,1,"@SuppressWarnings(""unchecked"")
protected void doConfigure() {
    boolean setRoot = false;
    boolean setLoggers = false;
    for (final Node child : rootNode.getChildren()) {
        createConfiguration(child, null);
        if (child.getObject() == null) {
            continue;
        }
        if (child.getName().equalsIgnoreCase(""Properties"")) {
            if (tempLookup == subst.getVariableResolver()) {
                subst.setVariableResolver((StrLookup) child.getObject());
            } else {
                LOGGER.error(""Properties declaration must be the first element in the configuration"");
            }
            continue;
        } else if (tempLookup == subst.getVariableResolver()) {
            final Map<String, String> map = (Map<String, String>) componentMap.get(CONTEXT_PROPERTIES);
            final StrLookup lookup = map == null ? null : new MapLookup(map);
            subst.setVariableResolver(new Interpolator(lookup));
        }
        if (child.getName().equalsIgnoreCase(""Appenders"")) {
            appenders = (ConcurrentMap<String, Appender>) child.getObject();
        } else if (child.getObject() instanceof Filter) {
            addFilter((Filter) child.getObject());
        } else if (child.getName().equalsIgnoreCase(""Loggers"")) {
            final Loggers l = (Loggers) child.getObject();
            loggers = l.getMap();
            setLoggers = true;
            if (l.getRoot() != null) {
                root = l.getRoot();
                setRoot = true;
            }
        } else {
            LOGGER.error(""Unknown object \"""" + child.getName() + ""\"" of type "" + child.getObject().getClass().getName() + "" is ignored"");
        }
    }
    if (!setLoggers) {
        LOGGER.warn(""No Loggers were configured, using default. Is the Loggers element missing?"");
        setToDefault();
        return;
    } else if (!setRoot) {
        LOGGER.warn(""No Root logger was configured, creating default ERROR-level Root logger with Console appender"");
        setToDefault();
    // return; // LOG4J2-219: creating default root=ok, but don't exclude configured Loggers
    }
    for (final Map.Entry<String, LoggerConfig> entry : loggers.entrySet()) {
        final LoggerConfig l = entry.getValue();
        for (final AppenderRef ref : l.getAppenderRefs()) {
            final Appender app = appenders.get(ref.getRef());
            if (app != null) {
                l.addAppender(app, ref.getLevel(), ref.getFilter());
            } else {
                LOGGER.error(""Unable to locate appender "" + ref.getRef() + "" for logger "" + l.getName());
            }
        }
    }
    setParents();
}",,"@SuppressWarnings(""unchecked"")
protected void doConfigure() {
    boolean setRoot = false;
    boolean setLoggers = false;
    for (final Node child : rootNode.getChildren()) {
        createConfiguration(child, null);
        if (child.getObject() == null) {
            continue;
        }
        if (child.getName().equalsIgnoreCase(""Properties"")) {
            if (tempLookup == subst.getVariableResolver()) {
                subst.setVariableResolver((StrLookup) child.getObject());
            } else {
                LOGGER.error(""Properties declaration must be the first element in the configuration"");
            }
            continue;
        } else if (tempLookup == subst.getVariableResolver()) {
            final Map<String, String> map = (Map<String, String>) componentMap.get(CONTEXT_PROPERTIES);
            final StrLookup lookup = map == null ? null : new MapLookup(map);
            subst.setVariableResolver(new Interpolator(lookup));
        }
        if (child.getName().equalsIgnoreCase(""Appenders"")) {
            appenders = (ConcurrentMap<String, Appender>) child.getObject();
        } else if (child.getObject() instanceof Filter) {
            addFilter((Filter) child.getObject());
        } else if (child.getName().equalsIgnoreCase(""Loggers"")) {
            final Loggers l = (Loggers) child.getObject();
            loggers = l.getMap();
            setLoggers = true;
            if (l.getRoot() != null) {
                root = l.getRoot();
                setRoot = true;
            }
        } else {
            LOGGER.error(""Unknown object \"""" + child.getName() + ""\"" of type "" + child.getObject().getClass().getName() + "" is ignored"");
        }
    }
    if (!setLoggers) {
        LOGGER.warn(""No Loggers were configured, using default. Is the Loggers element missing?"");
        setToDefault();
        return;
    } else if (!setRoot) {
        LOGGER.warn(""No Root logger was configured, creating default ERROR-level Root logger with Console appender"");
        setToDefault();
        }
    for (final Map.Entry<String, LoggerConfig> entry : loggers.entrySet()) {
        final LoggerConfig l = entry.getValue();
        for (final AppenderRef ref : l.getAppenderRefs()) {
            final Appender app = appenders.get(ref.getRef());
            if (app != null) {
                l.addAppender(app, ref.getLevel(), ref.getFilter());
            } else {
                LOGGER.error(""Unable to locate appender "" + ref.getRef() + "" for logger "" + l.getName());
            }
        }
    }
    setParents();
}",2.0,0.5612244897959184,2.3333333333333335,1.5,1.5,0.4873949579831933,-1.0238026957269863,3.25,-0.028571428571428574,1.9289235526659558
maven,remotes/origin/bugs-dot-jar_MNG-4383_0f3d4d24,1,"public void validateEffectiveModel(Model model, ModelBuildingRequest request, ModelProblemCollector problems) {
    validateStringNotEmpty(""modelVersion"", problems, false, model.getModelVersion());
    validateId(""groupId"", problems, model.getGroupId());
    validateId(""artifactId"", problems, model.getArtifactId());
    validateStringNotEmpty(""packaging"", problems, false, model.getPackaging());
    if (!model.getModules().isEmpty() && !""pom"".equals(model.getPackaging())) {
        addViolation(problems, false, ""Packaging '"" + model.getPackaging() + ""' is invalid. Aggregator projects "" + ""require 'pom' as packaging."");
    }
    Parent parent = model.getParent();
    if (parent != null) {
        if (parent.getGroupId().equals(model.getGroupId()) && parent.getArtifactId().equals(model.getArtifactId())) {
            addViolation(problems, false, ""The parent element cannot have the same ID as the project."");
        }
    }
    validateStringNotEmpty(""version"", problems, false, model.getVersion());
    boolean warnOnBadBoolean = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;
    boolean warnOnBadDependencyScope = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;
    for (Dependency d : model.getDependencies()) {
        validateId(""dependencies.dependency.artifactId"", problems, d.getArtifactId());
        validateId(""dependencies.dependency.groupId"", problems, d.getGroupId());
        validateStringNotEmpty(""dependencies.dependency.type"", problems, false, d.getType(), d.getManagementKey());
        validateStringNotEmpty(""dependencies.dependency.version"", problems, false, d.getVersion(), d.getManagementKey());
        if (""system"".equals(d.getScope())) {
            String systemPath = d.getSystemPath();
            if (StringUtils.isEmpty(systemPath)) {
                addViolation(problems, false, ""For dependency "" + d + "": system-scoped dependency must specify systemPath."");
            } else {
                if (!new File(systemPath).isAbsolute()) {
                    addViolation(problems, false, ""For dependency "" + d + "": system-scoped dependency must "" + ""specify an absolute path systemPath."");
                }
            }
        } else if (StringUtils.isNotEmpty(d.getSystemPath())) {
            addViolation(problems, false, ""For dependency "" + d + "": only dependency with system scope can specify systemPath."");
        }
        if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {
            validateBoolean(""dependencies.dependency.optional"", problems, warnOnBadBoolean, d.getOptional(), d.getManagementKey());
            /*
                 * TODO: Extensions like Flex Mojos use custom scopes like ""merged"", ""internal"", ""external"", etc. In
                 * order to don't break backward-compat with those, only warn but don't error our.
                 */
            validateEnum(""dependencies.dependency.scope"", problems, true, d.getScope(), d.getManagementKey(), ""provided"", ""compile"", ""runtime"", ""test"", ""system"");
        }
    }
    DependencyManagement mgmt = model.getDependencyManagement();
    if (mgmt != null) {
        for (Dependency d : mgmt.getDependencies()) {
            validateSubElementStringNotEmpty(d, ""dependencyManagement.dependencies.dependency.artifactId"", problems, d.getArtifactId());
            validateSubElementStringNotEmpty(d, ""dependencyManagement.dependencies.dependency.groupId"", problems, d.getGroupId());
            if (""system"".equals(d.getScope())) {
                String systemPath = d.getSystemPath();
                if (StringUtils.isEmpty(systemPath)) {
                    addViolation(problems, false, ""For managed dependency "" + d + "": system-scoped dependency must specify systemPath."");
                } else {
                    if (!new File(systemPath).isAbsolute()) {
                        addViolation(problems, false, ""For managed dependency "" + d + "": system-scoped dependency must "" + ""specify an absolute path systemPath."");
                    }
                }
            } else if (StringUtils.isNotEmpty(d.getSystemPath())) {
                addViolation(problems, false, ""For managed dependency "" + d + "": only dependency with system scope can specify systemPath."");
            }
            if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {
                validateBoolean(""dependencyManagement.dependencies.dependency.optional"", problems, warnOnBadBoolean, d.getOptional(), d.getManagementKey());
            }
        }
    }
    if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {
        boolean warnOnMissingPluginVersion = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1;
        Build build = model.getBuild();
        if (build != null) {
            for (Plugin p : build.getPlugins()) {
                validateStringNotEmpty(""build.plugins.plugin.artifactId"", problems, false, p.getArtifactId());
                validateStringNotEmpty(""build.plugins.plugin.groupId"", problems, false, p.getGroupId());
                validateStringNotEmpty(""build.plugins.plugin.version"", problems, warnOnMissingPluginVersion, p.getVersion(), p.getKey());
                validateBoolean(""build.plugins.plugin.inherited"", problems, warnOnBadBoolean, p.getInherited(), p.getKey());
                validateBoolean(""build.plugins.plugin.extensions"", problems, warnOnBadBoolean, p.getExtensions(), p.getKey());
                for (Dependency d : p.getDependencies()) {
                    validateEnum(""build.plugins.plugin["" + p.getKey() + ""].dependencies.dependency.scope"", problems, warnOnBadDependencyScope, d.getScope(), d.getManagementKey(), ""compile"", ""runtime"", ""system"");
                }
            }
            validateResources(problems, build.getResources(), ""build.resources.resource"", request);
            validateResources(problems, build.getTestResources(), ""build.testResources.testResource"", request);
        }
        Reporting reporting = model.getReporting();
        if (reporting != null) {
            for (ReportPlugin p : reporting.getPlugins()) {
                validateStringNotEmpty(""reporting.plugins.plugin.artifactId"", problems, false, p.getArtifactId());
                validateStringNotEmpty(""reporting.plugins.plugin.groupId"", problems, false, p.getGroupId());
                validateStringNotEmpty(""reporting.plugins.plugin.version"", problems, warnOnMissingPluginVersion, p.getVersion(), p.getKey());
            }
        }
        forcePluginExecutionIdCollision(model, problems);
        for (Repository repository : model.getRepositories()) {
            validateRepositoryLayout(problems, repository, ""repositories.repository"", request);
        }
        for (Repository repository : model.getPluginRepositories()) {
            validateRepositoryLayout(problems, repository, ""pluginRepositories.pluginRepository"", request);
        }
        DistributionManagement distMgmt = model.getDistributionManagement();
        if (distMgmt != null) {
            validateRepositoryLayout(problems, distMgmt.getRepository(), ""distributionManagement.repository"", request);
            validateRepositoryLayout(problems, distMgmt.getSnapshotRepository(), ""distributionManagement.snapshotRepository"", request);
        }
    }
}",,"public void validateEffectiveModel(Model model, ModelBuildingRequest request, ModelProblemCollector problems) {
    validateStringNotEmpty(""modelVersion"", problems, false, model.getModelVersion());
    validateId(""groupId"", problems, model.getGroupId());
    validateId(""artifactId"", problems, model.getArtifactId());
    validateStringNotEmpty(""packaging"", problems, false, model.getPackaging());
    if (!model.getModules().isEmpty() && !""pom"".equals(model.getPackaging())) {
        addViolation(problems, false, ""Packaging '"" + model.getPackaging() + ""' is invalid. Aggregator projects "" + ""require 'pom' as packaging."");
    }
    Parent parent = model.getParent();
    if (parent != null) {
        if (parent.getGroupId().equals(model.getGroupId()) && parent.getArtifactId().equals(model.getArtifactId())) {
            addViolation(problems, false, ""The parent element cannot have the same ID as the project."");
        }
    }
    validateStringNotEmpty(""version"", problems, false, model.getVersion());
    boolean warnOnBadBoolean = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;
    boolean warnOnBadDependencyScope = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;
    for (Dependency d : model.getDependencies()) {
        validateId(""dependencies.dependency.artifactId"", problems, d.getArtifactId());
        validateId(""dependencies.dependency.groupId"", problems, d.getGroupId());
        validateStringNotEmpty(""dependencies.dependency.type"", problems, false, d.getType(), d.getManagementKey());
        validateStringNotEmpty(""dependencies.dependency.version"", problems, false, d.getVersion(), d.getManagementKey());
        if (""system"".equals(d.getScope())) {
            String systemPath = d.getSystemPath();
            if (StringUtils.isEmpty(systemPath)) {
                addViolation(problems, false, ""For dependency "" + d + "": system-scoped dependency must specify systemPath."");
            } else {
                if (!new File(systemPath).isAbsolute()) {
                    addViolation(problems, false, ""For dependency "" + d + "": system-scoped dependency must "" + ""specify an absolute path systemPath."");
                }
            }
        } else if (StringUtils.isNotEmpty(d.getSystemPath())) {
            addViolation(problems, false, ""For dependency "" + d + "": only dependency with system scope can specify systemPath."");
        }
        if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {
            validateBoolean(""dependencies.dependency.optional"", problems, warnOnBadBoolean, d.getOptional(), d.getManagementKey());
                        validateEnum(""dependencies.dependency.scope"", problems, true, d.getScope(), d.getManagementKey(), ""provided"", ""compile"", ""runtime"", ""test"", ""system"");
        }
    }
    DependencyManagement mgmt = model.getDependencyManagement();
    if (mgmt != null) {
        for (Dependency d : mgmt.getDependencies()) {
            validateSubElementStringNotEmpty(d, ""dependencyManagement.dependencies.dependency.artifactId"", problems, d.getArtifactId());
            validateSubElementStringNotEmpty(d, ""dependencyManagement.dependencies.dependency.groupId"", problems, d.getGroupId());
            if (""system"".equals(d.getScope())) {
                String systemPath = d.getSystemPath();
                if (StringUtils.isEmpty(systemPath)) {
                    addViolation(problems, false, ""For managed dependency "" + d + "": system-scoped dependency must specify systemPath."");
                } else {
                    if (!new File(systemPath).isAbsolute()) {
                        addViolation(problems, false, ""For managed dependency "" + d + "": system-scoped dependency must "" + ""specify an absolute path systemPath."");
                    }
                }
            } else if (StringUtils.isNotEmpty(d.getSystemPath())) {
                addViolation(problems, false, ""For managed dependency "" + d + "": only dependency with system scope can specify systemPath."");
            }
            if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {
                validateBoolean(""dependencyManagement.dependencies.dependency.optional"", problems, warnOnBadBoolean, d.getOptional(), d.getManagementKey());
            }
        }
    }
    if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {
        boolean warnOnMissingPluginVersion = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1;
        Build build = model.getBuild();
        if (build != null) {
            for (Plugin p : build.getPlugins()) {
                validateStringNotEmpty(""build.plugins.plugin.artifactId"", problems, false, p.getArtifactId());
                validateStringNotEmpty(""build.plugins.plugin.groupId"", problems, false, p.getGroupId());
                validateStringNotEmpty(""build.plugins.plugin.version"", problems, warnOnMissingPluginVersion, p.getVersion(), p.getKey());
                validateBoolean(""build.plugins.plugin.inherited"", problems, warnOnBadBoolean, p.getInherited(), p.getKey());
                validateBoolean(""build.plugins.plugin.extensions"", problems, warnOnBadBoolean, p.getExtensions(), p.getKey());
                for (Dependency d : p.getDependencies()) {
                    validateEnum(""build.plugins.plugin["" + p.getKey() + ""].dependencies.dependency.scope"", problems, warnOnBadDependencyScope, d.getScope(), d.getManagementKey(), ""compile"", ""runtime"", ""system"");
                }
            }
            validateResources(problems, build.getResources(), ""build.resources.resource"", request);
            validateResources(problems, build.getTestResources(), ""build.testResources.testResource"", request);
        }
        Reporting reporting = model.getReporting();
        if (reporting != null) {
            for (ReportPlugin p : reporting.getPlugins()) {
                validateStringNotEmpty(""reporting.plugins.plugin.artifactId"", problems, false, p.getArtifactId());
                validateStringNotEmpty(""reporting.plugins.plugin.groupId"", problems, false, p.getGroupId());
                validateStringNotEmpty(""reporting.plugins.plugin.version"", problems, warnOnMissingPluginVersion, p.getVersion(), p.getKey());
            }
        }
        forcePluginExecutionIdCollision(model, problems);
        for (Repository repository : model.getRepositories()) {
            validateRepositoryLayout(problems, repository, ""repositories.repository"", request);
        }
        for (Repository repository : model.getPluginRepositories()) {
            validateRepositoryLayout(problems, repository, ""pluginRepositories.pluginRepository"", request);
        }
        DistributionManagement distMgmt = model.getDistributionManagement();
        if (distMgmt != null) {
            validateRepositoryLayout(problems, distMgmt.getRepository(), ""distributionManagement.repository"", request);
            validateRepositoryLayout(problems, distMgmt.getSnapshotRepository(), ""distributionManagement.snapshotRepository"", request);
        }
    }
}",3.909090909090909,0.9948979591836733,3.6666666666666665,1.5,2.9166666666666665,1.5076618882847261,-1.480068827071982,9.416666666666666,-0.028571428571428574,12.314616606918765
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-334_9d8cc45d,1,"@Override
public SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {
    return new TimestampFilter(getSource(), hasStart, start, startInclusive, hasEnd, end, endInclusive);
}",,"@Override
public SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {
    return new TimestampFilter(getSource(), hasStart, start, startInclusive, hasEnd, end, endInclusive);
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.756524232864927,-0.4166666666666667,-0.028571428571428574,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1655_c91bfa54,1,"@Override
public boolean apply(DataIdentifier input) {
    try {
        DataRecord dr = delegate.getRecord(input);
        if (dr != null && dr.getLastModified() < maxLastModifiedTime) {
            return true;
        }
    } catch (DataStoreException e) {
        log.warn(""Error occurred while fetching DataRecord for identifier {}"", input, e);
    }
    return false;
}",,"@Override
public boolean apply(DataIdentifier input) {
    try {
        DataRecord dr = delegate.getRecord(input);
        if (dr != null && dr.getLastModified() < maxLastModifiedTime) {
            return true;
        }
    } catch (DataStoreException e) {
        log.warn(""Error occurred while fetching DataRecord for identifier {}"", input, e);
    }
    return false;
}",-0.09090909090909091,0.3469387755102042,-0.16666666666666666,0.0,0.0,0.11962432031636186,0.13105821623171765,-0.25,0.2285714285714286,-0.027179941836808982
wicket,remotes/origin/bugs-dot-jar_WICKET-5359_61122bab,3,"/**
 *  Convert to enum, returning null if text is null or empty.
 *
 *  @param eClass
 *             enum type
 *
 *  @return converted
 *  @throws StringValueConversionException
 */
public final <T extends Enum<T>> T toOptionalEnum(Class<T> eClass) throws StringValueConversionException {
    return Strings.isEmpty(text) ? null : toEnum(eClass);
}","/**
 *  Convert to enum, returning null if text is null or empty.
 *
 *  @param eClass
 *             enum type
 *
 *  @return converted
 *  @throws StringValueConversionException
 */
","public final <T extends Enum<T>> T toOptionalEnum(Class<T> eClass) throws StringValueConversionException {
    return Strings.isEmpty(text) ? null : toEnum(eClass);
}",-0.5,-0.576530612244898,-0.3333333333333333,-1.0,-0.16666666666666666,-0.3806228373702422,0.8999139661600231,-0.3333333333333333,2.8285714285714287,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-8125_36e7b668,3,"private void doStartCamel() throws Exception {
    if (applicationContextClassLoader == null) {
        // Using the TCCL as the default value of ApplicationClassLoader
        ClassLoader cl = Thread.currentThread().getContextClassLoader();
        if (cl == null) {
            // use the classloader that loaded this class
            cl = this.getClass().getClassLoader();
        }
        setApplicationContextClassLoader(cl);
    }
    if (log.isDebugEnabled()) {
        log.debug(""Using ClassResolver={}, PackageScanClassResolver={}, ApplicationContextClassLoader={}"", new Object[] { getClassResolver(), getPackageScanClassResolver(), getApplicationContextClassLoader() });
    }
    if (isStreamCaching()) {
        log.info(""StreamCaching is enabled on CamelContext: {}"", getName());
    }
    if (isTracing()) {
        // tracing is added in the DefaultChannel so we can enable it on the fly
        log.info(""Tracing is enabled on CamelContext: {}"", getName());
    }
    if (isUseMDCLogging()) {
        // log if MDC has been enabled
        log.info(""MDC logging is enabled on CamelContext: {}"", getName());
    }
    if (isHandleFault()) {
        // only add a new handle fault if not already configured
        if (HandleFault.getHandleFault(this) == null) {
            log.info(""HandleFault is enabled on CamelContext: {}"", getName());
            addInterceptStrategy(new HandleFault());
        }
    }
    if (getDelayer() != null && getDelayer() > 0) {
        log.info(""Delayer is enabled with: {} ms. on CamelContext: {}"", getDelayer(), getName());
    }
    // register debugger
    if (getDebugger() != null) {
        log.info(""Debugger: {} is enabled on CamelContext: {}"", getDebugger(), getName());
        // register this camel context on the debugger
        getDebugger().setCamelContext(this);
        startService(getDebugger());
        addInterceptStrategy(new Debug(getDebugger()));
    }
    // start management strategy before lifecycles are started
    ManagementStrategy managementStrategy = getManagementStrategy();
    // inject CamelContext if aware
    if (managementStrategy instanceof CamelContextAware) {
        ((CamelContextAware) managementStrategy).setCamelContext(this);
    }
    ServiceHelper.startService(managementStrategy);
    // start lifecycle strategies
    ServiceHelper.startServices(lifecycleStrategies);
    Iterator<LifecycleStrategy> it = lifecycleStrategies.iterator();
    while (it.hasNext()) {
        LifecycleStrategy strategy = it.next();
        try {
            strategy.onContextStart(this);
        } catch (VetoCamelContextStartException e) {
            // okay we should not start Camel since it was vetoed
            log.warn(""Lifecycle strategy vetoed starting CamelContext ({}) due {}"", getName(), e.getMessage());
            throw e;
        } catch (Exception e) {
            log.warn(""Lifecycle strategy "" + strategy + "" failed starting CamelContext ({}) due {}"", getName(), e.getMessage());
            throw e;
        }
    }
    // start notifiers as services
    for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {
        if (notifier instanceof Service) {
            Service service = (Service) notifier;
            for (LifecycleStrategy strategy : lifecycleStrategies) {
                strategy.onServiceAdd(this, service, null);
            }
        }
        if (notifier instanceof Service) {
            startService((Service) notifier);
        }
    }
    // must let some bootstrap service be started before we can notify the starting event
    EventHelper.notifyCamelContextStarting(this);
    forceLazyInitialization();
    // re-create endpoint registry as the cache size limit may be set after the constructor of this instance was called.
    // and we needed to create endpoints up-front as it may be accessed before this context is started
    endpoints = new EndpointRegistry(this, endpoints);
    addService(endpoints);
    // special for executorServiceManager as want to stop it manually
    doAddService(executorServiceManager, false);
    addService(producerServicePool);
    addService(inflightRepository);
    addService(shutdownStrategy);
    addService(packageScanClassResolver);
    addService(restRegistry);
    if (runtimeEndpointRegistry != null) {
        if (runtimeEndpointRegistry instanceof EventNotifier) {
            getManagementStrategy().addEventNotifier((EventNotifier) runtimeEndpointRegistry);
        }
        addService(runtimeEndpointRegistry);
    }
    // eager lookup any configured properties component to avoid subsequent lookup attempts which may impact performance
    // due we use properties component for property placeholder resolution at runtime
    Component existing = lookupPropertiesComponent();
    if (existing != null) {
        // store reference to the existing properties component
        if (existing instanceof PropertiesComponent) {
            propertiesComponent = (PropertiesComponent) existing;
        } else {
            // properties component must be expected type
            throw new IllegalArgumentException(""Found properties component of type: "" + existing.getClass() + "" instead of expected: "" + PropertiesComponent.class);
        }
    }
    // start components
    startServices(components.values());
    // start the route definitions before the routes is started
    startRouteDefinitions(routeDefinitions);
    // is there any stream caching enabled then log an info about this and its limit of spooling to disk, so people is aware of this
    boolean streamCachingInUse = isStreamCaching();
    if (!streamCachingInUse) {
        for (RouteDefinition route : routeDefinitions) {
            Boolean routeCache = CamelContextHelper.parseBoolean(this, route.getStreamCache());
            if (routeCache != null && routeCache) {
                streamCachingInUse = true;
                break;
            }
        }
    }
    if (isAllowUseOriginalMessage()) {
        log.info(""AllowUseOriginalMessage is enabled. If access to the original message is not needed,"" + "" then its recommended to turn this option off as it may improve performance."");
    }
    if (streamCachingInUse) {
        // stream caching is in use so enable the strategy
        getStreamCachingStrategy().setEnabled(true);
        addService(getStreamCachingStrategy());
    } else {
        // log if stream caching is not in use as this can help people to enable it if they use streams
        log.info(""StreamCaching is not in use. If using streams then its recommended to enable stream caching."" + "" See more details at http://camel.apache.org/stream-caching.html"");
    }
    // start routes
    if (doNotStartRoutesOnFirstStart) {
        log.debug(""Skip starting of routes as CamelContext has been configured with autoStartup=false"");
    }
    // invoke this logic to warmup the routes and if possible also start the routes
    doStartOrResumeRoutes(routeServices, true, !doNotStartRoutesOnFirstStart, false, true);
// starting will continue in the start method
}",,"private void doStartCamel() throws Exception {
    if (applicationContextClassLoader == null) {
                ClassLoader cl = Thread.currentThread().getContextClassLoader();
        if (cl == null) {
                        cl = this.getClass().getClassLoader();
        }
        setApplicationContextClassLoader(cl);
    }
    if (log.isDebugEnabled()) {
        log.debug(""Using ClassResolver={}, PackageScanClassResolver={}, ApplicationContextClassLoader={}"", new Object[] { getClassResolver(), getPackageScanClassResolver(), getApplicationContextClassLoader() });
    }
    if (isStreamCaching()) {
        log.info(""StreamCaching is enabled on CamelContext: {}"", getName());
    }
    if (isTracing()) {
                log.info(""Tracing is enabled on CamelContext: {}"", getName());
    }
    if (isUseMDCLogging()) {
                log.info(""MDC logging is enabled on CamelContext: {}"", getName());
    }
    if (isHandleFault()) {
                if (HandleFault.getHandleFault(this) == null) {
            log.info(""HandleFault is enabled on CamelContext: {}"", getName());
            addInterceptStrategy(new HandleFault());
        }
    }
    if (getDelayer() != null && getDelayer() > 0) {
        log.info(""Delayer is enabled with: {} ms. on CamelContext: {}"", getDelayer(), getName());
    }
        if (getDebugger() != null) {
        log.info(""Debugger: {} is enabled on CamelContext: {}"", getDebugger(), getName());
                getDebugger().setCamelContext(this);
        startService(getDebugger());
        addInterceptStrategy(new Debug(getDebugger()));
    }
        ManagementStrategy managementStrategy = getManagementStrategy();
        if (managementStrategy instanceof CamelContextAware) {
        ((CamelContextAware) managementStrategy).setCamelContext(this);
    }
    ServiceHelper.startService(managementStrategy);
        ServiceHelper.startServices(lifecycleStrategies);
    Iterator<LifecycleStrategy> it = lifecycleStrategies.iterator();
    while (it.hasNext()) {
        LifecycleStrategy strategy = it.next();
        try {
            strategy.onContextStart(this);
        } catch (VetoCamelContextStartException e) {
                        log.warn(""Lifecycle strategy vetoed starting CamelContext ({}) due {}"", getName(), e.getMessage());
            throw e;
        } catch (Exception e) {
            log.warn(""Lifecycle strategy "" + strategy + "" failed starting CamelContext ({}) due {}"", getName(), e.getMessage());
            throw e;
        }
    }
        for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {
        if (notifier instanceof Service) {
            Service service = (Service) notifier;
            for (LifecycleStrategy strategy : lifecycleStrategies) {
                strategy.onServiceAdd(this, service, null);
            }
        }
        if (notifier instanceof Service) {
            startService((Service) notifier);
        }
    }
        EventHelper.notifyCamelContextStarting(this);
    forceLazyInitialization();
            endpoints = new EndpointRegistry(this, endpoints);
    addService(endpoints);
        doAddService(executorServiceManager, false);
    addService(producerServicePool);
    addService(inflightRepository);
    addService(shutdownStrategy);
    addService(packageScanClassResolver);
    addService(restRegistry);
    if (runtimeEndpointRegistry != null) {
        if (runtimeEndpointRegistry instanceof EventNotifier) {
            getManagementStrategy().addEventNotifier((EventNotifier) runtimeEndpointRegistry);
        }
        addService(runtimeEndpointRegistry);
    }
            Component existing = lookupPropertiesComponent();
    if (existing != null) {
                if (existing instanceof PropertiesComponent) {
            propertiesComponent = (PropertiesComponent) existing;
        } else {
                        throw new IllegalArgumentException(""Found properties component of type: "" + existing.getClass() + "" instead of expected: "" + PropertiesComponent.class);
        }
    }
        startServices(components.values());
        startRouteDefinitions(routeDefinitions);
        boolean streamCachingInUse = isStreamCaching();
    if (!streamCachingInUse) {
        for (RouteDefinition route : routeDefinitions) {
            Boolean routeCache = CamelContextHelper.parseBoolean(this, route.getStreamCache());
            if (routeCache != null && routeCache) {
                streamCachingInUse = true;
                break;
            }
        }
    }
    if (isAllowUseOriginalMessage()) {
        log.info(""AllowUseOriginalMessage is enabled. If access to the original message is not needed,"" + "" then its recommended to turn this option off as it may improve performance."");
    }
    if (streamCachingInUse) {
                getStreamCachingStrategy().setEnabled(true);
        addService(getStreamCachingStrategy());
    } else {
                log.info(""StreamCaching is not in use. If using streams then its recommended to enable stream caching."" + "" See more details at http://camel.apache.org/stream-caching.html"");
    }
        if (doNotStartRoutesOnFirstStart) {
        log.debug(""Skip starting of routes as CamelContext has been configured with autoStartup=false"");
    }
        doStartOrResumeRoutes(routeServices, true, !doNotStartRoutesOnFirstStart, false, true);
}",4.590909090909091,0.18367346938775503,4.833333333333333,0.5,3.25,0.8116658428077115,-1.517063378262117,6.666666666666667,-0.028571428571428574,4.617532047575605
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1364_05c89637,1,"boolean containsValue(Object value) {
    for (Segment<K, V> s : segments) {
        for (K k : s.keySet()) {
            V v = find(k).value;
            if (v != null && v.equals(value)) {
                return true;
            }
        }
    }
    return false;
}",,"boolean containsValue(Object value) {
    for (Segment<K, V> s : segments) {
        for (K k : s.keySet()) {
            V v = find(k).value;
            if (v != null && v.equals(value)) {
                return true;
            }
        }
    }
    return false;
}",-0.13636363636363635,1.040816326530612,0.0,0.5,0.0,-0.08996539792387542,0.171780900487525,-0.25,0.6571428571428571,-0.08800716118228036
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1807_077efee5,3,"/**
 * Create a simple revision id. The format is similar to MongoDB ObjectId.
 *
 * @param clusterId the unique machineId + processId
 * @return the unique revision id
 */
static Revision newRevision(int clusterId) {
    long timestamp = getCurrentTimestamp();
    int c;
    synchronized (Revision.class) {
        if (timestamp == lastRevisionTimestamp) {
            c = ++lastRevisionCount;
        } else {
            lastRevisionTimestamp = timestamp;
            lastRevisionCount = c = 0;
        }
    }
    return new Revision(timestamp, c, clusterId);
}","/**
 * Create a simple revision id. The format is similar to MongoDB ObjectId.
 *
 * @param clusterId the unique machineId + processId
 * @return the unique revision id
 */
","static Revision newRevision(int clusterId) {
    long timestamp = getCurrentTimestamp();
    int c;
    synchronized (Revision.class) {
        if (timestamp == lastRevisionTimestamp) {
            c = ++lastRevisionCount;
        } else {
            lastRevisionTimestamp = timestamp;
            lastRevisionCount = c = 0;
        }
    }
    return new Revision(timestamp, c, clusterId);
}",-0.045454545454545456,0.5204081632653061,-0.3333333333333333,0.0,-0.16666666666666666,0.03460207612456753,0.1304846572985374,-0.4166666666666667,2.2571428571428576,-0.07103361729648237
Cli,9,1,"/**
 * <p>Throws a {@link MissingOptionException} if all of the
 * required options are no present.</p>
 *
 * @throws MissingOptionException if any of the required Options
 * are not present.
 */
protected void checkRequiredOptions() throws MissingOptionException {
    // processsed
    if (getRequiredOptions().size() > 0) {
        Iterator iter = getRequiredOptions().iterator();
        StringBuffer buff = new StringBuffer(""Missing required option"");
        buff.append(getRequiredOptions().size() == 1 ? """" : ""s"");
        buff.append("": "");
        // loop through the required options
        while (iter.hasNext()) {
            buff.append(iter.next());
        }
        throw new MissingOptionException(buff.toString());
    }
}","/**
 * <p>Throws a {@link MissingOptionException} if all of the
 * required options are no present.</p>
 *
 * @throws MissingOptionException if any of the required Options
 * are not present.
 */
","protected void checkRequiredOptions() throws MissingOptionException {
        if (getRequiredOptions().size() > 0) {
        Iterator iter = getRequiredOptions().iterator();
        StringBuffer buff = new StringBuffer(""Missing required option"");
        buff.append(getRequiredOptions().size() == 1 ? """" : ""s"");
        buff.append("": "");
                while (iter.hasNext()) {
            buff.append(iter.next());
        }
        throw new MissingOptionException(buff.toString());
    }
}",-0.09090909090909091,0.2193877551020409,0.16666666666666666,0.0,0.0,-0.054374691052891735,0.07628333811299104,0.5,1.3714285714285714,-0.04594806429645238
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-177_f91ce934,1,"protected void setOutputStream(final OutputStream os) {
    this.os = os;
}",,"protected void setOutputStream(final OutputStream os) {
    this.os = os;
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.0943504445081733,-0.5,2.085714285714286,-0.16422749602751402
Math,5,3,"/**
 * {@inheritDoc}
 */
public Complex reciprocal() {
    if (isNaN) {
        return NaN;
    }
    if (real == 0.0 && imaginary == 0.0) {
        return NaN;
    }
    if (isInfinite) {
        return ZERO;
    }
    if (FastMath.abs(real) < FastMath.abs(imaginary)) {
        double q = real / imaginary;
        double scale = 1. / (real * q + imaginary);
        return createComplex(scale * q, -scale);
    } else {
        double q = imaginary / real;
        double scale = 1. / (imaginary * q + real);
        return createComplex(scale, -scale * q);
    }
}","/**
 * {@inheritDoc}
 */
","public Complex reciprocal() {
    if (isNaN) {
        return NaN;
    }
    if (real == 0.0 && imaginary == 0.0) {
        return NaN;
    }
    if (isInfinite) {
        return ZERO;
    }
    if (FastMath.abs(real) < FastMath.abs(imaginary)) {
        double q = real / imaginary;
        double scale = 1. / (real * q + imaginary);
        return createComplex(scale * q, -scale);
    } else {
        double q = imaginary / real;
        double scale = 1. / (imaginary * q + real);
        return createComplex(scale, -scale * q);
    }
}",0.2727272727272727,-0.20408163265306117,0.16666666666666666,-0.5,0.5,1.6955017301038064,-0.24003441353599103,-0.16666666666666666,0.4857142857142857,1.114167748125115
wicket,remotes/origin/bugs-dot-jar_WICKET-3618_fbfd17e6,1,"/**
 *  Writes the content of the buffer to the specified response. Also sets the properties and and
 *  headers.
 *
 *  @param response
 */
public void writeTo(final WebResponse response) {
    Args.notNull(response, ""response"");
    for (Action action : actions) {
        action.invoke(response);
    }
}","/**
 *  Writes the content of the buffer to the specified response. Also sets the properties and and
 *  headers.
 *
 *  @param response
 */
","public void writeTo(final WebResponse response) {
    Args.notNull(response, ""response"");
    for (Action action : actions) {
        action.invoke(response);
    }
}",-0.36363636363636365,-0.13775510204081634,-0.3333333333333333,-0.5,-0.4166666666666667,-0.3806228373702422,0.6091195870375681,-0.3333333333333333,2.1142857142857143,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-4309_b4274415,1,"/**
 *  Convert to object types, returning null if text is null.
 *
 *  @return converted
 *  @throws StringValueConversionException
 */
public final Duration toOptionalDuration() throws StringValueConversionException {
    return (text == null) ? null : toDuration();
}","/**
 *  Convert to object types, returning null if text is null.
 *
 *  @return converted
 *  @throws StringValueConversionException
 */
","public final Duration toOptionalDuration() throws StringValueConversionException {
    return (text == null) ? null : toDuration();
}",-0.5,-0.576530612244898,-0.3333333333333333,-1.0,-0.25,-0.3806228373702422,1.012044737596788,-0.4166666666666667,2.8285714285714287,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3549_9772f5b2,1,"/**
 * OAK-2624 : background read operations are split from background update ops
 */
private void internalRunBackgroundReadOperations() {
    synchronized (backgroundReadMonitor) {
        long start = clock.getTime();
        // pull in changes from other cluster nodes
        BackgroundReadStats readStats = backgroundRead(true);
        long readTime = clock.getTime() - start;
        String msg = ""Background read operations stats (read:{} {})"";
        if (clock.getTime() - start > TimeUnit.SECONDS.toMillis(10)) {
            // log as info if it took more than 10 seconds
            LOG.info(msg, readTime, readStats);
        } else {
            LOG.debug(msg, readTime, readStats);
        }
    }
}","/**
 * OAK-2624 : background read operations are split from background update ops
 */
","private void internalRunBackgroundReadOperations() {
    synchronized (backgroundReadMonitor) {
        long start = clock.getTime();
                BackgroundReadStats readStats = backgroundRead(true);
        long readTime = clock.getTime() - start;
        String msg = ""Background read operations stats (read:{} {})"";
        if (clock.getTime() - start > TimeUnit.SECONDS.toMillis(10)) {
                        LOG.info(msg, readTime, readStats);
        } else {
            LOG.debug(msg, readTime, readStats);
        }
    }
}",-0.045454545454545456,0.31632653061224497,-0.3333333333333333,0.0,-0.08333333333333333,-0.06030647553138898,0.04158302265557795,0.08333333333333333,1.885714285714286,-0.03387427670774066
camel,remotes/origin/bugs-dot-jar_CAMEL-3789_9319e139,1,"@Override
public boolean begin(GenericFileOperations<T> operations, GenericFileEndpoint<T> endpoint, Exchange exchange, GenericFile<T> file) throws Exception {
    // must invoke super
    boolean result = super.begin(operations, endpoint, exchange, file);
    if (!result) {
        return false;
    }
    if (beginRenamer != null) {
        GenericFile<T> newName = beginRenamer.renameFile(exchange, file);
        GenericFile<T> to = renameFile(operations, file, newName);
        if (to != null) {
            to.bindToExchange(exchange);
        }
    }
    return true;
}",,"@Override
public boolean begin(GenericFileOperations<T> operations, GenericFileEndpoint<T> endpoint, Exchange exchange, GenericFile<T> file) throws Exception {
        boolean result = super.begin(operations, endpoint, exchange, file);
    if (!result) {
        return false;
    }
    if (beginRenamer != null) {
        GenericFile<T> newName = beginRenamer.renameFile(exchange, file);
        GenericFile<T> to = renameFile(operations, file, newName);
        if (to != null) {
            to.bindToExchange(exchange);
        }
    }
    return true;
}",0.045454545454545456,0.19897959183673475,0.0,0.0,0.08333333333333333,0.024715768660405344,-0.07255520504731866,-0.16666666666666666,-0.028571428571428574,0.04325833793756237
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3396_c83755c3,0,"@Nonnull
private ExternalGroup createGroup(@Nonnull Entry entry, @CheckForNull String name) throws LdapInvalidAttributeValueException {
    ExternalIdentityRef ref = new ExternalIdentityRef(entry.getDn().getName(), this.getName());
    if (name == null) {
        name = entry.get(config.getGroupConfig().getIdAttribute()).getString();
    }
    String path = config.getGroupConfig().makeDnPath() ? createDNPath(entry.getDn()) : null;
    LdapGroup group = new LdapGroup(this, ref, name, path);
    Map<String, Object> props = group.getProperties();
    applyAttributes(props, entry);
    return group;
}",,"@Nonnull
private ExternalGroup createGroup(@Nonnull Entry entry, @CheckForNull String name) throws LdapInvalidAttributeValueException {
    ExternalIdentityRef ref = new ExternalIdentityRef(entry.getDn().getName(), this.getName());
    if (name == null) {
        name = entry.get(config.getGroupConfig().getIdAttribute()).getString();
    }
    String path = config.getGroupConfig().makeDnPath() ? createDNPath(entry.getDn()) : null;
    LdapGroup group = new LdapGroup(this, ref, name, path);
    Map<String, Object> props = group.getProperties();
    applyAttributes(props, entry);
    return group;
}",-0.09090909090909091,-0.413265306122449,-0.16666666666666666,-0.5,-0.08333333333333333,-0.0385565991102323,0.007456266131344737,0.5833333333333334,-0.028571428571428574,0.05106625378510458
wicket,remotes/origin/bugs-dot-jar_WICKET-2624_ef880545,1,"/**
 *  @param object
 *  @param value
 *  @param converter
 */
public final void setValue(final Object object, final Object value, PropertyResolverConverter converter) {
    Class type = null;
    if (setMethod != null) {
        type = getMethod.getReturnType();
    } else if (field != null) {
        type = field.getType();
    }
    Object converted = null;
    if (type != null) {
        converted = converter.convert(value, getMethod.getReturnType());
        if (converted == null) {
            if (value != null) {
                throw new ConversionException(""Can't convert value: "" + value + "" to class: "" + getMethod.getReturnType() + "" for setting it on "" + object);
            } else if (getMethod.getReturnType().isPrimitive()) {
                throw new ConversionException(""Can't convert null value to a primitive class: "" + getMethod.getReturnType() + "" for setting it on "" + object);
            }
        }
    }
    if (setMethod != null) {
        try {
            setMethod.invoke(object, new Object[] { converted });
        } catch (InvocationTargetException ex) {
            throw new WicketRuntimeException(""Error calling method: "" + setMethod + "" on object: "" + object, ex.getCause());
        } catch (Exception ex) {
            throw new WicketRuntimeException(""Error calling method: "" + setMethod + "" on object: "" + object, ex);
        }
    } else if (field != null) {
        try {
            field.set(object, converted);
        } catch (Exception ex) {
            throw new WicketRuntimeException(""Error setting field: "" + field + "" on object: "" + object, ex);
        }
    } else {
        throw new WicketRuntimeException(""no set method defined for value: "" + value + "" on object: "" + object + "" while respective getMethod being "" + getMethod.getName());
    }
}","/**
 *  @param object
 *  @param value
 *  @param converter
 */
","public final void setValue(final Object object, final Object value, PropertyResolverConverter converter) {
    Class type = null;
    if (setMethod != null) {
        type = getMethod.getReturnType();
    } else if (field != null) {
        type = field.getType();
    }
    Object converted = null;
    if (type != null) {
        converted = converter.convert(value, getMethod.getReturnType());
        if (converted == null) {
            if (value != null) {
                throw new ConversionException(""Can't convert value: "" + value + "" to class: "" + getMethod.getReturnType() + "" for setting it on "" + object);
            } else if (getMethod.getReturnType().isPrimitive()) {
                throw new ConversionException(""Can't convert null value to a primitive class: "" + getMethod.getReturnType() + "" for setting it on "" + object);
            }
        }
    }
    if (setMethod != null) {
        try {
            setMethod.invoke(object, new Object[] { converted });
        } catch (InvocationTargetException ex) {
            throw new WicketRuntimeException(""Error calling method: "" + setMethod + "" on object: "" + object, ex.getCause());
        } catch (Exception ex) {
            throw new WicketRuntimeException(""Error calling method: "" + setMethod + "" on object: "" + object, ex);
        }
    } else if (field != null) {
        try {
            field.set(object, converted);
        } catch (Exception ex) {
            throw new WicketRuntimeException(""Error setting field: "" + field + "" on object: "" + object, ex);
        }
    } else {
        throw new WicketRuntimeException(""no set method defined for value: "" + value + "" on object: "" + object + "" while respective getMethod being "" + getMethod.getName());
    }
}",1.0,0.46428571428571436,2.3333333333333335,1.0,0.75,0.7068709836875928,-0.71580154860912,0.5,-0.028571428571428574,1.302555668341321
Math,29,1,"/**
 * {@inheritDoc}
 */
@Override
public OpenMapRealVector ebeDivide(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);
    /*
         * MATH-803: it is not sufficient to loop through non zero entries of
         * this only. Indeed, if this[i] = 0d and v[i] = 0d, then
         * this[i] / v[i] = NaN, and not 0d.
         */
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
    }
    return res;
}","/**
 * {@inheritDoc}
 */
","@Override
public OpenMapRealVector ebeDivide(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);
        Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
    }
    return res;
}",-0.13636363636363635,-0.17857142857142863,-0.3333333333333333,-0.5,-0.25,-0.05832921403855659,0.15342701462575267,0.3333333333333333,0.5428571428571429,-0.05986782650408384
wicket,remotes/origin/bugs-dot-jar_WICKET-4398_f88721fd,1,"/**
 *  @param qp
 *  @param charset
 *  @return query parameters
 */
private static QueryParameter parseQueryParameter(final String qp, final Charset charset) {
    if (qp.indexOf('=') == -1) {
        return new QueryParameter(decodeParameter(qp, charset), """");
    }
    String[] parts = Strings.split(qp, '=');
    if (parts.length == 0) {
        return new QueryParameter("""", """");
    } else if (parts.length == 1) {
        return new QueryParameter("""", decodeParameter(parts[0], charset));
    } else {
        return new QueryParameter(decodeParameter(parts[0], charset), decodeParameter(parts[1], charset));
    }
}","/**
 *  @param qp
 *  @param charset
 *  @return query parameters
 */
","private static QueryParameter parseQueryParameter(final String qp, final Charset charset) {
    if (qp.indexOf('=') == -1) {
        return new QueryParameter(decodeParameter(qp, charset), """");
    }
    String[] parts = Strings.split(qp, '=');
    if (parts.length == 0) {
        return new QueryParameter("""", """");
    } else if (parts.length == 1) {
        return new QueryParameter("""", decodeParameter(parts[0], charset));
    } else {
        return new QueryParameter(decodeParameter(parts[0], charset), decodeParameter(parts[1], charset));
    }
}",-0.045454545454545456,-0.1887755102040817,0.0,0.0,0.0,0.1552150271873456,0.004588471465442978,0.0,0.028571428571428574,0.09122369700318225
wicket,remotes/origin/bugs-dot-jar_WICKET-5701_087c0a26,1,"@Override
public void run() {
    if (pageId != NO_PAGE_ID) {
        page.send(application, Broadcast.BREADTH, payload);
    } else {
        ResourceReference reference = new SharedResourceReference(resourceName);
        IResource resource = reference.getResource();
        if (resource instanceof WebSocketResource) {
            WebSocketResource wsResource = (WebSocketResource) resource;
            wsResource.onPayload(payload);
        } else {
            throw new IllegalStateException(String.format(""Shared resource with name '%s' is not a %s but %s"", resourceName, WebSocketResource.class.getSimpleName(), Classes.name(resource.getClass())));
        }
    }
}",,"@Override
public void run() {
    if (pageId != NO_PAGE_ID) {
        page.send(application, Broadcast.BREADTH, payload);
    } else {
        ResourceReference reference = new SharedResourceReference(resourceName);
        IResource resource = reference.getResource();
        if (resource instanceof WebSocketResource) {
            WebSocketResource wsResource = (WebSocketResource) resource;
            wsResource.onPayload(payload);
        } else {
            throw new IllegalStateException(String.format(""Shared resource with name '%s' is not a %s but %s"", resourceName, WebSocketResource.class.getSimpleName(), Classes.name(resource.getClass())));
        }
    }
}",0.045454545454545456,0.5408163265306123,0.0,0.0,-0.08333333333333333,-0.11566979733069695,-0.05678233438485818,0.08333333333333333,-0.028571428571428574,-0.04152372141630368
camel,remotes/origin/bugs-dot-jar_CAMEL-5515_b3bb8670,1,"/**
 * Continues processing the {@link org.apache.camel.Exchange} using asynchronous routing engine.
 *
 * @param poolSize    the core pool size
 * @param maxPoolSize the maximum pool size
 * @param threadName the thread pool name
 * @return the builder
 */
public ThreadsDefinition threads(int poolSize, int maxPoolSize, String threadName) {
    ThreadsDefinition answer = threads();
    answer.setPoolSize(poolSize);
    answer.setMaxPoolSize(maxPoolSize);
    answer.setThreadName(threadName);
    addOutput(answer);
    return answer;
}","/**
 * Continues processing the {@link org.apache.camel.Exchange} using asynchronous routing engine.
 *
 * @param poolSize    the core pool size
 * @param maxPoolSize the maximum pool size
 * @param threadName the thread pool name
 * @return the builder
 */
","public ThreadsDefinition threads(int poolSize, int maxPoolSize, String threadName) {
    ThreadsDefinition answer = threads();
    answer.setPoolSize(poolSize);
    answer.setMaxPoolSize(maxPoolSize);
    answer.setThreadName(threadName);
    addOutput(answer);
    return answer;
}",-0.2727272727272727,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.3917407513622025,-0.08333333333333333,1.6285714285714286,-0.16422749602751402
flink,remotes/origin/bugs-dot-jar_FLINK-2294_fef9f115,0,"@Override
public void collect(T record) {
    try {
        operator.processElement(serializer.copy(record));
    } catch (Exception e) {
        if (LOG.isErrorEnabled()) {
            LOG.error(""Could not forward element to operator."", e);
        }
        throw new RuntimeException(e);
    }
}",,"@Override
public void collect(T record) {
    try {
        operator.processElement(serializer.copy(record));
    } catch (Exception e) {
        if (LOG.isErrorEnabled()) {
            LOG.error(""Could not forward element to operator."", e);
        }
        throw new RuntimeException(e);
    }
}",-0.13636363636363635,0.42346938775510207,0.0,0.0,-0.25,-0.3806228373702422,0.23343848580441648,-0.16666666666666666,0.4857142857142857,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-6447_020c451a,1,"public void done(boolean doneSync) {
    // we only have to handle async completion of the pipeline
    if (doneSync) {
        return;
    }
    // continue processing the pipeline asynchronously
    while (continueRouting(processors, exchange)) {
        AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());
        // check for error if so we should break out
        if (!continueProcessing(exchange, ""so breaking out of pipeline"", LOG)) {
            break;
        }
        doneSync = process(exchange, callback, processors, processor);
        if (!doneSync) {
            LOG.trace(""Processing exchangeId: {} is continued being processed asynchronously"", exchange.getExchangeId());
            return;
        }
    }
    LOG.trace(""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
    callback.done(false);
}",,"public void done(boolean doneSync) {
        if (doneSync) {
        return;
    }
        while (continueRouting(processors, exchange)) {
        AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());
                if (!continueProcessing(exchange, ""so breaking out of pipeline"", LOG)) {
            break;
        }
        doneSync = process(exchange, callback, processors, processor);
        if (!doneSync) {
            LOG.trace(""Processing exchangeId: {} is continued being processed asynchronously"", exchange.getExchangeId());
            return;
        }
    }
    LOG.trace(""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
    callback.done(false);
}",0.18181818181818182,0.2755102040816327,0.3333333333333333,0.0,0.3333333333333333,-0.02273850716757287,-0.13765414396329217,0.3333333333333333,-0.028571428571428574,-0.01698210989331037
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3530_4d231938,1,"public int getType(Tree tree) {
    if (tree.isRoot()) {
        return TYPE_DEFAULT;
    } else {
        return getType(tree, getType(tree.getParent()));
    }
}",,"public int getType(Tree tree) {
    if (tree.isRoot()) {
        return TYPE_DEFAULT;
    } else {
        return getType(tree, getType(tree.getParent()));
    }
}",-0.3181818181818182,0.0,-0.3333333333333333,-0.5,-0.25,-0.3806228373702422,0.5856036707771726,-0.16666666666666666,0.4285714285714286,-0.16422749602751402
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1025_a96b455c,1,"/*
     * TODO consider making public.
     */
private void mapJulToLog4j(java.util.logging.Level julLevel, Level level) {
    julToLog4j.put(julLevel, level);
}",,"private void mapJulToLog4j(java.util.logging.Level julLevel, Level level) {
    julToLog4j.put(julLevel, level);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9486664754803554,-0.4166666666666667,2.4,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-349_4cc9a49d,3,"/**
 * Set the Poisson mean for the distribution. The mean value must be
 * positive; otherwise an <code>IllegalArgument</code> is thrown.
 *
 * @param p the Poisson mean value
 * @throws IllegalArgumentException if p &le; 0
 * @deprecated as of 2.1 (class will become immutable in 3.0)
 */
@Deprecated
public void setMean(double p) {
    setNormalAndMeanInternal(normal, p);
}","/**
 * Set the Poisson mean for the distribution. The mean value must be
 * positive; otherwise an <code>IllegalArgument</code> is thrown.
 *
 * @param p the Poisson mean value
 * @throws IllegalArgumentException if p &le; 0
 * @deprecated as of 2.1 (class will become immutable in 3.0)
 */
","@Deprecated
public void setMean(double p) {
    setNormalAndMeanInternal(normal, p);
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9446515629480932,-0.4166666666666667,2.685714285714286,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2528_239de7b8,1,"private List<UpdateOp> create() {
    if (!considerSplit()) {
        return Collections.emptyList();
    }
    splitOps = Lists.newArrayList();
    mostRecentRevs = Sets.newHashSet();
    splitRevs = Sets.newHashSet();
    garbage = Maps.newHashMap();
    committedChanges = getCommittedLocalChanges();
    // revisions of the most recent committed changes on this document
    // these are kept in the main document. _revisions and _commitRoot
    // entries with these revisions are retained in the main document
    populateSplitRevs();
    // collect _revisions and _commitRoot entries for split document
    collectRevisionsAndCommitRoot();
    // create split ops out of the split values
    main = createSplitOps();
    // create intermediate docs if needed
    createIntermediateDocs();
    // remove stale references to previous docs
    disconnectStalePrevDocs();
    // remove garbage
    removeGarbage();
    // main document must be updated last
    if (main != null) {
        splitOps.add(main);
    }
    return splitOps;
}",,"private List<UpdateOp> create() {
    if (!considerSplit()) {
        return Collections.emptyList();
    }
    splitOps = Lists.newArrayList();
    mostRecentRevs = Sets.newHashSet();
    splitRevs = Sets.newHashSet();
    garbage = Maps.newHashMap();
    committedChanges = getCommittedLocalChanges();
                populateSplitRevs();
        collectRevisionsAndCommitRoot();
        main = createSplitOps();
        createIntermediateDocs();
        disconnectStalePrevDocs();
        removeGarbage();
        if (main != null) {
        splitOps.add(main);
    }
    return splitOps;
}",0.2727272727272727,-0.6275510204081632,-0.16666666666666666,-0.5,-0.08333333333333333,-0.14137419673751853,-0.18038428448523108,0.6666666666666666,0.20000000000000004,-0.05601312312350898
wicket,remotes/origin/bugs-dot-jar_WICKET-3620_1a2bc1bc,1,"@Override
protected void invoke(WebResponse response) {
    AppendingStringBuffer responseBuffer = new AppendingStringBuffer(builder);
    List<IResponseFilter> responseFilters = Application.get().getRequestCycleSettings().getResponseFilters();
    if (responseFilters != null) {
        for (IResponseFilter filter : responseFilters) {
            filter.filter(responseBuffer);
        }
    }
    response.write(builder);
}",,"@Override
protected void invoke(WebResponse response) {
    AppendingStringBuffer responseBuffer = new AppendingStringBuffer(builder);
    List<IResponseFilter> responseFilters = Application.get().getRequestCycleSettings().getResponseFilters();
    if (responseFilters != null) {
        for (IResponseFilter filter : responseFilters) {
            filter.filter(responseBuffer);
        }
    }
    response.write(builder);
}",-0.13636363636363635,0.2959183673469388,-0.16666666666666666,0.0,-0.25,-0.08403361344537813,0.16805276742185263,-0.08333333333333333,0.1142857142857143,-0.08092735597329119
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7,3,"@Override
public void write(org.apache.thrift.protocol.TProtocol prot, removeConstraint_result struct) throws org.apache.thrift.TException {
    TTupleProtocol oprot = (TTupleProtocol) prot;
    BitSet optionals = new BitSet();
    if (struct.isSetOuch1()) {
        optionals.set(0);
    }
    if (struct.isSetOuch2()) {
        optionals.set(1);
    }
    oprot.writeBitSet(optionals, 2);
    if (struct.isSetOuch1()) {
        struct.ouch1.write(oprot);
    }
    if (struct.isSetOuch2()) {
        struct.ouch2.write(oprot);
    }
}",,"@Override
public void write(org.apache.thrift.protocol.TProtocol prot, removeConstraint_result struct) throws org.apache.thrift.TException {
    TTupleProtocol oprot = (TTupleProtocol) prot;
    BitSet optionals = new BitSet();
    if (struct.isSetOuch1()) {
        optionals.set(0);
    }
    if (struct.isSetOuch2()) {
        optionals.set(1);
    }
    oprot.writeBitSet(optionals, 2);
    if (struct.isSetOuch1()) {
        struct.ouch1.write(oprot);
    }
    if (struct.isSetOuch2()) {
        struct.ouch2.write(oprot);
    }
}",0.18181818181818182,-0.2755102040816327,0.16666666666666666,-0.5,0.08333333333333333,-0.3806228373702422,-0.16260395755663903,0.25,-0.028571428571428574,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-4173_84bbbf68,1,"/*
	 * TODO: simplify the code below. See WICKET-3347
	 */
@Override
public void respond(RequestCycle requestCycle) {
    Url currentUrl = requestCycle.getUrlRenderer().getBaseUrl();
    Url targetUrl = requestCycle.mapUrlFor(getRenderPageRequestHandler());
    // 
    // the code below is little hairy but we have to handle 3 redirect policies,
    // 3 rendering strategies and two kind of requests (ajax and normal)
    // 
    // try to get an already rendered buffered response for current URL
    BufferedWebResponse bufferedResponse = getAndRemoveBufferedResponse(currentUrl);
    boolean isAjax = isAjax(requestCycle);
    boolean shouldPreserveClientUrl = ((WebRequest) requestCycle.getRequest()).shouldPreserveClientUrl();
    if (bufferedResponse != null) {
        logger.warn(""The Buffered response should be handled by BufferedResponseRequestHandler"");
        // if there is saved response for this URL render it
        bufferedResponse.writeTo((WebResponse) requestCycle.getResponse());
    } else if (getRedirectPolicy() == RedirectPolicy.NEVER_REDIRECT || // 
    (isOnePassRender() && isAjax == false) || (// 
    !isAjax && // 
    (targetUrl.equals(currentUrl) && !getPageProvider().isNewPageInstance() && !getPage().isPageStateless()) || // 
    (targetUrl.equals(currentUrl) && isRedirectToRender())) || // 
    shouldPreserveClientUrl) {
        // if the policy is never to redirect
        // or one pass render mode is on
        // or the targetUrl matches current url and the page is not stateless
        // or the targetUrl matches current url, page is stateless but it's redirect-to-render
        // or the request determines that the current url should be preserved
        // just render the page
        BufferedWebResponse response = renderPage(currentUrl, requestCycle);
        if (response != null) {
            response.writeTo((WebResponse) requestCycle.getResponse());
        }
    } else if (// 
    getRedirectPolicy() == RedirectPolicy.ALWAYS_REDIRECT || // 
    isRedirectToRender() || (isAjax && targetUrl.equals(currentUrl))) {
        // if target URL is different
        // and render policy is always-redirect or it's redirect-to-render
        redirectTo(targetUrl, requestCycle);
    } else if (// 
    !targetUrl.equals(currentUrl) && (getPageProvider().isNewPageInstance() || (isSessionTemporary() && getPage().isPageStateless()))) {
        // if target URL is different and session is temporary and page is stateless
        // this is special case when page is stateless but there is no session so we can't
        // render it to buffer
        // alternatively if URLs are different and we have a page class and not an instance we
        // can redirect to the url which will instantiate the instance of us
        // note: if we had session here we would render the page to buffer and then redirect to
        // URL generated *after* page has been rendered (the statelessness may change during
        // render). this would save one redirect because now we have to render to URL generated
        // *before* page is rendered, render the page, get URL after render and if the URL is
        // different (meaning page is not stateless), save the buffer and redirect again (which
        // is pretty much what the next step does)
        redirectTo(targetUrl, requestCycle);
    } else {
        if (isRedirectToBuffer() == false && logger.isWarnEnabled()) {
            logger.warn(""Falling back to Redirect_To_Buffer render strategy because none of the conditions matched."");
        }
        // redirect to buffer
        BufferedWebResponse response = renderPage(targetUrl, requestCycle);
        if (response == null) {
            return;
        }
        // check if the url hasn't changed after page has been rendered
        // (i.e. the stateless flag might have changed which could result in different page url)
        Url targetUrl2 = requestCycle.mapUrlFor(getRenderPageRequestHandler());
        if (targetUrl.getSegments().equals(targetUrl2.getSegments()) == false) {
            // the amount of segments is different - generated relative URLs will not work, we
            // need to rerender the page. This shouldn't happen, but in theory it can - with
            // RequestHandlerEncoders that produce different URLs with different amount of
            // segments for stateless and stateful pages
            response = renderPage(targetUrl2, requestCycle);
        }
        if (currentUrl.equals(targetUrl2)) {
            // no need to redirect when both urls are exactly the same
            response.writeTo((WebResponse) requestCycle.getResponse());
        } else // if page is still stateless after render
        if (getPage().isPageStateless() && !enableRedirectForStatelessPage()) {
            // we don't want the redirect to happen for stateless page
            // example:
            // when a normal mounted stateful page is hit at /mount/point
            // wicket renders the page to buffer and redirects to /mount/point?12
            // but for stateless page the redirect is not necessary
            // also for listener interface on stateful page we want to redirect
            // after the listener is invoked, but on stateless page the user
            // must ask for redirect explicitly
            response.writeTo((WebResponse) requestCycle.getResponse());
        } else {
            storeBufferedResponse(targetUrl2, response);
            redirectTo(targetUrl2, requestCycle);
        }
    }
}",,"@Override
public void respond(RequestCycle requestCycle) {
    Url currentUrl = requestCycle.getUrlRenderer().getBaseUrl();
    Url targetUrl = requestCycle.mapUrlFor(getRenderPageRequestHandler());
                        BufferedWebResponse bufferedResponse = getAndRemoveBufferedResponse(currentUrl);
    boolean isAjax = isAjax(requestCycle);
    boolean shouldPreserveClientUrl = ((WebRequest) requestCycle.getRequest()).shouldPreserveClientUrl();
    if (bufferedResponse != null) {
        logger.warn(""The Buffered response should be handled by BufferedResponseRequestHandler"");
                bufferedResponse.writeTo((WebResponse) requestCycle.getResponse());
    } else if (getRedirectPolicy() == RedirectPolicy.NEVER_REDIRECT ||     (isOnePassRender() && isAjax == false) || (    !isAjax &&     (targetUrl.equals(currentUrl) && !getPageProvider().isNewPageInstance() && !getPage().isPageStateless()) ||     (targetUrl.equals(currentUrl) && isRedirectToRender())) ||     shouldPreserveClientUrl) {
                                                        BufferedWebResponse response = renderPage(currentUrl, requestCycle);
        if (response != null) {
            response.writeTo((WebResponse) requestCycle.getResponse());
        }
    } else if (    getRedirectPolicy() == RedirectPolicy.ALWAYS_REDIRECT ||     isRedirectToRender() || (isAjax && targetUrl.equals(currentUrl))) {
                        redirectTo(targetUrl, requestCycle);
    } else if (    !targetUrl.equals(currentUrl) && (getPageProvider().isNewPageInstance() || (isSessionTemporary() && getPage().isPageStateless()))) {
                                                                                                redirectTo(targetUrl, requestCycle);
    } else {
        if (isRedirectToBuffer() == false && logger.isWarnEnabled()) {
            logger.warn(""Falling back to Redirect_To_Buffer render strategy because none of the conditions matched."");
        }
                BufferedWebResponse response = renderPage(targetUrl, requestCycle);
        if (response == null) {
            return;
        }
                        Url targetUrl2 = requestCycle.mapUrlFor(getRenderPageRequestHandler());
        if (targetUrl.getSegments().equals(targetUrl2.getSegments()) == false) {
                                                            response = renderPage(targetUrl2, requestCycle);
        }
        if (currentUrl.equals(targetUrl2)) {
                        response.writeTo((WebResponse) requestCycle.getResponse());
        } else         if (getPage().isPageStateless() && !enableRedirectForStatelessPage()) {
                                                                                                            response.writeTo((WebResponse) requestCycle.getResponse());
        } else {
            storeBufferedResponse(targetUrl2, response);
            redirectTo(targetUrl2, requestCycle);
        }
    }
}",1.6363636363636365,0.12244897959183662,1.1666666666666667,2.0,3.4166666666666665,1.3257538309441428,-0.8979065098938919,4.0,-0.028571428571428574,3.6620453056137334
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2336_d0f6715d,1,"/**
 * Returns a {@link DocumentNodeState} as seen at the given
 * <code>readRevision</code>.
 *
 * @param nodeStore    the node store.
 * @param readRevision the read revision.
 * @param lastModified the revision when this node was last modified, but
 *                     the value is potentially not yet reflected in this
 *                     document.
 *                     See {@link RevisionContext#getPendingModifications()}.
 * @return the node or <code>null</code> if the node doesn't exist at the
 *         given read revision.
 */
@CheckForNull
public DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore, @Nonnull Revision readRevision, @Nullable Revision lastModified) {
    Map<Revision, String> validRevisions = Maps.newHashMap();
    Branch branch = nodeStore.getBranches().getBranch(readRevision);
    LastRevs lastRevs = new LastRevs(getLastRev(), readRevision, branch);
    // overlay with unsaved last modified from this instance
    lastRevs.update(lastModified);
    Revision min = getLiveRevision(nodeStore, readRevision, validRevisions, lastRevs);
    if (min == null) {
        // deleted
        return null;
    }
    String path = getPath();
    DocumentNodeState n = new DocumentNodeState(nodeStore, path, readRevision, hasChildren());
    Revision lastRevision = min;
    for (String key : keySet()) {
        if (!Utils.isPropertyName(key)) {
            continue;
        }
        // first check local map, which contains most recent values
        Value value = getLatestValue(nodeStore, getLocalMap(key), min, readRevision, validRevisions, lastRevs);
        // check if there may be more recent values in a previous document
        if (value != null && !getPreviousRanges().isEmpty()) {
            Revision newest = getLocalMap(key).firstKey();
            if (!value.revision.equals(newest)) {
                // not reading the most recent value, we may need to
                // consider previous documents as well
                Revision newestPrev = getPreviousRanges().firstKey();
                if (isRevisionNewer(nodeStore, newestPrev, value.revision)) {
                    // a previous document has more recent changes
                    // than value.revision
                    value = null;
                }
            }
        }
        if (value == null && !getPreviousRanges().isEmpty()) {
            // check complete revision history
            value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions, lastRevs);
        }
        String propertyName = Utils.unescapePropertyName(key);
        String v = value != null ? value.value : null;
        n.setProperty(propertyName, v);
        // keep track of when this node was last modified
        if (value != null && isRevisionNewer(nodeStore, value.revision, lastRevision)) {
            lastRevision = value.revision;
        }
    }
    // lastRevision now points to the revision when this node was
    // last modified directly. but it may also have been 'modified'
    // by an operation on a descendant node, which is tracked in
    // _lastRev.
    // when was this node last modified?
    Revision branchBase = null;
    if (branch != null) {
        branchBase = branch.getBase(readRevision);
    }
    for (Revision r : lastRevs.get().values()) {
        // ignore if newer than readRevision
        if (isRevisionNewer(nodeStore, r, readRevision)) {
            // the node has a _lastRev which is newer than readRevision
            // this means we don't know when this node was
            // modified by an operation on a descendant node between
            // current lastRevision and readRevision. therefore we have
            // to stay on the safe side and use readRevision
            lastRevision = readRevision;
            continue;
        } else if (branchBase != null && isRevisionNewer(nodeStore, r, branchBase)) {
            // readRevision is on a branch and the node has a
            // _lastRev which is newer than the base of the branch
            // we cannot use this _lastRev because it is not visible
            // from this branch. highest possible revision of visible
            // changes is the base of the branch
            r = branchBase;
        }
        if (revisionAreAmbiguous(nodeStore, r, lastRevision)) {
            // _lastRev entries from multiple cluster nodes are ambiguous
            // use readRevision to make sure read is consistent
            lastRevision = readRevision;
        } else if (isRevisionNewer(nodeStore, r, lastRevision)) {
            lastRevision = r;
        }
    }
    if (branch != null) {
        // read from a branch
        // -> possibly overlay with unsaved last revs from branch
        lastRevs.updateBranch(branch.getUnsavedLastRevision(path, readRevision));
        Revision r = lastRevs.getBranchRevision();
        if (r != null) {
            lastRevision = r;
        }
    }
    n.setLastRevision(lastRevision);
    return n;
}","/**
 * Returns a {@link DocumentNodeState} as seen at the given
 * <code>readRevision</code>.
 *
 * @param nodeStore    the node store.
 * @param readRevision the read revision.
 * @param lastModified the revision when this node was last modified, but
 *                     the value is potentially not yet reflected in this
 *                     document.
 *                     See {@link RevisionContext#getPendingModifications()}.
 * @return the node or <code>null</code> if the node doesn't exist at the
 *         given read revision.
 */
","@CheckForNull
public DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore, @Nonnull Revision readRevision, @Nullable Revision lastModified) {
    Map<Revision, String> validRevisions = Maps.newHashMap();
    Branch branch = nodeStore.getBranches().getBranch(readRevision);
    LastRevs lastRevs = new LastRevs(getLastRev(), readRevision, branch);
        lastRevs.update(lastModified);
    Revision min = getLiveRevision(nodeStore, readRevision, validRevisions, lastRevs);
    if (min == null) {
                return null;
    }
    String path = getPath();
    DocumentNodeState n = new DocumentNodeState(nodeStore, path, readRevision, hasChildren());
    Revision lastRevision = min;
    for (String key : keySet()) {
        if (!Utils.isPropertyName(key)) {
            continue;
        }
                Value value = getLatestValue(nodeStore, getLocalMap(key), min, readRevision, validRevisions, lastRevs);
                if (value != null && !getPreviousRanges().isEmpty()) {
            Revision newest = getLocalMap(key).firstKey();
            if (!value.revision.equals(newest)) {
                                                Revision newestPrev = getPreviousRanges().firstKey();
                if (isRevisionNewer(nodeStore, newestPrev, value.revision)) {
                                                            value = null;
                }
            }
        }
        if (value == null && !getPreviousRanges().isEmpty()) {
                        value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions, lastRevs);
        }
        String propertyName = Utils.unescapePropertyName(key);
        String v = value != null ? value.value : null;
        n.setProperty(propertyName, v);
                if (value != null && isRevisionNewer(nodeStore, value.revision, lastRevision)) {
            lastRevision = value.revision;
        }
    }
                        Revision branchBase = null;
    if (branch != null) {
        branchBase = branch.getBase(readRevision);
    }
    for (Revision r : lastRevs.get().values()) {
                if (isRevisionNewer(nodeStore, r, readRevision)) {
                                                                        lastRevision = readRevision;
            continue;
        } else if (branchBase != null && isRevisionNewer(nodeStore, r, branchBase)) {
                                                                        r = branchBase;
        }
        if (revisionAreAmbiguous(nodeStore, r, lastRevision)) {
                                    lastRevision = readRevision;
        } else if (isRevisionNewer(nodeStore, r, lastRevision)) {
            lastRevision = r;
        }
    }
    if (branch != null) {
                        lastRevs.updateBranch(branch.getUnsavedLastRevision(path, readRevision));
        Revision r = lastRevs.getBranchRevision();
        if (r != null) {
            lastRevision = r;
        }
    }
    n.setLastRevision(lastRevision);
    return n;
}",2.272727272727273,0.5204081632653061,2.6666666666666665,1.0,2.9166666666666665,0.8492338111715275,-1.1210209349010616,2.6666666666666665,-0.028571428571428574,3.6643923916721275
maven,remotes/origin/bugs-dot-jar_MNG-5003_a7d9b689,1,"public synchronized void setupPluginRealm(PluginDescriptor pluginDescriptor, MavenSession session, ClassLoader parent, List<String> imports, DependencyFilter filter) throws PluginResolutionException, PluginContainerException {
    Plugin plugin = pluginDescriptor.getPlugin();
    MavenProject project = session.getCurrentProject();
    Map<String, ClassLoader> foreignImports = calcImports(project, parent, imports);
    PluginRealmCache.Key cacheKey = pluginRealmCache.createKey(plugin, parent, foreignImports, filter, project.getRemotePluginRepositories(), session.getRepositorySession());
    PluginRealmCache.CacheRecord cacheRecord = pluginRealmCache.get(cacheKey);
    if (cacheRecord != null) {
        pluginDescriptor.setClassRealm(cacheRecord.realm);
        pluginDescriptor.setArtifacts(new ArrayList<Artifact>(cacheRecord.artifacts));
    } else {
        createPluginRealm(pluginDescriptor, session, parent, foreignImports, filter);
        cacheRecord = pluginRealmCache.put(cacheKey, pluginDescriptor.getClassRealm(), pluginDescriptor.getArtifacts());
    }
    pluginRealmCache.register(project, cacheRecord);
}",,"public synchronized void setupPluginRealm(PluginDescriptor pluginDescriptor, MavenSession session, ClassLoader parent, List<String> imports, DependencyFilter filter) throws PluginResolutionException, PluginContainerException {
    Plugin plugin = pluginDescriptor.getPlugin();
    MavenProject project = session.getCurrentProject();
    Map<String, ClassLoader> foreignImports = calcImports(project, parent, imports);
    PluginRealmCache.Key cacheKey = pluginRealmCache.createKey(plugin, parent, foreignImports, filter, project.getRemotePluginRepositories(), session.getRepositorySession());
    PluginRealmCache.CacheRecord cacheRecord = pluginRealmCache.get(cacheKey);
    if (cacheRecord != null) {
        pluginDescriptor.setClassRealm(cacheRecord.realm);
        pluginDescriptor.setArtifacts(new ArrayList<Artifact>(cacheRecord.artifacts));
    } else {
        createPluginRealm(pluginDescriptor, session, parent, foreignImports, filter);
        cacheRecord = pluginRealmCache.put(cacheKey, pluginDescriptor.getClassRealm(), pluginDescriptor.getArtifacts());
    }
    pluginRealmCache.register(project, cacheRecord);
}",0.045454545454545456,-0.2806122448979591,-0.3333333333333333,-0.5,-0.25,-0.03657933761739987,-0.16661887008890175,0.6666666666666666,-0.028571428571428574,0.1976991703821724
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-621_00b4b8a0,1,"@Override
public Iterable<Tree> getChildren() {
    root.checkLive();
    Iterable<String> childNames;
    if (hasOrderableChildren()) {
        childNames = getOrderedChildNames();
    } else {
        childNames = getNodeBuilder().getChildNodeNames();
    }
    return Iterables.filter(Iterables.transform(childNames, new Function<String, Tree>() {

        @Override
        public Tree apply(String input) {
            return new TreeImpl(root, TreeImpl.this, input);
        }
    }), new Predicate<Tree>() {

        @Override
        public boolean apply(Tree tree) {
            return tree != null && canRead(tree);
        }
    });
}",,"@Override
public Iterable<Tree> getChildren() {
    root.checkLive();
    Iterable<String> childNames;
    if (hasOrderableChildren()) {
        childNames = getOrderedChildNames();
    } else {
        childNames = getNodeBuilder().getChildNodeNames();
    }
    return Iterables.filter(Iterables.transform(childNames, new Function<String, Tree>() {

        @Override
        public Tree apply(String input) {
            return new TreeImpl(root, TreeImpl.this, input);
        }
    }), new Predicate<Tree>() {

        @Override
        public boolean apply(Tree tree) {
            return tree != null && canRead(tree);
        }
    });
}",0.3181818181818182,0.1938775510204081,-0.3333333333333333,-0.5,-0.25,-0.026693030153237728,-0.20705477487811874,0.16666666666666666,0.0,0.007263974370505515
flink,remotes/origin/bugs-dot-jar_FLINK-3740_f2f5bd5b,1,"@Override
public final void trigger(long time) throws Exception {
    boolean fire;
    do {
        Timer<K, W> timer = processingTimeTimersQueue.peek();
        if (timer != null && timer.timestamp <= time) {
            fire = true;
            processingTimeTimers.remove(timer);
            processingTimeTimersQueue.remove();
            context.key = timer.key;
            context.window = timer.window;
            setKeyContext(timer.key);
            TriggerResult triggerResult = context.onProcessingTime(timer.timestamp);
            processTriggerResult(triggerResult, context.key, context.window);
        } else {
            fire = false;
        }
    } while (fire);
    // Also check any watermark timers. We might have some in here since
    // Context.registerEventTimeTimer sets a trigger if an event-time trigger is registered
    // that is already behind the watermark.
    processTriggersFor(new Watermark(currentWatermark));
}",,"@Override
public final void trigger(long time) throws Exception {
    boolean fire;
    do {
        Timer<K, W> timer = processingTimeTimersQueue.peek();
        if (timer != null && timer.timestamp <= time) {
            fire = true;
            processingTimeTimers.remove(timer);
            processingTimeTimersQueue.remove();
            context.key = timer.key;
            context.window = timer.window;
            setKeyContext(timer.key);
            TriggerResult triggerResult = context.onProcessingTime(timer.timestamp);
            processTriggerResult(triggerResult, context.key, context.window);
        } else {
            fire = false;
        }
    } while (fire);
                processTriggersFor(new Watermark(currentWatermark));
}",0.2727272727272727,0.7397959183673468,-0.16666666666666666,0.0,0.16666666666666666,0.34305486900642623,-0.24118153140235157,0.08333333333333333,-0.028571428571428574,0.32538836136559296
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-359_296ea4a5,1,"@Override
public void onStartup(final Set<Class<?>> classes, final ServletContext servletContext) throws ServletException {
    if (servletContext.getMajorVersion() > 2) {
        servletContext.log(""Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment."");
        final Log4jWebInitializer initializer = Log4jWebInitializerImpl.getLog4jWebInitializer(servletContext);
        initializer.initialize();
        // the application is just now starting to start up
        initializer.setLoggerContext();
        servletContext.addListener(new Log4jServletContextListener());
        final FilterRegistration.Dynamic filter = servletContext.addFilter(""log4jServletFilter"", new Log4jServletFilter());
        if (filter == null) {
            throw new UnavailableException(""In a Servlet 3.0+ application, you must not define a "" + ""log4jServletFilter in web.xml. Log4j 2 defines this for you automatically."");
        }
        filter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, ""/*"");
    }
}",,"@Override
public void onStartup(final Set<Class<?>> classes, final ServletContext servletContext) throws ServletException {
    if (servletContext.getMajorVersion() > 2) {
        servletContext.log(""Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment."");
        final Log4jWebInitializer initializer = Log4jWebInitializerImpl.getLog4jWebInitializer(servletContext);
        initializer.initialize();
                initializer.setLoggerContext();
        servletContext.addListener(new Log4jServletContextListener());
        final FilterRegistration.Dynamic filter = servletContext.addFilter(""log4jServletFilter"", new Log4jServletFilter());
        if (filter == null) {
            throw new UnavailableException(""In a Servlet 3.0+ application, you must not define a "" + ""log4jServletFilter in web.xml. Log4j 2 defines this for you automatically."");
        }
        filter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, ""/*"");
    }
}",0.045454545454545456,0.2653061224489796,0.0,0.0,-0.08333333333333333,0.11171527434503223,-0.09377688557499274,0.25,-0.028571428571428574,0.12675977916832631
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-554_3f51fb09,1,"@Override
public String toString() {
    return propertyState.getValue(Type.STRING, index);
}",,"@Override
public String toString() {
    return propertyState.getValue(Type.STRING, index);
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8769716088328073,-0.4166666666666667,0.9142857142857144,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-2337_36a41358,1,"private static ObjectAndGetSetter getObjectAndGetSetter(final String expression, final Object object, int tryToCreateNull) {
    final String expressionBracketsSeperated = Strings.replaceAll(expression, ""["", "".["").toString();
    int index = getNextDotIndex(expressionBracketsSeperated, 0);
    int lastIndex = 0;
    Object value = object;
    Class<?> clz = value.getClass();
    String exp = expressionBracketsSeperated;
    while (index != -1) {
        exp = expressionBracketsSeperated.substring(lastIndex, index);
        IGetAndSet getAndSetter = null;
        try {
            getAndSetter = getGetAndSetter(exp, clz);
        } catch (WicketRuntimeException ex) {
            // expression by it self can't be found. try to find a
            // setPropertyByIndex(int,value) method
            index = getNextDotIndex(expressionBracketsSeperated, index + 1);
            if (index != -1) {
                String indexExpression = expressionBracketsSeperated.substring(lastIndex, index);
                getAndSetter = getGetAndSetter(indexExpression, clz);
            } else {
                exp = expressionBracketsSeperated.substring(lastIndex);
                break;
            }
        }
        Object newValue = null;
        if (value != null) {
            newValue = getAndSetter.getValue(value);
        }
        if (newValue == null) {
            if (tryToCreateNull == CREATE_NEW_VALUE) {
                newValue = getAndSetter.newValue(value);
                if (newValue == null) {
                    return null;
                }
            } else if (tryToCreateNull == RESOLVE_CLASS) {
                clz = getAndSetter.getTargetClass();
            } else {
                return null;
            }
        }
        value = newValue;
        if (value != null) {
            // value can be null if we are in the RESOLVE_CLASS
            clz = value.getClass();
        }
        lastIndex = index + 1;
        index = getNextDotIndex(expressionBracketsSeperated, lastIndex);
        if (index == -1) {
            exp = expressionBracketsSeperated.substring(lastIndex);
            break;
        }
    }
    IGetAndSet getAndSetter = getGetAndSetter(exp, clz);
    return new ObjectAndGetSetter(getAndSetter, value);
}",,"private static ObjectAndGetSetter getObjectAndGetSetter(final String expression, final Object object, int tryToCreateNull) {
    final String expressionBracketsSeperated = Strings.replaceAll(expression, ""["", "".["").toString();
    int index = getNextDotIndex(expressionBracketsSeperated, 0);
    int lastIndex = 0;
    Object value = object;
    Class<?> clz = value.getClass();
    String exp = expressionBracketsSeperated;
    while (index != -1) {
        exp = expressionBracketsSeperated.substring(lastIndex, index);
        IGetAndSet getAndSetter = null;
        try {
            getAndSetter = getGetAndSetter(exp, clz);
        } catch (WicketRuntimeException ex) {
                                    index = getNextDotIndex(expressionBracketsSeperated, index + 1);
            if (index != -1) {
                String indexExpression = expressionBracketsSeperated.substring(lastIndex, index);
                getAndSetter = getGetAndSetter(indexExpression, clz);
            } else {
                exp = expressionBracketsSeperated.substring(lastIndex);
                break;
            }
        }
        Object newValue = null;
        if (value != null) {
            newValue = getAndSetter.getValue(value);
        }
        if (newValue == null) {
            if (tryToCreateNull == CREATE_NEW_VALUE) {
                newValue = getAndSetter.newValue(value);
                if (newValue == null) {
                    return null;
                }
            } else if (tryToCreateNull == RESOLVE_CLASS) {
                clz = getAndSetter.getTargetClass();
            } else {
                return null;
            }
        }
        value = newValue;
        if (value != null) {
                        clz = value.getClass();
        }
        lastIndex = index + 1;
        index = getNextDotIndex(expressionBracketsSeperated, lastIndex);
        if (index == -1) {
            exp = expressionBracketsSeperated.substring(lastIndex);
            break;
        }
    }
    IGetAndSet getAndSetter = getGetAndSetter(exp, clz);
    return new ObjectAndGetSetter(getAndSetter, value);
}",1.7272727272727273,0.7959183673469388,1.5,1.0,0.6666666666666666,0.934256055363322,-0.902208201892745,0.9166666666666666,-0.028571428571428574,2.2926148166231943
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3510_01f5a26f,1,"/**
 * Tests if the given object is an external identity reference and if it's getString() is equal to this.
 */
@Override
public boolean equals(Object o) {
    try {
        // assuming that we never compare other types of classes
        return this == o || string.equals(((ExternalIdentityRef) o).string);
    } catch (Exception e) {
        return false;
    }
}","/**
 * Tests if the given object is an external identity reference and if it's getString() is equal to this.
 */
","@Override
public boolean equals(Object o) {
    try {
                return this == o || string.equals(((ExternalIdentityRef) o).string);
    } catch (Exception e) {
        return false;
    }
}",-0.2727272727272727,0.051020408163265356,-0.3333333333333333,-0.5,-0.4166666666666667,-0.10380622837370242,0.4442213937482076,-0.4166666666666667,2.7142857142857144,-0.12983497586527384
wicket,remotes/origin/bugs-dot-jar_WICKET-4757_fd910746,1,"@Override
public void component(final FormComponent<?> formComponent, final IVisit<Void> visit) {
    Form<?> form = formComponent.getForm();
    if (!form.isVisibleInHierarchy() || !form.isEnabledInHierarchy()) {
        // do not validate formComponent or any of formComponent's children
        visit.dontGoDeeper();
        return;
    }
    if (formComponent.isVisibleInHierarchy() && formComponent.isValid() && formComponent.isEnabledInHierarchy()) {
        validate(formComponent);
    }
    if (formComponent.processChildren() == false) {
        visit.dontGoDeeper();
    }
}",,"@Override
public void component(final FormComponent<?> formComponent, final IVisit<Void> visit) {
    Form<?> form = formComponent.getForm();
    if (!form.isVisibleInHierarchy() || !form.isEnabledInHierarchy()) {
                visit.dontGoDeeper();
        return;
    }
    if (formComponent.isVisibleInHierarchy() && formComponent.isValid() && formComponent.isEnabledInHierarchy()) {
        validate(formComponent);
    }
    if (formComponent.processChildren() == false) {
        visit.dontGoDeeper();
    }
}",0.0,-0.10714285714285712,0.0,-0.5,0.5833333333333334,0.2995551161641128,0.011184399197017513,0.3333333333333333,-0.028571428571428574,0.08268767051708704
wicket,remotes/origin/bugs-dot-jar_WICKET-2172_ea4a3f8a,3,"/**
 *  @see IValueMap#getAsEnum(String, Class<T>, T)
 */
public <T extends Enum<T>> T getAsEnum(String key, Class<T> eClass, T defaultValue) {
    return getEnumImpl(key, eClass, defaultValue);
}","/**
 *  @see IValueMap#getAsEnum(String, Class<T>, T)
 */
","public <T extends Enum<T>> T getAsEnum(String key, Class<T> eClass, T defaultValue) {
    return getEnumImpl(key, eClass, defaultValue);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9088041296243191,-0.4166666666666667,0.5714285714285714,-0.16422749602751402
Compress,32,3,"private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {
    /*
         * The following headers are defined for Pax.
         * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields
         * mtime
         * comment
         * gid, gname
         * linkpath
         * size
         * uid,uname
         * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those
         */
    for (Entry<String, String> ent : headers.entrySet()) {
        String key = ent.getKey();
        String val = ent.getValue();
        if (""path"".equals(key)) {
            currEntry.setName(val);
        } else if (""linkpath"".equals(key)) {
            currEntry.setLinkName(val);
        } else if (""gid"".equals(key)) {
            currEntry.setGroupId(Integer.parseInt(val));
        } else if (""gname"".equals(key)) {
            currEntry.setGroupName(val);
        } else if (""uid"".equals(key)) {
            currEntry.setUserId(Integer.parseInt(val));
        } else if (""uname"".equals(key)) {
            currEntry.setUserName(val);
        } else if (""size"".equals(key)) {
            currEntry.setSize(Long.parseLong(val));
        } else if (""mtime"".equals(key)) {
            currEntry.setModTime((long) (Double.parseDouble(val) * 1000));
        } else if (""SCHILY.devminor"".equals(key)) {
            currEntry.setDevMinor(Integer.parseInt(val));
        } else if (""SCHILY.devmajor"".equals(key)) {
            currEntry.setDevMajor(Integer.parseInt(val));
        }
    }
}",,"private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {
        for (Entry<String, String> ent : headers.entrySet()) {
        String key = ent.getKey();
        String val = ent.getValue();
        if (""path"".equals(key)) {
            currEntry.setName(val);
        } else if (""linkpath"".equals(key)) {
            currEntry.setLinkName(val);
        } else if (""gid"".equals(key)) {
            currEntry.setGroupId(Integer.parseInt(val));
        } else if (""gname"".equals(key)) {
            currEntry.setGroupName(val);
        } else if (""uid"".equals(key)) {
            currEntry.setUserId(Integer.parseInt(val));
        } else if (""uname"".equals(key)) {
            currEntry.setUserName(val);
        } else if (""size"".equals(key)) {
            currEntry.setSize(Long.parseLong(val));
        } else if (""mtime"".equals(key)) {
            currEntry.setModTime((long) (Double.parseDouble(val) * 1000));
        } else if (""SCHILY.devminor"".equals(key)) {
            currEntry.setDevMinor(Integer.parseInt(val));
        } else if (""SCHILY.devmajor"".equals(key)) {
            currEntry.setDevMajor(Integer.parseInt(val));
        }
    }
}",0.5909090909090909,0.1887755102040817,1.3333333333333333,4.5,1.3333333333333333,0.06821552150271878,-0.5159162603957561,1.9166666666666667,-0.028571428571428574,0.3418522278044037
maven,remotes/origin/bugs-dot-jar_MNG-3131_56cd921f,1,"private static void decomposeParameterIntoUserInstructions(MojoDescriptor mojo, Parameter param, StringBuilder messageBuffer) {
    String expression = param.getExpression();
    if (param.isEditable()) {
        messageBuffer.append(""Inside the definition for plugin \'"" + mojo.getPluginDescriptor().getArtifactId() + ""\', specify the following:\n\n<configuration>\n  ...\n  <"" + param.getName() + "">VALUE</"" + param.getName() + "">\n</configuration>"");
        String alias = param.getAlias();
        if (StringUtils.isNotEmpty(alias) && !alias.equals(param.getName())) {
            messageBuffer.append(""\n\n-OR-\n\n<configuration>\n  ...\n  <"" + alias + "">VALUE</"" + alias + "">\n</configuration>\n"");
        }
    }
    if (StringUtils.isEmpty(expression)) {
        messageBuffer.append(""."");
    } else {
        if (param.isEditable()) {
            messageBuffer.append(""\n\n-OR-\n\n"");
        }
    // addParameterUsageInfo( expression, messageBuffer );
    }
}",,"private static void decomposeParameterIntoUserInstructions(MojoDescriptor mojo, Parameter param, StringBuilder messageBuffer) {
    String expression = param.getExpression();
    if (param.isEditable()) {
        messageBuffer.append(""Inside the definition for plugin \'"" + mojo.getPluginDescriptor().getArtifactId() + ""\', specify the following:\n\n<configuration>\n  ...\n  <"" + param.getName() + "">VALUE</"" + param.getName() + "">\n</configuration>"");
        String alias = param.getAlias();
        if (StringUtils.isNotEmpty(alias) && !alias.equals(param.getName())) {
            messageBuffer.append(""\n\n-OR-\n\n<configuration>\n  ...\n  <"" + alias + "">VALUE</"" + alias + "">\n</configuration>\n"");
        }
    }
    if (StringUtils.isEmpty(expression)) {
        messageBuffer.append(""."");
    } else {
        if (param.isEditable()) {
            messageBuffer.append(""\n\n-OR-\n\n"");
        }
        }
}",0.13636363636363635,0.1887755102040817,0.16666666666666666,0.0,0.5833333333333334,0.35689569945625316,-0.18009750501864075,0.8333333333333334,-0.028571428571428574,0.34013046029441363
commons-math,remotes/origin/bugs-dot-jar_MATH-344_a0b4b4b7,0,"/**
 * Find a zero in the given interval with an initial guess.
 * <p>Throws <code>IllegalArgumentException</code> if the values of the
 * function at the three points have the same sign (note that it is
 * allowed to have endpoints with the same sign if the initial point has
 * opposite sign function-wise).</p>
 *
 * @param f function to solve.
 * @param min the lower bound for the interval.
 * @param max the upper bound for the interval.
 * @param initial the start value to use (must be set to min if no
 * initial point is known).
 * @return the value where the function is zero
 * @throws MaxIterationsExceededException the maximum iteration count
 * is exceeded
 * @throws FunctionEvaluationException if an error occurs evaluating
 *  the function
 * @throws IllegalArgumentException if initial is not between min and max
 * (even if it <em>is</em> a root)
 */
public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {
    clearResult();
    verifySequence(min, initial, max);
    // return the initial guess if it is good enough
    double yInitial = f.value(initial);
    if (Math.abs(yInitial) <= functionValueAccuracy) {
        setResult(initial, 0);
        return result;
    }
    // return the first endpoint if it is good enough
    double yMin = f.value(min);
    if (Math.abs(yMin) <= functionValueAccuracy) {
        setResult(yMin, 0);
        return result;
    }
    // reduce interval if min and initial bracket the root
    if (yInitial * yMin < 0) {
        return solve(f, min, yMin, initial, yInitial, min, yMin);
    }
    // return the second endpoint if it is good enough
    double yMax = f.value(max);
    if (Math.abs(yMax) <= functionValueAccuracy) {
        setResult(yMax, 0);
        return result;
    }
    // reduce interval if initial and max bracket the root
    if (yInitial * yMax < 0) {
        return solve(f, initial, yInitial, max, yMax, initial, yInitial);
    }
    if (yMin * yMax > 0) {
        throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
    }
    // full Brent algorithm starting with provided initial guess
    return solve(f, min, yMin, max, yMax, initial, yInitial);
}","/**
 * Find a zero in the given interval with an initial guess.
 * <p>Throws <code>IllegalArgumentException</code> if the values of the
 * function at the three points have the same sign (note that it is
 * allowed to have endpoints with the same sign if the initial point has
 * opposite sign function-wise).</p>
 *
 * @param f function to solve.
 * @param min the lower bound for the interval.
 * @param max the upper bound for the interval.
 * @param initial the start value to use (must be set to min if no
 * initial point is known).
 * @return the value where the function is zero
 * @throws MaxIterationsExceededException the maximum iteration count
 * is exceeded
 * @throws FunctionEvaluationException if an error occurs evaluating
 *  the function
 * @throws IllegalArgumentException if initial is not between min and max
 * (even if it <em>is</em> a root)
 */
","public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {
    clearResult();
    verifySequence(min, initial, max);
        double yInitial = f.value(initial);
    if (Math.abs(yInitial) <= functionValueAccuracy) {
        setResult(initial, 0);
        return result;
    }
        double yMin = f.value(min);
    if (Math.abs(yMin) <= functionValueAccuracy) {
        setResult(yMin, 0);
        return result;
    }
        if (yInitial * yMin < 0) {
        return solve(f, min, yMin, initial, yInitial, min, yMin);
    }
        double yMax = f.value(max);
    if (Math.abs(yMax) <= functionValueAccuracy) {
        setResult(yMax, 0);
        return result;
    }
        if (yInitial * yMax < 0) {
        return solve(f, initial, yInitial, max, yMax, initial, yInitial);
    }
    if (yMin * yMax > 0) {
        throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
    }
        return solve(f, min, yMin, max, yMax, initial, yInitial);
}",0.6818181818181818,-0.3826530612244898,0.6666666666666666,-0.5,0.6666666666666666,1.1023232822540783,-0.5153427014625754,0.75,-0.028571428571428574,1.4274908879095087
flink,remotes/origin/bugs-dot-jar_FLINK-2734_8b40bb7a,0,"// TODO:fix cluster default parallelism
/**
 *  Creates a {@link RemoteStreamEnvironment}. The remote environment sends
 *  (parts of) the program to a cluster for execution. Note that all file
 *  paths used in the program must be accessible from the cluster. The
 *  execution will use no parallelism, unless the parallelism is set
 *  explicitly via {@link #setParallelism}.
 *
 *  @param host
 *  		The host name or address of the master (JobManager), where the
 *  		program should be executed.
 *  @param port
 *  		The port of the master (JobManager), where the program should
 *  		be executed.
 *  @param jarFiles
 *  		The JAR files with code that needs to be shipped to the
 *  		cluster. If the program uses user-defined functions,
 *  		user-defined input formats, or any libraries, those must be
 *  		provided in the JAR files.
 *  @return A remote environment that executes the program on a cluster.
 */
public static StreamExecutionEnvironment createRemoteEnvironment(String host, int port, String... jarFiles) {
    RemoteStreamEnvironment env = new RemoteStreamEnvironment(host, port, jarFiles);
    return env;
}","/**
 *  Creates a {@link RemoteStreamEnvironment}. The remote environment sends
 *  (parts of) the program to a cluster for execution. Note that all file
 *  paths used in the program must be accessible from the cluster. The
 *  execution will use no parallelism, unless the parallelism is set
 *  explicitly via {@link #setParallelism}.
 *
 *  @param host
 *  		The host name or address of the master (JobManager), where the
 *  		program should be executed.
 *  @param port
 *  		The port of the master (JobManager), where the program should
 *  		be executed.
 *  @param jarFiles
 *  		The JAR files with code that needs to be shipped to the
 *  		cluster. If the program uses user-defined functions,
 *  		user-defined input formats, or any libraries, those must be
 *  		provided in the JAR files.
 *  @return A remote environment that executes the program on a cluster.
 */
","public static StreamExecutionEnvironment createRemoteEnvironment(String host, int port, String... jarFiles) {
    RemoteStreamEnvironment env = new RemoteStreamEnvironment(host, port, jarFiles);
    return env;
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7840550616575857,-0.5,-0.028571428571428574,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-218_15476a0d,1,"@Override
public int compareTo(Key o) {
    int compare = super.compareTo(o);
    if (compare != 0)
        return compare;
    if (o instanceof MockMemKey) {
        MockMemKey other = (MockMemKey) o;
        if (count < other.count)
            return -1;
        if (count > other.count)
            return 1;
    } else {
        return 1;
    }
    return 0;
}",,"@Override
public int compareTo(Key o) {
    int compare = super.compareTo(o);
    if (compare != 0)
        return compare;
    if (o instanceof MockMemKey) {
        MockMemKey other = (MockMemKey) o;
        if (count < other.count)
            return -1;
        if (count > other.count)
            return 1;
    } else {
        return 1;
    }
    return 0;
}",0.09090909090909091,0.3520408163265306,0.16666666666666666,-0.5,0.25,0.5902125556104797,-0.022082018927444685,-0.4166666666666667,0.3428571428571429,0.11331114737387625
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-93_0be7e8f0,1,"@Override
public Iterable<Tree> getChildren() {
    return new Iterable<Tree>() {

        @Override
        public Iterator<Tree> iterator() {
            Iterator<? extends ChildNodeEntry> childEntries = getNodeState().getChildNodeEntries().iterator();
            return Iterators.map(childEntries, new Function1<ChildNodeEntry, Tree>() {

                @Override
                public Tree apply(ChildNodeEntry entry) {
                    NodeStateBuilder childBuilder = builder.getChildBuilder(entry.getName());
                    return new TreeImpl(store, childBuilder.getNodeState(), childBuilder, TreeImpl.this, entry.getName(), listener);
                }
            });
        }
    };
}",,"@Override
public Iterable<Tree> getChildren() {
    return new Iterable<Tree>() {

        @Override
        public Iterator<Tree> iterator() {
            Iterator<? extends ChildNodeEntry> childEntries = getNodeState().getChildNodeEntries().iterator();
            return Iterators.map(childEntries, new Function1<ChildNodeEntry, Tree>() {

                @Override
                public Tree apply(ChildNodeEntry entry) {
                    NodeStateBuilder childBuilder = builder.getChildBuilder(entry.getName());
                    return new TreeImpl(store, childBuilder.getNodeState(), childBuilder, TreeImpl.this, entry.getName(), listener);
                }
            });
        }
    };
}",0.09090909090909091,1.8418367346938775,-0.5,0.0,-0.4166666666666667,-0.3806228373702422,-0.06423860051620332,0.16666666666666666,-0.028571428571428574,-0.16422749602751402
flink,remotes/origin/bugs-dot-jar_FLINK-1133_27e40205,1,"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoWithTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {
    // check if type is a subclass of tuple
    if ((t instanceof Class<?> && Tuple.class.isAssignableFrom((Class<?>) t)) || (t instanceof ParameterizedType && Tuple.class.isAssignableFrom((Class<?>) ((ParameterizedType) t).getRawType()))) {
        Type curT = t;
        // do not allow usage of Tuple as type
        if (curT instanceof Class<?> && ((Class<?>) curT).equals(Tuple.class)) {
            throw new InvalidTypesException(""Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead."");
        }
        // collect the types while moving up for a later top-down
        while (!(curT instanceof ParameterizedType && ((Class<?>) ((ParameterizedType) curT).getRawType()).getSuperclass().equals(Tuple.class)) && !(curT instanceof Class<?> && ((Class<?>) curT).getSuperclass().equals(Tuple.class))) {
            typeHierarchy.add(curT);
            // parameterized type
            if (curT instanceof ParameterizedType) {
                curT = ((Class<?>) ((ParameterizedType) curT).getRawType()).getGenericSuperclass();
            } else // class
            {
                curT = ((Class<?>) curT).getGenericSuperclass();
            }
        }
        // check if immediate child of Tuple has generics
        if (curT instanceof Class<?>) {
            throw new InvalidTypesException(""Tuple needs to be parameterized by using generics."");
        }
        ParameterizedType tupleChild = (ParameterizedType) curT;
        Type[] subtypes = new Type[tupleChild.getActualTypeArguments().length];
        // materialize possible type variables
        for (int i = 0; i < subtypes.length; i++) {
            // materialize immediate TypeVariables
            if (tupleChild.getActualTypeArguments()[i] instanceof TypeVariable<?>) {
                subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) tupleChild.getActualTypeArguments()[i]);
            } else // class or parameterized type
            {
                subtypes[i] = tupleChild.getActualTypeArguments()[i];
            }
        }
        TypeInformation<?>[] tupleSubTypes = new TypeInformation<?>[subtypes.length];
        for (int i = 0; i < subtypes.length; i++) {
            // try to derive the type info of the TypeVariable from the immediate base child input as a last attempt
            if (subtypes[i] instanceof TypeVariable<?>) {
                tupleSubTypes[i] = createTypeInfoFromInput((TypeVariable<?>) subtypes[i], typeHierarchy, in1Type, in2Type);
                // variable could not be determined
                if (tupleSubTypes[i] == null) {
                    throw new InvalidTypesException(""Type of TypeVariable '"" + ((TypeVariable<?>) subtypes[i]).getName() + ""' in '"" + ((TypeVariable<?>) subtypes[i]).getGenericDeclaration() + ""' could not be determined. This is most likely a type erasure problem. "" + ""The type extraction currently supports types with generic variables only in cases where "" + ""all variables in the return type can be deduced from the input type(s)."");
                }
            } else {
                tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new ArrayList<Type>(typeHierarchy), subtypes[i], in1Type, in2Type);
            }
        }
        if (t instanceof Class<?>) {
            return new TupleTypeInfo(((Class<? extends Tuple>) t), tupleSubTypes);
        } else if (t instanceof ParameterizedType) {
            return new TupleTypeInfo(((Class<? extends Tuple>) ((ParameterizedType) t).getRawType()), tupleSubTypes);
        }
    } else // e.g. class MyMapper<E> extends MapFunction<String, E>
    if (t instanceof TypeVariable) {
        Type typeVar = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) t);
        if (!(typeVar instanceof TypeVariable)) {
            return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);
        } else // try to derive the type info of the TypeVariable from the immediate base child input as a last attempt
        {
            TypeInformation<OUT> typeInfo = (TypeInformation<OUT>) createTypeInfoFromInput((TypeVariable<?>) t, typeHierarchy, in1Type, in2Type);
            if (typeInfo != null) {
                return typeInfo;
            } else {
                throw new InvalidTypesException(""Type of TypeVariable '"" + ((TypeVariable<?>) t).getName() + ""' in '"" + ((TypeVariable<?>) t).getGenericDeclaration() + ""' could not be determined. This is most likely a type erasure problem. "" + ""The type extraction currently supports types with generic variables only in cases where "" + ""all variables in the return type can be deduced from the input type(s)."");
            }
        }
    } else // arrays with generics
    if (t instanceof GenericArrayType) {
        GenericArrayType genericArray = (GenericArrayType) t;
        Type componentType = genericArray.getGenericComponentType();
        // due to a Java 6 bug, it is possible that the JVM classifies e.g. String[] or int[] as GenericArrayType instead of Class
        if (componentType instanceof Class) {
            Class<?> componentClass = (Class<?>) componentType;
            String className;
            // for int[], double[] etc.
            if (componentClass.isPrimitive()) {
                className = encodePrimitiveClass(componentClass);
            } else // for String[], Integer[] etc.
            {
                className = ""L"" + componentClass.getName() + "";"";
            }
            Class<OUT> classArray = null;
            try {
                classArray = (Class<OUT>) Class.forName(""["" + className);
            } catch (ClassNotFoundException e) {
                throw new InvalidTypesException(""Could not convert GenericArrayType to Class."");
            }
            return getForClass(classArray);
        }
        TypeInformation<?> componentInfo = createTypeInfoWithTypeHierarchy(typeHierarchy, genericArray.getGenericComponentType(), in1Type, in2Type);
        return ObjectArrayTypeInfo.getInfoFor(t, componentInfo);
    } else // objects with generics are treated as raw type
    if (t instanceof ParameterizedType) {
        return privateGetForClass((Class<OUT>) ((ParameterizedType) t).getRawType());
    } else // no tuple, no TypeVariable, no generic type
    if (t instanceof Class) {
        return privateGetForClass((Class<OUT>) t);
    }
    throw new InvalidTypesException(""Type Information could not be created."");
}",,"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoWithTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {
        if ((t instanceof Class<?> && Tuple.class.isAssignableFrom((Class<?>) t)) || (t instanceof ParameterizedType && Tuple.class.isAssignableFrom((Class<?>) ((ParameterizedType) t).getRawType()))) {
        Type curT = t;
                if (curT instanceof Class<?> && ((Class<?>) curT).equals(Tuple.class)) {
            throw new InvalidTypesException(""Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead."");
        }
                while (!(curT instanceof ParameterizedType && ((Class<?>) ((ParameterizedType) curT).getRawType()).getSuperclass().equals(Tuple.class)) && !(curT instanceof Class<?> && ((Class<?>) curT).getSuperclass().equals(Tuple.class))) {
            typeHierarchy.add(curT);
                        if (curT instanceof ParameterizedType) {
                curT = ((Class<?>) ((ParameterizedType) curT).getRawType()).getGenericSuperclass();
            } else             {
                curT = ((Class<?>) curT).getGenericSuperclass();
            }
        }
                if (curT instanceof Class<?>) {
            throw new InvalidTypesException(""Tuple needs to be parameterized by using generics."");
        }
        ParameterizedType tupleChild = (ParameterizedType) curT;
        Type[] subtypes = new Type[tupleChild.getActualTypeArguments().length];
                for (int i = 0; i < subtypes.length; i++) {
                        if (tupleChild.getActualTypeArguments()[i] instanceof TypeVariable<?>) {
                subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) tupleChild.getActualTypeArguments()[i]);
            } else             {
                subtypes[i] = tupleChild.getActualTypeArguments()[i];
            }
        }
        TypeInformation<?>[] tupleSubTypes = new TypeInformation<?>[subtypes.length];
        for (int i = 0; i < subtypes.length; i++) {
                        if (subtypes[i] instanceof TypeVariable<?>) {
                tupleSubTypes[i] = createTypeInfoFromInput((TypeVariable<?>) subtypes[i], typeHierarchy, in1Type, in2Type);
                                if (tupleSubTypes[i] == null) {
                    throw new InvalidTypesException(""Type of TypeVariable '"" + ((TypeVariable<?>) subtypes[i]).getName() + ""' in '"" + ((TypeVariable<?>) subtypes[i]).getGenericDeclaration() + ""' could not be determined. This is most likely a type erasure problem. "" + ""The type extraction currently supports types with generic variables only in cases where "" + ""all variables in the return type can be deduced from the input type(s)."");
                }
            } else {
                tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new ArrayList<Type>(typeHierarchy), subtypes[i], in1Type, in2Type);
            }
        }
        if (t instanceof Class<?>) {
            return new TupleTypeInfo(((Class<? extends Tuple>) t), tupleSubTypes);
        } else if (t instanceof ParameterizedType) {
            return new TupleTypeInfo(((Class<? extends Tuple>) ((ParameterizedType) t).getRawType()), tupleSubTypes);
        }
    } else     if (t instanceof TypeVariable) {
        Type typeVar = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) t);
        if (!(typeVar instanceof TypeVariable)) {
            return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);
        } else         {
            TypeInformation<OUT> typeInfo = (TypeInformation<OUT>) createTypeInfoFromInput((TypeVariable<?>) t, typeHierarchy, in1Type, in2Type);
            if (typeInfo != null) {
                return typeInfo;
            } else {
                throw new InvalidTypesException(""Type of TypeVariable '"" + ((TypeVariable<?>) t).getName() + ""' in '"" + ((TypeVariable<?>) t).getGenericDeclaration() + ""' could not be determined. This is most likely a type erasure problem. "" + ""The type extraction currently supports types with generic variables only in cases where "" + ""all variables in the return type can be deduced from the input type(s)."");
            }
        }
    } else     if (t instanceof GenericArrayType) {
        GenericArrayType genericArray = (GenericArrayType) t;
        Type componentType = genericArray.getGenericComponentType();
                if (componentType instanceof Class) {
            Class<?> componentClass = (Class<?>) componentType;
            String className;
                        if (componentClass.isPrimitive()) {
                className = encodePrimitiveClass(componentClass);
            } else             {
                className = ""L"" + componentClass.getName() + "";"";
            }
            Class<OUT> classArray = null;
            try {
                classArray = (Class<OUT>) Class.forName(""["" + className);
            } catch (ClassNotFoundException e) {
                throw new InvalidTypesException(""Could not convert GenericArrayType to Class."");
            }
            return getForClass(classArray);
        }
        TypeInformation<?> componentInfo = createTypeInfoWithTypeHierarchy(typeHierarchy, genericArray.getGenericComponentType(), in1Type, in2Type);
        return ObjectArrayTypeInfo.getInfoFor(t, componentInfo);
    } else     if (t instanceof ParameterizedType) {
        return privateGetForClass((Class<OUT>) ((ParameterizedType) t).getRawType());
    } else     if (t instanceof Class) {
        return privateGetForClass((Class<OUT>) t);
    }
    throw new InvalidTypesException(""Type Information could not be created."");
}",3.5,0.5612244897959184,4.0,1.5,2.9166666666666665,2.848245180425111,-1.3960424433610557,2.8333333333333335,-0.028571428571428574,14.737670302936854
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3733_a5ff019e,1,"/**
 * Checks if the update operation introduced any conflicts on the given
 * document. The document shows the state right before the operation was
 * applied.
 *
 * @param op the update operation.
 * @param before how the document looked before the update was applied or
 *               {@code null} if it didn't exist before.
 * @throws ConflictException if there was a conflict introduced by the
 *          given update operation.
 */
private void checkConflicts(@Nonnull UpdateOp op, @Nullable NodeDocument before) throws ConflictException {
    DocumentStore store = nodeStore.getDocumentStore();
    collisions.clear();
    if (baseRevision != null) {
        Revision newestRev = null;
        if (before != null) {
            Revision base = baseRevision;
            if (nodeStore.isDisableBranches()) {
                base = base.asTrunkRevision();
            }
            newestRev = before.getNewestRevision(nodeStore, base, revision, getBranch(), collisions);
        }
        String conflictMessage = null;
        Revision conflictRevision = newestRev;
        if (newestRev == null) {
            if ((op.isDelete() || !op.isNew()) && isConflicting(before, op)) {
                conflictMessage = ""The node "" + op.getId() + "" does not exist or is already deleted"";
                if (before != null && !before.getLocalDeleted().isEmpty()) {
                    conflictRevision = before.getLocalDeleted().firstKey();
                }
            }
        } else {
            if (op.isNew() && isConflicting(before, op)) {
                conflictMessage = ""The node "" + op.getId() + "" was already added in revision\n"" + formatConflictRevision(newestRev);
            } else if (nodeStore.isRevisionNewer(newestRev, baseRevision) && (op.isDelete() || isConflicting(before, op))) {
                conflictMessage = ""The node "" + op.getId() + "" was changed in revision\n"" + formatConflictRevision(newestRev) + "", which was applied after the base revision\n"" + baseRevision;
            }
        }
        if (conflictMessage == null) {
            // TODO: unify above conflict detection and isConflicting()
            if (!collisions.isEmpty() && isConflicting(before, op)) {
                for (Revision r : collisions) {
                    // mark collisions on commit root
                    Collision c = new Collision(before, r, op, revision);
                    if (c.mark(store).equals(revision)) {
                        // our revision was marked
                        if (baseRevision.isBranch()) {
                        // this is a branch commit. do not fail immediately
                        // merging this branch will fail later.
                        } else {
                            // fail immediately
                            conflictMessage = ""The node "" + op.getId() + "" was changed in revision\n"" + formatConflictRevision(r) + "", which was applied after the base revision\n"" + baseRevision;
                            conflictRevision = r;
                        }
                    }
                }
            }
        }
        if (conflictMessage != null) {
            conflictMessage += "", before\n"" + revision;
            if (LOG.isDebugEnabled()) {
                LOG.debug(conflictMessage + ""; document:\n"" + (before == null ? """" : before.format()) + "",\nrevision order:\n"" + nodeStore.getRevisionComparator());
            }
            throw new ConflictException(conflictMessage, conflictRevision);
        }
    }
}","/**
 * Checks if the update operation introduced any conflicts on the given
 * document. The document shows the state right before the operation was
 * applied.
 *
 * @param op the update operation.
 * @param before how the document looked before the update was applied or
 *               {@code null} if it didn't exist before.
 * @throws ConflictException if there was a conflict introduced by the
 *          given update operation.
 */
","private void checkConflicts(@Nonnull UpdateOp op, @Nullable NodeDocument before) throws ConflictException {
    DocumentStore store = nodeStore.getDocumentStore();
    collisions.clear();
    if (baseRevision != null) {
        Revision newestRev = null;
        if (before != null) {
            Revision base = baseRevision;
            if (nodeStore.isDisableBranches()) {
                base = base.asTrunkRevision();
            }
            newestRev = before.getNewestRevision(nodeStore, base, revision, getBranch(), collisions);
        }
        String conflictMessage = null;
        Revision conflictRevision = newestRev;
        if (newestRev == null) {
            if ((op.isDelete() || !op.isNew()) && isConflicting(before, op)) {
                conflictMessage = ""The node "" + op.getId() + "" does not exist or is already deleted"";
                if (before != null && !before.getLocalDeleted().isEmpty()) {
                    conflictRevision = before.getLocalDeleted().firstKey();
                }
            }
        } else {
            if (op.isNew() && isConflicting(before, op)) {
                conflictMessage = ""The node "" + op.getId() + "" was already added in revision\n"" + formatConflictRevision(newestRev);
            } else if (nodeStore.isRevisionNewer(newestRev, baseRevision) && (op.isDelete() || isConflicting(before, op))) {
                conflictMessage = ""The node "" + op.getId() + "" was changed in revision\n"" + formatConflictRevision(newestRev) + "", which was applied after the base revision\n"" + baseRevision;
            }
        }
        if (conflictMessage == null) {
                        if (!collisions.isEmpty() && isConflicting(before, op)) {
                for (Revision r : collisions) {
                                        Collision c = new Collision(before, r, op, revision);
                    if (c.mark(store).equals(revision)) {
                                                if (baseRevision.isBranch()) {
                                                                        } else {
                                                        conflictMessage = ""The node "" + op.getId() + "" was changed in revision\n"" + formatConflictRevision(r) + "", which was applied after the base revision\n"" + baseRevision;
                            conflictRevision = r;
                        }
                    }
                }
            }
        }
        if (conflictMessage != null) {
            conflictMessage += "", before\n"" + revision;
            if (LOG.isDebugEnabled()) {
                LOG.debug(conflictMessage + ""; document:\n"" + (before == null ? """" : before.format()) + "",\nrevision order:\n"" + nodeStore.getRevisionComparator());
            }
            throw new ConflictException(conflictMessage, conflictRevision);
        }
    }
}",1.6818181818181819,1.7040816326530615,2.3333333333333335,2.0,2.75,1.756796836381612,-0.9698881560080304,2.3333333333333335,-0.028571428571428574,5.187856827750438
Closure,108,2,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (isCallToScopeMethod(n)) {
        validateScopeCall(t, n, n.getParent());
    }
    if (t.getScopeDepth() < 2) {
        return;
    }
    int type = n.getType();
    Var aliasVar = null;
    if (type == Token.NAME) {
        String name = n.getString();
        Var lexicalVar = t.getScope().getVar(n.getString());
        if (lexicalVar != null && lexicalVar == aliases.get(name)) {
            aliasVar = lexicalVar;
        }
    }
    // Validate the top-level of the goog.scope block.
    if (t.getScopeDepth() == 2) {
        if (aliasVar != null && NodeUtil.isLValue(n)) {
            if (aliasVar.getNode() == n) {
                aliasDefinitionsInOrder.add(n);
                // twice.
                return;
            } else {
                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());
            }
        }
        if (type == Token.RETURN) {
            report(t, n, GOOG_SCOPE_USES_RETURN);
        } else if (type == Token.THIS) {
            report(t, n, GOOG_SCOPE_REFERENCES_THIS);
        } else if (type == Token.THROW) {
            report(t, n, GOOG_SCOPE_USES_THROW);
        }
    }
    // Validate all descendent scopes of the goog.scope block.
    if (t.getScopeDepth() >= 2) {
        // Check if this name points to an alias.
        if (aliasVar != null) {
            // Note, to support the transitive case, it's important we don't
            // clone aliasedNode here.  For example,
            // var g = goog; var d = g.dom; d.createElement('DIV');
            // The node in aliasedNode (which is ""g"") will be replaced in the
            // changes pass above with ""goog"".  If we cloned here, we'd end up
            // with <code>g.dom.createElement('DIV')</code>.
            aliasUsages.add(new AliasedNode(aliasVar, n));
        }
        // When we inject declarations, we duplicate jsdoc. Make sure
        // we only process that jsdoc once.
        JSDocInfo info = n.getJSDocInfo();
        if (info != null) {
            for (Node node : info.getTypeNodes()) {
                fixTypeNode(node);
            }
        }
    // TODO(robbyw): Error for goog.scope not at root.
    }
}",,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (isCallToScopeMethod(n)) {
        validateScopeCall(t, n, n.getParent());
    }
    if (t.getScopeDepth() < 2) {
        return;
    }
    int type = n.getType();
    Var aliasVar = null;
    if (type == Token.NAME) {
        String name = n.getString();
        Var lexicalVar = t.getScope().getVar(n.getString());
        if (lexicalVar != null && lexicalVar == aliases.get(name)) {
            aliasVar = lexicalVar;
        }
    }
        if (t.getScopeDepth() == 2) {
        if (aliasVar != null && NodeUtil.isLValue(n)) {
            if (aliasVar.getNode() == n) {
                aliasDefinitionsInOrder.add(n);
                                return;
            } else {
                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());
            }
        }
        if (type == Token.RETURN) {
            report(t, n, GOOG_SCOPE_USES_RETURN);
        } else if (type == Token.THIS) {
            report(t, n, GOOG_SCOPE_REFERENCES_THIS);
        } else if (type == Token.THROW) {
            report(t, n, GOOG_SCOPE_USES_THROW);
        }
    }
        if (t.getScopeDepth() >= 2) {
                if (aliasVar != null) {
                                                                                    aliasUsages.add(new AliasedNode(aliasVar, n));
        }
                        JSDocInfo info = n.getJSDocInfo();
        if (info != null) {
            for (Node node : info.getTypeNodes()) {
                fixTypeNode(node);
            }
        }
        }
}",1.4545454545454546,0.586734693877551,1.8333333333333333,1.0,1.75,0.9500741473059815,-0.8391167192429025,1.5,-0.028571428571428574,2.0203528338494356
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3019_5135cf4b,1,"@Override
public boolean childNodeChanged(String name, NodeState before, NodeState after) {
    Node node = new Node(nodeAfter, name);
    return after.compareAgainstBaseState(before, new Diff(versionManager, node, exceptions));
}",,"@Override
public boolean childNodeChanged(String name, NodeState before, NodeState after) {
    Node node = new Node(nodeAfter, name);
    return after.compareAgainstBaseState(before, new Diff(versionManager, node, exceptions));
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.6051046745053055,-0.4166666666666667,-0.028571428571428574,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-554_fbbb96eb,1,"/**
 * Compute the cross-product of two vectors.
 * @param v1 first vector
 * @param v2 second vector
 * @return the cross product v1 ^ v2 as a new Vector
 */
public static Vector3D crossProduct(Vector3D v1, Vector3D v2) {
    return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);
}","/**
 * Compute the cross-product of two vectors.
 * @param v1 first vector
 * @param v2 second vector
 * @return the cross product v1 ^ v2 as a new Vector
 */
","public static Vector3D crossProduct(Vector3D v1, Vector3D v2) {
    return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,0.41028175976272874,0.7774591339260111,-0.5,0.05714285714285714,0.06911054860995111
Math,24,3,"/**
 * {@inheritDoc}
 */
@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();
    // Optional additional convergence criteria.
    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();
    double a;
    double b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }
    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;
    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;
        // Default stopping criterion.
        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (!stop) {
            double p = 0;
            double q = 0;
            double r = 0;
            double u = 0;
            if (FastMath.abs(e) > tol1) {
                // Fit parabola.
                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);
                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }
                r = e;
                e = d;
                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                    // Parabolic interpolation step.
                    d = p / q;
                    u = x + d;
                    // f must not be evaluated too close to a or b.
                    if (u - a < tol2 || b - u < tol2) {
                        if (x <= m) {
                            d = tol1;
                        } else {
                            d = -tol1;
                        }
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }
            } else {
                // Golden section step.
                if (x < m) {
                    e = b - x;
                } else {
                    e = a - x;
                }
                d = GOLDEN_SECTION * e;
            }
            // Update by at least ""tol1"".
            if (FastMath.abs(d) < tol1) {
                if (d >= 0) {
                    u = x + tol1;
                } else {
                    u = x - tol1;
                }
            } else {
                u = x + d;
            }
            double fu = computeObjectiveValue(u);
            if (!isMinim) {
                fu = -fu;
            }
            // User-defined convergence checker.
            previous = current;
            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);
            if (checker != null) {
                if (checker.converged(iter, previous, current)) {
                    return current;
                }
            }
            // Update a, b, v, w and x.
            if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || Precision.equals(w, x)) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                    v = u;
                    fv = fu;
                }
            }
        } else {
            // Default termination (Brent's criterion).
            return current;
        }
        ++iter;
    }
}","/**
 * {@inheritDoc}
 */
","@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();
        final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();
    double a;
    double b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }
    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;
    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;
                final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (!stop) {
            double p = 0;
            double q = 0;
            double r = 0;
            double u = 0;
            if (FastMath.abs(e) > tol1) {
                                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);
                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }
                r = e;
                e = d;
                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                                        d = p / q;
                    u = x + d;
                                        if (u - a < tol2 || b - u < tol2) {
                        if (x <= m) {
                            d = tol1;
                        } else {
                            d = -tol1;
                        }
                    }
                } else {
                                        if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }
            } else {
                                if (x < m) {
                    e = b - x;
                } else {
                    e = a - x;
                }
                d = GOLDEN_SECTION * e;
            }
                        if (FastMath.abs(d) < tol1) {
                if (d >= 0) {
                    u = x + tol1;
                } else {
                    u = x - tol1;
                }
            } else {
                u = x + d;
            }
            double fu = computeObjectiveValue(u);
            if (!isMinim) {
                fu = -fu;
            }
                        previous = current;
            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);
            if (checker != null) {
                if (checker.converged(iter, previous, current)) {
                    return current;
                }
            }
                        if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || Precision.equals(w, x)) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                    v = u;
                    fv = fu;
                }
            }
        } else {
                        return current;
        }
        ++iter;
    }
}",5.363636363636363,1.7500000000000002,3.3333333333333335,2.0,4.833333333333333,6.879881364310432,-1.5718382563808437,0.9166666666666666,-0.028571428571428574,40.61709946419623
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2430_be3a9114,1,"@Override
public boolean childNodeChanged(String name, NodeState before, NodeState after) {
    if (!loader.isRunning()) {
        return false;
    }
    return after.compareAgainstBaseState(before, new StandbyApplyDiff(builder.getChildNode(name), store, loader, path + name + ""/""));
}",,"@Override
public boolean childNodeChanged(String name, NodeState before, NodeState after) {
    if (!loader.isRunning()) {
        return false;
    }
    return after.compareAgainstBaseState(before, new StandbyApplyDiff(builder.getChildNode(name), store, loader, path + name + ""/""));
}",-0.3181818181818182,-0.11224489795918377,-0.3333333333333333,-0.5,-0.25,-0.11764705882352938,0.40579294522512177,-0.25,-0.028571428571428574,-0.10005525074845491
wicket,remotes/origin/bugs-dot-jar_WICKET-4927_8c827e33,1,"@Override
public void setContentLength(long length) {
    checkHeader();
    bufferedResponse.setContentLength(length);
}",,"@Override
public void setContentLength(long length) {
    checkHeader();
    bufferedResponse.setContentLength(length);
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8213363923143101,-0.3333333333333333,1.2285714285714286,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-657_32b0f733,3,"/**
 * Returns a {@code Complex} whose value is
 * {@code (this / divisor)}.
 * Implements the definitional formula
 * <pre>
 *  <code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di         c<sup>2</sup> + d<sup>2</sup>
 *  </code>
 * </pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.
 * <br/>
 * {@code Infinite} and {@code NaN} values are handled according to the
 * following rules, applied in the order presented:
 * <ul>
 *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value
 *   in either part, {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code divisor} equals {@link #ZERO}, {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} and {@code divisor} are both infinite,
 *   {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or
 *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts
 *   infinite), {@link #ZERO} is returned.
 *  </li>
 *  <li>If {@code this} is infinite and {@code divisor} is finite,
 *   {@code NaN} values are returned in the parts of the result if the
 *   {@link java.lang.Double} rules applied to the definitional formula
 *   force {@code NaN} results.
 *  </li>
 * </ul>
 *
 * @param divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @throws NullArgumentException if {@code divisor} is {@code null}.
 */
public Complex divide(Complex divisor) throws NullArgumentException {
    MathUtils.checkNotNull(divisor);
    if (isNaN || divisor.isNaN) {
        return NaN;
    }
    final double c = divisor.getReal();
    final double d = divisor.getImaginary();
    if (c == 0.0 && d == 0.0) {
        return NaN;
    }
    if (divisor.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    if (FastMath.abs(c) < FastMath.abs(d)) {
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this / divisor)}.
 * Implements the definitional formula
 * <pre>
 *  <code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di         c<sup>2</sup> + d<sup>2</sup>
 *  </code>
 * </pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.
 * <br/>
 * {@code Infinite} and {@code NaN} values are handled according to the
 * following rules, applied in the order presented:
 * <ul>
 *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value
 *   in either part, {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code divisor} equals {@link #ZERO}, {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} and {@code divisor} are both infinite,
 *   {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or
 *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts
 *   infinite), {@link #ZERO} is returned.
 *  </li>
 *  <li>If {@code this} is infinite and {@code divisor} is finite,
 *   {@code NaN} values are returned in the parts of the result if the
 *   {@link java.lang.Double} rules applied to the definitional formula
 *   force {@code NaN} results.
 *  </li>
 * </ul>
 *
 * @param divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @throws NullArgumentException if {@code divisor} is {@code null}.
 */
","public Complex divide(Complex divisor) throws NullArgumentException {
    MathUtils.checkNotNull(divisor);
    if (isNaN || divisor.isNaN) {
        return NaN;
    }
    final double c = divisor.getReal();
    final double d = divisor.getImaginary();
    if (c == 0.0 && d == 0.0) {
        return NaN;
    }
    if (divisor.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    if (FastMath.abs(c) < FastMath.abs(d)) {
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}",0.4090909090909091,-0.2755102040816327,0.16666666666666666,-0.5,0.8333333333333334,2.456747404844291,-0.386005162030399,0.25,-0.028571428571428574,2.842646725001178
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1668_63070cf9,1,"private static void addNonFullTextConstraints(List<Query> qs, Filter filter, IndexReader reader, Analyzer analyzer) {
    if (!filter.matchesAllTypes()) {
        addNodeTypeConstraints(qs, filter);
    }
    String path = filter.getPath();
    switch(filter.getPathRestriction()) {
        case ALL_CHILDREN:
            if (""/"".equals(path)) {
                break;
            }
            if (!path.endsWith(""/"")) {
                path += ""/"";
            }
            qs.add(new PrefixQuery(newPathTerm(path)));
            break;
        case DIRECT_CHILDREN:
            if (!path.endsWith(""/"")) {
                path += ""/"";
            }
            qs.add(new PrefixQuery(newPathTerm(path)));
            break;
        case EXACT:
            qs.add(new TermQuery(newPathTerm(path)));
            break;
        case PARENT:
            if (denotesRoot(path)) {
                // there's no parent of the root node
                // we add a path that can not possibly occur because there
                // is no way to say ""match no documents"" in Lucene
                qs.add(new TermQuery(new Term(FieldNames.PATH, ""///"")));
            } else {
                qs.add(new TermQuery(newPathTerm(getParentPath(path))));
            }
            break;
        case NO_RESTRICTION:
            break;
    }
    for (PropertyRestriction pr : filter.getPropertyRestrictions()) {
        if (pr.first == null && pr.last == null) {
            // is not null' queries (OAK-1208)
            continue;
        }
        String name = pr.propertyName;
        if (name.contains(""/"")) {
            // lucene cannot handle child-level property restrictions
            continue;
        }
        if (""rep:excerpt"".equals(name)) {
            continue;
        }
        if (JCR_PRIMARYTYPE.equals(name)) {
            continue;
        }
        if (skipTokenization(name)) {
            qs.add(new TermQuery(new Term(name, pr.first.getValue(STRING))));
            continue;
        }
        String first = null;
        String last = null;
        boolean isLike = pr.isLike;
        // TODO what to do with escaped tokens?
        if (pr.first != null) {
            first = pr.first.getValue(STRING);
            first = first.replace(""\\"", """");
        }
        if (pr.last != null) {
            last = pr.last.getValue(STRING);
            last = last.replace(""\\"", """");
        }
        if (isLike) {
            first = first.replace('%', WildcardQuery.WILDCARD_STRING);
            first = first.replace('_', WildcardQuery.WILDCARD_CHAR);
            int indexOfWS = first.indexOf(WildcardQuery.WILDCARD_STRING);
            int indexOfWC = first.indexOf(WildcardQuery.WILDCARD_CHAR);
            int len = first.length();
            if (indexOfWS == len || indexOfWC == len) {
                // remove trailing ""*"" for prefixquery
                first = first.substring(0, first.length() - 1);
                if (JCR_PATH.equals(name)) {
                    qs.add(new PrefixQuery(newPathTerm(first)));
                } else {
                    qs.add(new PrefixQuery(new Term(name, first)));
                }
            } else {
                if (JCR_PATH.equals(name)) {
                    qs.add(new WildcardQuery(newPathTerm(first)));
                } else {
                    qs.add(new WildcardQuery(new Term(name, first)));
                }
            }
            continue;
        }
        if (first != null && first.equals(last) && pr.firstIncluding && pr.lastIncluding) {
            if (JCR_PATH.equals(name)) {
                qs.add(new TermQuery(newPathTerm(first)));
            } else {
                if (""*"".equals(name)) {
                    addReferenceConstraint(first, qs, reader);
                } else {
                    for (String t : tokenize(first, analyzer)) {
                        qs.add(new TermQuery(new Term(name, t)));
                    }
                }
            }
            continue;
        }
        first = tokenizeAndPoll(first, analyzer);
        last = tokenizeAndPoll(last, analyzer);
        qs.add(TermRangeQuery.newStringRange(name, first, last, pr.firstIncluding, pr.lastIncluding));
    }
}",,"private static void addNonFullTextConstraints(List<Query> qs, Filter filter, IndexReader reader, Analyzer analyzer) {
    if (!filter.matchesAllTypes()) {
        addNodeTypeConstraints(qs, filter);
    }
    String path = filter.getPath();
    switch(filter.getPathRestriction()) {
        case ALL_CHILDREN:
            if (""/"".equals(path)) {
                break;
            }
            if (!path.endsWith(""/"")) {
                path += ""/"";
            }
            qs.add(new PrefixQuery(newPathTerm(path)));
            break;
        case DIRECT_CHILDREN:
            if (!path.endsWith(""/"")) {
                path += ""/"";
            }
            qs.add(new PrefixQuery(newPathTerm(path)));
            break;
        case EXACT:
            qs.add(new TermQuery(newPathTerm(path)));
            break;
        case PARENT:
            if (denotesRoot(path)) {
                                                                qs.add(new TermQuery(new Term(FieldNames.PATH, ""///"")));
            } else {
                qs.add(new TermQuery(newPathTerm(getParentPath(path))));
            }
            break;
        case NO_RESTRICTION:
            break;
    }
    for (PropertyRestriction pr : filter.getPropertyRestrictions()) {
        if (pr.first == null && pr.last == null) {
                        continue;
        }
        String name = pr.propertyName;
        if (name.contains(""/"")) {
                        continue;
        }
        if (""rep:excerpt"".equals(name)) {
            continue;
        }
        if (JCR_PRIMARYTYPE.equals(name)) {
            continue;
        }
        if (skipTokenization(name)) {
            qs.add(new TermQuery(new Term(name, pr.first.getValue(STRING))));
            continue;
        }
        String first = null;
        String last = null;
        boolean isLike = pr.isLike;
                if (pr.first != null) {
            first = pr.first.getValue(STRING);
            first = first.replace(""\\"", """");
        }
        if (pr.last != null) {
            last = pr.last.getValue(STRING);
            last = last.replace(""\\"", """");
        }
        if (isLike) {
            first = first.replace('%', WildcardQuery.WILDCARD_STRING);
            first = first.replace('_', WildcardQuery.WILDCARD_CHAR);
            int indexOfWS = first.indexOf(WildcardQuery.WILDCARD_STRING);
            int indexOfWC = first.indexOf(WildcardQuery.WILDCARD_CHAR);
            int len = first.length();
            if (indexOfWS == len || indexOfWC == len) {
                                first = first.substring(0, first.length() - 1);
                if (JCR_PATH.equals(name)) {
                    qs.add(new PrefixQuery(newPathTerm(first)));
                } else {
                    qs.add(new PrefixQuery(new Term(name, first)));
                }
            } else {
                if (JCR_PATH.equals(name)) {
                    qs.add(new WildcardQuery(newPathTerm(first)));
                } else {
                    qs.add(new WildcardQuery(new Term(name, first)));
                }
            }
            continue;
        }
        if (first != null && first.equals(last) && pr.firstIncluding && pr.lastIncluding) {
            if (JCR_PATH.equals(name)) {
                qs.add(new TermQuery(newPathTerm(first)));
            } else {
                if (""*"".equals(name)) {
                    addReferenceConstraint(first, qs, reader);
                } else {
                    for (String t : tokenize(first, analyzer)) {
                        qs.add(new TermQuery(new Term(name, t)));
                    }
                }
            }
            continue;
        }
        first = tokenizeAndPoll(first, analyzer);
        last = tokenizeAndPoll(last, analyzer);
        qs.add(TermRangeQuery.newStringRange(name, first, last, pr.firstIncluding, pr.lastIncluding));
    }
}",4.090909090909091,0.7142857142857143,6.0,1.5,4.0,2.3044982698961944,-1.5179237166618875,4.166666666666667,-0.028571428571428574,10.728598900981238
camel,remotes/origin/bugs-dot-jar_CAMEL-5261_55c2e2d8,1,"@Override
protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {
    int consumers = getAndRemoveParameter(parameters, ""concurrentConsumers"", Integer.class, defaultConcurrentConsumers);
    boolean limitConcurrentConsumers = getAndRemoveParameter(parameters, ""limitConcurrentConsumers"", Boolean.class, true);
    if (limitConcurrentConsumers && consumers > maxConcurrentConsumers) {
        throw new IllegalArgumentException(""The limitConcurrentConsumers flag in set to true. ConcurrentConsumers cannot be set at a value greater than "" + maxConcurrentConsumers + "" was "" + consumers);
    }
    SedaEndpoint answer = new SedaEndpoint(uri, this, createQueue(uri, parameters), consumers);
    answer.configureProperties(parameters);
    return answer;
}",,"@Override
protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {
    int consumers = getAndRemoveParameter(parameters, ""concurrentConsumers"", Integer.class, defaultConcurrentConsumers);
    boolean limitConcurrentConsumers = getAndRemoveParameter(parameters, ""limitConcurrentConsumers"", Boolean.class, true);
    if (limitConcurrentConsumers && consumers > maxConcurrentConsumers) {
        throw new IllegalArgumentException(""The limitConcurrentConsumers flag in set to true. ConcurrentConsumers cannot be set at a value greater than "" + maxConcurrentConsumers + "" was "" + consumers);
    }
    SedaEndpoint answer = new SedaEndpoint(uri, this, createQueue(uri, parameters), consumers);
    answer.configureProperties(parameters);
    return answer;
}",-0.13636363636363635,-0.36734693877551033,-0.16666666666666666,-0.5,0.0,0.2778052397429561,0.06854029251505596,-0.16666666666666666,-0.028571428571428574,0.19649136332292566
Lang,41,3,"/**
 * <p>Gets the class name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 *
 * @param className  the className to get the short name for
 * @return the class name of the class without the package name or an empty string
 */
public static String getShortClassName(String className) {
    if (className == null) {
        return StringUtils.EMPTY;
    }
    if (className.length() == 0) {
        return StringUtils.EMPTY;
    }
    // Handle array encoding
    // Strip Object type encoding
    int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);
    String out = className.substring(lastDotIdx + 1);
    if (innerIdx != -1) {
        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
    }
    return out;
}","/**
 * <p>Gets the class name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 *
 * @param className  the className to get the short name for
 * @return the class name of the class without the package name or an empty string
 */
","public static String getShortClassName(String className) {
    if (className == null) {
        return StringUtils.EMPTY;
    }
    if (className.length() == 0) {
        return StringUtils.EMPTY;
    }
            int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);
    String out = className.substring(lastDotIdx + 1);
    if (innerIdx != -1) {
        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
    }
    return out;
}",0.045454545454545456,-0.37244897959183676,0.16666666666666666,-0.5,0.25,0.47355412753336645,-0.08287926584456556,-0.08333333333333333,0.28571428571428575,0.2849525229033626
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-964_16ad8763,1,"private void writeObject(final ObjectOutputStream out) throws IOException {
    out.defaultWriteObject();
    getFormattedMessage();
    out.writeUTF(formattedMessage);
    out.writeUTF(messagePattern);
    out.writeInt(argArray.length);
    stringArgs = new String[argArray.length];
    int i = 0;
    for (final Object obj : argArray) {
        stringArgs[i] = obj.toString();
        ++i;
    }
}",,"private void writeObject(final ObjectOutputStream out) throws IOException {
    out.defaultWriteObject();
    getFormattedMessage();
    out.writeUTF(formattedMessage);
    out.writeUTF(messagePattern);
    out.writeInt(argArray.length);
    stringArgs = new String[argArray.length];
    int i = 0;
    for (final Object obj : argArray) {
        stringArgs[i] = obj.toString();
        ++i;
    }
}",-0.045454545454545456,-0.40816326530612235,-0.3333333333333333,-0.5,-0.4166666666666667,-0.06426099851705384,0.06509893891597351,0.0,0.05714285714285714,-0.05421426154590737
wicket,remotes/origin/bugs-dot-jar_WICKET-4441_54c86ebb,1,"/**
 *  Looks up a page by id from the {@link IPageStore}. <br/>
 *  If {@linkplain #pageClass} is specified then compares it against the stored instance class
 *  and returns the found instance only if they match.
 *
 *  @param pageId
 *             the id of the page to look for.
 *  @return the found page instance by id.
 */
private IRequestablePage getStoredPage(final int pageId) {
    IRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);
    if (storedPageInstance != null) {
        if (pageClass == null || pageClass.equals(storedPageInstance.getClass())) {
            pageInstance = storedPageInstance;
            pageInstanceIsFresh = false;
            if (renderCount != null && pageInstance.getRenderCount() != renderCount) {
                throw new StalePageException(pageInstance);
            }
        } else {
            // the found page class doesn't match the requested one
            storedPageInstance = null;
        }
    }
    return storedPageInstance;
}","/**
 *  Looks up a page by id from the {@link IPageStore}. <br/>
 *  If {@linkplain #pageClass} is specified then compares it against the stored instance class
 *  and returns the found instance only if they match.
 *
 *  @param pageId
 *             the id of the page to look for.
 *  @return the found page instance by id.
 */
","private IRequestablePage getStoredPage(final int pageId) {
    IRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);
    if (storedPageInstance != null) {
        if (pageClass == null || pageClass.equals(storedPageInstance.getClass())) {
            pageInstance = storedPageInstance;
            pageInstanceIsFresh = false;
            if (renderCount != null && pageInstance.getRenderCount() != renderCount) {
                throw new StalePageException(pageInstance);
            }
        } else {
                        storedPageInstance = null;
        }
    }
    return storedPageInstance;
}",0.045454545454545456,0.872448979591837,0.16666666666666666,0.5,0.5,0.34107760751359373,-0.04072268425580734,-0.08333333333333333,0.1142857142857143,0.12137176044303394
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd,1,"/**
 * Creates a cursor which wraps another cursor and adds a path prefix to
 * each of row of the wrapped cursor. This method will return the passed
 * cursor as is if {@code path} is the empty string or the root path (""/"").
 *
 * @param c    the cursor to wrap.
 * @param path the path prefix.
 * @return the cursor.
 */
public static Cursor newPrefixCursor(Cursor c, String path) {
    if (path.isEmpty() || PathUtils.denotesRoot(path)) {
        // no need to wrap
        return c;
    }
    return new PrefixCursor(c, path);
}","/**
 * Creates a cursor which wraps another cursor and adds a path prefix to
 * each of row of the wrapped cursor. This method will return the passed
 * cursor as is if {@code path} is the empty string or the root path (""/"").
 *
 * @param c    the cursor to wrap.
 * @param path the path prefix.
 * @return the cursor.
 */
","public static Cursor newPrefixCursor(Cursor c, String path) {
    if (path.isEmpty() || PathUtils.denotesRoot(path)) {
                return c;
    }
    return new PrefixCursor(c, path);
}",-0.36363636363636365,-0.13775510204081634,-0.3333333333333333,-0.5,0.0,-0.3806228373702422,0.5741324921135648,-0.3333333333333333,1.1428571428571428,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-3603_aa1d177a,1,"private void addToolbar(final AbstractToolbar toolbar, final RepeatingView container) {
    if (toolbar == null) {
        throw new IllegalArgumentException(""argument [toolbar] cannot be null"");
    }
    container.add(toolbar);
}",,"private void addToolbar(final AbstractToolbar toolbar, final RepeatingView container) {
    if (toolbar == null) {
        throw new IllegalArgumentException(""argument [toolbar] cannot be null"");
    }
    container.add(toolbar);
}",-0.36363636363636365,-0.13775510204081634,-0.16666666666666666,-0.5,-0.25,-0.3806228373702422,0.5965012905075997,-0.4166666666666667,1.0857142857142859,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-776_dc9f23d9,3,"/**
 * A convenience method for setting the end timestamp accepted by the timestamp filter.
 *
 * @param is
 *          the iterator setting object to configure
 * @param end
 *          the end timestamp (yyyyMMddHHmmssz)
 * @param endInclusive
 *          boolean indicating whether the end is inclusive
 */
public static void setEnd(IteratorSetting is, String end, boolean endInclusive) {
    is.addOption(END, end);
    is.addOption(END_INCL, Boolean.toString(endInclusive));
}","/**
 * A convenience method for setting the end timestamp accepted by the timestamp filter.
 *
 * @param is
 *          the iterator setting object to configure
 * @param end
 *          the end timestamp (yyyyMMddHHmmssz)
 * @param endInclusive
 *          boolean indicating whether the end is inclusive
 */
","public static void setEnd(IteratorSetting is, String end, boolean endInclusive) {
    is.addOption(END, end);
    is.addOption(END_INCL, Boolean.toString(endInclusive));
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7636937195296818,-0.25,2.5142857142857147,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_add180fb,1,"@Override
public void checkIteratorConflicts(String tableName, IteratorSetting setting) throws AccumuloException, TableNotFoundException {
    for (IteratorScope scope : setting.getScopes()) {
        String scopeStr = String.format(""%s%s"", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase());
        String nameStr = String.format(""%s.%s"", scopeStr, setting.getName());
        String optStr = String.format(""%s.opt."", nameStr);
        Map<String, String> optionConflicts = new TreeMap<String, String>();
        for (Entry<String, String> property : this.getProperties(tableName)) {
            if (property.getKey().startsWith(scopeStr)) {
                if (property.getKey().equals(nameStr))
                    throw new IllegalArgumentException(""iterator name conflict for "" + setting.getName() + "": "" + property.getKey() + ""="" + property.getValue());
                if (property.getKey().startsWith(optStr))
                    optionConflicts.put(property.getKey(), property.getValue());
                if (property.getKey().contains("".opt.""))
                    continue;
                String[] parts = property.getValue().split("","");
                if (parts.length != 2)
                    throw new AccumuloException(""Bad value for existing iterator setting: "" + property.getKey() + ""="" + property.getValue());
                try {
                    if (Integer.parseInt(parts[0]) == setting.getPriority())
                        throw new IllegalArgumentException(""iterator priority conflict: "" + property.getKey() + ""="" + property.getValue());
                } catch (NumberFormatException e) {
                    throw new AccumuloException(""Bad value for existing iterator setting: "" + property.getKey() + ""="" + property.getValue());
                }
            }
        }
        if (optionConflicts.size() > 0)
            throw new IllegalArgumentException(""iterator options conflict for "" + setting.getName() + "": "" + optionConflicts);
    }
}",,"@Override
public void checkIteratorConflicts(String tableName, IteratorSetting setting) throws AccumuloException, TableNotFoundException {
    for (IteratorScope scope : setting.getScopes()) {
        String scopeStr = String.format(""%s%s"", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase());
        String nameStr = String.format(""%s.%s"", scopeStr, setting.getName());
        String optStr = String.format(""%s.opt."", nameStr);
        Map<String, String> optionConflicts = new TreeMap<String, String>();
        for (Entry<String, String> property : this.getProperties(tableName)) {
            if (property.getKey().startsWith(scopeStr)) {
                if (property.getKey().equals(nameStr))
                    throw new IllegalArgumentException(""iterator name conflict for "" + setting.getName() + "": "" + property.getKey() + ""="" + property.getValue());
                if (property.getKey().startsWith(optStr))
                    optionConflicts.put(property.getKey(), property.getValue());
                if (property.getKey().contains("".opt.""))
                    continue;
                String[] parts = property.getValue().split("","");
                if (parts.length != 2)
                    throw new AccumuloException(""Bad value for existing iterator setting: "" + property.getKey() + ""="" + property.getValue());
                try {
                    if (Integer.parseInt(parts[0]) == setting.getPriority())
                        throw new IllegalArgumentException(""iterator priority conflict: "" + property.getKey() + ""="" + property.getValue());
                } catch (NumberFormatException e) {
                    throw new AccumuloException(""Bad value for existing iterator setting: "" + property.getKey() + ""="" + property.getValue());
                }
            }
        }
        if (optionConflicts.size() > 0)
            throw new IllegalArgumentException(""iterator options conflict for "" + setting.getName() + "": "" + optionConflicts);
    }
}",0.7272727272727273,1.846938775510204,2.1666666666666665,1.0,1.0833333333333333,0.5308947108255069,-0.6696300544880991,2.3333333333333335,-0.028571428571428574,1.4975651123646034
Closure,22,2,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    // so we'll allow it.
    if (n.isEmpty() || n.isComma()) {
        return;
    }
    if (parent == null) {
        return;
    }
    // fix up the tree in more clever ways when these are removed.
    if (parent.getType() == Token.COMMA) {
        Node gramps = parent.getParent();
        if (gramps.isCall() && parent == gramps.getFirstChild()) {
            if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
                return;
            }
        }
        // be attached to the name. This check should not complain about it.
        if (n == parent.getLastChild()) {
            for (Node an : parent.getAncestors()) {
                int ancestorType = an.getType();
                if (ancestorType == Token.COMMA)
                    continue;
                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)
                    return;
                else
                    break;
            }
        }
    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
        if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {
        } else {
            return;
        }
    }
    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
    if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
        if (n.isQualifiedName() && n.getJSDocInfo() != null) {
            return;
        } else if (n.isExprResult()) {
            return;
        }
        String msg = ""This code lacks side-effects. Is there a bug?"";
        if (n.isString()) {
            msg = ""Is there a missing '+' on the previous line?"";
        } else if (isSimpleOp) {
            msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() + ""' operator is not being used."";
        }
        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));
        // try to protect side-effect free statements as well.
        if (!NodeUtil.isStatement(n)) {
            problemNodes.add(n);
        }
    }
}",,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
        if (n.isEmpty() || n.isComma()) {
        return;
    }
    if (parent == null) {
        return;
    }
        if (parent.getType() == Token.COMMA) {
        Node gramps = parent.getParent();
        if (gramps.isCall() && parent == gramps.getFirstChild()) {
            if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
                return;
            }
        }
                if (n == parent.getLastChild()) {
            for (Node an : parent.getAncestors()) {
                int ancestorType = an.getType();
                if (ancestorType == Token.COMMA)
                    continue;
                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)
                    return;
                else
                    break;
            }
        }
    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
        if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {
        } else {
            return;
        }
    }
    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
    if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
        if (n.isQualifiedName() && n.getJSDocInfo() != null) {
            return;
        } else if (n.isExprResult()) {
            return;
        }
        String msg = ""This code lacks side-effects. Is there a bug?"";
        if (n.isString()) {
            msg = ""Is there a missing '+' on the previous line?"";
        } else if (isSimpleOp) {
            msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() + ""' operator is not being used."";
        }
        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));
                if (!NodeUtil.isStatement(n)) {
            problemNodes.add(n);
        }
    }
}",1.7272727272727273,0.9438775510204083,2.6666666666666665,0.5,4.0,1.0074147305981218,-0.9813593346716377,2.9166666666666665,-0.028571428571428574,3.06924760473015
commons-math,remotes/origin/bugs-dot-jar_MATH-1300_1d635088,1,"/**
 * Generates random bytes and places them into a user-supplied
 * byte array.  The number of random bytes produced is equal to
 * the length of the byte array.
 * <p>
 * The default implementation fills the array with bytes extracted from
 * random integers generated using {@link #nextInt}.</p>
 *
 * @param bytes the non-null byte array in which to put the
 * random bytes
 */
@Override
public void nextBytes(byte[] bytes) {
    int bytesOut = 0;
    while (bytesOut < bytes.length) {
        int randInt = nextInt();
        for (int i = 0; i < 3; i++) {
            if (i > 0) {
                randInt >>= 8;
            }
            bytes[bytesOut++] = (byte) randInt;
            if (bytesOut == bytes.length) {
                return;
            }
        }
    }
}","/**
 * Generates random bytes and places them into a user-supplied
 * byte array.  The number of random bytes produced is equal to
 * the length of the byte array.
 * <p>
 * The default implementation fills the array with bytes extracted from
 * random integers generated using {@link #nextInt}.</p>
 *
 * @param bytes the non-null byte array in which to put the
 * random bytes
 */
","@Override
public void nextBytes(byte[] bytes) {
    int bytesOut = 0;
    while (bytesOut < bytes.length) {
        int randInt = nextInt();
        for (int i = 0; i < 3; i++) {
            if (i > 0) {
                randInt >>= 8;
            }
            bytes[bytesOut++] = (byte) randInt;
            if (bytesOut == bytes.length) {
                return;
            }
        }
    }
}",0.09090909090909091,1.1581632653061225,0.16666666666666666,0.5,0.16666666666666666,0.9045971329708355,-0.04531115572125032,-0.4166666666666667,0.2571428571428572,0.2653021016699432
