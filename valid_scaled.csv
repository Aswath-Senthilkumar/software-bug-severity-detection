project_name,project_version,label,code,code_comment,code_no_comment,lc,pi,ma,nbd,ml,d,mi,fo,r,e
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-4038_557eec4f,1,"@Override
public double getCost(Filter filter, NodeState root) {
    if (filter.getFullTextConstraint() != null) {
        // not an appropriate index for full-text search
        return Double.POSITIVE_INFINITY;
    }
    if (filter.containsNativeConstraint()) {
        // not an appropriate index for native search
        return Double.POSITIVE_INFINITY;
    }
    if (filter.getPropertyRestrictions().isEmpty() && filter.getSelector().getSelectorConstraints().isEmpty()) {
        // not an appropriate index for no property restrictions & selector constraints
        return Double.POSITIVE_INFINITY;
    }
    PropertyIndexPlan plan = getPlan(root, filter);
    if (plan != null) {
        return plan.getCost();
    } else {
        return Double.POSITIVE_INFINITY;
    }
}",,"@Override
public double getCost(Filter filter, NodeState root) {
    if (filter.getFullTextConstraint() != null) {
                return Double.POSITIVE_INFINITY;
    }
    if (filter.containsNativeConstraint()) {
                return Double.POSITIVE_INFINITY;
    }
    if (filter.getPropertyRestrictions().isEmpty() && filter.getSelector().getSelectorConstraints().isEmpty()) {
                return Double.POSITIVE_INFINITY;
    }
    PropertyIndexPlan plan = getPlan(root, filter);
    if (plan != null) {
        return plan.getCost();
    } else {
        return Double.POSITIVE_INFINITY;
    }
}",0.18181818181818182,-0.19897959183673475,0.16666666666666666,-0.5,0.4166666666666667,-0.00692041522491348,-0.12159449383424176,0.25,0.0,-0.019470535075659254
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1363_69b68890,0,"@Override
public boolean commit() throws LoginException {
    if (tokenCredentials != null) {
        updateSubject(tokenCredentials, getAuthInfo(tokenInfo), principals);
        return true;
    }
    if (tokenProvider != null && sharedState.containsKey(SHARED_KEY_CREDENTIALS)) {
        Credentials shared = getSharedCredentials();
        if (shared != null && tokenProvider.doCreateToken(shared)) {
            TokenInfo ti = tokenProvider.createToken(shared);
            if (ti != null) {
                TokenCredentials tc = new TokenCredentials(ti.getToken());
                Map<String, String> attributes = ti.getPrivateAttributes();
                for (String name : attributes.keySet()) {
                    tc.setAttribute(name, attributes.get(name));
                }
                attributes = ti.getPublicAttributes();
                for (String name : attributes.keySet()) {
                    tc.setAttribute(name, attributes.get(name));
                }
                updateSubject(tc, getAuthInfo(ti), null);
            } else {
                // failed to create token -> fail commit()
                log.debug(""TokenProvider failed to create a login token for user "" + userId);
                throw new LoginException(""Failed to create login token for user "" + userId);
            }
        }
    }
    // the login attempt on this module did not succeed: clear state
    clearState();
    return false;
}",,"@Override
public boolean commit() throws LoginException {
    if (tokenCredentials != null) {
        updateSubject(tokenCredentials, getAuthInfo(tokenInfo), principals);
        return true;
    }
    if (tokenProvider != null && sharedState.containsKey(SHARED_KEY_CREDENTIALS)) {
        Credentials shared = getSharedCredentials();
        if (shared != null && tokenProvider.doCreateToken(shared)) {
            TokenInfo ti = tokenProvider.createToken(shared);
            if (ti != null) {
                TokenCredentials tc = new TokenCredentials(ti.getToken());
                Map<String, String> attributes = ti.getPrivateAttributes();
                for (String name : attributes.keySet()) {
                    tc.setAttribute(name, attributes.get(name));
                }
                attributes = ti.getPublicAttributes();
                for (String name : attributes.keySet()) {
                    tc.setAttribute(name, attributes.get(name));
                }
                updateSubject(tc, getAuthInfo(ti), null);
            } else {
                                log.debug(""TokenProvider failed to create a login token for user "" + userId);
                throw new LoginException(""Failed to create login token for user "" + userId);
            }
        }
    }
        clearState();
    return false;
}",0.7272727272727273,1.5612244897959184,0.6666666666666666,1.0,0.5833333333333334,0.3905091448344044,-0.5357040435904793,1.0833333333333333,-0.028571428571428574,0.6894351146345956
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2494_0dc92ca1,1,"public void addStat(long stat) {
    if (stat > max)
        max = stat;
    if (stat < min)
        min = stat;
    sum += stat;
    partialStdDev += stat * stat;
    count++;
}",,"public void addStat(long stat) {
    if (stat > max)
        max = stat;
    if (stat < min)
        min = stat;
    sum += stat;
    partialStdDev += stat * stat;
    count++;
}",-0.22727272727272727,-0.17857142857142863,-0.16666666666666666,-1.0,0.0,0.8808699950568464,0.3071408087180957,-0.5,0.6,0.09566517189835574
wicket,remotes/origin/bugs-dot-jar_WICKET-3931_8fbdc68f,1,"/**
 *  Detaches the component. This is called at the end of the request for all the pages that are
 *  touched in that request.
 */
public final void detach() {
    // if the component has been previously attached via attach()
    // detach it now
    setFlag(FLAG_DETACHING, true);
    onDetach();
    if (getFlag(FLAG_DETACHING)) {
        throw new IllegalStateException(Component.class.getName() + "" has not been properly detached. Something in the hierarchy of "" + getClass().getName() + "" has not called super.onDetach() in the override of onDetach() method"");
    }
    // always detach models because they can be attached without the
    // component. eg component has a compoundpropertymodel and one of its
    // children component's getmodelobject is called
    detachModels();
    // detach any behaviors
    new Behaviors(this).detach();
    // always detach children because components can be attached
    // independently of their parents
    detachChildren();
    // The model will be created next time.
    if (getFlag(FLAG_INHERITABLE_MODEL)) {
        setModelImpl(null);
        setFlag(FLAG_INHERITABLE_MODEL, false);
    }
    clearEnabledInHierarchyCache();
    clearVisibleInHierarchyCache();
    requestFlags = 0;
    // notify any detach listener
    IDetachListener detachListener = getApplication().getFrameworkSettings().getDetachListener();
    if (detachListener != null) {
        detachListener.onDetach(this);
    }
}","/**
 *  Detaches the component. This is called at the end of the request for all the pages that are
 *  touched in that request.
 */
","public final void detach() {
            setFlag(FLAG_DETACHING, true);
    onDetach();
    if (getFlag(FLAG_DETACHING)) {
        throw new IllegalStateException(Component.class.getName() + "" has not been properly detached. Something in the hierarchy of "" + getClass().getName() + "" has not called super.onDetach() in the override of onDetach() method"");
    }
                detachModels();
        new Behaviors(this).detach();
            detachChildren();
        if (getFlag(FLAG_INHERITABLE_MODEL)) {
        setModelImpl(null);
        setFlag(FLAG_INHERITABLE_MODEL, false);
    }
    clearEnabledInHierarchyCache();
    clearVisibleInHierarchyCache();
    requestFlags = 0;
        IDetachListener detachListener = getApplication().getFrameworkSettings().getDetachListener();
    if (detachListener != null) {
        detachListener.onDetach(this);
    }
}",0.3181818181818182,-0.4693877551020408,0.16666666666666666,-0.5,0.08333333333333333,-0.11566979733069695,-0.22110696874103844,1.0,-0.028571428571428574,-0.0403887254209122
Closure,54,2,"/**
 * Sets the prototype.
 * @param prototype the prototype. If this value is {@code null} it will
 *        silently be discarded.
 */
public boolean setPrototype(PrototypeObjectType prototype) {
    if (prototype == null) {
        return false;
    }
    // getInstanceType fails if the function is not a constructor
    if (isConstructor() && prototype == getInstanceType()) {
        return false;
    }
    boolean replacedPrototype = prototype != null;
    this.prototype = prototype;
    this.prototypeSlot = new SimpleSlot(""prototype"", prototype, true);
    this.prototype.setOwnerFunction(this);
    if (isConstructor() || isInterface()) {
        FunctionType superClass = getSuperClassConstructor();
        if (superClass != null) {
            superClass.addSubType(this);
        }
        if (isInterface()) {
            for (ObjectType interfaceType : getExtendedInterfaces()) {
                if (interfaceType.getConstructor() != null) {
                    interfaceType.getConstructor().addSubType(this);
                }
            }
        }
    }
    if (replacedPrototype) {
        clearCachedValues();
    }
    return true;
}","/**
 * Sets the prototype.
 * @param prototype the prototype. If this value is {@code null} it will
 *        silently be discarded.
 */
","public boolean setPrototype(PrototypeObjectType prototype) {
    if (prototype == null) {
        return false;
    }
        if (isConstructor() && prototype == getInstanceType()) {
        return false;
    }
    boolean replacedPrototype = prototype != null;
    this.prototype = prototype;
    this.prototypeSlot = new SimpleSlot(""prototype"", prototype, true);
    this.prototype.setOwnerFunction(this);
    if (isConstructor() || isInterface()) {
        FunctionType superClass = getSuperClassConstructor();
        if (superClass != null) {
            superClass.addSubType(this);
        }
        if (isInterface()) {
            for (ObjectType interfaceType : getExtendedInterfaces()) {
                if (interfaceType.getConstructor() != null) {
                    interfaceType.getConstructor().addSubType(this);
                }
            }
        }
    }
    if (replacedPrototype) {
        clearCachedValues();
    }
    return true;
}",0.6818181818181818,0.8367346938775511,0.8333333333333334,1.0,0.9166666666666666,0.3924864063272369,-0.43102953828505897,0.5833333333333334,-0.028571428571428574,0.28696125166501774
wicket,remotes/origin/bugs-dot-jar_WICKET-3428_ffc0cae9,1,"/**
 *  Convenience method that processes the request and detaches the {@link RequestCycle}.
 *
 *  @return <code>true</code> if the request resolved to a Wicket request, <code>false</code>
 *          otherwise.
 */
public boolean processRequestAndDetach() {
    boolean result;
    try {
        listeners.onBeginRequest(this);
        onBeginRequest();
        result = processRequest();
    } finally {
        detach();
    }
    return result;
}","/**
 *  Convenience method that processes the request and detaches the {@link RequestCycle}.
 *
 *  @return <code>true</code> if the request resolved to a Wicket request, <code>false</code>
 *          otherwise.
 */
","public boolean processRequestAndDetach() {
    boolean result;
    try {
        listeners.onBeginRequest(this);
        onBeginRequest();
        result = processRequest();
    } finally {
        detach();
    }
    return result;
}",-0.13636363636363635,-0.08163265306122457,-0.5,-0.5,-0.4166666666666667,-0.3806228373702422,0.38514482363062796,-0.16666666666666666,1.6285714285714286,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-370_495f04bc,3,"/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link #equals(double,double) this method}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements.
 * @deprecated This method considers that {@code NaN == NaN}. In release
 * 3.0, the semantics will change in order to comply with IEEE754 where it
 * is specified that {@code NaN != NaN}.
 * New methods have been added for those cases wher the old semantics is
 * useful (see e.g. {@link #equalsIncludingNaN(double[],double[])
 * equalsIncludingNaN}.
 */
public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}","/**
 * Returns true iff both arguments are null or have same dimensions and all
 * their elements are equal as defined by
 * {@link #equals(double,double) this method}.
 *
 * @param x first array
 * @param y second array
 * @return true if the values are both null or have same dimension
 * and equal elements.
 * @deprecated This method considers that {@code NaN == NaN}. In release
 * 3.0, the semantics will change in order to comply with IEEE754 where it
 * is specified that {@code NaN != NaN}.
 * New methods have been added for those cases wher the old semantics is
 * useful (see e.g. {@link #equalsIncludingNaN(double[],double[])
 * equalsIncludingNaN}.
 */
","public static boolean equals(double[] x, double[] y) {
    if ((x == null) || (y == null)) {
        return !((x == null) ^ (y == null));
    }
    if (x.length != y.length) {
        return false;
    }
    for (int i = 0; i < x.length; ++i) {
        if (!equals(x[i], y[i])) {
            return false;
        }
    }
    return true;
}",0.0,0.08163265306122457,0.16666666666666666,0.0,0.5,1.9920909540286704,-0.0020074562661315577,-0.4166666666666667,0.4285714285714286,0.7359057053893036
wicket,remotes/origin/bugs-dot-jar_WICKET-5265_0eb596df,1,"@Override
protected FeedbackMessagesModel newFeedbackMessagesModel() {
    return new FeedbackMessagesModel(this) {

        private static final long serialVersionUID = 1L;

        @Override
        protected List<FeedbackMessage> collectMessages(Component panel, IFeedbackMessageFilter filter) {
            if (fence == null) {
                return new FeedbackCollector(panel.getPage()) {

                    @Override
                    protected boolean shouldRecurseInto(Component component) {
                        return component.getMetaData(FENCE_KEY) == null;
                    }
                }.collect(filter);
            } else {
                return new FeedbackCollector(fence) {

                    @Override
                    protected boolean shouldRecurseInto(Component component) {
                        return component.getMetaData(FENCE_KEY) == null;
                    }
                }.setIncludeSession(false).collect(filter);
            }
        }
    };
}",,"@Override
protected FeedbackMessagesModel newFeedbackMessagesModel() {
    return new FeedbackMessagesModel(this) {

        private static final long serialVersionUID = 1L;

        @Override
        protected List<FeedbackMessage> collectMessages(Component panel, IFeedbackMessageFilter filter) {
            if (fence == null) {
                return new FeedbackCollector(panel.getPage()) {

                    @Override
                    protected boolean shouldRecurseInto(Component component) {
                        return component.getMetaData(FENCE_KEY) == null;
                    }
                }.collect(filter);
            } else {
                return new FeedbackCollector(fence) {

                    @Override
                    protected boolean shouldRecurseInto(Component component) {
                        return component.getMetaData(FENCE_KEY) == null;
                    }
                }.setIncludeSession(false).collect(filter);
            }
        }
    };
}",0.45454545454545453,2.275510204081633,-0.3333333333333333,0.5,-0.25,-0.01878398418190801,-0.27043303699455146,0.0,0.0,0.012934671343706764
wicket,remotes/origin/bugs-dot-jar_WICKET-5724_b92591f6,1,"@Override
public Component newComponent(ComponentTag tag) {
    String attributeName = getInlineEnclosureAttributeName(null);
    String childId = tag.getAttribute(attributeName);
    return new InlineEnclosure(tag.getId(), childId);
}",,"@Override
public Component newComponent(ComponentTag tag) {
    String attributeName = getInlineEnclosureAttributeName(null);
    String childId = tag.getAttribute(attributeName);
    return new InlineEnclosure(tag.getId(), childId);
}",-0.36363636363636365,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.5311155721250359,-0.25,1.2857142857142858,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2246_dcadb0e1,1,"@Override
public void startNode(NodeInfo nodeInfo, List<PropInfo> propInfos) throws RepositoryException {
    Tree parent = parents.peek();
    Tree tree = null;
    String id = nodeInfo.getUUID();
    String nodeName = nodeInfo.getName();
    String ntName = nodeInfo.getPrimaryTypeName();
    if (parent == null) {
        log.debug(""Skipping node: "" + nodeName);
        // parent node was skipped, skip this child node too
        // push null onto stack for skipped node
        parents.push(null);
        // notify the p-i-importer
        if (pnImporter != null) {
            pnImporter.startChildInfo(nodeInfo, propInfos);
        }
        return;
    }
    NodeDefinition parentDef = getDefinition(parent);
    if (parentDef.isProtected()) {
        // skip protected node
        parents.push(null);
        log.debug(""Skipping protected node: "" + nodeName);
        if (pnImporter != null) {
            // pnImporter was already started (current nodeInfo is a sibling)
            // notify it about this child node.
            pnImporter.startChildInfo(nodeInfo, propInfos);
        } else {
            // potentially is able to deal with it, notify it about the child node.
            for (ProtectedNodeImporter pni : getNodeImporters()) {
                if (pni.start(parent)) {
                    log.debug(""Protected node -> delegated to ProtectedNodeImporter"");
                    pnImporter = pni;
                    pnImporter.startChildInfo(nodeInfo, propInfos);
                    break;
                }
            /* else: p-i-Importer isn't able to deal with the protected tree.
                     try next. and if none can handle the passed parent the
                     tree below will be skipped */
            }
        }
        return;
    }
    if (parent.hasChild(nodeName)) {
        // a node with that name already exists...
        Tree existing = parent.getChild(nodeName);
        NodeDefinition def = getDefinition(existing);
        if (!def.allowsSameNameSiblings()) {
            // check for potential conflicts
            if (def.isProtected() && isNodeType(existing, ntName)) {
                /*
                     use the existing node as parent for the possible subsequent
                     import of a protected tree, that the protected node importer
                     may or may not be able to deal with.
                     -> upon the next 'startNode' the check for the parent being
                        protected will notify the protected node importer.
                     -> if the importer is able to deal with that node it needs
                        to care of the complete subtree until it is notified
                        during the 'endNode' call.
                     -> if the import can't deal with that node or if that node
                        is the a leaf in the tree to be imported 'end' will
                        not have an effect on the importer, that was never started.
                    */
                log.debug(""Skipping protected node: "" + existing);
                parents.push(existing);
                /**
                 * let ProtectedPropertyImporters handle the properties
                 * associated with the imported node. this may include overwriting,
                 * merging or just adding missing properties.
                 */
                importProperties(existing, propInfos, true);
                return;
            }
            if (def.isAutoCreated() && isNodeType(existing, ntName)) {
                // this node has already been auto-created, no need to create it
                tree = existing;
            } else {
                // edge case: colliding node does have same uuid
                // (see http://issues.apache.org/jira/browse/JCR-1128)
                String existingIdentifier = IdentifierManager.getIdentifier(existing);
                if (!(existingIdentifier.equals(id) && (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING || uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING))) {
                    throw new ItemExistsException(""Node with the same UUID exists:"" + existing);
                }
            // fall through
            }
        }
    }
    if (tree == null) {
        // create node
        if (id == null) {
            // no potential uuid conflict, always add new node
            tree = createTree(parent, nodeInfo, null);
        } else if (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {
            // always create a new UUID even if no
            // conflicting node exists. see OAK-1244
            tree = createTree(parent, nodeInfo, UUID.randomUUID().toString());
            // remember uuid mapping
            if (isNodeType(tree, JcrConstants.MIX_REFERENCEABLE)) {
                refTracker.put(nodeInfo.getUUID(), TreeUtil.getString(tree, JcrConstants.JCR_UUID));
            }
        } else {
            // 1. First check from base state that tree corresponding to
            // this id exist
            Tree conflicting = baseStateIdManager.getTree(id);
            if (conflicting == null) {
                // 1.a. Check if id is found in newly created nodes
                if (uuids.contains(id)) {
                    conflicting = currentStateIdManager.getTree(id);
                }
            } else {
                // 1.b Re obtain the conflicting tree from Id Manager
                // associated with current root. Such that any operation
                // on it gets reflected in later operations
                // In case a tree with same id was removed earlier then it
                // would return null
                conflicting = currentStateIdManager.getTree(id);
            }
            if (conflicting != null && conflicting.exists()) {
                // resolve uuid conflict
                tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);
                if (tree == null) {
                    // no new node has been created, so skip this node
                    // push null onto stack for skipped node
                    parents.push(null);
                    log.debug(""Skipping existing node "" + nodeInfo.getName());
                    return;
                }
            } else {
                // create new with given uuid
                tree = createTree(parent, nodeInfo, id);
            }
        }
    }
    // process properties
    importProperties(tree, propInfos, false);
    parents.push(tree);
}","/**
 * let ProtectedPropertyImporters handle the properties
 * associated with the imported node. this may include overwriting,
 * merging or just adding missing properties.
 */
","@Override
public void startNode(NodeInfo nodeInfo, List<PropInfo> propInfos) throws RepositoryException {
    Tree parent = parents.peek();
    Tree tree = null;
    String id = nodeInfo.getUUID();
    String nodeName = nodeInfo.getName();
    String ntName = nodeInfo.getPrimaryTypeName();
    if (parent == null) {
        log.debug(""Skipping node: "" + nodeName);
                        parents.push(null);
                if (pnImporter != null) {
            pnImporter.startChildInfo(nodeInfo, propInfos);
        }
        return;
    }
    NodeDefinition parentDef = getDefinition(parent);
    if (parentDef.isProtected()) {
                parents.push(null);
        log.debug(""Skipping protected node: "" + nodeName);
        if (pnImporter != null) {
                                    pnImporter.startChildInfo(nodeInfo, propInfos);
        } else {
                        for (ProtectedNodeImporter pni : getNodeImporters()) {
                if (pni.start(parent)) {
                    log.debug(""Protected node -> delegated to ProtectedNodeImporter"");
                    pnImporter = pni;
                    pnImporter.startChildInfo(nodeInfo, propInfos);
                    break;
                }
                        }
        }
        return;
    }
    if (parent.hasChild(nodeName)) {
                Tree existing = parent.getChild(nodeName);
        NodeDefinition def = getDefinition(existing);
        if (!def.allowsSameNameSiblings()) {
                        if (def.isProtected() && isNodeType(existing, ntName)) {
                                log.debug(""Skipping protected node: "" + existing);
                parents.push(existing);
                /**
                 * let ProtectedPropertyImporters handle the properties
                 * associated with the imported node. this may include overwriting,
                 * merging or just adding missing properties.
                 */
                importProperties(existing, propInfos, true);
                return;
            }
            if (def.isAutoCreated() && isNodeType(existing, ntName)) {
                                tree = existing;
            } else {
                                                String existingIdentifier = IdentifierManager.getIdentifier(existing);
                if (!(existingIdentifier.equals(id) && (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING || uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING))) {
                    throw new ItemExistsException(""Node with the same UUID exists:"" + existing);
                }
                        }
        }
    }
    if (tree == null) {
                if (id == null) {
                        tree = createTree(parent, nodeInfo, null);
        } else if (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {
                                    tree = createTree(parent, nodeInfo, UUID.randomUUID().toString());
                        if (isNodeType(tree, JcrConstants.MIX_REFERENCEABLE)) {
                refTracker.put(nodeInfo.getUUID(), TreeUtil.getString(tree, JcrConstants.JCR_UUID));
            }
        } else {
                                    Tree conflicting = baseStateIdManager.getTree(id);
            if (conflicting == null) {
                                if (uuids.contains(id)) {
                    conflicting = currentStateIdManager.getTree(id);
                }
            } else {
                                                                                                conflicting = currentStateIdManager.getTree(id);
            }
            if (conflicting != null && conflicting.exists()) {
                                tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);
                if (tree == null) {
                                                            parents.push(null);
                    log.debug(""Skipping existing node "" + nodeInfo.getName());
                    return;
                }
            } else {
                                tree = createTree(parent, nodeInfo, id);
            }
        }
    }
        importProperties(tree, propInfos, false);
    parents.push(tree);
}",3.4545454545454546,1.2448979591836735,3.0,1.5,3.1666666666666665,1.2189817103311915,-1.3117292801835392,3.5833333333333335,-0.028571428571428574,5.490536703200688
camel,remotes/origin/bugs-dot-jar_CAMEL-7429_43956f93,1,"public String parseUri(String text, Properties properties, String prefixToken, String suffixToken, String propertyPrefix, String propertySuffix, boolean fallbackToUnaugmentedProperty) throws IllegalArgumentException {
    String answer = text;
    boolean done = false;
    // the placeholders can contain nested placeholders so we need to do recursive parsing
    // we must therefore also do circular reference check and must keep a list of visited keys
    List<String> visited = new ArrayList<String>();
    while (!done) {
        List<String> replaced = new ArrayList<String>();
        answer = doParseUri(answer, properties, replaced, prefixToken, suffixToken, propertyPrefix, propertySuffix, fallbackToUnaugmentedProperty);
        // check the replaced with the visited to avoid circular reference
        for (String replace : replaced) {
            if (visited.contains(replace)) {
                throw new IllegalArgumentException(""Circular reference detected with key ["" + replace + ""] from text: "" + text);
            }
        }
        // okay all okay so add the replaced as visited
        visited.addAll(replaced);
        // we are done when we can no longer find any prefix tokens in the answer
        done = findTokenPosition(answer, 0, prefixToken) == -1;
    }
    return answer;
}",,"public String parseUri(String text, Properties properties, String prefixToken, String suffixToken, String propertyPrefix, String propertySuffix, boolean fallbackToUnaugmentedProperty) throws IllegalArgumentException {
    String answer = text;
    boolean done = false;
            List<String> visited = new ArrayList<String>();
    while (!done) {
        List<String> replaced = new ArrayList<String>();
        answer = doParseUri(answer, properties, replaced, prefixToken, suffixToken, propertyPrefix, propertySuffix, fallbackToUnaugmentedProperty);
                for (String replace : replaced) {
            if (visited.contains(replace)) {
                throw new IllegalArgumentException(""Circular reference detected with key ["" + replace + ""] from text: "" + text);
            }
        }
                visited.addAll(replaced);
                done = findTokenPosition(answer, 0, prefixToken) == -1;
    }
    return answer;
}",0.13636363636363635,0.5510204081632651,0.16666666666666666,0.5,0.0,0.5229856648541772,-0.2050473186119876,-0.16666666666666666,-0.028571428571428574,0.5666456799482613
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1093_531aca78,1,"@Override
public Value[] getValues() throws RepositoryException {
    PropertyValue[] values = row.getValues();
    int len = values.length;
    Value[] v2 = new Value[values.length];
    for (int i = 0; i < len; i++) {
        if (values[i].isArray()) {
            v2[i] = result.createValue(mvpToString(values[i]));
        } else {
            v2[i] = result.createValue(values[i]);
        }
    }
    return v2;
}",,"@Override
public Value[] getValues() throws RepositoryException {
    PropertyValue[] values = row.getValues();
    int len = values.length;
    Value[] v2 = new Value[values.length];
    for (int i = 0; i < len; i++) {
        if (values[i].isArray()) {
            v2[i] = result.createValue(mvpToString(values[i]));
        } else {
            v2[i] = result.createValue(values[i]);
        }
    }
    return v2;
}",0.0,0.413265306122449,-0.16666666666666666,0.0,0.0,0.07217004448838364,-0.010897619730427174,-0.08333333333333333,0.17142857142857146,0.03536476201489629
wicket,remotes/origin/bugs-dot-jar_WICKET-3620_1a2bc1bc,1,"/**
 *  Runs the configured {@link IResponseFilter}s over the constructed Ajax response
 *
 *  @param contentResponse
 *             the Ajax {@link Response} body
 */
private void invokeResponseFilters(final StringResponse contentResponse) {
    AppendingStringBuffer responseBuffer = new AppendingStringBuffer(contentResponse.getBuffer());
    List<IResponseFilter> responseFilters = Application.get().getRequestCycleSettings().getResponseFilters();
    if (responseFilters != null) {
        for (IResponseFilter filter : responseFilters) {
            filter.filter(responseBuffer);
        }
    }
}","/**
 *  Runs the configured {@link IResponseFilter}s over the constructed Ajax response
 *
 *  @param contentResponse
 *             the Ajax {@link Response} body
 */
","private void invokeResponseFilters(final StringResponse contentResponse) {
    AppendingStringBuffer responseBuffer = new AppendingStringBuffer(contentResponse.getBuffer());
    List<IResponseFilter> responseFilters = Application.get().getRequestCycleSettings().getResponseFilters();
    if (responseFilters != null) {
        for (IResponseFilter filter : responseFilters) {
            filter.filter(responseBuffer);
        }
    }
}",-0.22727272727272727,0.32653061224489804,-0.16666666666666666,0.0,-0.25,-0.08403361344537813,0.28219099512474927,-0.08333333333333333,2.0285714285714285,-0.09189612859290477
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-276_1bf5c550,1,"public Id readHead() throws Exception {
    Connection con = cp.getConnection();
    try {
        PreparedStatement stmt = con.prepareStatement(""select * from HEAD"");
        ResultSet rs = stmt.executeQuery();
        byte[] rawId = null;
        if (rs.next()) {
            rawId = rs.getBytes(1);
        }
        stmt.close();
        return rawId == null ? null : new Id(rawId);
    } finally {
        con.close();
    }
}",,"public Id readHead() throws Exception {
    Connection con = cp.getConnection();
    try {
        PreparedStatement stmt = con.prepareStatement(""select * from HEAD"");
        ResultSet rs = stmt.executeQuery();
        byte[] rawId = null;
        if (rs.next()) {
            rawId = rs.getBytes(1);
        }
        stmt.close();
        return rawId == null ? null : new Id(rawId);
    } finally {
        con.close();
    }
}",0.045454545454545456,0.10204081632653071,-0.16666666666666666,0.0,-0.08333333333333333,-0.06030647553138898,-0.025810151993117463,0.08333333333333333,0.7714285714285716,-0.038756900989802175
wicket,remotes/origin/bugs-dot-jar_WICKET-442_246d53c5,1,"/**
 *  Call this method when the current (ajax) request shouldn't merge
 *  the changes that are happening to the page with the previous version.
 *
 *  This is for example needed when you want to redirect to this
 *  page in an ajax request and then you do want to version normally..
 *
 *  This method doesn't do anything if the getRequest().mergeVersion
 *  doesn't return true.
 */
public final void ignoreVersionMerge() {
    if (getRequest().mergeVersion()) {
        mayTrackChangesFor(this, null);
        if (versionManager != null) {
            versionManager.ignoreVersionMerge();
        }
    }
}","/**
 *  Call this method when the current (ajax) request shouldn't merge
 *  the changes that are happening to the page with the previous version.
 *
 *  This is for example needed when you want to redirect to this
 *  page in an ajax request and then you do want to version normally..
 *
 *  This method doesn't do anything if the getRequest().mergeVersion
 *  doesn't return true.
 */
","public final void ignoreVersionMerge() {
    if (getRequest().mergeVersion()) {
        mayTrackChangesFor(this, null);
        if (versionManager != null) {
            versionManager.ignoreVersionMerge();
        }
    }
}",-0.2727272727272727,0.4846938775510205,-0.16666666666666666,0.0,-0.08333333333333333,-0.3806228373702422,0.5199311729280184,-0.16666666666666666,1.9428571428571428,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-393_d4b02f6a,3,"/**
 * Get the result of the last run of the optimizer.
 *
 * @return the last result.
 * @throws IllegalStateException if there is no result available, either
 * because no result was yet computed or the last attempt failed.
 */
double getResult();","/**
 * Get the result of the last run of the optimizer.
 *
 * @return the last result.
 * @throws IllegalStateException if there is no result available, either
 * because no result was yet computed or the last attempt failed.
 */
",double getResult();,-0.5909090909090909,-1.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.9174075136220248,-0.5,2.8285714285714287,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2330_408a566e,3,"private boolean indexAggregates(final String path, final List<Field> fields, final NodeState state) throws CommitFailedException {
    final AtomicBoolean dirtyFlag = new AtomicBoolean();
    indexingRule.getAggregate().collectAggregates(state, new Aggregate.ResultCollector() {

        @Override
        public void onResult(Aggregate.NodeIncludeResult result) throws CommitFailedException {
            boolean dirty = indexAggregatedNode(path, fields, result);
            if (dirty) {
                dirtyFlag.set(true);
            }
        }

        @Override
        public void onResult(Aggregate.PropertyIncludeResult result) throws CommitFailedException {
            boolean dirty = false;
            if (result.pd.ordered) {
                dirty |= addTypedOrderedFields(fields, result.propertyState, result.propertyPath, result.pd);
            }
            dirty |= indexProperty(path, fields, state, result.propertyState, result.propertyPath, true, result.pd);
            if (dirty) {
                dirtyFlag.set(true);
            }
        }
    });
    return dirtyFlag.get();
}",,"private boolean indexAggregates(final String path, final List<Field> fields, final NodeState state) throws CommitFailedException {
    final AtomicBoolean dirtyFlag = new AtomicBoolean();
    indexingRule.getAggregate().collectAggregates(state, new Aggregate.ResultCollector() {

        @Override
        public void onResult(Aggregate.NodeIncludeResult result) throws CommitFailedException {
            boolean dirty = indexAggregatedNode(path, fields, result);
            if (dirty) {
                dirtyFlag.set(true);
            }
        }

        @Override
        public void onResult(Aggregate.PropertyIncludeResult result) throws CommitFailedException {
            boolean dirty = false;
            if (result.pd.ordered) {
                dirty |= addTypedOrderedFields(fields, result.propertyState, result.propertyPath, result.pd);
            }
            dirty |= indexProperty(path, fields, state, result.propertyState, result.propertyPath, true, result.pd);
            if (dirty) {
                dirtyFlag.set(true);
            }
        }
    });
    return dirtyFlag.get();
}",0.45454545454545453,0.7755102040816326,0.0,0.0,0.0,0.03855659911023239,-0.36851161456839726,0.16666666666666666,-0.028571428571428574,0.196829720619665
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1310_c6318b63,1,"/**
 * Looks up the value of the JNDI resource.
 * @param event The current LogEvent (is ignored by this StrLookup).
 * @param key  the JNDI resource name to be looked up, may be null
 * @return The value of the JNDI resource.
 */
@Override
public String lookup(final LogEvent event, final String key) {
    if (key == null) {
        return null;
    }
    final String jndiName = convertJndiName(key);
    final JndiManager jndiManager = JndiManager.getDefaultManager();
    try {
        return jndiManager.lookup(jndiName);
    } catch (final NamingException e) {
        LOGGER.warn(LOOKUP, ""Error looking up JNDI resource [{}]."", jndiName, e);
        return null;
    } finally {
        jndiManager.release();
    }
}","/**
 * Looks up the value of the JNDI resource.
 * @param event The current LogEvent (is ignored by this StrLookup).
 * @param key  the JNDI resource name to be looked up, may be null
 * @return The value of the JNDI resource.
 */
","@Override
public String lookup(final LogEvent event, final String key) {
    if (key == null) {
        return null;
    }
    final String jndiName = convertJndiName(key);
    final JndiManager jndiManager = JndiManager.getDefaultManager();
    try {
        return jndiManager.lookup(jndiName);
    } catch (final NamingException e) {
        LOGGER.warn(LOOKUP, ""Error looking up JNDI resource [{}]."", jndiName, e);
        return null;
    } finally {
        jndiManager.release();
    }
}",0.09090909090909091,-0.12244897959183684,-0.16666666666666666,-0.5,-0.25,-0.054374691052891735,-0.037854889589905585,-0.08333333333333333,0.39999999999999997,-0.05077500952968336
camel,remotes/origin/bugs-dot-jar_CAMEL-6779_f412d744,1,"@Converter
public XMLStreamReader createXMLStreamReader(InputStream in, Exchange exchange) throws XMLStreamException {
    XMLInputFactory factory = getInputFactory();
    try {
        return factory.createXMLStreamReader(IOHelper.buffered(in), IOHelper.getCharsetName(exchange));
    } finally {
        returnXMLInputFactory(factory);
    }
}",,"@Converter
public XMLStreamReader createXMLStreamReader(InputStream in, Exchange exchange) throws XMLStreamException {
    XMLInputFactory factory = getInputFactory();
    try {
        return factory.createXMLStreamReader(IOHelper.buffered(in), IOHelper.getCharsetName(exchange));
    } finally {
        returnXMLInputFactory(factory);
    }
}",-0.22727272727272727,-0.035714285714285636,-0.5,-0.5,-0.4166666666666667,-0.3806228373702422,0.3223401204473759,-0.08333333333333333,0.31428571428571433,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-434_133cbc2d,1,"/**
 * Solves Phase 1 of the Simplex method.
 * @param tableau simple tableau for the problem
 * @exception OptimizationException if the maximal number of iterations is
 * exceeded, or if the problem is found not to have a bounded solution, or
 * if there is no feasible solution
 */
protected void solvePhase1(final SimplexTableau tableau) throws OptimizationException {
    // make sure we're in Phase 1
    if (tableau.getNumArtificialVariables() == 0) {
        return;
    }
    while (!tableau.isOptimal()) {
        doIteration(tableau);
    }
    // if W is not zero then we have no feasible solution
    if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0, epsilon)) {
        throw new NoFeasibleSolutionException();
    }
}","/**
 * Solves Phase 1 of the Simplex method.
 * @param tableau simple tableau for the problem
 * @exception OptimizationException if the maximal number of iterations is
 * exceeded, or if the problem is found not to have a bounded solution, or
 * if there is no feasible solution
 */
","protected void solvePhase1(final SimplexTableau tableau) throws OptimizationException {
        if (tableau.getNumArtificialVariables() == 0) {
        return;
    }
    while (!tableau.isOptimal()) {
        doIteration(tableau);
    }
        if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0, epsilon)) {
        throw new NoFeasibleSolutionException();
    }
}",-0.13636363636363635,-0.17857142857142863,0.16666666666666666,-0.5,0.3333333333333333,-0.08996539792387542,0.1901347863492973,0.0,0.05714285714285714,-0.10003811873343013
wicket,remotes/origin/bugs-dot-jar_WICKET-5071_d3d42d42,1,"/**
 *  Matches when the request url starts with
 *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}
 *  or when the base url starts with
 *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}
 *  and the request url with {@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}
 *
 *  @param request
 *       the request to check
 *  @return {@code true} if the conditions match
 */
private boolean matches(final Request request) {
    boolean matches = false;
    Url url = request.getUrl();
    String namespace = getContext().getNamespace();
    String pageIdentifier = getContext().getPageIdentifier();
    if (urlStartsWith(url, namespace, pageIdentifier)) {
        matches = true;
    } else if (urlStartsWith(request.getClientUrl(), namespace, pageIdentifier) && urlStartsWith(url, pageIdentifier)) {
        matches = true;
    } else if (urlStartsWith(request.getClientUrl(), pageIdentifier) && urlStartsWith(url, pageIdentifier)) {
        matches = true;
    }
    return matches;
}","/**
 *  Matches when the request url starts with
 *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}
 *  or when the base url starts with
 *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}
 *  and the request url with {@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}
 *
 *  @param request
 *       the request to check
 *  @return {@code true} if the conditions match
 */
","private boolean matches(final Request request) {
    boolean matches = false;
    Url url = request.getUrl();
    String namespace = getContext().getNamespace();
    String pageIdentifier = getContext().getPageIdentifier();
    if (urlStartsWith(url, namespace, pageIdentifier)) {
        matches = true;
    } else if (urlStartsWith(request.getClientUrl(), namespace, pageIdentifier) && urlStartsWith(url, pageIdentifier)) {
        matches = true;
    } else if (urlStartsWith(request.getClientUrl(), pageIdentifier) && urlStartsWith(url, pageIdentifier)) {
        matches = true;
    }
    return matches;
}",0.0,-0.33163265306122447,0.0,0.5,0.6666666666666666,0.13148788927335642,-0.03297963865787227,0.5,-0.028571428571428574,0.0853516988534399
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1933_2e16a983,1,"/**
 * The estimated number of entries. This value does not have to be
 * accurate.
 *
 * @return the estimated number of entries
 */
long getEstimatedEntryCount();","/**
 * The estimated number of entries. This value does not have to be
 * accurate.
 *
 * @return the estimated number of entries
 */
",long getEstimatedEntryCount();,-0.5909090909090909,-1.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.9174075136220248,-0.5,2.8285714285714287,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-4505_a4caaa57,1,"@Override
public final Object put(String key, Object value) {
    return super.put(key, unescapeHtml(value));
}",,"@Override
public final Object put(String key, Object value) {
    return super.put(key, unescapeHtml(value));
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8422712933753946,-0.3333333333333333,0.39999999999999997,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-428_d906576c,3,"public Iterator iterator() {
    return new Iterator() {

        public boolean hasNext() {
            return index < MicroMap.this.size();
        }

        public Object next() {
            index++;
            return key;
        }

        public void remove() {
            MicroMap.this.clear();
        }

        int index;
    };
}",,"public Iterator iterator() {
    return new Iterator() {

        public boolean hasNext() {
            return index < MicroMap.this.size();
        }

        public Object next() {
            index++;
            return key;
        }

        public void remove() {
            MicroMap.this.clear();
        }

        int index;
    };
}",0.045454545454545456,0.413265306122449,-0.5,-0.5,-0.4166666666666667,-0.11764705882352938,0.1322053340980786,-0.3333333333333333,2.342857142857143,-0.12508940770341057
wicket,remotes/origin/bugs-dot-jar_WICKET-5345_3fc7234e,1,"/**
 *  Try to reduce url by eliminating '..' and '.' from the path where appropriate (this is
 *  somehow similar to {@link java.io.File#getCanonicalPath()}). Either by different / unexpected
 *  browser behavior or by malicious attacks it can happen that these kind of redundant urls are
 *  processed by wicket. These urls can cause some trouble when mapping the request.
 *  <p/>
 *  <strong>example:</strong>
 *
 *  the url
 *
 *  <pre>
 *  /example/..;jsessionid=234792?0
 *  </pre>
 *
 *  will not get normalized by the browser due to the ';jsessionid' string that gets appended by
 *  the servlet container. After wicket strips the jsessionid part the resulting internal url
 *  will be
 *
 *  <pre>
 *  /example/..
 *  </pre>
 *
 *  instead of
 *
 *  <pre>
 *  /
 *  </pre>
 *
 *  <p/>
 *
 *  This code correlates to <a
 *  href=""https://issues.apache.org/jira/browse/WICKET-4303"">WICKET-4303</a>
 *
 *  @return canonical url
 */
public Url canonical() {
    Url url = new Url(this);
    url.segments.clear();
    for (int i = 0; i < segments.size(); i++) {
        final String segment = segments.get(i);
        // drop '.' from path
        if (""."".equals(segment)) {
            continue;
        }
        // skip segment if following segment is a '..'
        if ((i + 1) < segments.size() && "".."".equals(segments.get(i + 1))) {
            i++;
            continue;
        }
        url.segments.add(segment);
    }
    return url;
}","/**
 *  Try to reduce url by eliminating '..' and '.' from the path where appropriate (this is
 *  somehow similar to {@link java.io.File#getCanonicalPath()}). Either by different / unexpected
 *  browser behavior or by malicious attacks it can happen that these kind of redundant urls are
 *  processed by wicket. These urls can cause some trouble when mapping the request.
 *  <p/>
 *  <strong>example:</strong>
 *
 *  the url
 *
 *  <pre>
 *  /example/..;jsessionid=234792?0
 *  </pre>
 *
 *  will not get normalized by the browser due to the ';jsessionid' string that gets appended by
 *  the servlet container. After wicket strips the jsessionid part the resulting internal url
 *  will be
 *
 *  <pre>
 *  /example/..
 *  </pre>
 *
 *  instead of
 *
 *  <pre>
 *  /
 *  </pre>
 *
 *  <p/>
 *
 *  This code correlates to <a
 *  href=""https://issues.apache.org/jira/browse/WICKET-4303"">WICKET-4303</a>
 *
 *  @return canonical url
 */
","public Url canonical() {
    Url url = new Url(this);
    url.segments.clear();
    for (int i = 0; i < segments.size(); i++) {
        final String segment = segments.get(i);
                if (""."".equals(segment)) {
            continue;
        }
                if ((i + 1) < segments.size() && "".."".equals(segments.get(i + 1))) {
            i++;
            continue;
        }
        url.segments.add(segment);
    }
    return url;
}",0.09090909090909091,0.3520408163265306,0.3333333333333333,0.0,0.4166666666666667,0.5269401878398419,-0.10381416690564972,0.16666666666666666,0.05714285714285714,0.26518217756476975
commons-math,remotes/origin/bugs-dot-jar_MATH-657_97b440fc,3,"/**
 * Returns a {@code Complex} whose value is {@code (this / divisor)},
 * with {@code divisor} interpreted as a real number.
 *
 * @param  divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @see #divide(Complex)
 */
public Complex divide(double divisor) {
    if (isNaN || Double.isNaN(divisor)) {
        return NaN;
    }
    if (divisor == 0d) {
        return isZero ? NaN : INF;
    }
    if (Double.isInfinite(divisor)) {
        return !isInfinite() ? ZERO : NaN;
    }
    return createComplex(real / divisor, imaginary / divisor);
}","/**
 * Returns a {@code Complex} whose value is {@code (this / divisor)},
 * with {@code divisor} interpreted as a real number.
 *
 * @param  divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @see #divide(Complex)
 */
","public Complex divide(double divisor) {
    if (isNaN || Double.isNaN(divisor)) {
        return NaN;
    }
    if (divisor == 0d) {
        return isZero ? NaN : INF;
    }
    if (Double.isInfinite(divisor)) {
        return !isInfinite() ? ZERO : NaN;
    }
    return createComplex(real / divisor, imaginary / divisor);
}",-0.09090909090909091,-0.2346938775510204,0.3333333333333333,-0.5,0.5833333333333334,0.2778052397429561,0.11041009463722384,-0.16666666666666666,0.3428571428571429,0.017710220531863417
wicket,remotes/origin/bugs-dot-jar_WICKET-5359_61122bab,3,"/**
 *  Convert to duration, returning default value if text is inconvertible.
 *
 *  @param defaultValue
 *             the default value
 *  @return the converted text as a duration or the default value if text is empty or inconvertible
 *  @see Duration#valueOf(String, java.util.Locale)
 */
public final Duration toDuration(final Duration defaultValue) {
    if (text != null) {
        try {
            return toDuration();
        } catch (Exception x) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(String.format(""An error occurred while converting '%s' to a Duration: %s"", text, x.getMessage()), x);
            }
        }
    }
    return defaultValue;
}","/**
 *  Convert to duration, returning default value if text is inconvertible.
 *
 *  @param defaultValue
 *             the default value
 *  @return the converted text as a duration or the default value if text is empty or inconvertible
 *  @see Duration#valueOf(String, java.util.Locale)
 */
","public final Duration toDuration(final Duration defaultValue) {
    if (text != null) {
        try {
            return toDuration();
        } catch (Exception x) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(String.format(""An error occurred while converting '%s' to a Duration: %s"", text, x.getMessage()), x);
            }
        }
    }
    return defaultValue;
}",-0.09090909090909091,0.933673469387755,0.0,0.5,-0.08333333333333333,-0.3806228373702422,0.17206767995411534,-0.08333333333333333,0.7714285714285716,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-924_2836a6f9,0,"/**
 * Computes the square-root of the weight matrix.
 *
 * @param m Symmetric, positive-definite (weight) matrix.
 * @return the square-root of the weight matrix.
 */
private RealMatrix squareRoot(RealMatrix m) {
    final EigenDecomposition dec = new EigenDecomposition(m);
    return dec.getSquareRoot();
}","/**
 * Computes the square-root of the weight matrix.
 *
 * @param m Symmetric, positive-definite (weight) matrix.
 * @return the square-root of the weight matrix.
 */
","private RealMatrix squareRoot(RealMatrix m) {
    final EigenDecomposition dec = new EigenDecomposition(m);
    return dec.getSquareRoot();
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8422712933753946,-0.4166666666666667,2.7714285714285714,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-5783_7b8b6767,1,"@Override
protected void updateAjaxAttributes(AjaxRequestAttributes attributes) {
    super.updateAjaxAttributes(attributes);
    attributes.setEventNames(event);
}",,"@Override
protected void updateAjaxAttributes(AjaxRequestAttributes attributes) {
    super.updateAjaxAttributes(attributes);
    attributes.setEventNames(event);
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7757384571264698,-0.3333333333333333,0.4857142857142857,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-5565_204849bc,1,"/**
 *  @see IRequestMapper#getCompatibilityScore(Request)
 */
@Override
public abstract int getCompatibilityScore(Request request);","/**
 *  @see IRequestMapper#getCompatibilityScore(Request)
 */
","@Override
public abstract int getCompatibilityScore(Request request);",-0.5454545454545454,-1.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.332950960711213,-0.5,2.8285714285714287,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3433_b76b31f7,0,void acquiring();,,void acquiring();,-0.5909090909090909,-1.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.9174075136220248,-0.5,2.428571428571429,-0.16422749602751402
Closure,144,2,"/**
 * Builds the function type, and puts it in the registry.
 */
FunctionType buildAndRegister() {
    if (returnType == null) {
        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);
    }
    if (parametersNode == null) {
        throw new IllegalStateException(""All Function types must have params and a return type"");
    }
    FunctionType fnType;
    if (isConstructor) {
        fnType = getOrCreateConstructor();
    } else if (isInterface) {
        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);
        if (scope.isGlobal() && !fnName.isEmpty()) {
            typeRegistry.declareType(fnName, fnType.getInstanceType());
        }
        maybeSetBaseType(fnType);
    } else {
        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();
        maybeSetBaseType(fnType);
    }
    if (implementedInterfaces != null) {
        fnType.setImplementedInterfaces(implementedInterfaces);
    }
    typeRegistry.clearTemplateTypeName();
    return fnType;
}","/**
 * Builds the function type, and puts it in the registry.
 */
","FunctionType buildAndRegister() {
    if (returnType == null) {
        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);
    }
    if (parametersNode == null) {
        throw new IllegalStateException(""All Function types must have params and a return type"");
    }
    FunctionType fnType;
    if (isConstructor) {
        fnType = getOrCreateConstructor();
    } else if (isInterface) {
        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);
        if (scope.isGlobal() && !fnName.isEmpty()) {
            typeRegistry.declareType(fnName, fnType.getInstanceType());
        }
        maybeSetBaseType(fnType);
    } else {
        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();
        maybeSetBaseType(fnType);
    }
    if (implementedInterfaces != null) {
        fnType.setImplementedInterfaces(implementedInterfaces);
    }
    typeRegistry.clearTemplateTypeName();
    return fnType;
}",0.5454545454545454,-0.1479591836734694,0.6666666666666666,0.5,0.75,0.2718734552644588,-0.4241468310868945,1.0,-0.028571428571428574,0.368839434472184
flink,remotes/origin/bugs-dot-jar_FLINK-1496_0a4c7694,1,"public void updateInputChannel(PartitionInfo partitionInfo) throws IOException {
    synchronized (requestLock) {
        if (isReleased) {
            // There was a race with a task failure/cancel
            return;
        }
        final IntermediateResultPartitionID partitionId = partitionInfo.getPartitionId();
        InputChannel current = inputChannels.get(partitionId);
        if (current.getClass() == UnknownInputChannel.class) {
            UnknownInputChannel unknownChannel = (UnknownInputChannel) current;
            InputChannel newChannel;
            if (partitionInfo.getProducerLocation() == PartitionLocation.REMOTE) {
                newChannel = unknownChannel.toRemoteInputChannel(partitionInfo.getProducerAddress());
            } else if (partitionInfo.getProducerLocation() == PartitionLocation.LOCAL) {
                newChannel = unknownChannel.toLocalInputChannel();
            } else {
                throw new IllegalStateException(""Tried to update unknown channel with unknown channel."");
            }
            inputChannels.put(partitionId, newChannel);
            newChannel.requestIntermediateResultPartition(queueToRequest);
        }
    }
}",,"public void updateInputChannel(PartitionInfo partitionInfo) throws IOException {
    synchronized (requestLock) {
        if (isReleased) {
                        return;
        }
        final IntermediateResultPartitionID partitionId = partitionInfo.getPartitionId();
        InputChannel current = inputChannels.get(partitionId);
        if (current.getClass() == UnknownInputChannel.class) {
            UnknownInputChannel unknownChannel = (UnknownInputChannel) current;
            InputChannel newChannel;
            if (partitionInfo.getProducerLocation() == PartitionLocation.REMOTE) {
                newChannel = unknownChannel.toRemoteInputChannel(partitionInfo.getProducerAddress());
            } else if (partitionInfo.getProducerLocation() == PartitionLocation.LOCAL) {
                newChannel = unknownChannel.toLocalInputChannel();
            } else {
                throw new IllegalStateException(""Tried to update unknown channel with unknown channel."");
            }
            inputChannels.put(partitionId, newChannel);
            newChannel.requestIntermediateResultPartition(queueToRequest);
        }
    }
}",0.36363636363636365,0.7346938775510204,0.3333333333333333,1.0,0.16666666666666666,-0.05042016806722688,-0.293948953254947,0.3333333333333333,-0.028571428571428574,0.0427829245206248
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-3634_9339ecf8,3,"private int updateAuthKeys(String path) throws KeeperException, InterruptedException {
    int keysAdded = 0;
    for (String child : zk.getChildren(path, this)) {
        String childPath = path + ""/"" + child;
        // Get the node data and reset the watcher
        AuthenticationKey key = deserializeKey(zk.getData(childPath, this, null));
        secretManager.addKey(key);
        keysAdded++;
    }
    return keysAdded;
}",,"private int updateAuthKeys(String path) throws KeeperException, InterruptedException {
    int keysAdded = 0;
    for (String child : zk.getChildren(path, this)) {
        String childPath = path + ""/"" + child;
                AuthenticationKey key = deserializeKey(zk.getData(childPath, this, null));
        secretManager.addKey(key);
        keysAdded++;
    }
    return keysAdded;
}",-0.18181818181818182,-0.015306122448979493,-0.3333333333333333,-0.5,-0.4166666666666667,-0.08403361344537813,0.18898766848293677,-0.16666666666666666,0.37142857142857144,-0.06251043982165572
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2603_77d2d3b0,1,"private void collectDeletedDocuments(VersionGCStats stats, Revision headRevision, long oldestRevTimeStamp) {
    List<String> docIdsToDelete = new ArrayList<String>();
    Iterable<NodeDocument> itr = versionStore.getPossiblyDeletedDocs(oldestRevTimeStamp);
    try {
        for (NodeDocument doc : itr) {
            // So deleting it is safe
            if (doc.getNodeAtRevision(nodeStore, headRevision, null) == null) {
                docIdsToDelete.add(doc.getId());
                // Collect id of all previous docs also
                for (NodeDocument prevDoc : ImmutableList.copyOf(doc.getAllPreviousDocs())) {
                    docIdsToDelete.add(prevDoc.getId());
                }
            }
        }
    } finally {
        Utils.closeIfCloseable(itr);
    }
    if (log.isDebugEnabled()) {
        StringBuilder sb = new StringBuilder(""Deleted document with following ids were deleted as part of GC \n"");
        Joiner.on(StandardSystemProperty.LINE_SEPARATOR.value()).appendTo(sb, docIdsToDelete);
        log.debug(sb.toString());
    }
    nodeStore.getDocumentStore().remove(Collection.NODES, docIdsToDelete);
    nodeStore.invalidateDocChildrenCache();
    stats.deletedDocGCCount += docIdsToDelete.size();
}",,"private void collectDeletedDocuments(VersionGCStats stats, Revision headRevision, long oldestRevTimeStamp) {
    List<String> docIdsToDelete = new ArrayList<String>();
    Iterable<NodeDocument> itr = versionStore.getPossiblyDeletedDocs(oldestRevTimeStamp);
    try {
        for (NodeDocument doc : itr) {
                        if (doc.getNodeAtRevision(nodeStore, headRevision, null) == null) {
                docIdsToDelete.add(doc.getId());
                                for (NodeDocument prevDoc : ImmutableList.copyOf(doc.getAllPreviousDocs())) {
                    docIdsToDelete.add(prevDoc.getId());
                }
            }
        }
    } finally {
        Utils.closeIfCloseable(itr);
    }
    if (log.isDebugEnabled()) {
        StringBuilder sb = new StringBuilder(""Deleted document with following ids were deleted as part of GC \n"");
        Joiner.on(StandardSystemProperty.LINE_SEPARATOR.value()).appendTo(sb, docIdsToDelete);
        log.debug(sb.toString());
    }
    nodeStore.getDocumentStore().remove(Collection.NODES, docIdsToDelete);
    nodeStore.invalidateDocChildrenCache();
    stats.deletedDocGCCount += docIdsToDelete.size();
}",0.45454545454545453,1.1122448979591837,0.16666666666666666,1.0,0.08333333333333333,-0.07612456747404842,-0.3926010897619731,1.0833333333333333,-0.028571428571428574,0.1316638184691688
wicket,remotes/origin/bugs-dot-jar_WICKET-4102_e743fd7e,1,"@Override
public void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag) {
    boolean storeLabelText = false;
    // try and find some form of label content...
    String labelText = null;
    if (labeled instanceof ILabelProvider) {
        ILabelProvider<String> provider = (ILabelProvider<String>) labeled;
        if (provider.getLabel() != null) {
            String text = provider.getLabel().getObject();
            if (!Strings.isEmpty(text)) {
                labelText = text;
            }
        }
    }
    if (labelText == null && labeled instanceof FormComponent) {
        String text = ((FormComponent<?>) labeled).getDefaultLabel(""wicket:unknown"");
        if (!""wicket:unknown"".equals(text) && !Strings.isEmpty(text)) {
            labelText = text;
        }
    }
    // check if wicket:label tag has a message key
    if (labelText == null && openTag.getAttribute(""key"") != null) {
        String text = labeled.getString(openTag.getAttribute(""key""));
        if (!Strings.isEmpty(text)) {
            labelText = text;
            storeLabelText = true;
        }
    }
    // as last resort use the tag body
    if (labelText == null) {
        String text = new ResponseBufferZone(RequestCycle.get(), markupStream) {

            @Override
            protected void executeInsideBufferedZone() {
                TextLabel.super.onComponentTagBody(markupStream, openTag);
            }
        }.execute().toString();
        if (!Strings.isEmpty(text)) {
            labelText = text;
            storeLabelText = true;
        }
    }
    // print the label text
    replaceComponentTagBody(markupStream, openTag, labelText);
    // store the label text in FormComponent's label model so its available to errors
    if (labeled instanceof FormComponent) {
        FormComponent<?> fc = (FormComponent<?>) labeled;
        fc.setLabel(Model.of(labelText));
    }
}",,"@Override
public void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag) {
    boolean storeLabelText = false;
        String labelText = null;
    if (labeled instanceof ILabelProvider) {
        ILabelProvider<String> provider = (ILabelProvider<String>) labeled;
        if (provider.getLabel() != null) {
            String text = provider.getLabel().getObject();
            if (!Strings.isEmpty(text)) {
                labelText = text;
            }
        }
    }
    if (labelText == null && labeled instanceof FormComponent) {
        String text = ((FormComponent<?>) labeled).getDefaultLabel(""wicket:unknown"");
        if (!""wicket:unknown"".equals(text) && !Strings.isEmpty(text)) {
            labelText = text;
        }
    }
        if (labelText == null && openTag.getAttribute(""key"") != null) {
        String text = labeled.getString(openTag.getAttribute(""key""));
        if (!Strings.isEmpty(text)) {
            labelText = text;
            storeLabelText = true;
        }
    }
        if (labelText == null) {
        String text = new ResponseBufferZone(RequestCycle.get(), markupStream) {

            @Override
            protected void executeInsideBufferedZone() {
                TextLabel.super.onComponentTagBody(markupStream, openTag);
            }
        }.execute().toString();
        if (!Strings.isEmpty(text)) {
            labelText = text;
            storeLabelText = true;
        }
    }
        replaceComponentTagBody(markupStream, openTag, labelText);
        if (labeled instanceof FormComponent) {
        FormComponent<?> fc = (FormComponent<?>) labeled;
        fc.setLabel(Model.of(labelText));
    }
}",1.3636363636363635,0.4897959183673469,1.1666666666666667,0.5,1.25,0.6969846762234307,-0.7900774304559794,1.0833333333333333,-0.028571428571428574,1.5791948809539107
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-3475_7651b777,1,"public int start() throws IOException {
    if (configError)
        return 1;
    String input;
    if (isVerbose())
        printInfo();
    if (execFile != null) {
        java.util.Scanner scanner = new java.util.Scanner(new File(execFile), UTF_8.name());
        try {
            while (scanner.hasNextLine() && !hasExited()) {
                execCommand(scanner.nextLine(), true, isVerbose());
            }
        } finally {
            scanner.close();
        }
    } else if (execCommand != null) {
        for (String command : execCommand.split(""\n"")) {
            execCommand(command, true, isVerbose());
        }
        return exitCode;
    }
    while (true) {
        if (hasExited())
            return exitCode;
        reader.setDefaultPrompt(getDefaultPrompt());
        input = reader.readLine();
        if (input == null) {
            reader.printNewline();
            return exitCode;
        }
        // user canceled
        execCommand(input, false, false);
    }
}",,"public int start() throws IOException {
    if (configError)
        return 1;
    String input;
    if (isVerbose())
        printInfo();
    if (execFile != null) {
        java.util.Scanner scanner = new java.util.Scanner(new File(execFile), UTF_8.name());
        try {
            while (scanner.hasNextLine() && !hasExited()) {
                execCommand(scanner.nextLine(), true, isVerbose());
            }
        } finally {
            scanner.close();
        }
    } else if (execCommand != null) {
        for (String command : execCommand.split(""\n"")) {
            execCommand(command, true, isVerbose());
        }
        return exitCode;
    }
    while (true) {
        if (hasExited())
            return exitCode;
        reader.setDefaultPrompt(getDefaultPrompt());
        input = reader.readLine();
        if (input == null) {
            reader.printNewline();
            return exitCode;
        }
                execCommand(input, false, false);
    }
}",0.8636363636363636,0.2959183673469388,1.0,0.5,0.9166666666666666,0.34107760751359373,-0.5428735302552341,1.0,-0.028571428571428574,0.4054377015688642
wicket,remotes/origin/bugs-dot-jar_WICKET-5505_6cceff44,3,"@Override
public Property resolveProperty(FormComponent<?> component) {
    IModel<?> model = component.getModel();
    while (true) {
        if (model == null) {
            return null;
        }
        if (model instanceof IPropertyReflectionAwareModel) {
            break;
        }
        if (model instanceof IWrapModel<?>) {
            model = ((IWrapModel<?>) model).getWrappedModel();
            continue;
        }
        return null;
    }
    IPropertyReflectionAwareModel<?> delegate = (IPropertyReflectionAwareModel<?>) model;
    Field field = delegate.getPropertyField();
    if (field != null) {
        return new Property(field.getDeclaringClass(), field.getName());
    }
    Method getter = delegate.getPropertyGetter();
    if (getter != null) {
        String name = getter.getName().substring(3, 4).toLowerCase() + getter.getName().substring(4);
        return new Property(getter.getDeclaringClass(), name);
    }
    return null;
}",,"@Override
public Property resolveProperty(FormComponent<?> component) {
    IModel<?> model = component.getModel();
    while (true) {
        if (model == null) {
            return null;
        }
        if (model instanceof IPropertyReflectionAwareModel) {
            break;
        }
        if (model instanceof IWrapModel<?>) {
            model = ((IWrapModel<?>) model).getWrappedModel();
            continue;
        }
        return null;
    }
    IPropertyReflectionAwareModel<?> delegate = (IPropertyReflectionAwareModel<?>) model;
    Field field = delegate.getPropertyField();
    if (field != null) {
        return new Property(field.getDeclaringClass(), field.getName());
    }
    Method getter = delegate.getPropertyGetter();
    if (getter != null) {
        String name = getter.getName().substring(3, 4).toLowerCase() + getter.getName().substring(4);
        return new Property(getter.getDeclaringClass(), name);
    }
    return null;
}",0.6363636363636364,0.22448979591836732,0.8333333333333334,0.0,0.3333333333333333,0.4518042511122097,-0.45712646974476634,0.5,-0.028571428571428574,0.48109696292203646
Codec,9,3,"/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @param maxResultSize
 *            The maximum result size to accept.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than maxResultSize
 * @since 1.4
 */
public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
    if (binaryData == null || binaryData.length == 0) {
        return binaryData;
    }
    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
    if (len > maxResultSize) {
        throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" + len + "") than the specified maxium size of "" + maxResultSize);
    }
    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
    return b64.encode(binaryData);
}","/**
 * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
 *
 * @param binaryData
 *            Array containing binary data to encode.
 * @param isChunked
 *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
 * @param urlSafe
 *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.
 * @param maxResultSize
 *            The maximum result size to accept.
 * @return Base64-encoded data.
 * @throws IllegalArgumentException
 *             Thrown when the input array needs an output array bigger than maxResultSize
 * @since 1.4
 */
","public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
    if (binaryData == null || binaryData.length == 0) {
        return binaryData;
    }
    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
    if (len > maxResultSize) {
        throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" + len + "") than the specified maxium size of "" + maxResultSize);
    }
    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
    return b64.encode(binaryData);
}",-0.13636363636363635,-0.3112244897959183,0.16666666666666666,-0.5,0.3333333333333333,0.36875926841324774,0.09234298824204186,-0.3333333333333333,0.2285714285714286,0.1557599976015179
wicket,remotes/origin/bugs-dot-jar_WICKET-2033_420ac965,3,"/**
 *  @see org.apache.wicket.behavior.AbstractAjaxBehavior#onComponentTag(org.apache.wicket.markup.ComponentTag)
 */
@Override
protected void onComponentTag(final ComponentTag tag) {
    super.onComponentTag(tag);
    // only add the event handler when the component is enabled.
    Component myComponent = getComponent();
    if (myComponent.isEnabledInHierarchy()) {
        tag.put(event, getEventHandler());
    }
}","/**
 *  @see org.apache.wicket.behavior.AbstractAjaxBehavior#onComponentTag(org.apache.wicket.markup.ComponentTag)
 */
","@Override
protected void onComponentTag(final ComponentTag tag) {
    super.onComponentTag(tag);
        Component myComponent = getComponent();
    if (myComponent.isEnabledInHierarchy()) {
        tag.put(event, getEventHandler());
    }
}",-0.2727272727272727,-0.1887755102040817,-0.3333333333333333,-0.5,-0.25,-0.3806228373702422,0.43045597935187824,-0.08333333333333333,1.1428571428571428,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-926_e1ae968c,1,"@Override
@Nonnull
protected Map<?, ?> transformAndSeal(@Nonnull Map<Object, Object> map, @Nullable String key, int level) {
    if (level == 1) {
        if (PREVIOUS.equals(key)) {
            SortedMap<Revision, Range> transformed = new TreeMap<Revision, Range>(new Comparator<Revision>() {

                @Override
                public int compare(Revision o1, Revision o2) {
                    // in reverse order!
                    int c = o2.compareRevisionTime(o1);
                    if (c == 0) {
                        c = o1.getClusterId() < o2.getClusterId() ? -1 : (o1.getClusterId() == o2.getClusterId() ? 0 : 1);
                    }
                    return c;
                }
            });
            for (Map.Entry<Object, Object> entry : map.entrySet()) {
                Revision high = Revision.fromString(entry.getKey().toString());
                Revision low = Revision.fromString(entry.getValue().toString());
                transformed.put(high, new Range(high, low));
            }
            return Collections.unmodifiableSortedMap(transformed);
        }
    }
    return super.transformAndSeal(map, key, level);
}",,"@Override
@Nonnull
protected Map<?, ?> transformAndSeal(@Nonnull Map<Object, Object> map, @Nullable String key, int level) {
    if (level == 1) {
        if (PREVIOUS.equals(key)) {
            SortedMap<Revision, Range> transformed = new TreeMap<Revision, Range>(new Comparator<Revision>() {

                @Override
                public int compare(Revision o1, Revision o2) {
                                        int c = o2.compareRevisionTime(o1);
                    if (c == 0) {
                        c = o1.getClusterId() < o2.getClusterId() ? -1 : (o1.getClusterId() == o2.getClusterId() ? 0 : 1);
                    }
                    return c;
                }
            });
            for (Map.Entry<Object, Object> entry : map.entrySet()) {
                Revision high = Revision.fromString(entry.getKey().toString());
                Revision low = Revision.fromString(entry.getValue().toString());
                transformed.put(high, new Range(high, low));
            }
            return Collections.unmodifiableSortedMap(transformed);
        }
    }
    return super.transformAndSeal(map, key, level);
}",0.5,2.122448979591837,0.5,1.0,0.5,0.5012357884330204,-0.448809865213651,0.8333333333333334,-0.028571428571428574,0.8415588420471045
commons-math,remotes/origin/bugs-dot-jar_MATH-880_2a9cbbab,1,"/**
 * Mark the outgoing edge as processed.
 */
public void outgoingProcessed() {
    outgoingNeedsProcessing = false;
}","/**
 * Mark the outgoing edge as processed.
 */
","public void outgoingProcessed() {
    outgoingNeedsProcessing = false;
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.144536851161457,-0.5,2.8285714285714287,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-294_5c592d85,1,"/**
 *  Checks if the specified path matches any mount, and if so returns the
 *  coding strategy for that mount. Returns null if the path doesnt match
 *  any mounts.
 *
 *  NOTE: path here is not the mount - it is the full url path
 *
 *  @param path
 *             non-null url path
 *  @return coding strategy or null
 */
public IRequestTargetUrlCodingStrategy strategyForPath(String path) {
    if (path == null) {
        throw new IllegalArgumentException(""Argument [[path]] cannot be null"");
    }
    if (caseSensitiveMounts == false) {
        path = path.toLowerCase();
    }
    for (final Iterator it = map.entrySet().iterator(); it.hasNext(); ) {
        final Map.Entry entry = (Entry) it.next();
        final String key = (String) entry.getKey();
        if (path.startsWith(key)) {
            return (IRequestTargetUrlCodingStrategy) entry.getValue();
        }
    }
    return null;
}","/**
 *  Checks if the specified path matches any mount, and if so returns the
 *  coding strategy for that mount. Returns null if the path doesnt match
 *  any mounts.
 *
 *  NOTE: path here is not the mount - it is the full url path
 *
 *  @param path
 *             non-null url path
 *  @return coding strategy or null
 */
","public IRequestTargetUrlCodingStrategy strategyForPath(String path) {
    if (path == null) {
        throw new IllegalArgumentException(""Argument [[path]] cannot be null"");
    }
    if (caseSensitiveMounts == false) {
        path = path.toLowerCase();
    }
    for (final Iterator it = map.entrySet().iterator(); it.hasNext(); ) {
        final Map.Entry entry = (Entry) it.next();
        final String key = (String) entry.getKey();
        if (path.startsWith(key)) {
            return (IRequestTargetUrlCodingStrategy) entry.getValue();
        }
    }
    return null;
}",0.09090909090909091,0.051020408163265356,0.3333333333333333,0.0,0.3333333333333333,-0.07217004448838356,-0.10065959277315761,0.16666666666666666,0.0,-0.02126511364950466
commons-math,remotes/origin/bugs-dot-jar_MATH-434_133cbc2d,1,"/**
 * Create the tableau by itself.
 * @param maximize if true, goal is to maximize the objective function
 * @return created tableau
 */
protected RealMatrix createTableau(final boolean maximize) {
    // create a matrix of the correct size
    int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() + // + 1 is for RHS
    1;
    int height = constraints.size() + getNumObjectiveFunctions();
    Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width);
    // initialize the objective function rows
    if (getNumObjectiveFunctions() == 2) {
        matrix.setEntry(0, 0, -1);
    }
    int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;
    matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1);
    RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();
    copyArray(objectiveCoefficients.getData(), matrix.getDataRef()[zIndex]);
    matrix.setEntry(zIndex, width - 1, maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());
    if (!restrictToNonNegative) {
        matrix.setEntry(zIndex, getSlackVariableOffset() - 1, getInvertedCoeffiecientSum(objectiveCoefficients));
    }
    // initialize the constraint rows
    int slackVar = 0;
    int artificialVar = 0;
    for (int i = 0; i < constraints.size(); i++) {
        LinearConstraint constraint = constraints.get(i);
        int row = getNumObjectiveFunctions() + i;
        // decision variable coefficients
        copyArray(constraint.getCoefficients().getData(), matrix.getDataRef()[row]);
        // x-
        if (!restrictToNonNegative) {
            matrix.setEntry(row, getSlackVariableOffset() - 1, getInvertedCoeffiecientSum(constraint.getCoefficients()));
        }
        // RHS
        matrix.setEntry(row, width - 1, constraint.getValue());
        // slack variables
        if (constraint.getRelationship() == Relationship.LEQ) {
            // slack
            matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);
        } else if (constraint.getRelationship() == Relationship.GEQ) {
            // excess
            matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1);
        }
        // artificial variables
        if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) {
            matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);
            matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);
            matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row)));
        }
    }
    return matrix;
}","/**
 * Create the tableau by itself.
 * @param maximize if true, goal is to maximize the objective function
 * @return created tableau
 */
","protected RealMatrix createTableau(final boolean maximize) {
        int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() +     1;
    int height = constraints.size() + getNumObjectiveFunctions();
    Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width);
        if (getNumObjectiveFunctions() == 2) {
        matrix.setEntry(0, 0, -1);
    }
    int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;
    matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1);
    RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();
    copyArray(objectiveCoefficients.getData(), matrix.getDataRef()[zIndex]);
    matrix.setEntry(zIndex, width - 1, maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());
    if (!restrictToNonNegative) {
        matrix.setEntry(zIndex, getSlackVariableOffset() - 1, getInvertedCoeffiecientSum(objectiveCoefficients));
    }
        int slackVar = 0;
    int artificialVar = 0;
    for (int i = 0; i < constraints.size(); i++) {
        LinearConstraint constraint = constraints.get(i);
        int row = getNumObjectiveFunctions() + i;
                copyArray(constraint.getCoefficients().getData(), matrix.getDataRef()[row]);
                if (!restrictToNonNegative) {
            matrix.setEntry(row, getSlackVariableOffset() - 1, getInvertedCoeffiecientSum(constraint.getCoefficients()));
        }
                matrix.setEntry(row, width - 1, constraint.getValue());
                if (constraint.getRelationship() == Relationship.LEQ) {
                        matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);
        } else if (constraint.getRelationship() == Relationship.GEQ) {
                        matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1);
        }
                if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) {
            matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);
            matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);
            matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row)));
        }
    }
    return matrix;
}",1.1363636363636365,0.10714285714285712,1.3333333333333333,0.5,1.0833333333333333,2.322293623331686,-0.8107255520504733,3.5,-0.028571428571428574,6.834975865273834
wicket,remotes/origin/bugs-dot-jar_WICKET-4379_7a162f77,3,"/**
 *  @see org.apache.wicket.resource.loader.ComponentStringResourceLoader#loadStringResource(org.apache.wicket.Component,
 *       java.lang.String, java.util.Locale, java.lang.String, java.lang.String)
 */
@Override
public String loadStringResource(final Component component, final String key, final Locale locale, final String style, final String variation) {
    if (component == null || !(component instanceof FormComponent)) {
        return null;
    }
    FormComponent<?> fc = (FormComponent<?>) component;
    for (IValidator<?> validator : fc.getValidators()) {
        String resource = loadStringResource(validator.getClass(), key, locale, style, variation);
        if (resource != null) {
            return resource;
        }
    }
    // not found
    return null;
}","/**
 *  @see org.apache.wicket.resource.loader.ComponentStringResourceLoader#loadStringResource(org.apache.wicket.Component,
 *       java.lang.String, java.util.Locale, java.lang.String, java.lang.String)
 */
","@Override
public String loadStringResource(final Component component, final String key, final Locale locale, final String style, final String variation) {
    if (component == null || !(component instanceof FormComponent)) {
        return null;
    }
    FormComponent<?> fc = (FormComponent<?>) component;
    for (IValidator<?> validator : fc.getValidators()) {
        String resource = loadStringResource(validator.getClass(), key, locale, style, variation);
        if (resource != null) {
            return resource;
        }
    }
        return null;
}",0.0,0.21428571428571425,0.0,0.0,0.0,0.4518042511122097,-0.023229136793805637,-0.25,-0.028571428571428574,0.21611608653380787
Compress,7,1,"/**
 * Parse an entry name from a buffer.
 * Parsing stops when a NUL is found
 * or the buffer length is reached.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The entry name.
 */
public static String parseName(byte[] buffer, final int offset, final int length) {
    StringBuffer result = new StringBuffer(length);
    int end = offset + length;
    for (int i = offset; i < end; ++i) {
        if (buffer[i] == 0) {
            break;
        }
        result.append((char) buffer[i]);
    }
    return result.toString();
}","/**
 * Parse an entry name from a buffer.
 * Parsing stops when a NUL is found
 * or the buffer length is reached.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The entry name.
 */
","public static String parseName(byte[] buffer, final int offset, final int length) {
    StringBuffer result = new StringBuffer(length);
    int end = offset + length;
    for (int i = offset; i < end; ++i) {
        if (buffer[i] == 0) {
            break;
        }
        result.append((char) buffer[i]);
    }
    return result.toString();
}",-0.13636363636363635,0.2193877551020409,0.0,0.0,-0.08333333333333333,0.4399406821552152,0.14797820476053908,-0.3333333333333333,0.6285714285714287,0.08800716118228034
wicket,remotes/origin/bugs-dot-jar_WICKET-4138_7c89598a,1,"@Override
public boolean shouldPreserveClientUrl() {
    return errorAttributes != null && !Strings.isEmpty(errorAttributes.getRequestUri());
}",,"@Override
public boolean shouldPreserveClientUrl() {
    return errorAttributes != null && !Strings.isEmpty(errorAttributes.getRequestUri());
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.15916955017301035,0.8210496128477202,-0.3333333333333333,1.5428571428571431,-0.14422586848608668
commons-math,remotes/origin/bugs-dot-jar_MATH-939_49444ee6,1,"/**
 * Compute a covariance matrix from a rectangular array whose columns represent
 * covariates.
 * @param data input array (must have at least two columns and two rows)
 * @param biasCorrected determines whether or not covariance estimates are bias-corrected
 * @return covariance matrix
 * @throws MathIllegalArgumentException if the data array does not contain sufficient
 * data
 */
protected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected) throws MathIllegalArgumentException {
    return computeCovarianceMatrix(new BlockRealMatrix(data), biasCorrected);
}","/**
 * Compute a covariance matrix from a rectangular array whose columns represent
 * covariates.
 * @param data input array (must have at least two columns and two rows)
 * @param biasCorrected determines whether or not covariance estimates are bias-corrected
 * @return covariance matrix
 * @throws MathIllegalArgumentException if the data array does not contain sufficient
 * data
 */
","protected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected) throws MathIllegalArgumentException {
    return computeCovarianceMatrix(new BlockRealMatrix(data), biasCorrected);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.0129050759965588,-0.4166666666666667,2.8000000000000003,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-621_00b4b8a0,1,"@Nonnull
protected synchronized NodeBuilder getNodeBuilder() {
    if (nodeBuilder == null) {
        nodeBuilder = parent.getNodeBuilder().child(name);
    }
    return nodeBuilder;
}",,"@Nonnull
protected synchronized NodeBuilder getNodeBuilder() {
    if (nodeBuilder == null) {
        nodeBuilder = parent.getNodeBuilder().child(name);
    }
    return nodeBuilder;
}",-0.3181818181818182,-0.11224489795918377,-0.3333333333333333,-0.5,-0.25,-0.11764705882352938,0.5314023515916262,-0.3333333333333333,1.4000000000000001,-0.13656785777001126
Closure,167,2,"/**
 * @see maybeRestrictName
 */
private FlowScope maybeRestrictTwoNames(FlowScope blindScope, Node left, boolean leftIsRefineable, JSType restrictedLeftType, Node right, boolean rightIsRefineable, JSType restrictedRightType) {
    boolean shouldRefineLeft = leftIsRefineable && restrictedLeftType != null;
    boolean shouldRefineRight = rightIsRefineable && restrictedRightType != null;
    if (shouldRefineLeft || shouldRefineRight) {
        FlowScope informed = blindScope.createChildFlowScope();
        if (shouldRefineLeft) {
            declareNameInScope(informed, left, restrictedLeftType);
        }
        if (shouldRefineRight) {
            declareNameInScope(informed, right, restrictedRightType);
        }
        return informed;
    }
    return blindScope;
}","/**
 * @see maybeRestrictName
 */
","private FlowScope maybeRestrictTwoNames(FlowScope blindScope, Node left, boolean leftIsRefineable, JSType restrictedLeftType, Node right, boolean rightIsRefineable, JSType restrictedRightType) {
    boolean shouldRefineLeft = leftIsRefineable && restrictedLeftType != null;
    boolean shouldRefineRight = rightIsRefineable && restrictedRightType != null;
    if (shouldRefineLeft || shouldRefineRight) {
        FlowScope informed = blindScope.createChildFlowScope();
        if (shouldRefineLeft) {
            declareNameInScope(informed, left, restrictedLeftType);
        }
        if (shouldRefineRight) {
            declareNameInScope(informed, right, restrictedRightType);
        }
        return informed;
    }
    return blindScope;
}",0.045454545454545456,0.2653061224489796,0.0,0.0,0.08333333333333333,0.5210084033613446,-0.06051046745053054,-0.25,-0.028571428571428574,0.2621198298790908
wicket,remotes/origin/bugs-dot-jar_WICKET-5147_184e51e9,1,"@Override
public IRequestHandler map(Exception e) {
    try {
        Response response = RequestCycle.get().getResponse();
        if (response instanceof WebResponse) {
            // we don't wan't to cache an exceptional reply in the browser
            ((WebResponse) response).disableCaching();
        }
        return internalMap(e);
    } catch (RuntimeException e2) {
        if (logger.isDebugEnabled()) {
            logger.error(""An error occurred while handling a previous error: "" + e2.getMessage(), e2);
        }
        // hmmm, we were already handling an exception! give up
        logger.error(""unexpected exception when handling another exception: "" + e.getMessage(), e);
        return new ErrorCodeRequestHandler(500);
    }
}",,"@Override
public IRequestHandler map(Exception e) {
    try {
        Response response = RequestCycle.get().getResponse();
        if (response instanceof WebResponse) {
                        ((WebResponse) response).disableCaching();
        }
        return internalMap(e);
    } catch (RuntimeException e2) {
        if (logger.isDebugEnabled()) {
            logger.error(""An error occurred while handling a previous error: "" + e2.getMessage(), e2);
        }
                logger.error(""unexpected exception when handling another exception: "" + e.getMessage(), e);
        return new ErrorCodeRequestHandler(500);
    }
}",0.09090909090909091,0.3622448979591837,0.0,0.0,-0.08333333333333333,-0.08403361344537813,-0.06423860051620332,0.25,0.0,-0.046453458739683304
JxPath,7,1,"public Object computeValue(EvalContext context) {
    double l = InfoSetUtil.doubleValue(args[0].computeValue(context));
    double r = InfoSetUtil.doubleValue(args[1].computeValue(context));
    return l <= r ? Boolean.TRUE : Boolean.FALSE;
}",,"public Object computeValue(EvalContext context) {
    double l = InfoSetUtil.doubleValue(args[0].computeValue(context));
    double r = InfoSetUtil.doubleValue(args[1].computeValue(context));
    return l <= r ? Boolean.TRUE : Boolean.FALSE;
}",-0.4090909090909091,-0.5408163265306123,-0.3333333333333333,-1.0,-0.16666666666666666,-0.05042016806722688,0.5595067393174648,-0.16666666666666666,0.20000000000000004,-0.08252919937810786
wicket,remotes/origin/bugs-dot-jar_WICKET-3511_4a875f46,1,"/**
 *  Make a copy before returning an item from the cache as resource streams are not thread-safe.
 *
 *  @param key
 *             the cache key
 *  @return the cached File or Url resource stream
 */
private IResourceStream getCopyFromCache(Key key) {
    final IResourceStreamReference orig = cache.get(key);
    if (NullResourceStreamReference.INSTANCE == orig) {
        return null;
    }
    if (orig instanceof UrlResourceStreamReference) {
        UrlResourceStreamReference resourceStreamReference = (UrlResourceStreamReference) orig;
        String url = resourceStreamReference.getReference();
        try {
            return new UrlResourceStream(new URL(url));
        } catch (MalformedURLException e) {
            return null;
        }
    }
    if (orig instanceof FileResourceStreamReference) {
        FileResourceStreamReference resourceStreamReference = (FileResourceStreamReference) orig;
        String absolutePath = resourceStreamReference.getReference();
        return new FileResourceStream(new File(absolutePath));
    }
    return null;
}","/**
 *  Make a copy before returning an item from the cache as resource streams are not thread-safe.
 *
 *  @param key
 *             the cache key
 *  @return the cached File or Url resource stream
 */
","private IResourceStream getCopyFromCache(Key key) {
    final IResourceStreamReference orig = cache.get(key);
    if (NullResourceStreamReference.INSTANCE == orig) {
        return null;
    }
    if (orig instanceof UrlResourceStreamReference) {
        UrlResourceStreamReference resourceStreamReference = (UrlResourceStreamReference) orig;
        String url = resourceStreamReference.getReference();
        try {
            return new UrlResourceStream(new URL(url));
        } catch (MalformedURLException e) {
            return null;
        }
    }
    if (orig instanceof FileResourceStreamReference) {
        FileResourceStreamReference resourceStreamReference = (FileResourceStreamReference) orig;
        String absolutePath = resourceStreamReference.getReference();
        return new FileResourceStream(new File(absolutePath));
    }
    return null;
}",0.3181818181818182,0.08163265306122457,0.16666666666666666,0.0,-0.08333333333333333,-0.032624814631735014,-0.23601950100372832,-0.25,-0.028571428571428574,0.014986230142923839
camel,remotes/origin/bugs-dot-jar_CAMEL-3276_205420e2,3,"/**
 * Copies the results of a message exchange from the source exchange to the result exchange
 * which will copy the out and fault message contents and the exception
 *
 * @param result the result exchange which will have the output and error state added
 * @param source the source exchange which is not modified
 */
public static void copyResults(Exchange result, Exchange source) {
    if (result != source) {
        result.setException(source.getException());
        if (source.hasOut()) {
            result.getOut().copyFrom(source.getOut());
        } else if (result.getPattern() == ExchangePattern.InOptionalOut) {
            // special case where the result is InOptionalOut and with no OUT response
            // so we should return null to indicate this fact
            result.setOut(null);
        } else {
            // so lets assume the last IN is the OUT
            if (result.getPattern().isOutCapable()) {
                // only set OUT if its OUT capable
                result.getOut().copyFrom(source.getIn());
            } else {
                // if not replace IN instead to keep the MEP
                result.getIn().copyFrom(source.getIn());
            }
        }
        if (source.hasProperties()) {
            result.getProperties().putAll(source.getProperties());
        }
    }
}","/**
 * Copies the results of a message exchange from the source exchange to the result exchange
 * which will copy the out and fault message contents and the exception
 *
 * @param result the result exchange which will have the output and error state added
 * @param source the source exchange which is not modified
 */
","public static void copyResults(Exchange result, Exchange source) {
    if (result != source) {
        result.setException(source.getException());
        if (source.hasOut()) {
            result.getOut().copyFrom(source.getOut());
        } else if (result.getPattern() == ExchangePattern.InOptionalOut) {
                                    result.setOut(null);
        } else {
                        if (result.getPattern().isOutCapable()) {
                                result.getOut().copyFrom(source.getIn());
            } else {
                                result.getIn().copyFrom(source.getIn());
            }
        }
        if (source.hasProperties()) {
            result.getProperties().putAll(source.getProperties());
        }
    }
}",0.22727272727272727,0.7142857142857143,0.3333333333333333,1.0,0.5833333333333334,0.07414730598121602,-0.18038428448523108,1.1666666666666667,-0.028571428571428574,0.046633344897443474
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2494_0dc92ca1,1,"public String toString() {
    return String.format(""%,d %,d %,.2f %,d"", getMin(), getMax(), getAverage(), count);
}",,"public String toString() {
    return String.format(""%,d %,d %,.2f %,d"", getMin(), getMax(), getAverage(), count);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9948379696013767,-0.16666666666666666,-0.028571428571428574,-0.16422749602751402
Closure,75,2,"static Double getStringNumberValue(String rawJsString) {
    // vertical tab is not always whitespace
    String s = trimJsWhiteSpace(rawJsString);
    // return ScriptRuntime.toNumber(s);
    if (s.length() == 0) {
        return 0.0;
    }
    if (s.length() > 2 && s.charAt(0) == '0' && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {
        // Attempt to convert hex numbers.
        try {
            return Double.valueOf(Integer.parseInt(s.substring(2), 16));
        } catch (NumberFormatException e) {
            return Double.NaN;
        }
    }
    if (s.length() > 3 && (s.charAt(0) == '-' || s.charAt(0) == '+') && s.charAt(1) == '0' && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {
        // hex numbers with explicit signs vary between browsers.
        return null;
    }
    // insensitive, but IE treats ""infinity"" as NaN.  So leave it alone.
    if (s.equals(""infinity"") || s.equals(""-infinity"") || s.equals(""+infinity"")) {
        return null;
    }
    try {
        return Double.parseDouble(s);
    } catch (NumberFormatException e) {
        return Double.NaN;
    }
}",,"static Double getStringNumberValue(String rawJsString) {
        String s = trimJsWhiteSpace(rawJsString);
        if (s.length() == 0) {
        return 0.0;
    }
    if (s.length() > 2 && s.charAt(0) == '0' && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {
                try {
            return Double.valueOf(Integer.parseInt(s.substring(2), 16));
        } catch (NumberFormatException e) {
            return Double.NaN;
        }
    }
    if (s.length() > 3 && (s.charAt(0) == '-' || s.charAt(0) == '+') && s.charAt(1) == '0' && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {
                return null;
    }
        if (s.equals(""infinity"") || s.equals(""-infinity"") || s.equals(""+infinity"")) {
        return null;
    }
    try {
        return Double.parseDouble(s);
    } catch (NumberFormatException e) {
        return Double.NaN;
    }
}",0.45454545454545453,0.01020408163265307,0.5,0.0,1.3333333333333333,0.6198714780029659,-0.4313163177516493,1.0833333333333333,-0.028571428571428574,0.9879133634000198
camel,remotes/origin/bugs-dot-jar_CAMEL-7146_b6981cfd,3,"protected Exchange onCompletion(final String key, final Exchange original, final Exchange aggregated, boolean fromTimeout) {
    // store the correlation key as property before we remove so the repository has that information
    if (original != null) {
        original.setProperty(Exchange.AGGREGATED_CORRELATION_KEY, key);
    }
    aggregated.setProperty(Exchange.AGGREGATED_CORRELATION_KEY, key);
    // remove from repository as its completed, we do this first as to trigger any OptimisticLockingException's
    aggregationRepository.remove(aggregated.getContext(), key, original);
    if (!fromTimeout && timeoutMap != null) {
        // cleanup timeout map if it was a incoming exchange which triggered the timeout (and not the timeout checker)
        timeoutMap.remove(key);
    }
    // this key has been closed so add it to the closed map
    if (closedCorrelationKeys != null) {
        closedCorrelationKeys.put(key, key);
    }
    if (fromTimeout) {
        // to allow any custom processing before discarding the exchange
        if (aggregationStrategy instanceof TimeoutAwareAggregationStrategy) {
            long timeout = getCompletionTimeout() > 0 ? getCompletionTimeout() : -1;
            ((TimeoutAwareAggregationStrategy) aggregationStrategy).timeout(aggregated, -1, -1, timeout);
        }
    }
    Exchange answer;
    if (fromTimeout && isDiscardOnCompletionTimeout()) {
        // discard due timeout
        LOG.debug(""Aggregation for correlation key {} discarding aggregated exchange: {}"", key, aggregated);
        // must confirm the discarded exchange
        aggregationRepository.confirm(aggregated.getContext(), aggregated.getExchangeId());
        // and remove redelivery state as well
        redeliveryState.remove(aggregated.getExchangeId());
        // the completion was from timeout and we should just discard it
        answer = null;
    } else {
        // the aggregated exchange should be published (sent out)
        answer = aggregated;
    }
    return answer;
}",,"protected Exchange onCompletion(final String key, final Exchange original, final Exchange aggregated, boolean fromTimeout) {
        if (original != null) {
        original.setProperty(Exchange.AGGREGATED_CORRELATION_KEY, key);
    }
    aggregated.setProperty(Exchange.AGGREGATED_CORRELATION_KEY, key);
        aggregationRepository.remove(aggregated.getContext(), key, original);
    if (!fromTimeout && timeoutMap != null) {
                timeoutMap.remove(key);
    }
        if (closedCorrelationKeys != null) {
        closedCorrelationKeys.put(key, key);
    }
    if (fromTimeout) {
                if (aggregationStrategy instanceof TimeoutAwareAggregationStrategy) {
            long timeout = getCompletionTimeout() > 0 ? getCompletionTimeout() : -1;
            ((TimeoutAwareAggregationStrategy) aggregationStrategy).timeout(aggregated, -1, -1, timeout);
        }
    }
    Exchange answer;
    if (fromTimeout && isDiscardOnCompletionTimeout()) {
                LOG.debug(""Aggregation for correlation key {} discarding aggregated exchange: {}"", key, aggregated);
                aggregationRepository.confirm(aggregated.getContext(), aggregated.getExchangeId());
                redeliveryState.remove(aggregated.getExchangeId());
                answer = null;
    } else {
                answer = aggregated;
    }
    return answer;
}",0.6818181818181818,-0.0714285714285715,0.6666666666666666,0.0,0.9166666666666666,1.1319822046465648,-0.5104674505305421,0.8333333333333334,-0.028571428571428574,1.4051036272758812
commons-math,remotes/origin/bugs-dot-jar_MATH-757_76b7413d,1,"/**
 * Sets the <code>expansionMode</code>. The specified value must be one of
 * ADDITIVE_MODE, MULTIPLICATIVE_MODE.
 *
 * @param expansionMode The expansionMode to set.
 * @throws MathIllegalArgumentException if the specified mode value is not valid.
 * @deprecated As of 3.1. Please use {@link #setExpansionMode(ExpansionMode)} instead.
 */
@Deprecated
public void setExpansionMode(int expansionMode) throws MathIllegalArgumentException {
    if (expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE) {
        throw new MathIllegalArgumentException(LocalizedFormats.UNSUPPORTED_EXPANSION_MODE, expansionMode, MULTIPLICATIVE_MODE, ""MULTIPLICATIVE_MODE"", ADDITIVE_MODE, ""ADDITIVE_MODE"");
    }
    synchronized (this) {
        if (expansionMode == MULTIPLICATIVE_MODE) {
            setExpansionMode(ExpansionMode.MULTIPLICATIVE);
        } else if (expansionMode == ADDITIVE_MODE) {
            setExpansionMode(ExpansionMode.ADDITIVE);
        }
    }
}","/**
 * Sets the <code>expansionMode</code>. The specified value must be one of
 * ADDITIVE_MODE, MULTIPLICATIVE_MODE.
 *
 * @param expansionMode The expansionMode to set.
 * @throws MathIllegalArgumentException if the specified mode value is not valid.
 * @deprecated As of 3.1. Please use {@link #setExpansionMode(ExpansionMode)} instead.
 */
","@Deprecated
public void setExpansionMode(int expansionMode) throws MathIllegalArgumentException {
    if (expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE) {
        throw new MathIllegalArgumentException(LocalizedFormats.UNSUPPORTED_EXPANSION_MODE, expansionMode, MULTIPLICATIVE_MODE, ""MULTIPLICATIVE_MODE"", ADDITIVE_MODE, ""ADDITIVE_MODE"");
    }
    synchronized (this) {
        if (expansionMode == MULTIPLICATIVE_MODE) {
            setExpansionMode(ExpansionMode.MULTIPLICATIVE);
        } else if (expansionMode == ADDITIVE_MODE) {
            setExpansionMode(ExpansionMode.ADDITIVE);
        }
    }
}",-0.045454545454545456,0.5051020408163264,0.16666666666666666,0.5,0.0,0.06426099851705393,0.08259248637797523,-0.3333333333333333,0.0,-0.043746600365768516
wicket,remotes/origin/bugs-dot-jar_WICKET-4572_dfc56674,0,"/**
 *  Splits the window with given index to two windows. First of those will have size specified by
 *  the argument, the other one will fill up the rest of the original window.
 *
 *  @param index
 *  @param size
 */
private void splitWindow(int index, int size) {
    PageWindowInternal window = windows.get(index);
    int delta = window.filePartSize - size;
    if (index == windows.size() - 1) {
        // if this is last window
        totalSize -= delta;
        window.filePartSize = size;
    } else if (window.filePartSize != size) {
        PageWindowInternal newWindow = new PageWindowInternal();
        newWindow.pageId = -1;
        window.filePartSize = size;
        windows.add(index + 1, newWindow);
        newWindow.filePartOffset = getWindowFileOffset(index + 1);
        newWindow.filePartSize = delta;
    }
    idToWindowIndex = null;
}","/**
 *  Splits the window with given index to two windows. First of those will have size specified by
 *  the argument, the other one will fill up the rest of the original window.
 *
 *  @param index
 *  @param size
 */
","private void splitWindow(int index, int size) {
    PageWindowInternal window = windows.get(index);
    int delta = window.filePartSize - size;
    if (index == windows.size() - 1) {
                totalSize -= delta;
        window.filePartSize = size;
    } else if (window.filePartSize != size) {
        PageWindowInternal newWindow = new PageWindowInternal();
        newWindow.pageId = -1;
        window.filePartSize = size;
        windows.add(index + 1, newWindow);
        newWindow.filePartOffset = getWindowFileOffset(index + 1);
        newWindow.filePartSize = delta;
    }
    idToWindowIndex = null;
}",0.09090909090909091,-0.12244897959183684,-0.16666666666666666,0.0,0.08333333333333333,1.1497775580820566,-0.13449956983080008,-0.16666666666666666,0.08571428571428572,0.8514011846788391
camel,remotes/origin/bugs-dot-jar_CAMEL-3448_b345dd82,0,"public static ExceptionPolicyKey newInstance(Class exceptionClass, WhenDefinition when) {
    return new ExceptionPolicyKey(exceptionClass, when);
}",,"public static ExceptionPolicyKey newInstance(Class exceptionClass, WhenDefinition when) {
    return new ExceptionPolicyKey(exceptionClass, when);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.0129050759965588,-0.5,0.6285714285714287,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5,3,"public void getResult() throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException {
    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
        throw new IllegalStateException(""Method call not finished!"");
    }
    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
    (new Client(prot)).recv_update();
}",,"public void getResult() throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException {
    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
        throw new IllegalStateException(""Method call not finished!"");
    }
    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
    (new Client(prot)).recv_update();
}",-0.2727272727272727,-0.31632653061224497,-0.16666666666666666,-0.5,-0.25,-0.07019278299555112,0.22999713220533405,0.0,-0.028571428571428574,-0.00900715689927659
wicket,remotes/origin/bugs-dot-jar_WICKET-3989_6a8fc1cc,1,"/**
 *  Will <b>replace</b> the respective component's method. However by returning null, the
 *  component's method will be called.
 *
 *  @see MarkupContainer#getMarkup(Component)
 *
 *  @param container
 *             The parent containing the child. (@TODO Is container ever != child.getParent()??)
 *  @param child
 *             The component to find the markup for.
 *  @return markup fragment
 */
IMarkupFragment getMarkup(final MarkupContainer container, final Component child);","/**
 *  Will <b>replace</b> the respective component's method. However by returning null, the
 *  component's method will be called.
 *
 *  @see MarkupContainer#getMarkup(Component)
 *
 *  @param container
 *             The parent containing the child. (@TODO Is container ever != child.getParent()??)
 *  @param child
 *             The component to find the markup for.
 *  @return markup fragment
 */
","IMarkupFragment getMarkup(final MarkupContainer container, final Component child);",-0.5909090909090909,-1.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.5764267278462867,-0.5,2.8285714285714287,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-7513_85ced066,1,"protected AggregationStrategyMethodInfo createMethodInfo() {
    Class<?>[] parameterTypes = method.getParameterTypes();
    int size = parameterTypes.length;
    if (LOG.isTraceEnabled()) {
        LOG.trace(""Creating MethodInfo for class: {} method: {} having {} parameters"", new Object[] { type, method, size });
    }
    // must have equal number of parameters
    if (size < 2) {
        throw new IllegalArgumentException(""The method "" + method.getName() + "" must have at least two parameters, has: "" + size);
    } else if (size % 2 != 0) {
        throw new IllegalArgumentException(""The method "" + method.getName() + "" must have equal number of parameters, has: "" + size);
    }
    // must not have annotations as they are not supported (yet)
    for (int i = 0; i < size; i++) {
        Class<?> type = parameterTypes[i];
        if (type.getAnnotations().length > 0) {
            throw new IllegalArgumentException(""Parameter annotations at index "" + i + "" is not supported on method: "" + method);
        }
    }
    List<ParameterInfo> oldParameters = new ArrayList<ParameterInfo>();
    List<ParameterInfo> newParameters = new ArrayList<ParameterInfo>();
    for (int i = 0; i < size / 2; i++) {
        Class<?> oldType = parameterTypes[i];
        if (oldParameters.size() == 0) {
            // the first parameter is the body
            Expression oldBody = ExpressionBuilder.mandatoryBodyExpression(oldType);
            ParameterInfo info = new ParameterInfo(i, oldType, null, oldBody);
            oldParameters.add(info);
        } else if (oldParameters.size() == 1) {
            // the 2nd parameter is the headers
            Expression oldHeaders = ExpressionBuilder.headersExpression();
            ParameterInfo info = new ParameterInfo(i, oldType, null, oldHeaders);
            oldParameters.add(info);
        } else if (oldParameters.size() == 2) {
            // the 3rd parameter is the properties
            Expression oldProperties = ExpressionBuilder.propertiesExpression();
            ParameterInfo info = new ParameterInfo(i, oldType, null, oldProperties);
            oldParameters.add(info);
        }
    }
    for (int i = size / 2; i < size; i++) {
        Class<?> newType = parameterTypes[i];
        if (newParameters.size() == 0) {
            // the first parameter is the body
            Expression newBody = ExpressionBuilder.mandatoryBodyExpression(newType);
            ParameterInfo info = new ParameterInfo(i, newType, null, newBody);
            newParameters.add(info);
        } else if (newParameters.size() == 1) {
            // the 2nd parameter is the headers
            Expression newHeaders = ExpressionBuilder.headersExpression();
            ParameterInfo info = new ParameterInfo(i, newType, null, newHeaders);
            newParameters.add(info);
        } else if (newParameters.size() == 2) {
            // the 3rd parameter is the properties
            Expression newProperties = ExpressionBuilder.propertiesExpression();
            ParameterInfo info = new ParameterInfo(i, newType, null, newProperties);
            newParameters.add(info);
        }
    }
    return new AggregationStrategyMethodInfo(camelContext, type, method, oldParameters, newParameters);
}",,"protected AggregationStrategyMethodInfo createMethodInfo() {
    Class<?>[] parameterTypes = method.getParameterTypes();
    int size = parameterTypes.length;
    if (LOG.isTraceEnabled()) {
        LOG.trace(""Creating MethodInfo for class: {} method: {} having {} parameters"", new Object[] { type, method, size });
    }
        if (size < 2) {
        throw new IllegalArgumentException(""The method "" + method.getName() + "" must have at least two parameters, has: "" + size);
    } else if (size % 2 != 0) {
        throw new IllegalArgumentException(""The method "" + method.getName() + "" must have equal number of parameters, has: "" + size);
    }
        for (int i = 0; i < size; i++) {
        Class<?> type = parameterTypes[i];
        if (type.getAnnotations().length > 0) {
            throw new IllegalArgumentException(""Parameter annotations at index "" + i + "" is not supported on method: "" + method);
        }
    }
    List<ParameterInfo> oldParameters = new ArrayList<ParameterInfo>();
    List<ParameterInfo> newParameters = new ArrayList<ParameterInfo>();
    for (int i = 0; i < size / 2; i++) {
        Class<?> oldType = parameterTypes[i];
        if (oldParameters.size() == 0) {
                        Expression oldBody = ExpressionBuilder.mandatoryBodyExpression(oldType);
            ParameterInfo info = new ParameterInfo(i, oldType, null, oldBody);
            oldParameters.add(info);
        } else if (oldParameters.size() == 1) {
                        Expression oldHeaders = ExpressionBuilder.headersExpression();
            ParameterInfo info = new ParameterInfo(i, oldType, null, oldHeaders);
            oldParameters.add(info);
        } else if (oldParameters.size() == 2) {
                        Expression oldProperties = ExpressionBuilder.propertiesExpression();
            ParameterInfo info = new ParameterInfo(i, oldType, null, oldProperties);
            oldParameters.add(info);
        }
    }
    for (int i = size / 2; i < size; i++) {
        Class<?> newType = parameterTypes[i];
        if (newParameters.size() == 0) {
                        Expression newBody = ExpressionBuilder.mandatoryBodyExpression(newType);
            ParameterInfo info = new ParameterInfo(i, newType, null, newBody);
            newParameters.add(info);
        } else if (newParameters.size() == 1) {
                        Expression newHeaders = ExpressionBuilder.headersExpression();
            ParameterInfo info = new ParameterInfo(i, newType, null, newHeaders);
            newParameters.add(info);
        } else if (newParameters.size() == 2) {
                        Expression newProperties = ExpressionBuilder.propertiesExpression();
            ParameterInfo info = new ParameterInfo(i, newType, null, newProperties);
            newParameters.add(info);
        }
    }
    return new AggregationStrategyMethodInfo(camelContext, type, method, oldParameters, newParameters);
}",1.7727272727272727,0.2959183673469388,2.1666666666666665,1.0,1.1666666666666667,2.7513593672763226,-1.008603383997706,1.5,-0.028571428571428574,9.252727202641758
wicket,remotes/origin/bugs-dot-jar_WICKET-3297_71499e17,1,"protected static String encodeResourceReferenceAttributes(ResourceReference.UrlAttributes attributes) {
    if (attributes == null || (attributes.getLocale() == null && attributes.getStyle() == null && attributes.getVariation() == null)) {
        return null;
    } else {
        StringBuilder res = new StringBuilder();
        if (attributes.getLocale() != null) {
            res.append(attributes.getLocale().toString());
        }
        if (!Strings.isEmpty(attributes.getStyle())) {
            res.append(""-"");
            res.append(attributes.getStyle());
        }
        if (!Strings.isEmpty(attributes.getVariation())) {
            res.append(""-"");
            res.append(attributes.getVariation());
        }
        return res.toString();
    }
}",,"protected static String encodeResourceReferenceAttributes(ResourceReference.UrlAttributes attributes) {
    if (attributes == null || (attributes.getLocale() == null && attributes.getStyle() == null && attributes.getVariation() == null)) {
        return null;
    } else {
        StringBuilder res = new StringBuilder();
        if (attributes.getLocale() != null) {
            res.append(attributes.getLocale().toString());
        }
        if (!Strings.isEmpty(attributes.getStyle())) {
            res.append(""-"");
            res.append(attributes.getStyle());
        }
        if (!Strings.isEmpty(attributes.getVariation())) {
            res.append(""-"");
            res.append(attributes.getVariation());
        }
        return res.toString();
    }
}",0.22727272727272727,0.3214285714285714,0.16666666666666666,0.0,0.6666666666666666,1.4681166584280774,-0.21881273300831652,1.0,-0.028571428571428574,0.995502846055996
camel,remotes/origin/bugs-dot-jar_CAMEL-3395_8433e6db,3,"public Iterator iterator() {
    return new Iterator() {

        private int index;

        private boolean closed;

        public boolean hasNext() {
            if (closed) {
                return false;
            }
            boolean answer = iterator.hasNext();
            if (!answer) {
                // we are now closed
                closed = true;
                // nothing more so we need to close the expression value in case it needs to be
                if (value instanceof Closeable) {
                    IOHelper.close((Closeable) value, value.getClass().getName(), LOG);
                } else if (value instanceof Scanner) {
                    // special for Scanner as it does not implement Closeable
                    ((Scanner) value).close();
                }
            }
            return answer;
        }

        public Object next() {
            Object part = iterator.next();
            Exchange newExchange = exchange.copy();
            if (part instanceof Message) {
                newExchange.setIn((Message) part);
            } else {
                Message in = newExchange.getIn();
                in.setBody(part);
            }
            return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);
        }

        public void remove() {
            throw new UnsupportedOperationException(""Remove is not supported by this iterator"");
        }
    };
}",,"public Iterator iterator() {
    return new Iterator() {

        private int index;

        private boolean closed;

        public boolean hasNext() {
            if (closed) {
                return false;
            }
            boolean answer = iterator.hasNext();
            if (!answer) {
                                closed = true;
                                if (value instanceof Closeable) {
                    IOHelper.close((Closeable) value, value.getClass().getName(), LOG);
                } else if (value instanceof Scanner) {
                                        ((Scanner) value).close();
                }
            }
            return answer;
        }

        public Object next() {
            Object part = iterator.next();
            Exchange newExchange = exchange.copy();
            if (part instanceof Message) {
                newExchange.setIn((Message) part);
            } else {
                Message in = newExchange.getIn();
                in.setBody(part);
            }
            return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);
        }

        public void remove() {
            throw new UnsupportedOperationException(""Remove is not supported by this iterator"");
        }
    };
}",0.9545454545454546,0.872448979591837,0.5,1.0,0.3333333333333333,-0.014829461196243152,-0.5503297963865789,0.6666666666666666,-0.028571428571428574,0.12517506777853446
Closure,169,2,"JSType getGreatestSubtypeHelper(JSType that) {
    if (that.isRecordType()) {
        RecordType thatRecord = that.toMaybeRecordType();
        RecordTypeBuilder builder = new RecordTypeBuilder(registry);
        builder.setSynthesized(true);
        // is returned.
        for (String property : properties.keySet()) {
            if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isInvariant(getPropertyType(property))) {
                return registry.getNativeObjectType(JSTypeNative.NO_TYPE);
            }
            builder.addProperty(property, getPropertyType(property), getPropertyNode(property));
        }
        for (String property : thatRecord.properties.keySet()) {
            if (!hasProperty(property)) {
                builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property));
            }
        }
        return builder.build();
    }
    JSType greatestSubtype = registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
    JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE).getGreatestSubtype(that);
    if (!thatRestrictedToObj.isEmptyType()) {
        // 2) Take the intersection of all of these unions.
        for (Map.Entry<String, JSType> entry : properties.entrySet()) {
            String propName = entry.getKey();
            JSType propType = entry.getValue();
            UnionTypeBuilder builder = new UnionTypeBuilder(registry);
            for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) {
                JSType altPropType = alt.getPropertyType(propName);
                if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) {
                    builder.addAlternate(alt);
                }
            }
            greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());
        }
    }
    return greatestSubtype;
}",,"JSType getGreatestSubtypeHelper(JSType that) {
    if (that.isRecordType()) {
        RecordType thatRecord = that.toMaybeRecordType();
        RecordTypeBuilder builder = new RecordTypeBuilder(registry);
        builder.setSynthesized(true);
                for (String property : properties.keySet()) {
            if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isInvariant(getPropertyType(property))) {
                return registry.getNativeObjectType(JSTypeNative.NO_TYPE);
            }
            builder.addProperty(property, getPropertyType(property), getPropertyNode(property));
        }
        for (String property : thatRecord.properties.keySet()) {
            if (!hasProperty(property)) {
                builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property));
            }
        }
        return builder.build();
    }
    JSType greatestSubtype = registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
    JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE).getGreatestSubtype(that);
    if (!thatRestrictedToObj.isEmptyType()) {
                for (Map.Entry<String, JSType> entry : properties.entrySet()) {
            String propName = entry.getKey();
            JSType propType = entry.getValue();
            UnionTypeBuilder builder = new UnionTypeBuilder(registry);
            for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) {
                JSType altPropType = alt.getPropertyType(propName);
                if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) {
                    builder.addAlternate(alt);
                }
            }
            greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());
        }
    }
    return greatestSubtype;
}",1.0,0.872448979591837,1.0,1.0,1.75,0.592189817103312,-0.7106395182104963,2.4166666666666665,-0.028571428571428574,1.643722615544734
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-4291_cdb34ffc,0,"/**
 * Flush any pending changes on any {@link SegmentBufferWriter} managed by this instance.
 * This method <em>does not block</em> to wait for concurrent write operations. However, if
 * a write operation is currently in progress a call to this method ensures the respective
 * changes are properly flushed at the end of that call.
 * @throws IOException
 */
void flush() throws IOException;","/**
 * Flush any pending changes on any {@link SegmentBufferWriter} managed by this instance.
 * This method <em>does not block</em> to wait for concurrent write operations. However, if
 * a write operation is currently in progress a call to this method ensures the respective
 * changes are properly flushed at the end of that call.
 * @throws IOException
 */
",void flush() throws IOException;,-0.5909090909090909,-1.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.7880699741898483,-0.5,2.8000000000000003,-0.16422749602751402
Lang,24,1,"/**
 * <p>Checks whether the String a valid Java number.</p>
 *
 * <p>Valid numbers include hexadecimal marked with the <code>0x</code>
 * qualifier, scientific notation and numbers marked with a type
 * qualifier (e.g. 123L).</p>
 *
 * <p><code>Null</code> and empty String will return
 * <code>false</code>.</p>
 *
 * @param str  the <code>String</code> to check
 * @return <code>true</code> if the string is a correctly formatted number
 */
public static boolean isNumber(String str) {
    if (StringUtils.isEmpty(str)) {
        return false;
    }
    char[] chars = str.toCharArray();
    int sz = chars.length;
    boolean hasExp = false;
    boolean hasDecPoint = false;
    boolean allowSigns = false;
    boolean foundDigit = false;
    // deal with any possible sign up front
    int start = (chars[0] == '-') ? 1 : 0;
    if (sz > start + 1) {
        if (chars[start] == '0' && chars[start + 1] == 'x') {
            int i = start + 2;
            if (i == sz) {
                // str == ""0x""
                return false;
            }
            // checking hex (it can't be anything else)
            for (; i < chars.length; i++) {
                if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {
                    return false;
                }
            }
            return true;
        }
    }
    // don't want to loop to the last char, check it afterwords
    sz--;
    // for type qualifiers
    int i = start;
    // make a valid number (e.g. chars[0..5] = ""1234E"")
    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {
        if (chars[i] >= '0' && chars[i] <= '9') {
            foundDigit = true;
            allowSigns = false;
        } else if (chars[i] == '.') {
            if (hasDecPoint || hasExp) {
                // two decimal points or dec in exponent
                return false;
            }
            hasDecPoint = true;
        } else if (chars[i] == 'e' || chars[i] == 'E') {
            // we've already taken care of hex.
            if (hasExp) {
                // two E's
                return false;
            }
            if (!foundDigit) {
                return false;
            }
            hasExp = true;
            allowSigns = true;
        } else if (chars[i] == '+' || chars[i] == '-') {
            if (!allowSigns) {
                return false;
            }
            allowSigns = false;
            // we need a digit after the E
            foundDigit = false;
        } else {
            return false;
        }
        i++;
    }
    if (i < chars.length) {
        if (chars[i] >= '0' && chars[i] <= '9') {
            // no type qualifier, OK
            return true;
        }
        if (chars[i] == 'e' || chars[i] == 'E') {
            // can't have an E at the last byte
            return false;
        }
        if (chars[i] == '.') {
            if (hasDecPoint || hasExp) {
                // two decimal points or dec in exponent
                return false;
            }
            // single trailing decimal point after non-exponent is ok
            return foundDigit;
        }
        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {
            return foundDigit;
        }
        if (chars[i] == 'l' || chars[i] == 'L') {
            // not allowing L with an exponent or decimal point
            return foundDigit && !hasExp;
        }
        // last character is illegal
        return false;
    }
    // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass
    return !allowSigns && foundDigit;
}","/**
 * <p>Checks whether the String a valid Java number.</p>
 *
 * <p>Valid numbers include hexadecimal marked with the <code>0x</code>
 * qualifier, scientific notation and numbers marked with a type
 * qualifier (e.g. 123L).</p>
 *
 * <p><code>Null</code> and empty String will return
 * <code>false</code>.</p>
 *
 * @param str  the <code>String</code> to check
 * @return <code>true</code> if the string is a correctly formatted number
 */
","public static boolean isNumber(String str) {
    if (StringUtils.isEmpty(str)) {
        return false;
    }
    char[] chars = str.toCharArray();
    int sz = chars.length;
    boolean hasExp = false;
    boolean hasDecPoint = false;
    boolean allowSigns = false;
    boolean foundDigit = false;
        int start = (chars[0] == '-') ? 1 : 0;
    if (sz > start + 1) {
        if (chars[start] == '0' && chars[start + 1] == 'x') {
            int i = start + 2;
            if (i == sz) {
                                return false;
            }
                        for (; i < chars.length; i++) {
                if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {
                    return false;
                }
            }
            return true;
        }
    }
        sz--;
        int i = start;
        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {
        if (chars[i] >= '0' && chars[i] <= '9') {
            foundDigit = true;
            allowSigns = false;
        } else if (chars[i] == '.') {
            if (hasDecPoint || hasExp) {
                                return false;
            }
            hasDecPoint = true;
        } else if (chars[i] == 'e' || chars[i] == 'E') {
                        if (hasExp) {
                                return false;
            }
            if (!foundDigit) {
                return false;
            }
            hasExp = true;
            allowSigns = true;
        } else if (chars[i] == '+' || chars[i] == '-') {
            if (!allowSigns) {
                return false;
            }
            allowSigns = false;
                        foundDigit = false;
        } else {
            return false;
        }
        i++;
    }
    if (i < chars.length) {
        if (chars[i] >= '0' && chars[i] <= '9') {
                        return true;
        }
        if (chars[i] == 'e' || chars[i] == 'E') {
                        return false;
        }
        if (chars[i] == '.') {
            if (hasDecPoint || hasExp) {
                                return false;
            }
                        return foundDigit;
        }
        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {
            return foundDigit;
        }
        if (chars[i] == 'l' || chars[i] == 'L') {
                        return foundDigit && !hasExp;
        }
                return false;
    }
        return !allowSigns && foundDigit;
}",2.9545454545454546,0.6071428571428571,3.3333333333333335,2.0,4.083333333333333,5.319822046465646,-1.2449096644680246,-0.3333333333333333,-0.028571428571428574,17.561197699170382
wicket,remotes/origin/bugs-dot-jar_WICKET-3280_295e73bd,1,"/**
 *  @see org.apache.wicket.request.handler.IPageRequestHandler#respond(org.apache.wicket.request.IRequestCycle)
 */
public final void respond(final IRequestCycle requestCycle) {
    // do not increment page id during ajax processing
    boolean frozen = page.setFreezePageId(true);
    try {
        RequestCycle rc = (RequestCycle) requestCycle;
        final WebResponse response = (WebResponse) requestCycle.getResponse();
        if (markupIdToComponent.values().contains(page)) {
            // the page itself has been added to the request target, we simply issue a redirect
            // back to the page
            IRequestHandler handler = new RenderPageRequestHandler(new PageProvider(page));
            final String url = rc.urlFor(handler).toString();
            response.sendRedirect(url);
            return;
        }
        for (ITargetRespondListener listener : respondListeners) {
            listener.onTargetRespond(this);
        }
        final Application app = Application.get();
        page.send(app, Broadcast.BREADTH, this);
        // Determine encoding
        final String encoding = app.getRequestCycleSettings().getResponseRequestEncoding();
        // Set content type based on markup type for page
        response.setContentType(""text/xml; charset="" + encoding);
        // Make sure it is not cached by a client
        response.disableCaching();
        response.write(""<?xml version=\""1.0\"" encoding=\"""");
        response.write(encoding);
        response.write(""\""?>"");
        response.write(""<ajax-response>"");
        // invoke onbeforerespond event on listeners
        fireOnBeforeRespondListeners();
        // normal behavior
        Iterator<CharSequence> it = prependJavaScripts.iterator();
        while (it.hasNext()) {
            CharSequence js = it.next();
            respondInvocation(response, js);
        }
        // process added components
        respondComponents(response);
        fireOnAfterRespondListeners(response);
        // execute the dom ready javascripts as first javascripts
        // after component replacement
        it = domReadyJavaScripts.iterator();
        while (it.hasNext()) {
            CharSequence js = it.next();
            respondInvocation(response, js);
        }
        it = appendJavaScripts.iterator();
        while (it.hasNext()) {
            CharSequence js = it.next();
            respondInvocation(response, js);
        }
        response.write(""</ajax-response>"");
    } finally {
        page.setFreezePageId(frozen);
    }
}","/**
 *  @see org.apache.wicket.request.handler.IPageRequestHandler#respond(org.apache.wicket.request.IRequestCycle)
 */
","public final void respond(final IRequestCycle requestCycle) {
        boolean frozen = page.setFreezePageId(true);
    try {
        RequestCycle rc = (RequestCycle) requestCycle;
        final WebResponse response = (WebResponse) requestCycle.getResponse();
        if (markupIdToComponent.values().contains(page)) {
                                    IRequestHandler handler = new RenderPageRequestHandler(new PageProvider(page));
            final String url = rc.urlFor(handler).toString();
            response.sendRedirect(url);
            return;
        }
        for (ITargetRespondListener listener : respondListeners) {
            listener.onTargetRespond(this);
        }
        final Application app = Application.get();
        page.send(app, Broadcast.BREADTH, this);
                final String encoding = app.getRequestCycleSettings().getResponseRequestEncoding();
                response.setContentType(""text/xml; charset="" + encoding);
                response.disableCaching();
        response.write(""<?xml version=\""1.0\"" encoding=\"""");
        response.write(encoding);
        response.write(""\""?>"");
        response.write(""<ajax-response>"");
                fireOnBeforeRespondListeners();
                Iterator<CharSequence> it = prependJavaScripts.iterator();
        while (it.hasNext()) {
            CharSequence js = it.next();
            respondInvocation(response, js);
        }
                respondComponents(response);
        fireOnAfterRespondListeners(response);
                        it = domReadyJavaScripts.iterator();
        while (it.hasNext()) {
            CharSequence js = it.next();
            respondInvocation(response, js);
        }
        it = appendJavaScripts.iterator();
        while (it.hasNext()) {
            CharSequence js = it.next();
            respondInvocation(response, js);
        }
        response.write(""</ajax-response>"");
    } finally {
        page.setFreezePageId(frozen);
    }
}",1.4545454545454546,-0.10204081632653071,0.3333333333333333,0.0,0.16666666666666666,0.0187839841819081,-0.7886435331230286,2.4166666666666665,-0.028571428571428574,0.5300602618628496
flink,remotes/origin/bugs-dot-jar_FLINK-1761_380ef878,1,"private boolean decodeBufferOrEvent(RemoteInputChannel inputChannel, NettyMessage.BufferResponse bufferOrEvent) throws Throwable {
    boolean releaseNettyBuffer = true;
    try {
        if (bufferOrEvent.isBuffer()) {
            // ---- Buffer ------------------------------------------------
            BufferProvider bufferProvider = inputChannel.getBufferProvider();
            if (bufferProvider == null) {
                // receiver has been cancelled/failed
                return false;
            }
            while (true) {
                Buffer buffer = bufferProvider.requestBuffer();
                if (buffer != null) {
                    buffer.setSize(bufferOrEvent.getSize());
                    bufferOrEvent.getNettyBuffer().readBytes(buffer.getNioBuffer());
                    inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber);
                    return true;
                } else if (bufferListener.waitForBuffer(bufferProvider, bufferOrEvent)) {
                    releaseNettyBuffer = false;
                    return false;
                } else if (bufferProvider.isDestroyed()) {
                    return false;
                }
            }
        } else {
            // ---- Event -------------------------------------------------
            // TODO We can just keep the serialized data in the Netty buffer and release it later at the reader
            byte[] byteArray = new byte[bufferOrEvent.getSize()];
            bufferOrEvent.getNettyBuffer().readBytes(byteArray);
            Buffer buffer = new Buffer(new MemorySegment(byteArray), EventSerializer.RECYCLER, false);
            inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber);
            return true;
        }
    } finally {
        if (releaseNettyBuffer) {
            bufferOrEvent.releaseBuffer();
        }
    }
}",,"private boolean decodeBufferOrEvent(RemoteInputChannel inputChannel, NettyMessage.BufferResponse bufferOrEvent) throws Throwable {
    boolean releaseNettyBuffer = true;
    try {
        if (bufferOrEvent.isBuffer()) {
                        BufferProvider bufferProvider = inputChannel.getBufferProvider();
            if (bufferProvider == null) {
                                return false;
            }
            while (true) {
                Buffer buffer = bufferProvider.requestBuffer();
                if (buffer != null) {
                    buffer.setSize(bufferOrEvent.getSize());
                    bufferOrEvent.getNettyBuffer().readBytes(buffer.getNioBuffer());
                    inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber);
                    return true;
                } else if (bufferListener.waitForBuffer(bufferProvider, bufferOrEvent)) {
                    releaseNettyBuffer = false;
                    return false;
                } else if (bufferProvider.isDestroyed()) {
                    return false;
                }
            }
        } else {
                                    byte[] byteArray = new byte[bufferOrEvent.getSize()];
            bufferOrEvent.getNettyBuffer().readBytes(byteArray);
            Buffer buffer = new Buffer(new MemorySegment(byteArray), EventSerializer.RECYCLER, false);
            inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber);
            return true;
        }
    } finally {
        if (releaseNettyBuffer) {
            bufferOrEvent.releaseBuffer();
        }
    }
}",0.9545454545454546,1.4081632653061227,0.6666666666666666,2.0,0.75,0.056351952545724206,-0.5824490966446805,0.8333333333333334,-0.028571428571428574,0.24428111923454154
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1153_9f924f10,1,"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
private void processRemainingProperties(ComponentBuilder<?> builder, String name, Properties properties) {
    while (properties.size() > 0) {
        String propertyName = properties.stringPropertyNames().iterator().next();
        int index = propertyName.indexOf('.');
        if (index > 0) {
            String prefix = propertyName.substring(0, index);
            Properties componentProperties = PropertiesUtil.extractSubset(properties, prefix);
            builder.addComponent(createComponent(builder, prefix, componentProperties));
        } else {
            builder.addAttribute(propertyName, properties.getProperty(propertyName));
            properties.remove(propertyName);
        }
    }
}",,"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
private void processRemainingProperties(ComponentBuilder<?> builder, String name, Properties properties) {
    while (properties.size() > 0) {
        String propertyName = properties.stringPropertyNames().iterator().next();
        int index = propertyName.indexOf('.');
        if (index > 0) {
            String prefix = propertyName.substring(0, index);
            Properties componentProperties = PropertiesUtil.extractSubset(properties, prefix);
            builder.addComponent(createComponent(builder, prefix, componentProperties));
        } else {
            builder.addAttribute(propertyName, properties.getProperty(propertyName));
            properties.remove(propertyName);
        }
    }
}",0.045454545454545456,0.7193877551020407,-0.16666666666666666,0.0,-0.08333333333333333,-0.030647553138902585,-0.09865213650702606,0.5,-0.028571428571428574,0.058989810734064
wicket,remotes/origin/bugs-dot-jar_WICKET-2172_ea4a3f8a,3,"// //
// // getAs convenience methods
// //
/**
 *  @see IValueMap#getAsBoolean(String)
 */
public Boolean getAsBoolean(String key) {
    if (!containsKey(key))
        return null;
    try {
        return getBoolean(key);
    } catch (StringValueConversionException ignored) {
        return null;
    }
}","/**
 *  @see IValueMap#getAsBoolean(String)
 */
","public Boolean getAsBoolean(String key) {
    if (!containsKey(key))
        return null;
    try {
        return getBoolean(key);
    } catch (StringValueConversionException ignored) {
        return null;
    }
}",-0.22727272727272727,-0.035714285714285636,-0.16666666666666666,-0.5,-0.16666666666666666,-0.3806228373702422,0.40808718095784363,-0.3333333333333333,2.8000000000000003,-0.16422749602751402
flink,remotes/origin/bugs-dot-jar_FLINK-2121_03340919,3,"/**
 *  Computes the input splits for the file. By default, one file block is one split. If more splits
 *  are requested than blocks are available, then a split may be a fraction of a block and splits may cross
 *  block boundaries.
 *
 *  @param minNumSplits The minimum desired number of file splits.
 *  @return The computed file splits.
 *
 *  @see org.apache.flink.api.common.io.InputFormat#createInputSplits(int)
 */
@Override
public FileInputSplit[] createInputSplits(int minNumSplits) throws IOException {
    if (minNumSplits < 1) {
        throw new IllegalArgumentException(""Number of input splits has to be at least 1."");
    }
    // take the desired number of splits into account
    minNumSplits = Math.max(minNumSplits, this.numSplits);
    final Path path = this.filePath;
    final List<FileInputSplit> inputSplits = new ArrayList<FileInputSplit>(minNumSplits);
    // get all the files that are involved in the splits
    List<FileStatus> files = new ArrayList<FileStatus>();
    long totalLength = 0;
    final FileSystem fs = path.getFileSystem();
    final FileStatus pathFile = fs.getFileStatus(path);
    if (pathFile.isDir()) {
        totalLength += addFilesInDir(path, files, totalLength, true);
    } else {
        testForUnsplittable(pathFile);
        files.add(pathFile);
        totalLength += pathFile.getLen();
    }
    // returns if unsplittable
    if (unsplittable) {
        int splitNum = 0;
        for (final FileStatus file : files) {
            final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, file.getLen());
            Set<String> hosts = new HashSet<String>();
            for (BlockLocation block : blocks) {
                hosts.addAll(Arrays.asList(block.getHosts()));
            }
            long len = file.getLen();
            if (testForUnsplittable(file)) {
                len = READ_WHOLE_SPLIT_FLAG;
            }
            FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), 0, len, hosts.toArray(new String[hosts.size()]));
            inputSplits.add(fis);
        }
        return inputSplits.toArray(new FileInputSplit[inputSplits.size()]);
    }
    final long maxSplitSize = (minNumSplits < 1) ? Long.MAX_VALUE : (totalLength / minNumSplits + (totalLength % minNumSplits == 0 ? 0 : 1));
    // now that we have the files, generate the splits
    int splitNum = 0;
    for (final FileStatus file : files) {
        final long len = file.getLen();
        final long blockSize = file.getBlockSize();
        final long minSplitSize;
        if (this.minSplitSize <= blockSize) {
            minSplitSize = this.minSplitSize;
        } else {
            if (LOG.isWarnEnabled()) {
                LOG.warn(""Minimal split size of "" + this.minSplitSize + "" is larger than the block size of "" + blockSize + "". Decreasing minimal split size to block size."");
            }
            minSplitSize = blockSize;
        }
        final long splitSize = Math.max(minSplitSize, Math.min(maxSplitSize, blockSize));
        final long halfSplit = splitSize >>> 1;
        final long maxBytesForLastSplit = (long) (splitSize * MAX_SPLIT_SIZE_DISCREPANCY);
        if (len > 0) {
            // get the block locations and make sure they are in order with respect to their offset
            final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, len);
            Arrays.sort(blocks);
            long bytesUnassigned = len;
            long position = 0;
            int blockIndex = 0;
            while (bytesUnassigned > maxBytesForLastSplit) {
                // get the block containing the majority of the data
                blockIndex = getBlockIndexForPosition(blocks, position, halfSplit, blockIndex);
                // create a new split
                FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), position, splitSize, blocks[blockIndex].getHosts());
                inputSplits.add(fis);
                // adjust the positions
                position += splitSize;
                bytesUnassigned -= splitSize;
            }
            // assign the last split
            if (bytesUnassigned > 0) {
                blockIndex = getBlockIndexForPosition(blocks, position, halfSplit, blockIndex);
                final FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), position, bytesUnassigned, blocks[blockIndex].getHosts());
                inputSplits.add(fis);
            }
        } else {
            // special case with a file of zero bytes size
            final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, 0);
            String[] hosts;
            if (blocks.length > 0) {
                hosts = blocks[0].getHosts();
            } else {
                hosts = new String[0];
            }
            final FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), 0, 0, hosts);
            inputSplits.add(fis);
        }
    }
    return inputSplits.toArray(new FileInputSplit[inputSplits.size()]);
}","/**
 *  Computes the input splits for the file. By default, one file block is one split. If more splits
 *  are requested than blocks are available, then a split may be a fraction of a block and splits may cross
 *  block boundaries.
 *
 *  @param minNumSplits The minimum desired number of file splits.
 *  @return The computed file splits.
 *
 *  @see org.apache.flink.api.common.io.InputFormat#createInputSplits(int)
 */
","@Override
public FileInputSplit[] createInputSplits(int minNumSplits) throws IOException {
    if (minNumSplits < 1) {
        throw new IllegalArgumentException(""Number of input splits has to be at least 1."");
    }
        minNumSplits = Math.max(minNumSplits, this.numSplits);
    final Path path = this.filePath;
    final List<FileInputSplit> inputSplits = new ArrayList<FileInputSplit>(minNumSplits);
        List<FileStatus> files = new ArrayList<FileStatus>();
    long totalLength = 0;
    final FileSystem fs = path.getFileSystem();
    final FileStatus pathFile = fs.getFileStatus(path);
    if (pathFile.isDir()) {
        totalLength += addFilesInDir(path, files, totalLength, true);
    } else {
        testForUnsplittable(pathFile);
        files.add(pathFile);
        totalLength += pathFile.getLen();
    }
        if (unsplittable) {
        int splitNum = 0;
        for (final FileStatus file : files) {
            final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, file.getLen());
            Set<String> hosts = new HashSet<String>();
            for (BlockLocation block : blocks) {
                hosts.addAll(Arrays.asList(block.getHosts()));
            }
            long len = file.getLen();
            if (testForUnsplittable(file)) {
                len = READ_WHOLE_SPLIT_FLAG;
            }
            FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), 0, len, hosts.toArray(new String[hosts.size()]));
            inputSplits.add(fis);
        }
        return inputSplits.toArray(new FileInputSplit[inputSplits.size()]);
    }
    final long maxSplitSize = (minNumSplits < 1) ? Long.MAX_VALUE : (totalLength / minNumSplits + (totalLength % minNumSplits == 0 ? 0 : 1));
        int splitNum = 0;
    for (final FileStatus file : files) {
        final long len = file.getLen();
        final long blockSize = file.getBlockSize();
        final long minSplitSize;
        if (this.minSplitSize <= blockSize) {
            minSplitSize = this.minSplitSize;
        } else {
            if (LOG.isWarnEnabled()) {
                LOG.warn(""Minimal split size of "" + this.minSplitSize + "" is larger than the block size of "" + blockSize + "". Decreasing minimal split size to block size."");
            }
            minSplitSize = blockSize;
        }
        final long splitSize = Math.max(minSplitSize, Math.min(maxSplitSize, blockSize));
        final long halfSplit = splitSize >>> 1;
        final long maxBytesForLastSplit = (long) (splitSize * MAX_SPLIT_SIZE_DISCREPANCY);
        if (len > 0) {
                        final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, len);
            Arrays.sort(blocks);
            long bytesUnassigned = len;
            long position = 0;
            int blockIndex = 0;
            while (bytesUnassigned > maxBytesForLastSplit) {
                                blockIndex = getBlockIndexForPosition(blocks, position, halfSplit, blockIndex);
                                FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), position, splitSize, blocks[blockIndex].getHosts());
                inputSplits.add(fis);
                                position += splitSize;
                bytesUnassigned -= splitSize;
            }
                        if (bytesUnassigned > 0) {
                blockIndex = getBlockIndexForPosition(blocks, position, halfSplit, blockIndex);
                final FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), position, bytesUnassigned, blocks[blockIndex].getHosts());
                inputSplits.add(fis);
            }
        } else {
                        final BlockLocation[] blocks = fs.getFileBlockLocations(file, 0, 0);
            String[] hosts;
            if (blocks.length > 0) {
                hosts = blocks[0].getHosts();
            } else {
                hosts = new String[0];
            }
            final FileInputSplit fis = new FileInputSplit(splitNum++, file.getPath(), 0, 0, hosts);
            inputSplits.add(fis);
        }
    }
    return inputSplits.toArray(new FileInputSplit[inputSplits.size()]);
}",3.227272727272727,0.6887755102040817,2.1666666666666665,0.5,1.6666666666666667,3.734058329214039,-1.2893604817895044,3.0833333333333335,-0.028571428571428574,18.520701898655567
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_add180fb,1,"@Override
public Map<String, Set<Text>> getLocalityGroups(String tableName) throws AccumuloException, TableNotFoundException {
    return null;
}",,"@Override
public Map<String, Set<Text>> getLocalityGroups(String tableName) throws AccumuloException, TableNotFoundException {
    return null;
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8210496128477202,-0.5,0.2285714285714286,-0.16422749602751402
flink,remotes/origin/bugs-dot-jar_FLINK-3534_734ba01d,0,"public void fail(Throwable t) {
    while (true) {
        JobStatus current = state;
        if (current == JobStatus.FAILED || current == JobStatus.FAILING) {
            return;
        } else if (transitionState(current, JobStatus.FAILING, t)) {
            this.failureCause = t;
            if (!verticesInCreationOrder.isEmpty()) {
                // cancel all. what is failed will not cancel but stay failed
                for (ExecutionJobVertex ejv : verticesInCreationOrder) {
                    ejv.cancel();
                }
            } else {
                // set the state of the job to failed
                transitionState(JobStatus.FAILING, JobStatus.FAILED, t);
            }
            return;
        }
    // no need to treat other states
    }
}",,"public void fail(Throwable t) {
    while (true) {
        JobStatus current = state;
        if (current == JobStatus.FAILED || current == JobStatus.FAILING) {
            return;
        } else if (transitionState(current, JobStatus.FAILING, t)) {
            this.failureCause = t;
            if (!verticesInCreationOrder.isEmpty()) {
                                for (ExecutionJobVertex ejv : verticesInCreationOrder) {
                    ejv.cancel();
                }
            } else {
                                transitionState(JobStatus.FAILING, JobStatus.FAILED, t);
            }
            return;
        }
        }
}",0.18181818181818182,1.1989795918367347,0.3333333333333333,1.5,0.3333333333333333,0.41028175976272874,-0.1258961858330944,-0.16666666666666666,0.028571428571428574,0.1367691589465524
Closure,90,2,"@Override
public boolean apply(JSType type) {
    // union types can also be object types, etc.
    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {
        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());
        return false;
    }
    return true;
}",,"@Override
public boolean apply(JSType type) {
        if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {
        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());
        return false;
    }
    return true;
}",-0.2727272727272727,0.051020408163265356,-0.3333333333333333,-0.5,-0.16666666666666666,-0.3806228373702422,0.4221393748207629,-0.16666666666666666,0.7714285714285716,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1369_ce0b0955,1,"private Expression parsePropertyOrFunction() throws ParseException {
    StringBuilder buff = new StringBuilder();
    boolean isPath = false;
    while (true) {
        if (currentTokenType == IDENTIFIER) {
            String name = readPathSegment();
            buff.append(name);
        } else if (readIf(""*"")) {
            // any node
            buff.append('*');
            isPath = true;
        } else if (readIf(""."")) {
            buff.append('.');
            if (readIf(""."")) {
                buff.append('.');
            }
            isPath = true;
        } else if (readIf(""@"")) {
            if (readIf(""*"")) {
                // xpath supports @*, even thought jackrabbit may not
                buff.append('*');
            } else {
                buff.append(readPathSegment());
            }
            return new Expression.Property(currentSelector, buff.toString(), false);
        } else {
            break;
        }
        if (readIf(""/"")) {
            isPath = true;
            buff.append('/');
        } else {
            break;
        }
    }
    if (!isPath && readIf(""("")) {
        return parseFunction(buff.toString());
    } else if (buff.length() > 0) {
        // jcr:contains(jcr:content, 'x')
        if (buff.toString().equals(""."")) {
            buff = new StringBuilder(""*"");
        } else {
            buff.append(""/*"");
        }
        return new Expression.Property(currentSelector, buff.toString(), true);
    }
    throw getSyntaxError();
}",,"private Expression parsePropertyOrFunction() throws ParseException {
    StringBuilder buff = new StringBuilder();
    boolean isPath = false;
    while (true) {
        if (currentTokenType == IDENTIFIER) {
            String name = readPathSegment();
            buff.append(name);
        } else if (readIf(""*"")) {
                        buff.append('*');
            isPath = true;
        } else if (readIf(""."")) {
            buff.append('.');
            if (readIf(""."")) {
                buff.append('.');
            }
            isPath = true;
        } else if (readIf(""@"")) {
            if (readIf(""*"")) {
                                buff.append('*');
            } else {
                buff.append(readPathSegment());
            }
            return new Expression.Property(currentSelector, buff.toString(), false);
        } else {
            break;
        }
        if (readIf(""/"")) {
            isPath = true;
            buff.append('/');
        } else {
            break;
        }
    }
    if (!isPath && readIf(""("")) {
        return parseFunction(buff.toString());
    } else if (buff.length() > 0) {
                if (buff.toString().equals(""."")) {
            buff = new StringBuilder(""*"");
        } else {
            buff.append(""/*"");
        }
        return new Expression.Property(currentSelector, buff.toString(), true);
    }
    throw getSyntaxError();
}",1.4090909090909092,0.44897959183673464,1.8333333333333333,2.0,1.3333333333333333,0.7523479980227388,-0.7662747347289935,1.5833333333333333,-0.028571428571428574,1.0575293064532019
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7,3,"public void getResult() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {
    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
        throw new IllegalStateException(""Method call not finished!"");
    }
    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
    (new Client(prot)).recv_removeTableProperty();
}",,"public void getResult() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {
    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
        throw new IllegalStateException(""Method call not finished!"");
    }
    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
    (new Client(prot)).recv_removeTableProperty();
}",-0.2727272727272727,-0.31632653061224497,-0.16666666666666666,-0.5,-0.25,-0.07019278299555112,0.22999713220533405,0.0,-0.028571428571428574,-0.00900715689927659
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2899_31aea2ad,0,"// TODO Remove deprecation warning suppression when Hadoop1 support is dropped
@SuppressWarnings(""deprecation"")
/**
 * Scans write-ahead log directories for logs. The maps passed in are
 * populated with scan information.
 *
 * @param walDirs write-ahead log directories
 * @param fileToServerMap map of file paths to servers
 * @param nameToFileMap map of file names to paths
 * @return number of servers located (including those with no logs present)
 */
int scanServers(String[] walDirs, Map<Path, String> fileToServerMap, Map<String, Path> nameToFileMap) throws Exception {
    Set<String> servers = new HashSet<String>();
    for (String walDir : walDirs) {
        Path walRoot = new Path(walDir);
        FileStatus[] listing = null;
        try {
            listing = fs.listStatus(walRoot);
        } catch (FileNotFoundException e) {
        // ignore dir
        }
        if (listing == null)
            continue;
        for (FileStatus status : listing) {
            String server = status.getPath().getName();
            servers.add(server);
            if (status.isDir()) {
                for (FileStatus file : fs.listStatus(new Path(walRoot, server))) {
                    if (isUUID(file.getPath().getName())) {
                        fileToServerMap.put(file.getPath(), server);
                        nameToFileMap.put(file.getPath().getName(), file.getPath());
                    } else {
                        log.info(""Ignoring file "" + file.getPath() + "" because it doesn't look like a uuid"");
                    }
                }
            } else if (isUUID(server)) {
                // old-style WAL are not under a directory
                fileToServerMap.put(status.getPath(), """");
            } else {
                log.info(""Ignoring file "" + status.getPath() + "" because it doesn't look like a uuid"");
            }
        }
    }
    return servers.size();
}","/**
 * Scans write-ahead log directories for logs. The maps passed in are
 * populated with scan information.
 *
 * @param walDirs write-ahead log directories
 * @param fileToServerMap map of file paths to servers
 * @param nameToFileMap map of file names to paths
 * @return number of servers located (including those with no logs present)
 */
","@SuppressWarnings(""deprecation"")
int scanServers(String[] walDirs, Map<Path, String> fileToServerMap, Map<String, Path> nameToFileMap) throws Exception {
    Set<String> servers = new HashSet<String>();
    for (String walDir : walDirs) {
        Path walRoot = new Path(walDir);
        FileStatus[] listing = null;
        try {
            listing = fs.listStatus(walRoot);
        } catch (FileNotFoundException e) {
                }
        if (listing == null)
            continue;
        for (FileStatus status : listing) {
            String server = status.getPath().getName();
            servers.add(server);
            if (status.isDir()) {
                for (FileStatus file : fs.listStatus(new Path(walRoot, server))) {
                    if (isUUID(file.getPath().getName())) {
                        fileToServerMap.put(file.getPath(), server);
                        nameToFileMap.put(file.getPath().getName(), file.getPath());
                    } else {
                        log.info(""Ignoring file "" + file.getPath() + "" because it doesn't look like a uuid"");
                    }
                }
            } else if (isUUID(server)) {
                                fileToServerMap.put(status.getPath(), """");
            } else {
                log.info(""Ignoring file "" + status.getPath() + "" because it doesn't look like a uuid"");
            }
        }
    }
    return servers.size();
}",0.8636363636363636,1.8826530612244898,1.0,1.5,0.4166666666666667,0.11369253583786461,-0.6045311155721251,1.4166666666666667,-0.028571428571428574,0.4266428531657822
Closure,112,2,"/**
 * For functions with function(this: T, ...) and T as parameters, type
 * inference will set the type of this on a function literal argument to the
 * the actual type of T.
 */
private boolean inferTemplatedTypesForCall(Node n, FunctionType fnType) {
    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap().getTemplateKeys();
    if (keys.isEmpty()) {
        return false;
    }
    // Try to infer the template types
    Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n);
    // Replace all template types. If we couldn't find a replacement, we
    // replace it with UNKNOWN.
    TemplateTypeReplacer replacer = new TemplateTypeReplacer(registry, inferred);
    Node callTarget = n.getFirstChild();
    FunctionType replacementFnType = fnType.visit(replacer).toMaybeFunctionType();
    Preconditions.checkNotNull(replacementFnType);
    callTarget.setJSType(replacementFnType);
    n.setJSType(replacementFnType.getReturnType());
    return replacer.madeChanges;
}","/**
 * For functions with function(this: T, ...) and T as parameters, type
 * inference will set the type of this on a function literal argument to the
 * the actual type of T.
 */
","private boolean inferTemplatedTypesForCall(Node n, FunctionType fnType) {
    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap().getTemplateKeys();
    if (keys.isEmpty()) {
        return false;
    }
        Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n);
            TemplateTypeReplacer replacer = new TemplateTypeReplacer(registry, inferred);
    Node callTarget = n.getFirstChild();
    FunctionType replacementFnType = fnType.visit(replacer).toMaybeFunctionType();
    Preconditions.checkNotNull(replacementFnType);
    callTarget.setJSType(replacementFnType);
    n.setJSType(replacementFnType.getReturnType());
    return replacer.madeChanges;
}",0.0,-0.6071428571428571,-0.3333333333333333,-0.5,-0.25,-0.3806228373702422,-0.04559793518784066,0.4166666666666667,-0.028571428571428574,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-5226_8e518d88,1,"@Override
public void onInstantiation(Component component) {
    Class<? extends Component> componentClass = component.getClass();
    if (componentClass.isMemberClass() && Modifier.isStatic(componentClass.getModifiers()) == false) {
        LOG.debug(""Skipping non-static inner class '{}' "", componentClass);
    } else {
        inject(component);
    }
}",,"@Override
public void onInstantiation(Component component) {
    Class<? extends Component> componentClass = component.getClass();
    if (componentClass.isMemberClass() && Modifier.isStatic(componentClass.getModifiers()) == false) {
        LOG.debug(""Skipping non-static inner class '{}' "", componentClass);
    } else {
        inject(component);
    }
}",-0.22727272727272727,-0.035714285714285636,-0.3333333333333333,-0.5,0.0,-0.11369253583786453,0.2890737023229137,0.0,0.2571428571428572,-0.09911298992209217
Cli,22,1,"/**
 * Add the special token ""<b>--</b>"" and the current <code>value</code>
 * to the processed tokens list. Then add all the remaining
 * <code>argument</code> values to the processed tokens list.
 *
 * @param value The current token
 */
private void processNonOptionToken(String value) {
    eatTheRest = true;
    tokens.add(""--"");
    tokens.add(value);
}","/**
 * Add the special token ""<b>--</b>"" and the current <code>value</code>
 * to the processed tokens list. Then add all the remaining
 * <code>argument</code> values to the processed tokens list.
 *
 * @param value The current token
 */
","private void processNonOptionToken(String value) {
    eatTheRest = true;
    tokens.add(""--"");
    tokens.add(value);
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7114998566102669,-0.3333333333333333,2.4571428571428573,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1308_69ba2a54,1,"private Expression parsePropertyOrFunction() throws ParseException {
    StringBuilder buff = new StringBuilder();
    boolean isPath = false;
    while (true) {
        if (currentTokenType == IDENTIFIER) {
            String name = readIdentifier();
            buff.append(name);
        } else if (readIf(""*"")) {
            // any node
            buff.append('*');
            isPath = true;
        } else if (readIf(""."")) {
            buff.append('.');
            if (readIf(""."")) {
                buff.append('.');
            }
            isPath = true;
        } else if (readIf(""@"")) {
            if (readIf(""*"")) {
                // xpath supports @*, even thought jackrabbit may not
                buff.append('*');
            } else {
                buff.append(readIdentifier());
            }
            return new Expression.Property(currentSelector, buff.toString());
        } else {
            break;
        }
        if (readIf(""/"")) {
            isPath = true;
            buff.append('/');
        } else {
            break;
        }
    }
    if (!isPath && readIf(""("")) {
        return parseFunction(buff.toString());
    } else if (buff.length() > 0) {
        // jcr:contains(jcr:content, 'x')
        if (buff.toString().equals(""."")) {
            buff = new StringBuilder(""*"");
        } else {
            buff.append(""/*"");
        }
        return new Expression.Property(currentSelector, buff.toString());
    }
    throw getSyntaxError();
}",,"private Expression parsePropertyOrFunction() throws ParseException {
    StringBuilder buff = new StringBuilder();
    boolean isPath = false;
    while (true) {
        if (currentTokenType == IDENTIFIER) {
            String name = readIdentifier();
            buff.append(name);
        } else if (readIf(""*"")) {
                        buff.append('*');
            isPath = true;
        } else if (readIf(""."")) {
            buff.append('.');
            if (readIf(""."")) {
                buff.append('.');
            }
            isPath = true;
        } else if (readIf(""@"")) {
            if (readIf(""*"")) {
                                buff.append('*');
            } else {
                buff.append(readIdentifier());
            }
            return new Expression.Property(currentSelector, buff.toString());
        } else {
            break;
        }
        if (readIf(""/"")) {
            isPath = true;
            buff.append('/');
        } else {
            break;
        }
    }
    if (!isPath && readIf(""("")) {
        return parseFunction(buff.toString());
    } else if (buff.length() > 0) {
                if (buff.toString().equals(""."")) {
            buff = new StringBuilder(""*"");
        } else {
            buff.append(""/*"");
        }
        return new Expression.Property(currentSelector, buff.toString());
    }
    throw getSyntaxError();
}",1.4090909090909092,0.44897959183673464,1.8333333333333333,2.0,1.3333333333333333,0.726643598615917,-0.7631201605965015,1.5833333333333333,-0.028571428571428574,1.0045100029552727
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1174_342809f7,3,"public static boolean parse(String jcrPath, Listener listener) {
    // check for length
    int len = jcrPath == null ? 0 : jcrPath.length();
    // shortcut for root path
    if (len == 1 && jcrPath.charAt(0) == '/') {
        listener.root();
        return true;
    }
    // short cut for empty path
    if (len == 0) {
        return true;
    }
    // check if absolute path
    int pos = 0;
    if (jcrPath.charAt(0) == '/') {
        if (!listener.root()) {
            return false;
        }
        pos++;
    }
    // parse the path
    int state = STATE_PREFIX_START;
    int lastPos = pos;
    String name = null;
    int index = 0;
    boolean wasSlash = false;
    while (pos <= len) {
        char c = pos == len ? EOF : jcrPath.charAt(pos);
        pos++;
        // special check for whitespace
        if (c != ' ' && Character.isWhitespace(c)) {
            c = '\t';
        }
        switch(c) {
            case '/':
            case EOF:
                if (state == STATE_PREFIX_START && c != EOF) {
                    listener.error('\'' + jcrPath + ""' is not a valid path. "" + ""double slash '//' not allowed."");
                    return false;
                }
                if (state == STATE_PREFIX || state == STATE_NAME || state == STATE_INDEX_END || state == STATE_URI_END) {
                    // eof path element
                    if (name == null) {
                        if (wasSlash) {
                            listener.error('\'' + jcrPath + ""' is not a valid path: "" + ""Trailing slashes not allowed in prefixes and names."");
                            return false;
                        }
                        name = jcrPath.substring(lastPos, pos - 1);
                    }
                    if (!JcrNameParser.parse(name, listener, index)) {
                        return false;
                    }
                    state = STATE_PREFIX_START;
                    lastPos = pos;
                    name = null;
                    index = 0;
                } else if (state == STATE_DOT) {
                    if (!listener.current()) {
                        return false;
                    }
                    lastPos = pos;
                    state = STATE_PREFIX_START;
                } else if (state == STATE_DOTDOT) {
                    if (!listener.parent()) {
                        return false;
                    }
                    lastPos = pos;
                    state = STATE_PREFIX_START;
                } else if (state != STATE_URI && !(state == STATE_PREFIX_START && c == EOF)) {
                    // ignore trailing slash
                    listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c + ""' not a valid name character."");
                    return false;
                }
                break;
            case '.':
                if (state == STATE_PREFIX_START) {
                    state = STATE_DOT;
                } else if (state == STATE_DOT) {
                    state = STATE_DOTDOT;
                } else if (state == STATE_DOTDOT) {
                    state = STATE_PREFIX;
                } else if (state == STATE_INDEX_END) {
                    listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c + ""' not valid after index. '/' expected."");
                    return false;
                }
                break;
            case ':':
                if (state == STATE_PREFIX_START) {
                    listener.error('\'' + jcrPath + ""' is not a valid path. Prefix "" + ""must not be empty"");
                    return false;
                } else if (state == STATE_PREFIX) {
                    if (wasSlash) {
                        listener.error('\'' + jcrPath + ""' is not a valid path: "" + ""Trailing slashes not allowed in prefixes and names."");
                        return false;
                    }
                    state = STATE_NAME_START;
                // don't reset the lastPos/pos since prefix+name are passed together to the NameResolver
                } else if (state != STATE_URI) {
                    listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c + ""' not valid name character"");
                    return false;
                }
                break;
            case '[':
                if (state == STATE_PREFIX || state == STATE_NAME) {
                    if (wasSlash) {
                        listener.error('\'' + jcrPath + ""' is not a valid path: "" + ""Trailing slashes not allowed in prefixes and names."");
                        return false;
                    }
                    state = STATE_INDEX;
                    name = jcrPath.substring(lastPos, pos - 1);
                    lastPos = pos;
                }
                break;
            case ']':
                if (state == STATE_INDEX) {
                    try {
                        index = Integer.parseInt(jcrPath.substring(lastPos, pos - 1));
                    } catch (NumberFormatException e) {
                        listener.error('\'' + jcrPath + ""' is not a valid path. "" + ""NumberFormatException in index: "" + jcrPath.substring(lastPos, pos - 1));
                        return false;
                    }
                    if (index < 0) {
                        listener.error('\'' + jcrPath + ""' is not a valid path. "" + ""Index number invalid: "" + index);
                        return false;
                    }
                    state = STATE_INDEX_END;
                } else {
                    listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c + ""' not a valid name character."");
                    return false;
                }
                break;
            case ' ':
                if (state == STATE_PREFIX_START || state == STATE_NAME_START) {
                    listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c + ""' not valid name start"");
                    return false;
                } else if (state == STATE_INDEX_END) {
                    listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c + ""' not valid after index. '/' expected."");
                    return false;
                } else if (state == STATE_DOT || state == STATE_DOTDOT) {
                    state = STATE_PREFIX;
                }
                break;
            case '\t':
                listener.error('\'' + jcrPath + ""' is not a valid path. "" + ""Whitespace not a allowed in name."");
                return false;
            case '*':
            case '|':
                listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c + ""' not a valid name character."");
                return false;
            case '{':
                if (state == STATE_PREFIX_START && lastPos == pos - 1) {
                    // '{' marks the start of a uri enclosed in an expanded name
                    // instead of the usual namespace prefix, if it is
                    // located at the beginning of a new segment.
                    state = STATE_URI;
                } else if (state == STATE_NAME_START || state == STATE_DOT || state == STATE_DOTDOT) {
                    // otherwise it's part of the local name
                    state = STATE_NAME;
                }
                break;
            case '}':
                if (state == STATE_URI) {
                    state = STATE_URI_END;
                }
                break;
            default:
                if (state == STATE_PREFIX_START || state == STATE_DOT || state == STATE_DOTDOT) {
                    state = STATE_PREFIX;
                } else if (state == STATE_NAME_START) {
                    state = STATE_NAME;
                } else if (state == STATE_INDEX_END) {
                    listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c + ""' not valid after index. '/' expected."");
                    return false;
                }
        }
        wasSlash = c == ' ';
    }
    return true;
}",,"public static boolean parse(String jcrPath, Listener listener) {
        int len = jcrPath == null ? 0 : jcrPath.length();
        if (len == 1 && jcrPath.charAt(0) == '/') {
        listener.root();
        return true;
    }
        if (len == 0) {
        return true;
    }
        int pos = 0;
    if (jcrPath.charAt(0) == '/') {
        if (!listener.root()) {
            return false;
        }
        pos++;
    }
        int state = STATE_PREFIX_START;
    int lastPos = pos;
    String name = null;
    int index = 0;
    boolean wasSlash = false;
    while (pos <= len) {
        char c = pos == len ? EOF : jcrPath.charAt(pos);
        pos++;
                if (c != ' ' && Character.isWhitespace(c)) {
            c = '\t';
        }
        switch(c) {
            case '/':
            case EOF:
                if (state == STATE_PREFIX_START && c != EOF) {
                    listener.error('\'' + jcrPath + ""' is not a valid path. "" + ""double slash '//' not allowed."");
                    return false;
                }
                if (state == STATE_PREFIX || state == STATE_NAME || state == STATE_INDEX_END || state == STATE_URI_END) {
                                        if (name == null) {
                        if (wasSlash) {
                            listener.error('\'' + jcrPath + ""' is not a valid path: "" + ""Trailing slashes not allowed in prefixes and names."");
                            return false;
                        }
                        name = jcrPath.substring(lastPos, pos - 1);
                    }
                    if (!JcrNameParser.parse(name, listener, index)) {
                        return false;
                    }
                    state = STATE_PREFIX_START;
                    lastPos = pos;
                    name = null;
                    index = 0;
                } else if (state == STATE_DOT) {
                    if (!listener.current()) {
                        return false;
                    }
                    lastPos = pos;
                    state = STATE_PREFIX_START;
                } else if (state == STATE_DOTDOT) {
                    if (!listener.parent()) {
                        return false;
                    }
                    lastPos = pos;
                    state = STATE_PREFIX_START;
                } else if (state != STATE_URI && !(state == STATE_PREFIX_START && c == EOF)) {
                                        listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c + ""' not a valid name character."");
                    return false;
                }
                break;
            case '.':
                if (state == STATE_PREFIX_START) {
                    state = STATE_DOT;
                } else if (state == STATE_DOT) {
                    state = STATE_DOTDOT;
                } else if (state == STATE_DOTDOT) {
                    state = STATE_PREFIX;
                } else if (state == STATE_INDEX_END) {
                    listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c + ""' not valid after index. '/' expected."");
                    return false;
                }
                break;
            case ':':
                if (state == STATE_PREFIX_START) {
                    listener.error('\'' + jcrPath + ""' is not a valid path. Prefix "" + ""must not be empty"");
                    return false;
                } else if (state == STATE_PREFIX) {
                    if (wasSlash) {
                        listener.error('\'' + jcrPath + ""' is not a valid path: "" + ""Trailing slashes not allowed in prefixes and names."");
                        return false;
                    }
                    state = STATE_NAME_START;
                                } else if (state != STATE_URI) {
                    listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c + ""' not valid name character"");
                    return false;
                }
                break;
            case '[':
                if (state == STATE_PREFIX || state == STATE_NAME) {
                    if (wasSlash) {
                        listener.error('\'' + jcrPath + ""' is not a valid path: "" + ""Trailing slashes not allowed in prefixes and names."");
                        return false;
                    }
                    state = STATE_INDEX;
                    name = jcrPath.substring(lastPos, pos - 1);
                    lastPos = pos;
                }
                break;
            case ']':
                if (state == STATE_INDEX) {
                    try {
                        index = Integer.parseInt(jcrPath.substring(lastPos, pos - 1));
                    } catch (NumberFormatException e) {
                        listener.error('\'' + jcrPath + ""' is not a valid path. "" + ""NumberFormatException in index: "" + jcrPath.substring(lastPos, pos - 1));
                        return false;
                    }
                    if (index < 0) {
                        listener.error('\'' + jcrPath + ""' is not a valid path. "" + ""Index number invalid: "" + index);
                        return false;
                    }
                    state = STATE_INDEX_END;
                } else {
                    listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c + ""' not a valid name character."");
                    return false;
                }
                break;
            case ' ':
                if (state == STATE_PREFIX_START || state == STATE_NAME_START) {
                    listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c + ""' not valid name start"");
                    return false;
                } else if (state == STATE_INDEX_END) {
                    listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c + ""' not valid after index. '/' expected."");
                    return false;
                } else if (state == STATE_DOT || state == STATE_DOTDOT) {
                    state = STATE_PREFIX;
                }
                break;
            case '\t':
                listener.error('\'' + jcrPath + ""' is not a valid path. "" + ""Whitespace not a allowed in name."");
                return false;
            case '*':
            case '|':
                listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c + ""' not a valid name character."");
                return false;
            case '{':
                if (state == STATE_PREFIX_START && lastPos == pos - 1) {
                                                                                state = STATE_URI;
                } else if (state == STATE_NAME_START || state == STATE_DOT || state == STATE_DOTDOT) {
                                        state = STATE_NAME;
                }
                break;
            case '}':
                if (state == STATE_URI) {
                    state = STATE_URI_END;
                }
                break;
            default:
                if (state == STATE_PREFIX_START || state == STATE_DOT || state == STATE_DOTDOT) {
                    state = STATE_PREFIX;
                } else if (state == STATE_NAME_START) {
                    state = STATE_NAME;
                } else if (state == STATE_INDEX_END) {
                    listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c + ""' not valid after index. '/' expected."");
                    return false;
                }
        }
        wasSlash = c == ' ';
    }
    return true;
}",6.909090909090909,1.5408163265306123,9.666666666666666,2.5,6.5,4.746416213544242,-1.9555491826785207,2.0833333333333335,-0.028571428571428574,34.26401720054309
Closure,166,2,"@Override
public void matchConstraint(JSType constraint) {
    // We only want to match constraints on anonymous types.
    if (hasReferenceName()) {
        return;
    }
    // properties on this object.
    if (constraint.isRecordType()) {
        matchRecordTypeConstraint(constraint.toObjectType());
    }
}",,"@Override
public void matchConstraint(JSType constraint) {
        if (hasReferenceName()) {
        return;
    }
        if (constraint.isRecordType()) {
        matchRecordTypeConstraint(constraint.toObjectType());
    }
}",-0.22727272727272727,-0.035714285714285636,-0.16666666666666666,-0.5,-0.08333333333333333,-0.3806228373702422,0.45712646974476634,-0.16666666666666666,2.085714285714286,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-395_962315ba,1,"/**
 * Find the minimum of the function {@code f} within the interval {@code (a, b)}.
 *
 * If the function {@code f} is defined on the interval {@code (a, b)}, then
 * this method finds an approximation {@code x} to the point at which {@code f}
 * attains its minimum.<br/>
 * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t} and
 * {@code f} is never evaluated at two points closer together than {@code tol}.
 * {@code eps} should be no smaller than <em>2 macheps</em> and preferable not
 * much less than <em>sqrt(macheps)</em>, where <em>macheps</em> is the relative
 * machine precision. {@code t} should be positive.
 * @param f the function to solve.
 * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}
 * or {@link GoalType#MINIMIZE}.
 * @param lo Lower bound of the interval.
 * @param mid Point inside the interval {@code [lo, hi]}.
 * @param hi Higher bound of the interval.
 * @param eps Relative accuracy.
 * @param t Absolute accuracy.
 * @return the optimum point.
 * @throws MaxIterationsExceededException if the maximum iteration count
 * is exceeded.
 * @throws FunctionEvaluationException if an error occurs evaluating
 * the function.
 */
private double localMin(UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {
    if (eps <= 0) {
        throw new NotStrictlyPositiveException(eps);
    }
    if (t <= 0) {
        throw new NotStrictlyPositiveException(t);
    }
    double a, b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }
    double x = mid;
    double v = x;
    double w = x;
    double e = 0;
    double fx = computeObjectiveValue(f, x);
    if (goalType == GoalType.MAXIMIZE) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;
    int count = 0;
    while (count < maximalIterationCount) {
        double m = 0.5 * (a + b);
        final double tol1 = eps * Math.abs(x) + t;
        final double tol2 = 2 * tol1;
        // Check stopping criterion.
        if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {
            double p = 0;
            double q = 0;
            double r = 0;
            double d = 0;
            double u = 0;
            if (Math.abs(e) > tol1) {
                // Fit parabola.
                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);
                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }
                r = e;
                e = d;
                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {
                    // Parabolic interpolation step.
                    d = p / q;
                    u = x + d;
                    // f must not be evaluated too close to a or b.
                    if (u - a < tol2 || b - u < tol2) {
                        if (x <= m) {
                            d = tol1;
                        } else {
                            d = -tol1;
                        }
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }
            } else {
                // Golden section step.
                if (x < m) {
                    e = b - x;
                } else {
                    e = a - x;
                }
                d = GOLDEN_SECTION * e;
            }
            // Update by at least ""tol1"".
            if (Math.abs(d) < tol1) {
                if (d >= 0) {
                    u = x + tol1;
                } else {
                    u = x - tol1;
                }
            } else {
                u = x + d;
            }
            double fu = computeObjectiveValue(f, u);
            if (goalType == GoalType.MAXIMIZE) {
                fu = -fu;
            }
            // Update a, b, v, w and x.
            if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || w == x) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || v == x || v == w) {
                    v = u;
                    fv = fu;
                }
            }
        } else {
            // termination
            setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);
            return x;
        }
        ++count;
    }
    throw new MaxIterationsExceededException(maximalIterationCount);
}","/**
 * Find the minimum of the function {@code f} within the interval {@code (a, b)}.
 *
 * If the function {@code f} is defined on the interval {@code (a, b)}, then
 * this method finds an approximation {@code x} to the point at which {@code f}
 * attains its minimum.<br/>
 * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t} and
 * {@code f} is never evaluated at two points closer together than {@code tol}.
 * {@code eps} should be no smaller than <em>2 macheps</em> and preferable not
 * much less than <em>sqrt(macheps)</em>, where <em>macheps</em> is the relative
 * machine precision. {@code t} should be positive.
 * @param f the function to solve.
 * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}
 * or {@link GoalType#MINIMIZE}.
 * @param lo Lower bound of the interval.
 * @param mid Point inside the interval {@code [lo, hi]}.
 * @param hi Higher bound of the interval.
 * @param eps Relative accuracy.
 * @param t Absolute accuracy.
 * @return the optimum point.
 * @throws MaxIterationsExceededException if the maximum iteration count
 * is exceeded.
 * @throws FunctionEvaluationException if an error occurs evaluating
 * the function.
 */
","private double localMin(UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {
    if (eps <= 0) {
        throw new NotStrictlyPositiveException(eps);
    }
    if (t <= 0) {
        throw new NotStrictlyPositiveException(t);
    }
    double a, b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }
    double x = mid;
    double v = x;
    double w = x;
    double e = 0;
    double fx = computeObjectiveValue(f, x);
    if (goalType == GoalType.MAXIMIZE) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;
    int count = 0;
    while (count < maximalIterationCount) {
        double m = 0.5 * (a + b);
        final double tol1 = eps * Math.abs(x) + t;
        final double tol2 = 2 * tol1;
                if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {
            double p = 0;
            double q = 0;
            double r = 0;
            double d = 0;
            double u = 0;
            if (Math.abs(e) > tol1) {
                                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);
                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }
                r = e;
                e = d;
                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {
                                        d = p / q;
                    u = x + d;
                                        if (u - a < tol2 || b - u < tol2) {
                        if (x <= m) {
                            d = tol1;
                        } else {
                            d = -tol1;
                        }
                    }
                } else {
                                        if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }
            } else {
                                if (x < m) {
                    e = b - x;
                } else {
                    e = a - x;
                }
                d = GOLDEN_SECTION * e;
            }
                        if (Math.abs(d) < tol1) {
                if (d >= 0) {
                    u = x + tol1;
                } else {
                    u = x - tol1;
                }
            } else {
                u = x + d;
            }
            double fu = computeObjectiveValue(f, u);
            if (goalType == GoalType.MAXIMIZE) {
                fu = -fu;
            }
                        if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || w == x) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || v == x || v == w) {
                    v = u;
                    fv = fu;
                }
            }
        } else {
                        setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);
            return x;
        }
        ++count;
    }
    throw new MaxIterationsExceededException(maximalIterationCount);
}",4.954545454545454,1.693877551020408,3.6666666666666665,2.0,4.416666666666667,6.903608502224421,-1.5377114998566108,0.25,-0.028571428571428574,36.94385838676381
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2246_dcadb0e1,1,"@Override
public void endNode(NodeInfo nodeInfo) throws RepositoryException {
    Tree parent = parents.pop();
    if (parent == null) {
        if (pnImporter != null) {
            pnImporter.endChildInfo();
        }
    } else if (getDefinition(parent).isProtected()) {
        if (pnImporter != null) {
            pnImporter.end(parent);
            // and reset the pnImporter field waiting for the next protected
            // parent -> selecting again from available importers
            pnImporter = null;
        }
    }
    collectUUIDs(parent);
}",,"@Override
public void endNode(NodeInfo nodeInfo) throws RepositoryException {
    Tree parent = parents.pop();
    if (parent == null) {
        if (pnImporter != null) {
            pnImporter.endChildInfo();
        }
    } else if (getDefinition(parent).isProtected()) {
        if (pnImporter != null) {
            pnImporter.end(parent);
                                    pnImporter = null;
        }
    }
    collectUUIDs(parent);
}",0.045454545454545456,0.5510204081632651,0.16666666666666666,0.5,0.16666666666666666,-0.054374691052891735,-0.003441353599082437,0.0,0.4285714285714286,-0.06361545479075385
camel,remotes/origin/bugs-dot-jar_CAMEL-6964_6b2ffb30,1,"/**
 * Strategy when the file was processed and a commit should be executed.
 *
 * @param processStrategy the strategy to perform the commit
 * @param exchange        the exchange
 * @param file            the file processed
 */
protected void processStrategyCommit(GenericFileProcessStrategy<T> processStrategy, Exchange exchange, GenericFile<T> file) {
    if (endpoint.isIdempotent()) {
        // use absolute file path as default key, but evaluate if an expression key was configured
        String key = absoluteFileName;
        if (endpoint.getIdempotentKey() != null) {
            Exchange dummy = endpoint.createExchange(file);
            key = endpoint.getIdempotentKey().evaluate(dummy, String.class);
        }
        // only add to idempotent repository if we could process the file
        if (key != null) {
            endpoint.getIdempotentRepository().add(key);
        }
    }
    // must be last in batch to delete the done file name
    // delete done file if used (and not noop=true)
    boolean complete = exchange.getProperty(Exchange.BATCH_COMPLETE, false, Boolean.class);
    if (endpoint.getDoneFileName() != null && !endpoint.isNoop()) {
        // done file must be in same path as the original input file
        String doneFileName = endpoint.createDoneFileName(absoluteFileName);
        ObjectHelper.notEmpty(doneFileName, ""doneFileName"", endpoint);
        // we should delete the dynamic done file
        if (endpoint.getDoneFileName().indexOf(""{file:name"") > 0 || complete) {
            try {
                // delete done file
                boolean deleted = operations.deleteFile(doneFileName);
                log.trace(""Done file: {} was deleted: {}"", doneFileName, deleted);
                if (!deleted) {
                    log.warn(""Done file: "" + doneFileName + "" could not be deleted"");
                }
            } catch (Exception e) {
                handleException(""Error deleting done file: "" + doneFileName, exchange, e);
            }
        }
    }
    try {
        log.trace(""Commit file strategy: {} for file: {}"", processStrategy, file);
        processStrategy.commit(operations, endpoint, exchange, file);
    } catch (Exception e) {
        handleException(""Error during commit"", exchange, e);
    }
}","/**
 * Strategy when the file was processed and a commit should be executed.
 *
 * @param processStrategy the strategy to perform the commit
 * @param exchange        the exchange
 * @param file            the file processed
 */
","protected void processStrategyCommit(GenericFileProcessStrategy<T> processStrategy, Exchange exchange, GenericFile<T> file) {
    if (endpoint.isIdempotent()) {
                String key = absoluteFileName;
        if (endpoint.getIdempotentKey() != null) {
            Exchange dummy = endpoint.createExchange(file);
            key = endpoint.getIdempotentKey().evaluate(dummy, String.class);
        }
                if (key != null) {
            endpoint.getIdempotentRepository().add(key);
        }
    }
            boolean complete = exchange.getProperty(Exchange.BATCH_COMPLETE, false, Boolean.class);
    if (endpoint.getDoneFileName() != null && !endpoint.isNoop()) {
                String doneFileName = endpoint.createDoneFileName(absoluteFileName);
        ObjectHelper.notEmpty(doneFileName, ""doneFileName"", endpoint);
                if (endpoint.getDoneFileName().indexOf(""{file:name"") > 0 || complete) {
            try {
                                boolean deleted = operations.deleteFile(doneFileName);
                log.trace(""Done file: {} was deleted: {}"", doneFileName, deleted);
                if (!deleted) {
                    log.warn(""Done file: "" + doneFileName + "" could not be deleted"");
                }
            } catch (Exception e) {
                handleException(""Error deleting done file: "" + doneFileName, exchange, e);
            }
        }
    }
    try {
        log.trace(""Commit file strategy: {} for file: {}"", processStrategy, file);
        processStrategy.commit(operations, endpoint, exchange, file);
    } catch (Exception e) {
        handleException(""Error during commit"", exchange, e);
    }
}",0.9090909090909091,0.9234693877551021,0.8333333333333334,1.0,0.9166666666666666,0.8057340583292142,-0.6455405792945228,1.25,-0.028571428571428574,1.6121268968352884
wicket,remotes/origin/bugs-dot-jar_WICKET-5783_7b8b6767,1,"/**
 *  @return event
 *       the event this behavior is attached to
 */
public final String getEvent() {
    return event;
}","/**
 *  @return event
 *       the event this behavior is attached to
 */
","public final String getEvent() {
    return event;
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.2001720676799543,-0.5,2.8285714285714287,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-9238_169b981e,1,"/**
 * Changes the name of this remote file. This method alters the absolute and
 * relative names as well.
 *
 * @param newName the new name
 */
public void changeFileName(String newName) {
    LOG.trace(""Changing name to: {}"", newName);
    // Make sure the names is normalized.
    String newFileName = FileUtil.normalizePath(newName);
    String newEndpointPath = FileUtil.normalizePath(endpointPath);
    LOG.trace(""Normalized endpointPath: {}"", newEndpointPath);
    LOG.trace(""Normalized newFileName: ()"", newFileName);
    File file = new File(newFileName);
    if (!absolute) {
        // for relative then we should avoid having the endpoint path duplicated so clip it
        if (ObjectHelper.isNotEmpty(newEndpointPath) && newFileName.startsWith(newEndpointPath)) {
            // in this logic here
            if (newEndpointPath.endsWith("""" + File.separatorChar)) {
                newFileName = ObjectHelper.after(newFileName, newEndpointPath);
            } else {
                newFileName = ObjectHelper.after(newFileName, newEndpointPath + File.separatorChar);
            }
            // reconstruct file with clipped name
            file = new File(newFileName);
        }
    }
    // store the file name only
    setFileNameOnly(file.getName());
    setFileName(file.getName());
    // relative path
    if (file.getParent() != null) {
        setRelativeFilePath(file.getParent() + getFileSeparator() + file.getName());
    } else {
        setRelativeFilePath(file.getName());
    }
    // absolute path
    if (isAbsolute(newFileName)) {
        setAbsolute(true);
        setAbsoluteFilePath(newFileName);
    } else {
        setAbsolute(false);
        // construct a pseudo absolute filename that the file operations uses even for relative only
        String path = ObjectHelper.isEmpty(endpointPath) ? """" : endpointPath + getFileSeparator();
        setAbsoluteFilePath(path + getRelativeFilePath());
    }
    if (LOG.isTraceEnabled()) {
        LOG.trace(""FileNameOnly: {}"", getFileNameOnly());
        LOG.trace(""FileName: {}"", getFileName());
        LOG.trace(""Absolute: {}"", isAbsolute());
        LOG.trace(""Relative path: {}"", getRelativeFilePath());
        LOG.trace(""Absolute path: {}"", getAbsoluteFilePath());
        LOG.trace(""Name changed to: {}"", this);
    }
}","/**
 * Changes the name of this remote file. This method alters the absolute and
 * relative names as well.
 *
 * @param newName the new name
 */
","public void changeFileName(String newName) {
    LOG.trace(""Changing name to: {}"", newName);
        String newFileName = FileUtil.normalizePath(newName);
    String newEndpointPath = FileUtil.normalizePath(endpointPath);
    LOG.trace(""Normalized endpointPath: {}"", newEndpointPath);
    LOG.trace(""Normalized newFileName: ()"", newFileName);
    File file = new File(newFileName);
    if (!absolute) {
                if (ObjectHelper.isNotEmpty(newEndpointPath) && newFileName.startsWith(newEndpointPath)) {
                        if (newEndpointPath.endsWith("""" + File.separatorChar)) {
                newFileName = ObjectHelper.after(newFileName, newEndpointPath);
            } else {
                newFileName = ObjectHelper.after(newFileName, newEndpointPath + File.separatorChar);
            }
                        file = new File(newFileName);
        }
    }
        setFileNameOnly(file.getName());
    setFileName(file.getName());
        if (file.getParent() != null) {
        setRelativeFilePath(file.getParent() + getFileSeparator() + file.getName());
    } else {
        setRelativeFilePath(file.getName());
    }
        if (isAbsolute(newFileName)) {
        setAbsolute(true);
        setAbsoluteFilePath(newFileName);
    } else {
        setAbsolute(false);
                String path = ObjectHelper.isEmpty(endpointPath) ? """" : endpointPath + getFileSeparator();
        setAbsoluteFilePath(path + getRelativeFilePath());
    }
    if (LOG.isTraceEnabled()) {
        LOG.trace(""FileNameOnly: {}"", getFileNameOnly());
        LOG.trace(""FileName: {}"", getFileName());
        LOG.trace(""Absolute: {}"", isAbsolute());
        LOG.trace(""Relative path: {}"", getRelativeFilePath());
        LOG.trace(""Absolute path: {}"", getAbsoluteFilePath());
        LOG.trace(""Name changed to: {}"", this);
    }
}",1.2272727272727273,0.2959183673469388,0.6666666666666666,0.5,1.25,0.5803262481463175,-0.7421852595354174,2.9166666666666665,-0.028571428571428574,1.4400186738963772
camel,remotes/origin/bugs-dot-jar_CAMEL-5215_033eb6fe,3,"@Converter
public static InputStream genericFileToInputStream(GenericFile<?> file, Exchange exchange) throws IOException {
    if (exchange != null) {
        // use a file input stream if its a java.io.File
        if (file.getFile() instanceof java.io.File) {
            return IOHelper.buffered(new FileInputStream((File) file.getFile()));
        }
        // otherwise ensure the body is loaded as we want the input stream of the body
        file.getBinding().loadContent(exchange, file);
        return exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, file.getBody());
    } else {
        // should revert to fallback converter if we don't have an exchange
        return null;
    }
}",,"@Converter
public static InputStream genericFileToInputStream(GenericFile<?> file, Exchange exchange) throws IOException {
    if (exchange != null) {
                if (file.getFile() instanceof java.io.File) {
            return IOHelper.buffered(new FileInputStream((File) file.getFile()));
        }
                file.getBinding().loadContent(exchange, file);
        return exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, file.getBody());
    } else {
                return null;
    }
}",-0.09090909090909091,0.3826530612244898,-0.16666666666666666,0.0,-0.08333333333333333,-0.3806228373702422,0.08746773731000855,0.25,-0.028571428571428574,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3021_494da6de,1,"@Override
public Validator childNodeChanged(String name, NodeState before, NodeState after) throws CommitFailedException {
    Tree treeAfter = checkNotNull(parentAfter.getChild(name));
    checkValidTree(parentAfter, treeAfter, after);
    return new AccessControlValidator(this, treeAfter);
}",,"@Override
public Validator childNodeChanged(String name, NodeState before, NodeState after) throws CommitFailedException {
    Tree treeAfter = checkNotNull(parentAfter.getChild(name));
    checkValidTree(parentAfter, treeAfter, after);
    return new AccessControlValidator(this, treeAfter);
}",-0.36363636363636365,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.5012905075996561,-0.25,0.0,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-3394_18e1a142,3,"public void done(boolean doneSync) {
    // we are done with the exchange pair
    pair.done();
    // we only have to handle async completion of the routing slip
    if (doneSync) {
        return;
    }
    // continue processing the multicast asynchronously
    Exchange subExchange = exchange;
    // Decide whether to continue with the multicast or not; similar logic to the Pipeline
    // remember to test for stop on exception and aggregate before copying back results
    boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, ""Sequential processing failed for number "" + total.get(), LOG);
    if (stopOnException && !continueProcessing) {
        if (subExchange.getException() != null) {
            // wrap in exception to explain where it failed
            subExchange.setException(new CamelExchangeException(""Sequential processing failed for number "" + total, subExchange, subExchange.getException()));
        } else {
            // we want to stop on exception, and the exception was handled by the error handler
            // this is similar to what the pipeline does, so we should do the same to not surprise end users
            // so we should set the failed exchange as the result and be done
            result.set(subExchange);
        }
        // and do the done work
        doDone(original, subExchange, callback, false);
        return;
    }
    try {
        doAggregate(getAggregationStrategy(subExchange), result, subExchange);
    } catch (Throwable e) {
        // wrap in exception to explain where it failed
        subExchange.setException(new CamelExchangeException(""Sequential processing failed for number "" + total, subExchange, e));
        // and do the done work
        doDone(original, subExchange, callback, false);
        return;
    }
    total.incrementAndGet();
    // maybe there are more processors to multicast
    while (it.hasNext()) {
        // prepare and run the next
        ProcessorExchangePair pair = it.next();
        subExchange = pair.getExchange();
        updateNewExchange(subExchange, total.get(), pairs, it);
        boolean sync = doProcessSequential(original, result, pairs, it, pair, callback, total);
        if (!sync) {
            if (LOG.isTraceEnabled()) {
                LOG.trace(""Processing exchangeId: "" + original.getExchangeId() + "" is continued being processed asynchronously"");
            }
            return;
        }
        // Decide whether to continue with the multicast or not; similar logic to the Pipeline
        // remember to test for stop on exception and aggregate before copying back results
        continueProcessing = PipelineHelper.continueProcessing(subExchange, ""Sequential processing failed for number "" + total.get(), LOG);
        if (stopOnException && !continueProcessing) {
            if (subExchange.getException() != null) {
                // wrap in exception to explain where it failed
                subExchange.setException(new CamelExchangeException(""Sequential processing failed for number "" + total, subExchange, subExchange.getException()));
            } else {
                // we want to stop on exception, and the exception was handled by the error handler
                // this is similar to what the pipeline does, so we should do the same to not surprise end users
                // so we should set the failed exchange as the result and be done
                result.set(subExchange);
            }
            // and do the done work
            doDone(original, subExchange, callback, false);
            return;
        }
        try {
            doAggregate(getAggregationStrategy(subExchange), result, subExchange);
        } catch (Throwable e) {
            // wrap in exception to explain where it failed
            subExchange.setException(new CamelExchangeException(""Sequential processing failed for number "" + total, subExchange, e));
            // and do the done work
            doDone(original, subExchange, callback, false);
            return;
        }
        total.incrementAndGet();
    }
    // do the done work
    subExchange = result.get() != null ? result.get() : null;
    doDone(original, subExchange, callback, false);
}",,"public void done(boolean doneSync) {
        pair.done();
        if (doneSync) {
        return;
    }
        Exchange subExchange = exchange;
            boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, ""Sequential processing failed for number "" + total.get(), LOG);
    if (stopOnException && !continueProcessing) {
        if (subExchange.getException() != null) {
                        subExchange.setException(new CamelExchangeException(""Sequential processing failed for number "" + total, subExchange, subExchange.getException()));
        } else {
                                                result.set(subExchange);
        }
                doDone(original, subExchange, callback, false);
        return;
    }
    try {
        doAggregate(getAggregationStrategy(subExchange), result, subExchange);
    } catch (Throwable e) {
                subExchange.setException(new CamelExchangeException(""Sequential processing failed for number "" + total, subExchange, e));
                doDone(original, subExchange, callback, false);
        return;
    }
    total.incrementAndGet();
        while (it.hasNext()) {
                ProcessorExchangePair pair = it.next();
        subExchange = pair.getExchange();
        updateNewExchange(subExchange, total.get(), pairs, it);
        boolean sync = doProcessSequential(original, result, pairs, it, pair, callback, total);
        if (!sync) {
            if (LOG.isTraceEnabled()) {
                LOG.trace(""Processing exchangeId: "" + original.getExchangeId() + "" is continued being processed asynchronously"");
            }
            return;
        }
                        continueProcessing = PipelineHelper.continueProcessing(subExchange, ""Sequential processing failed for number "" + total.get(), LOG);
        if (stopOnException && !continueProcessing) {
            if (subExchange.getException() != null) {
                                subExchange.setException(new CamelExchangeException(""Sequential processing failed for number "" + total, subExchange, subExchange.getException()));
            } else {
                                                                result.set(subExchange);
            }
                        doDone(original, subExchange, callback, false);
            return;
        }
        try {
            doAggregate(getAggregationStrategy(subExchange), result, subExchange);
        } catch (Throwable e) {
                        subExchange.setException(new CamelExchangeException(""Sequential processing failed for number "" + total, subExchange, e));
                        doDone(original, subExchange, callback, false);
            return;
        }
        total.incrementAndGet();
    }
        subExchange = result.get() != null ? result.get() : null;
    doDone(original, subExchange, callback, false);
}",1.9545454545454546,0.3520408163265306,1.3333333333333333,0.5,1.1666666666666667,1.0350963914977758,-0.9578434184112422,2.5833333333333335,-0.028571428571428574,2.8513026755924464
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3156_786b3d76,0,"@Override
public IndexRow next() {
    final IndexRow pathRow = pathCursor.next();
    return new IndexRow() {

        @Override
        public boolean isVirtualRow() {
            return getPath() == null;
        }

        @Override
        public String getPath() {
            return pathRow.getPath();
        }

        @Override
        public PropertyValue getValue(String columnName) {
            // overlay the score
            if (QueryImpl.JCR_SCORE.equals(columnName)) {
                return PropertyValues.newDouble(currentRow.score);
            }
            if (QueryImpl.REP_SPELLCHECK.equals(columnName) || QueryImpl.REP_SUGGEST.equals(columnName)) {
                return PropertyValues.newString(Iterables.toString(currentRow.suggestWords));
            }
            return pathRow.getValue(columnName);
        }
    };
}",,"@Override
public IndexRow next() {
    final IndexRow pathRow = pathCursor.next();
    return new IndexRow() {

        @Override
        public boolean isVirtualRow() {
            return getPath() == null;
        }

        @Override
        public String getPath() {
            return pathRow.getPath();
        }

        @Override
        public PropertyValue getValue(String columnName) {
                        if (QueryImpl.JCR_SCORE.equals(columnName)) {
                return PropertyValues.newDouble(currentRow.score);
            }
            if (QueryImpl.REP_SPELLCHECK.equals(columnName) || QueryImpl.REP_SUGGEST.equals(columnName)) {
                return PropertyValues.newString(Iterables.toString(currentRow.suggestWords));
            }
            return pathRow.getValue(columnName);
        }
    };
}",0.45454545454545453,0.7346938775510204,-0.16666666666666666,0.0,0.16666666666666666,-0.014829461196243152,-0.29108115858904526,0.3333333333333333,0.08571428571428572,0.03167709578081299
wicket,remotes/origin/bugs-dot-jar_WICKET-4000_38e928c1,1,"/**
 *  Render the child hierarchy headers.
 *
 *  @param headerContainer
 *  @param rootComponent
 */
@Override
protected void renderChildHeaders(final HtmlHeaderContainer headerContainer, final Component rootComponent) {
    Args.notNull(headerContainer, ""headerContainer"");
    Args.notNull(rootComponent, ""rootComponent"");
    if (rootComponent instanceof MarkupContainer) {
        new DeepChildFirstVisitor() {

            @Override
            public void component(final Component component, final IVisit<Void> visit) {
                component.renderHead(headerContainer);
            }

            @Override
            public boolean preCheck(Component component) {
                return component.isVisibleInHierarchy();
            }
        }.visit(rootComponent);
    }
}","/**
 *  Render the child hierarchy headers.
 *
 *  @param headerContainer
 *  @param rootComponent
 */
","@Override
protected void renderChildHeaders(final HtmlHeaderContainer headerContainer, final Component rootComponent) {
    Args.notNull(headerContainer, ""headerContainer"");
    Args.notNull(rootComponent, ""rootComponent"");
    if (rootComponent instanceof MarkupContainer) {
        new DeepChildFirstVisitor() {

            @Override
            public void component(final Component component, final IVisit<Void> visit) {
                component.renderHead(headerContainer);
            }

            @Override
            public boolean preCheck(Component component) {
                return component.isVisibleInHierarchy();
            }
        }.visit(rootComponent);
    }
}",0.13636363636363635,1.1683673469387754,-0.3333333333333333,0.0,-0.25,-0.3806228373702422,-0.04961284772010337,-0.08333333333333333,0.2285714285714286,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-757_76b7413d,1,"/**
 * Returns the internal storage array.  Note that this method returns
 * a reference to the internal storage array, not a copy, and to correctly
 * address elements of the array, the <code>startIndex</code> is
 * required (available via the {@link #start} method).  This method should
 * only be used in cases where copying the internal array is not practical.
 * The {@link #getElements} method should be used in all other cases.
 *
 * @return the internal storage array used by this object
 * @since 2.0
 * @deprecated As of 3.1.
 */
@Deprecated
public synchronized double[] getInternalValues() {
    return internalArray;
}","/**
 * Returns the internal storage array.  Note that this method returns
 * a reference to the internal storage array, not a copy, and to correctly
 * address elements of the array, the <code>startIndex</code> is
 * required (available via the {@link #start} method).  This method should
 * only be used in cases where copying the internal array is not practical.
 * The {@link #getElements} method should be used in all other cases.
 *
 * @return the internal storage array used by this object
 * @since 2.0
 * @deprecated As of 3.1.
 */
","@Deprecated
public synchronized double[] getInternalValues() {
    return internalArray;
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.0665328362489248,-0.5,1.2,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2021_004db804,1,"@Override
public String toString() {
    return s1 + "" union "" + s2;
}",,"@Override
public String toString() {
    return s1 + "" union "" + s2;
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9027817608259249,-0.5,2.7142857142857144,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3310_4416a9f8,1,"@Override
public void remove() throws RepositoryException {
    sessionDelegate.performVoid(new ItemWriteOperation(""remove"") {

        @Override
        public void performVoid() {
            dlg.remove();
        }

        @Override
        public String toString() {
            return String.format(""Removing property [%s/%s] "", dlg.getPath(), dlg.getName());
        }
    });
}",,"@Override
public void remove() throws RepositoryException {
    sessionDelegate.performVoid(new ItemWriteOperation(""remove"") {

        @Override
        public void performVoid() {
            dlg.remove();
        }

        @Override
        public String toString() {
            return String.format(""Removing property [%s/%s] "", dlg.getPath(), dlg.getName());
        }
    });
}",-0.045454545454545456,0.5204081632653061,-0.5,-0.5,-0.4166666666666667,-0.3806228373702422,0.16862632635503289,-0.08333333333333333,0.5142857142857143,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-4594_556a2236,1,"private void resolvePageInstance(Integer pageId, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters, Integer renderCount) {
    IRequestablePage page = null;
    boolean freshCreated = false;
    if (pageId != null) {
        page = getStoredPage(pageId);
    }
    if (page == null) {
        if (pageClass != null) {
            page = getPageSource().newPageInstance(pageClass, pageParameters);
            freshCreated = true;
        }
    }
    if (page != null && !freshCreated) {
        if (renderCount != null && page.getRenderCount() != renderCount) {
            throw new StalePageException(page);
        }
    }
    pageInstanceIsFresh = freshCreated;
    pageInstance = page;
}",,"private void resolvePageInstance(Integer pageId, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters, Integer renderCount) {
    IRequestablePage page = null;
    boolean freshCreated = false;
    if (pageId != null) {
        page = getStoredPage(pageId);
    }
    if (page == null) {
        if (pageClass != null) {
            page = getPageSource().newPageInstance(pageClass, pageParameters);
            freshCreated = true;
        }
    }
    if (page != null && !freshCreated) {
        if (renderCount != null && page.getRenderCount() != renderCount) {
            throw new StalePageException(page);
        }
    }
    pageInstanceIsFresh = freshCreated;
    pageInstance = page;
}",0.2727272727272727,0.22448979591836732,0.5,0.0,0.6666666666666666,0.4458724666337124,-0.25867507886435326,-0.16666666666666666,-0.028571428571428574,0.3637854900398747
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2345_a0dc4c89,1,"/**
 * Perform a background read and make external changes visible.
 *
 * @param dispatchChange whether to dispatch external changes
 *                       to {@link #dispatcher}.
 */
void backgroundRead(boolean dispatchChange) {
    String id = Utils.getIdFromPath(""/"");
    NodeDocument doc = store.find(Collection.NODES, id, asyncDelay);
    if (doc == null) {
        return;
    }
    Map<Integer, Revision> lastRevMap = doc.getLastRev();
    Revision.RevisionComparator revisionComparator = getRevisionComparator();
    // the (old) head occurred first
    Revision headSeen = Revision.newRevision(0);
    // then we saw this new revision (from another cluster node)
    Revision otherSeen = Revision.newRevision(0);
    Map<Revision, Revision> externalChanges = Maps.newHashMap();
    for (Map.Entry<Integer, Revision> e : lastRevMap.entrySet()) {
        int machineId = e.getKey();
        if (machineId == clusterId) {
            // ignore own lastRev
            continue;
        }
        Revision r = e.getValue();
        Revision last = lastKnownRevision.get(machineId);
        if (last == null || r.compareRevisionTime(last) > 0) {
            lastKnownRevision.put(machineId, r);
            externalChanges.put(r, otherSeen);
        }
    }
    if (!externalChanges.isEmpty()) {
        // invalidate caches
        store.invalidateCache();
        // TODO only invalidate affected items
        docChildrenCache.invalidateAll();
        // make sure update to revision comparator is atomic
        // and no local commit is in progress
        backgroundOperationLock.writeLock().lock();
        try {
            // the latest revisions of the current cluster node
            // happened before the latest revisions of other cluster nodes
            revisionComparator.add(newRevision(), headSeen);
            // then we saw other revisions
            for (Map.Entry<Revision, Revision> e : externalChanges.entrySet()) {
                revisionComparator.add(e.getKey(), e.getValue());
            }
            // the new head revision is after other revisions
            setHeadRevision(newRevision());
            if (dispatchChange) {
                dispatcher.contentChanged(getRoot(), null);
            }
        } finally {
            backgroundOperationLock.writeLock().unlock();
        }
    }
    revisionComparator.purge(Revision.getCurrentTimestamp() - REMEMBER_REVISION_ORDER_MILLIS);
}","/**
 * Perform a background read and make external changes visible.
 *
 * @param dispatchChange whether to dispatch external changes
 *                       to {@link #dispatcher}.
 */
","void backgroundRead(boolean dispatchChange) {
    String id = Utils.getIdFromPath(""/"");
    NodeDocument doc = store.find(Collection.NODES, id, asyncDelay);
    if (doc == null) {
        return;
    }
    Map<Integer, Revision> lastRevMap = doc.getLastRev();
    Revision.RevisionComparator revisionComparator = getRevisionComparator();
        Revision headSeen = Revision.newRevision(0);
        Revision otherSeen = Revision.newRevision(0);
    Map<Revision, Revision> externalChanges = Maps.newHashMap();
    for (Map.Entry<Integer, Revision> e : lastRevMap.entrySet()) {
        int machineId = e.getKey();
        if (machineId == clusterId) {
                        continue;
        }
        Revision r = e.getValue();
        Revision last = lastKnownRevision.get(machineId);
        if (last == null || r.compareRevisionTime(last) > 0) {
            lastKnownRevision.put(machineId, r);
            externalChanges.put(r, otherSeen);
        }
    }
    if (!externalChanges.isEmpty()) {
                store.invalidateCache();
                docChildrenCache.invalidateAll();
                        backgroundOperationLock.writeLock().lock();
        try {
                                    revisionComparator.add(newRevision(), headSeen);
                        for (Map.Entry<Revision, Revision> e : externalChanges.entrySet()) {
                revisionComparator.add(e.getKey(), e.getValue());
            }
                        setHeadRevision(newRevision());
            if (dispatchChange) {
                dispatcher.contentChanged(getRoot(), null);
            }
        } finally {
            backgroundOperationLock.writeLock().unlock();
        }
    }
    revisionComparator.purge(Revision.getCurrentTimestamp() - REMEMBER_REVISION_ORDER_MILLIS);
}",1.2727272727272727,0.43877551020408156,0.8333333333333334,0.5,0.6666666666666666,0.8057340583292142,-0.7705764267278467,2.25,-0.028571428571428574,1.963778637233865
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-412_5594b2e0,1,"@Override
public void run() {
    ClientService.Iface client = null;
    try {
        client = ServerClient.getConnection(HdfsZooInstance.getInstance());
        List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);
        attempt.removeAll(fail);
        filesToLoad.removeAll(attempt);
    } catch (Exception ex) {
        log.error(ex, ex);
    } finally {
        ServerClient.close(client);
    }
}",,"@Override
public void run() {
    ClientService.Iface client = null;
    try {
        client = ServerClient.getConnection(HdfsZooInstance.getInstance());
        List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);
        attempt.removeAll(fail);
        filesToLoad.removeAll(attempt);
    } catch (Exception ex) {
        log.error(ex, ex);
    } finally {
        ServerClient.close(client);
    }
}",0.0,0.035714285714285636,-0.3333333333333333,-0.5,-0.4166666666666667,-0.3806228373702422,-0.010037281330656973,0.16666666666666666,-0.028571428571428574,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-395_4ed7bc8e,1,"@Override
public PropertyImpl perform() throws RepositoryException {
    String oakName = sessionDelegate.getOakPathOrThrow(jcrName);
    if (value == null) {
        dlg.removeProperty(oakName);
        return null;
    } else {
        int targetType = getTargetType(value, type);
        Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());
        return new PropertyImpl(dlg.setProperty(oakName, targetValue));
    }
}",,"@Override
public PropertyImpl perform() throws RepositoryException {
    String oakName = sessionDelegate.getOakPathOrThrow(jcrName);
    if (value == null) {
        dlg.removeProperty(oakName);
        return null;
    } else {
        int targetType = getTargetType(value, type);
        Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());
        return new PropertyImpl(dlg.setProperty(oakName, targetValue));
    }
}",-0.09090909090909091,0.09183673469387764,-0.3333333333333333,-0.5,-0.25,-0.10578348986653485,0.09635790077430458,0.0,0.05714285714285714,-0.06460482865843474
flink,remotes/origin/bugs-dot-jar_FLINK-1820_39d526e6,0,"@Override
public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, IntValue reusable) {
    long val = 0;
    boolean neg = false;
    final int delimLimit = limit - delimiter.length + 1;
    this.result = reusable;
    if (bytes[startPos] == '-') {
        neg = true;
        startPos++;
        // check for empty field with only the sign
        if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);
            return -1;
        }
    }
    for (int i = startPos; i < limit; i++) {
        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {
            reusable.setValue((int) (neg ? -val : val));
            return i + delimiter.length;
        }
        if (bytes[i] < 48 || bytes[i] > 57) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);
            return -1;
        }
        val *= 10;
        val += bytes[i] - 48;
        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);
            return -1;
        }
    }
    reusable.setValue((int) (neg ? -val : val));
    return limit;
}",,"@Override
public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, IntValue reusable) {
    long val = 0;
    boolean neg = false;
    final int delimLimit = limit - delimiter.length + 1;
    this.result = reusable;
    if (bytes[startPos] == '-') {
        neg = true;
        startPos++;
                if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);
            return -1;
        }
    }
    for (int i = startPos; i < limit; i++) {
        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {
            reusable.setValue((int) (neg ? -val : val));
            return i + delimiter.length;
        }
        if (bytes[i] < 48 || bytes[i] > 57) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);
            return -1;
        }
        val *= 10;
        val += bytes[i] - 48;
        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {
            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);
            return -1;
        }
    }
    reusable.setValue((int) (neg ? -val : val));
    return limit;
}",0.8636363636363636,0.34183673469387754,0.8333333333333334,0.0,1.5833333333333333,2.881858625803263,-0.6271866934327505,0.08333333333333333,-0.028571428571428574,4.581306401805715
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1932_c215b267,1,"public SegmentNodeState compact(NodeState before, NodeState after) {
    after.compareAgainstBaseState(before, new CompactDiff(builder));
    return builder.getNodeState();
}",,"public SegmentNodeState compact(NodeState before, NodeState after) {
    after.compareAgainstBaseState(before, new CompactDiff(builder));
    return builder.getNodeState();
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8041296243188988,-0.3333333333333333,-0.028571428571428574,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-4138_eb0f9b41,1,"/**
 * Starts a full major compaction of the tablets in the range (start, end]. The compaction is preformed even for tablets that have only one file.
 *
 * @param tableName
 *          the table to compact
 * @param start
 *          first tablet to be compacted contains the row after this row, null means the first tablet in table
 * @param end
 *          last tablet to be merged contains this row, null means the last tablet in table
 * @param iterators
 *          A set of iterators that will be applied to each tablet compacted
 * @param flush
 *          when true, table memory is flushed before compaction starts
 * @param wait
 *          when true, the call will not return until compactions are finished
 * @since 1.5.0
 */
void compact(String tableName, Text start, Text end, List<IteratorSetting> iterators, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException;","/**
 * Starts a full major compaction of the tablets in the range (start, end]. The compaction is preformed even for tablets that have only one file.
 *
 * @param tableName
 *          the table to compact
 * @param start
 *          first tablet to be compacted contains the row after this row, null means the first tablet in table
 * @param end
 *          last tablet to be merged contains this row, null means the last tablet in table
 * @param iterators
 *          A set of iterators that will be applied to each tablet compacted
 * @param flush
 *          when true, table memory is flushed before compaction starts
 * @param wait
 *          when true, the call will not return until compactions are finished
 * @since 1.5.0
 */
","void compact(String tableName, Text start, Text end, List<IteratorSetting> iterators, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException;",-0.5909090909090909,-1.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.4040722684255813,-0.5,0.3428571428571429,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd,1,"private Set<String> getValues(PropertyRestriction restriction) {
    if (restriction.firstIncluding && restriction.lastIncluding && restriction.first != null && restriction.first.equals(restriction.last)) {
        // ""[property] = $value""
        return encode(restriction.first);
    } else if (restriction.list != null) {
        // ""[property] IN (...)
        // keep order for testing
        Set<String> values = newLinkedHashSet();
        for (PropertyValue value : restriction.list) {
            values.addAll(encode(value));
        }
        return values;
    } else {
        // processed as ""[property] is not null""
        return null;
    }
}",,"private Set<String> getValues(PropertyRestriction restriction) {
    if (restriction.firstIncluding && restriction.lastIncluding && restriction.first != null && restriction.first.equals(restriction.last)) {
                return encode(restriction.first);
    } else if (restriction.list != null) {
                        Set<String> values = newLinkedHashSet();
        for (PropertyValue value : restriction.list) {
            values.addAll(encode(value));
        }
        return values;
    } else {
                return null;
    }
}",-0.045454545454545456,0.17857142857142863,0.0,0.5,0.5,0.01482946119624324,0.025523372526527123,-0.08333333333333333,0.0,2.998102629335714e-05
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1655_01a8b283,1,"@Override
public Iterator<String> getAllChunkIds(long maxLastModifiedTime) throws Exception {
    // TODO Ignores the maxLastModifiedTime currently.
    return Iterators.transform(delegate.getAllIdentifiers(), new Function<DataIdentifier, String>() {

        @Nullable
        @Override
        public String apply(@Nullable DataIdentifier input) {
            return input.toString();
        }
    });
}",,"@Override
public Iterator<String> getAllChunkIds(long maxLastModifiedTime) throws Exception {
        return Iterators.transform(delegate.getAllIdentifiers(), new Function<DataIdentifier, String>() {

        @Nullable
        @Override
        public String apply(@Nullable DataIdentifier input) {
            return input.toString();
        }
    });
}",-0.18181818181818182,0.5102040816326529,-0.5,-0.5,-0.4166666666666667,-0.3806228373702422,0.2733008316604532,-0.25,0.6,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd,1,"/**
 * retrieve the cost for the query.
 *
 * !!! for now we want to skip the use-case of NON range-queries !!!
 */
public double getCost(Filter filter, NodeState root) {
    throw new UnsupportedOperationException(""Not supported as implementing AdvancedQueryIndex"");
}","/**
 * retrieve the cost for the query.
 *
 * !!! for now we want to skip the use-case of NON range-queries !!!
 */
","public double getCost(Filter filter, NodeState root) {
    throw new UnsupportedOperationException(""Not supported as implementing AdvancedQueryIndex"");
}",-0.5,-0.576530612244898,-0.3333333333333333,-1.0,-0.4166666666666667,-0.3806228373702422,1.0298250645253801,-0.5,2.8000000000000003,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-621_00b4b8a0,1,"// ------------------------------------------------------------< private >---
private TreeImpl internalGetChild(String childName) {
    return getNodeBuilder().hasChildNode(childName) ? new TreeImpl(root, this, childName) : null;
}",,"private TreeImpl internalGetChild(String childName) {
    return getNodeBuilder().hasChildNode(childName) ? new TreeImpl(root, this, childName) : null;
}",-0.5,-0.576530612244898,-0.3333333333333333,-1.0,-0.16666666666666666,-0.3806228373702422,0.9609979925437339,-0.3333333333333333,2.8285714285714287,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1081_4ce4e3c9,3,"/**
 * Returns an iterator for traversing all the children of this node.
 * If the node is orderable then the iterator will return child nodes in the
 * specified order. Otherwise the ordering of the iterator is undefined.
 *
 * @return child nodes of the node
 */
@Nonnull
public Iterator<NodeDelegate> getChildren() throws InvalidItemStateException {
    Iterator<Tree> iterator = getTree().getChildren().iterator();
    return transform(filter(iterator, new Predicate<Tree>() {

        @Override
        public boolean apply(Tree tree) {
            return !tree.getName().startsWith("":"");
        }
    }), new Function<Tree, NodeDelegate>() {

        @Override
        public NodeDelegate apply(Tree tree) {
            return new NodeDelegate(sessionDelegate, tree);
        }
    });
}","/**
 * Returns an iterator for traversing all the children of this node.
 * If the node is orderable then the iterator will return child nodes in the
 * specified order. Otherwise the ordering of the iterator is undefined.
 *
 * @return child nodes of the node
 */
","@Nonnull
public Iterator<NodeDelegate> getChildren() throws InvalidItemStateException {
    Iterator<Tree> iterator = getTree().getChildren().iterator();
    return transform(filter(iterator, new Predicate<Tree>() {

        @Override
        public boolean apply(Tree tree) {
            return !tree.getName().startsWith("":"");
        }
    }), new Function<Tree, NodeDelegate>() {

        @Override
        public NodeDelegate apply(Tree tree) {
            return new NodeDelegate(sessionDelegate, tree);
        }
    });
}",0.045454545454545456,0.413265306122449,-0.5,-0.5,-0.4166666666666667,-0.0247157686604053,-0.0028677946659021666,0.08333333333333333,0.0,-0.03358303245231947
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1178_84fb6b29,1,"@Override
public boolean isNew() {
    return !isRoot() && !parent.base().hasChildNode(name) && parent.hasChildNode(name);
}",,"@Override
public boolean isNew() {
    return !isRoot() && !parent.base().hasChildNode(name) && parent.hasChildNode(name);
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.10776075135936727,0.8041296243188988,-0.16666666666666666,1.3142857142857143,-0.1368376870066515
commons-math,remotes/origin/bugs-dot-jar_MATH-559_fc409e88,3,"/**
 * Returns true if both arguments are equal or within the range of allowed
 * error (inclusive).
 * Two float numbers are considered equal if there are {@code (maxUlps - 1)}
 * (or fewer) floating point numbers between them, i.e. two adjacent floating
 * point numbers are considered equal.
 * Adapted from <a
 * href=""http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"">
 * Bruce Dawson</a>
 *
 * @param x first value
 * @param y second value
 * @param maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.
 * @return {@code true} if there are fewer than {@code maxUlps} floating
 * point values between {@code x} and {@code y}.
 */
public static boolean equals(double x, double y, int maxUlps) {
    // NaN won't compare as equal to anything (except another NaN).
    assert maxUlps > 0 && maxUlps < NAN_GAP;
    long xInt = Double.doubleToLongBits(x);
    long yInt = Double.doubleToLongBits(y);
    // Make lexicographically ordered as a two's-complement integer.
    if (xInt < 0) {
        xInt = SGN_MASK - xInt;
    }
    if (yInt < 0) {
        yInt = SGN_MASK - yInt;
    }
    final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;
    return isEqual && !Double.isNaN(x) && !Double.isNaN(y);
}","/**
 * Returns true if both arguments are equal or within the range of allowed
 * error (inclusive).
 * Two float numbers are considered equal if there are {@code (maxUlps - 1)}
 * (or fewer) floating point numbers between them, i.e. two adjacent floating
 * point numbers are considered equal.
 * Adapted from <a
 * href=""http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"">
 * Bruce Dawson</a>
 *
 * @param x first value
 * @param y second value
 * @param maxUlps {@code (maxUlps - 1)} is the number of floating point
 * values between {@code x} and {@code y}.
 * @return {@code true} if there are fewer than {@code maxUlps} floating
 * point values between {@code x} and {@code y}.
 */
","public static boolean equals(double x, double y, int maxUlps) {
        assert maxUlps > 0 && maxUlps < NAN_GAP;
    long xInt = Double.doubleToLongBits(x);
    long yInt = Double.doubleToLongBits(y);
        if (xInt < 0) {
        xInt = SGN_MASK - xInt;
    }
    if (yInt < 0) {
        yInt = SGN_MASK - yInt;
    }
    final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;
    return isEqual && !Double.isNaN(x) && !Double.isNaN(y);
}",-0.045454545454545456,-0.40816326530612235,-0.16666666666666666,-0.5,-0.08333333333333333,-0.3806228373702422,0.45024376254660187,-0.08333333333333333,0.14285714285714285,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-939_49444ee6,1,"/**
 * Compute a covariance matrix from a matrix whose columns represent
 * covariates.
 * @param matrix input matrix (must have at least two columns and two rows)
 * @param biasCorrected determines whether or not covariance estimates are bias-corrected
 * @return covariance matrix
 * @throws MathIllegalArgumentException if the matrix does not contain sufficient data
 */
protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected) throws MathIllegalArgumentException {
    int dimension = matrix.getColumnDimension();
    Variance variance = new Variance(biasCorrected);
    RealMatrix outMatrix = new BlockRealMatrix(dimension, dimension);
    for (int i = 0; i < dimension; i++) {
        for (int j = 0; j < i; j++) {
            double cov = covariance(matrix.getColumn(i), matrix.getColumn(j), biasCorrected);
            outMatrix.setEntry(i, j, cov);
            outMatrix.setEntry(j, i, cov);
        }
        outMatrix.setEntry(i, i, variance.evaluate(matrix.getColumn(i)));
    }
    return outMatrix;
}","/**
 * Compute a covariance matrix from a matrix whose columns represent
 * covariates.
 * @param matrix input matrix (must have at least two columns and two rows)
 * @param biasCorrected determines whether or not covariance estimates are bias-corrected
 * @return covariance matrix
 * @throws MathIllegalArgumentException if the matrix does not contain sufficient data
 */
","protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected) throws MathIllegalArgumentException {
    int dimension = matrix.getColumnDimension();
    Variance variance = new Variance(biasCorrected);
    RealMatrix outMatrix = new BlockRealMatrix(dimension, dimension);
    for (int i = 0; i < dimension; i++) {
        for (int j = 0; j < i; j++) {
            double cov = covariance(matrix.getColumn(i), matrix.getColumn(j), biasCorrected);
            outMatrix.setEntry(i, j, cov);
            outMatrix.setEntry(j, i, cov);
        }
        outMatrix.setEntry(i, i, variance.evaluate(matrix.getColumn(i)));
    }
    return outMatrix;
}",0.0,0.46428571428571436,-0.16666666666666666,0.0,0.0,0.19278299555116168,-0.072841984513909,0.25,-0.028571428571428574,0.217837854043798
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-127_029e79da,1,"/**
 * Logs a message with the specific Marker at the {@link Level#ERROR ERROR} level.
 *
 * @param marker the marker data specific to this log statement
 * @param msg    the message string to be logged
 */
public void error(Marker marker, Message msg) {
    if (isEnabled(Level.ERROR, marker, msg, null)) {
        log(null, FQCN, Level.ERROR, msg, null);
    }
}","/**
 * Logs a message with the specific Marker at the {@link Level#ERROR ERROR} level.
 *
 * @param marker the marker data specific to this log statement
 * @param msg    the message string to be logged
 */
","public void error(Marker marker, Message msg) {
    if (isEnabled(Level.ERROR, marker, msg, null)) {
        log(null, FQCN, Level.ERROR, msg, null);
    }
}",-0.4090909090909091,-0.015306122448979493,-0.3333333333333333,-0.5,-0.08333333333333333,-0.3806228373702422,0.6369371952968167,-0.3333333333333333,0.9714285714285714,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-757_76b7413d,1,"/**
 * Checks the expansion factor and the contraction criterion and throws an
 * IllegalArgumentException if the contractionCriteria is less than the
 * expansionCriteria
 *
 * @param expansion factor to be checked
 * @param contraction criteria to be checked
 * @throws MathIllegalArgumentException if the contractionCriteria is less than
 * the expansionCriteria.
 * @deprecated As of 3.1. Please use
 * {@link #checkContractExpand(double,double)} instead.
 */
@Deprecated
protected void checkContractExpand(float contraction, float expansion) throws MathIllegalArgumentException {
    checkContractExpand((double) contraction, (double) expansion);
}","/**
 * Checks the expansion factor and the contraction criterion and throws an
 * IllegalArgumentException if the contractionCriteria is less than the
 * expansionCriteria
 *
 * @param expansion factor to be checked
 * @param contraction criteria to be checked
 * @throws MathIllegalArgumentException if the contractionCriteria is less than
 * the expansionCriteria.
 * @deprecated As of 3.1. Please use
 * {@link #checkContractExpand(double,double)} instead.
 */
","@Deprecated
protected void checkContractExpand(float contraction, float expansion) throws MathIllegalArgumentException {
    checkContractExpand((double) contraction, (double) expansion);
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9073702322913678,-0.4166666666666667,2.685714285714286,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-640_98556fed,1,"/**
 * Returns the next pseudorandom, uniformly distributed {@code long}
 * value from this random number generator's sequence.  All
 * 2<font size=""-1""><sup>64</sup></font> possible {@code long} values
 * should be produced with (approximately) equal probability.
 * <p>
 * The default implementation returns
 * <pre>
 * <code>(long) (nextDouble() * Long.MAX_VALUE)</code>
 * </pre></p>
 *
 * @return  the next pseudorandom, uniformly distributed {@code long}
 *value from this random number generator's sequence
 */
public long nextLong() {
    return (long) (nextDouble() * Long.MAX_VALUE);
}","/**
 * Returns the next pseudorandom, uniformly distributed {@code long}
 * value from this random number generator's sequence.  All
 * 2<font size=""-1""><sup>64</sup></font> possible {@code long} values
 * should be produced with (approximately) equal probability.
 * <p>
 * The default implementation returns
 * <pre>
 * <code>(long) (nextDouble() * Long.MAX_VALUE)</code>
 * </pre></p>
 *
 * @return  the next pseudorandom, uniformly distributed {@code long}
 *value from this random number generator's sequence
 */
","public long nextLong() {
    return (long) (nextDouble() * Long.MAX_VALUE);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.1015199311729282,-0.4166666666666667,2.2285714285714286,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-1300_1d635088,1,"/**
 * {@inheritDoc}
 */
@Override
public void nextBytes(byte[] bytes) {
    int i = 0;
    final int iEnd = bytes.length - 3;
    while (i < iEnd) {
        final int random = next(32);
        bytes[i] = (byte) (random & 0xff);
        bytes[i + 1] = (byte) ((random >> 8) & 0xff);
        bytes[i + 2] = (byte) ((random >> 16) & 0xff);
        bytes[i + 3] = (byte) ((random >> 24) & 0xff);
        i += 4;
    }
    int random = next(32);
    while (i < bytes.length) {
        bytes[i++] = (byte) (random & 0xff);
        random >>= 8;
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public void nextBytes(byte[] bytes) {
    int i = 0;
    final int iEnd = bytes.length - 3;
    while (i < iEnd) {
        final int random = next(32);
        bytes[i] = (byte) (random & 0xff);
        bytes[i + 1] = (byte) ((random >> 8) & 0xff);
        bytes[i + 2] = (byte) ((random >> 16) & 0xff);
        bytes[i + 3] = (byte) ((random >> 24) & 0xff);
        i += 4;
    }
    int random = next(32);
    while (i < bytes.length) {
        bytes[i++] = (byte) (random & 0xff);
        random >>= 8;
    }
}",0.18181818181818182,-0.051020408163265356,-0.16666666666666666,-0.5,0.0,1.742956005931785,-0.21737883567536564,-0.3333333333333333,0.31428571428571433,1.5380180828418586
wicket,remotes/origin/bugs-dot-jar_WICKET-4572_dfc56674,0,"/**
 *  @param pageId
 */
private void removeWindowIndex(int pageId) {
    idToWindowIndex.remove(pageId);
}","/**
 *  @param pageId
 */
","private void removeWindowIndex(int pageId) {
    idToWindowIndex.remove(pageId);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.1172928018353891,-0.4166666666666667,2.8000000000000003,-0.16422749602751402
Closure,163,1,"@Override
public void enterScope(NodeTraversal t) {
    symbolStack.peek().scope = t.getScope();
// NOTE(nicksantos): We use the same anonymous node for all
// functions that do not have reasonable names. I can't remember
// at the moment why we do this. I think it's because anonymous
// nodes can never have in-edges. They're just there as a placeholder
// for scope information, and do not matter in the edge propagation.
}",,"@Override
public void enterScope(NodeTraversal t) {
    symbolStack.peek().scope = t.getScope();
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8399770576426728,-0.3333333333333333,0.7714285714285716,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-5853_b80f6640,3,"/**
 *  @param locale
 *  @return Returns the numberFormat.
 */
public abstract NumberFormat getNumberFormat(Locale locale);","/**
 *  @param locale
 *  @return Returns the numberFormat.
 */
",public abstract NumberFormat getNumberFormat(Locale locale);,-0.5909090909090909,-1.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.6550043016919995,-0.5,2.8285714285714287,-0.16422749602751402
maven,remotes/origin/bugs-dot-jar_MNG-4915_1c3abfba,1,"private boolean validateVersion(String fieldName, ModelProblemCollector problems, Severity severity, String string, String sourceHint, InputLocationTracker tracker) {
    if (string == null || string.length() <= 0) {
        return true;
    }
    if (!hasExpression(string)) {
        return true;
    }
    addViolation(problems, severity, fieldName, sourceHint, ""must be a valid version but is '"" + string + ""'."", tracker);
    return false;
}",,"private boolean validateVersion(String fieldName, ModelProblemCollector problems, Severity severity, String string, String sourceHint, InputLocationTracker tracker) {
    if (string == null || string.length() <= 0) {
        return true;
    }
    if (!hasExpression(string)) {
        return true;
    }
    addViolation(problems, severity, fieldName, sourceHint, ""must be a valid version but is '"" + string + ""'."", tracker);
    return false;
}",-0.18181818181818182,-0.2500000000000001,-0.16666666666666666,-0.5,0.08333333333333333,0.24023727137914,0.16432463435618025,-0.25,-0.028571428571428574,0.07620748583396508
commons-math,remotes/origin/bugs-dot-jar_MATH-1103_a6f96306,1,"/**
 * {@inheritDoc}
 */
public Optimum optimize(final LeastSquaresProblem problem) {
    // pull in relevant data from the problem as locals
    // Number of observed data.
    final int nR = problem.getObservationSize();
    // Number of parameters.
    final int nC = problem.getParameterSize();
    final double[] currentPoint = problem.getStart().toArray();
    // counters
    final Incrementor iterationCounter = problem.getIterationCounter();
    final Incrementor evaluationCounter = problem.getEvaluationCounter();
    // convergence criterion
    final ConvergenceChecker<Evaluation> checker = problem.getConvergenceChecker();
    // arrays shared with the other private methods
    final int solvedCols = FastMath.min(nR, nC);
    /* Parameters evolution direction associated with lmPar. */
    double[] lmDir = new double[nC];
    /* Levenberg-Marquardt parameter. */
    double lmPar = 0;
    // local point
    double delta = 0;
    double xNorm = 0;
    double[] diag = new double[nC];
    double[] oldX = new double[nC];
    double[] oldRes = new double[nR];
    double[] qtf = new double[nR];
    double[] work1 = new double[nC];
    double[] work2 = new double[nC];
    double[] work3 = new double[nC];
    // Evaluate the function at the starting point and calculate its norm.
    evaluationCounter.incrementCount();
    // value will be reassigned in the loop
    Evaluation current = problem.evaluate(new ArrayRealVector(currentPoint, false));
    double[] currentResiduals = current.getResiduals().toArray();
    double currentCost = current.getCost();
    // Outer loop.
    boolean firstIteration = true;
    while (true) {
        iterationCounter.incrementCount();
        final Evaluation previous = current;
        // QR decomposition of the jacobian matrix
        final InternalData internalData = qrDecomposition(current.getJacobian(), solvedCols);
        final double[][] weightedJacobian = internalData.weightedJacobian;
        final int[] permutation = internalData.permutation;
        final double[] diagR = internalData.diagR;
        final double[] jacNorm = internalData.jacNorm;
        // residuals already have weights applied
        double[] weightedResidual = currentResiduals;
        for (int i = 0; i < nR; i++) {
            qtf[i] = weightedResidual[i];
        }
        // compute Qt.res
        qTy(qtf, internalData);
        // so let jacobian contain the R matrix with its diagonal elements
        for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            weightedJacobian[k][pk] = diagR[pk];
        }
        if (firstIteration) {
            // scale the point according to the norms of the columns
            // of the initial jacobian
            xNorm = 0;
            for (int k = 0; k < nC; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * currentPoint[k];
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = FastMath.sqrt(xNorm);
            // initialize the step bound delta
            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }
        // check orthogonality between function vector and jacobian columns
        double maxCosine = 0;
        if (currentCost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += weightedJacobian[i][pj] * qtf[i];
                    }
                    maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
            // Convergence has been reached.
            return new OptimumImpl(current, evaluationCounter.getCount(), iterationCounter.getCount());
        }
        // rescale if necessary
        for (int j = 0; j < nC; ++j) {
            diag[j] = FastMath.max(diag[j], jacNorm[j]);
        }
        // Inner loop.
        for (double ratio = 0; ratio < 1.0e-4; ) {
            // save the state
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = currentPoint[pj];
            }
            final double previousCost = currentCost;
            double[] tmpVec = weightedResidual;
            weightedResidual = oldRes;
            oldRes = tmpVec;
            // determine the Levenberg-Marquardt parameter
            lmPar = determineLMParameter(qtf, delta, diag, internalData, solvedCols, work1, work2, work3, lmDir, lmPar);
            // compute the new point and the norm of the evolution direction
            double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                currentPoint[pj] = oldX[pj] + lmDir[pj];
                double s = diag[pj] * lmDir[pj];
                lmNorm += s * s;
            }
            lmNorm = FastMath.sqrt(lmNorm);
            // on the first iteration, adjust the initial step bound.
            if (firstIteration) {
                delta = FastMath.min(delta, lmNorm);
            }
            // Evaluate the function at x + p and calculate its norm.
            evaluationCounter.incrementCount();
            current = problem.evaluate(new ArrayRealVector(currentPoint, false));
            currentResiduals = current.getResiduals().toArray();
            currentCost = current.getCost();
            // compute the scaled actual reduction
            double actRed = -1.0;
            if (0.1 * currentCost < previousCost) {
                double r = currentCost / previousCost;
                actRed = 1.0 - r * r;
            }
            // and the scaled directional derivative
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0; i <= j; ++i) {
                    work1[i] += weightedJacobian[i][pj] * dirJ;
                }
            }
            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                coeff1 += work1[j] * work1[j];
            }
            double pc2 = previousCost * previousCost;
            coeff1 /= pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);
            // ratio of the actual to the predicted reduction
            ratio = (preRed == 0) ? 0 : (actRed / preRed);
            // update the step bound
            if (ratio <= 0.25) {
                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {
                    tmp = 0.1;
                }
                delta = tmp * FastMath.min(delta, 10.0 * lmNorm);
                lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }
            // test for successful iteration.
            if (ratio >= 1.0e-4) {
                // successful iteration, update the norm
                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < nC; ++k) {
                    double xK = diag[k] * currentPoint[k];
                    xNorm += xK * xK;
                }
                xNorm = FastMath.sqrt(xNorm);
                // tests for convergence.
                if (checker != null && checker.converged(iterationCounter.getCount(), previous, current)) {
                    return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());
                }
            } else {
                // failed iteration, reset the previous values
                currentCost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    currentPoint[pj] = oldX[pj];
                }
                tmpVec = weightedResidual;
                weightedResidual = oldRes;
                oldRes = tmpVec;
                // Reset ""current"" to previous values.
                current = previous;
            }
            // Default convergence criteria.
            if ((FastMath.abs(actRed) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0) || delta <= parRelativeTolerance * xNorm) {
                return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());
            }
            // tests for termination and stringent tolerances
            if (FastMath.abs(actRed) <= TWO_EPS && preRed <= TWO_EPS && ratio <= 2.0) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);
            } else if (delta <= TWO_EPS * xNorm) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);
            } else if (maxCosine <= TWO_EPS) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);
            }
        }
    }
}","/**
 * {@inheritDoc}
 */
","public Optimum optimize(final LeastSquaresProblem problem) {
            final int nR = problem.getObservationSize();
        final int nC = problem.getParameterSize();
    final double[] currentPoint = problem.getStart().toArray();
        final Incrementor iterationCounter = problem.getIterationCounter();
    final Incrementor evaluationCounter = problem.getEvaluationCounter();
        final ConvergenceChecker<Evaluation> checker = problem.getConvergenceChecker();
        final int solvedCols = FastMath.min(nR, nC);
        double[] lmDir = new double[nC];
        double lmPar = 0;
        double delta = 0;
    double xNorm = 0;
    double[] diag = new double[nC];
    double[] oldX = new double[nC];
    double[] oldRes = new double[nR];
    double[] qtf = new double[nR];
    double[] work1 = new double[nC];
    double[] work2 = new double[nC];
    double[] work3 = new double[nC];
        evaluationCounter.incrementCount();
        Evaluation current = problem.evaluate(new ArrayRealVector(currentPoint, false));
    double[] currentResiduals = current.getResiduals().toArray();
    double currentCost = current.getCost();
        boolean firstIteration = true;
    while (true) {
        iterationCounter.incrementCount();
        final Evaluation previous = current;
                final InternalData internalData = qrDecomposition(current.getJacobian(), solvedCols);
        final double[][] weightedJacobian = internalData.weightedJacobian;
        final int[] permutation = internalData.permutation;
        final double[] diagR = internalData.diagR;
        final double[] jacNorm = internalData.jacNorm;
                double[] weightedResidual = currentResiduals;
        for (int i = 0; i < nR; i++) {
            qtf[i] = weightedResidual[i];
        }
                qTy(qtf, internalData);
                for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            weightedJacobian[k][pk] = diagR[pk];
        }
        if (firstIteration) {
                                    xNorm = 0;
            for (int k = 0; k < nC; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * currentPoint[k];
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = FastMath.sqrt(xNorm);
                        delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }
                double maxCosine = 0;
        if (currentCost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += weightedJacobian[i][pj] * qtf[i];
                    }
                    maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
                        return new OptimumImpl(current, evaluationCounter.getCount(), iterationCounter.getCount());
        }
                for (int j = 0; j < nC; ++j) {
            diag[j] = FastMath.max(diag[j], jacNorm[j]);
        }
                for (double ratio = 0; ratio < 1.0e-4; ) {
                        for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = currentPoint[pj];
            }
            final double previousCost = currentCost;
            double[] tmpVec = weightedResidual;
            weightedResidual = oldRes;
            oldRes = tmpVec;
                        lmPar = determineLMParameter(qtf, delta, diag, internalData, solvedCols, work1, work2, work3, lmDir, lmPar);
                        double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                currentPoint[pj] = oldX[pj] + lmDir[pj];
                double s = diag[pj] * lmDir[pj];
                lmNorm += s * s;
            }
            lmNorm = FastMath.sqrt(lmNorm);
                        if (firstIteration) {
                delta = FastMath.min(delta, lmNorm);
            }
                        evaluationCounter.incrementCount();
            current = problem.evaluate(new ArrayRealVector(currentPoint, false));
            currentResiduals = current.getResiduals().toArray();
            currentCost = current.getCost();
                        double actRed = -1.0;
            if (0.1 * currentCost < previousCost) {
                double r = currentCost / previousCost;
                actRed = 1.0 - r * r;
            }
                        for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0; i <= j; ++i) {
                    work1[i] += weightedJacobian[i][pj] * dirJ;
                }
            }
            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                coeff1 += work1[j] * work1[j];
            }
            double pc2 = previousCost * previousCost;
            coeff1 /= pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);
                        ratio = (preRed == 0) ? 0 : (actRed / preRed);
                        if (ratio <= 0.25) {
                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {
                    tmp = 0.1;
                }
                delta = tmp * FastMath.min(delta, 10.0 * lmNorm);
                lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }
                        if (ratio >= 1.0e-4) {
                                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < nC; ++k) {
                    double xK = diag[k] * currentPoint[k];
                    xNorm += xK * xK;
                }
                xNorm = FastMath.sqrt(xNorm);
                                if (checker != null && checker.converged(iterationCounter.getCount(), previous, current)) {
                    return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());
                }
            } else {
                                currentCost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    currentPoint[pj] = oldX[pj];
                }
                tmpVec = weightedResidual;
                weightedResidual = oldRes;
                oldRes = tmpVec;
                                current = previous;
            }
                        if ((FastMath.abs(actRed) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0) || delta <= parRelativeTolerance * xNorm) {
                return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());
            }
                        if (FastMath.abs(actRed) <= TWO_EPS && preRed <= TWO_EPS && ratio <= 2.0) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);
            } else if (delta <= TWO_EPS * xNorm) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);
            } else if (maxCosine <= TWO_EPS) {
                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);
            }
        }
    }
}",7.090909090909091,0.933673469387755,5.666666666666667,1.5,5.416666666666667,7.121107266435987,-1.880986521365071,2.9166666666666665,-0.028571428571428574,81.91069937168335
commons-math,remotes/origin/bugs-dot-jar_MATH-373_bfe4623c,1,"/**
 * {@inheritDoc}
 */
@Override
public double getResult() {
    if (n > 0) {
        return value;
    } else {
        return Double.NaN;
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public double getResult() {
    if (n > 0) {
        return value;
    } else {
        return Double.NaN;
    }
}",-0.2727272727272727,0.051020408163265356,-0.3333333333333333,-0.5,-0.25,-0.3806228373702422,0.5483223401204477,-0.5,2.742857142857143,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-5138_e8dab4a0,1,"/**
 *  Process the request cycle
 *
 *  @param requestCycle
 *  @param webResponse
 *  @param httpServletRequest
 *  @param httpServletResponse
 *  @param chain
 *  @return false, if the request could not be processed
 *  @throws IOException
 *  @throws ServletException
 */
protected boolean processRequestCycle(RequestCycle requestCycle, WebResponse webResponse, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, final FilterChain chain) throws IOException, ServletException {
    // Assume we are able to handle the request
    boolean res = true;
    if (!requestCycle.processRequestAndDetach()) {
        if (chain != null) {
            chain.doFilter(httpServletRequest, httpServletResponse);
        }
        res = false;
    } else {
        webResponse.flush();
    }
    return res;
}","/**
 *  Process the request cycle
 *
 *  @param requestCycle
 *  @param webResponse
 *  @param httpServletRequest
 *  @param httpServletResponse
 *  @param chain
 *  @return false, if the request could not be processed
 *  @throws IOException
 *  @throws ServletException
 */
","protected boolean processRequestCycle(RequestCycle requestCycle, WebResponse webResponse, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, final FilterChain chain) throws IOException, ServletException {
        boolean res = true;
    if (!requestCycle.processRequestAndDetach()) {
        if (chain != null) {
            chain.doFilter(httpServletRequest, httpServletResponse);
        }
        res = false;
    } else {
        webResponse.flush();
    }
    return res;
}",-0.09090909090909091,0.1938775510204081,-0.16666666666666666,0.0,-0.08333333333333333,-0.10776075135936727,0.10438772583882998,-0.25,0.31428571428571433,-0.07473841554559044
commons-math,remotes/origin/bugs-dot-jar_MATH-1093_7cfbc0da,1,"/**
 * Compute the relative position of the instance with respect
 * to an arc.
 * <p>
 * The {@link Side#MINUS} side of the arc is the one covered by the arc.
 * </p>
 * @param arc arc to check instance against
 * @return one of {@link Side#PLUS}, {@link Side#MINUS}, {@link Side#BOTH}
 * or {@link Side#HYPER}
 */
public Side side(final Arc arc) {
    final double reference = FastMath.PI + arc.getInf();
    final double arcLength = arc.getSup() - arc.getInf();
    boolean inMinus = false;
    boolean inPlus = false;
    for (final double[] a : this) {
        final double syncedStart = MathUtils.normalizeAngle(a[0], reference) - arc.getInf();
        final double arcOffset = a[0] - syncedStart;
        final double syncedEnd = a[1] - arcOffset;
        if (syncedStart < arcLength || syncedEnd > MathUtils.TWO_PI) {
            inMinus = true;
        }
        if (syncedEnd > arcLength) {
            inPlus = true;
        }
    }
    if (inMinus) {
        if (inPlus) {
            return Side.BOTH;
        } else {
            return Side.MINUS;
        }
    } else {
        if (inPlus) {
            return Side.PLUS;
        } else {
            return Side.HYPER;
        }
    }
}","/**
 * Compute the relative position of the instance with respect
 * to an arc.
 * <p>
 * The {@link Side#MINUS} side of the arc is the one covered by the arc.
 * </p>
 * @param arc arc to check instance against
 * @return one of {@link Side#PLUS}, {@link Side#MINUS}, {@link Side#BOTH}
 * or {@link Side#HYPER}
 */
","public Side side(final Arc arc) {
    final double reference = FastMath.PI + arc.getInf();
    final double arcLength = arc.getSup() - arc.getInf();
    boolean inMinus = false;
    boolean inPlus = false;
    for (final double[] a : this) {
        final double syncedStart = MathUtils.normalizeAngle(a[0], reference) - arc.getInf();
        final double arcOffset = a[0] - syncedStart;
        final double syncedEnd = a[1] - arcOffset;
        if (syncedStart < arcLength || syncedEnd > MathUtils.TWO_PI) {
            inMinus = true;
        }
        if (syncedEnd > arcLength) {
            inPlus = true;
        }
    }
    if (inMinus) {
        if (inPlus) {
            return Side.BOTH;
        } else {
            return Side.MINUS;
        }
    } else {
        if (inPlus) {
            return Side.PLUS;
        } else {
            return Side.HYPER;
        }
    }
}",0.7272727272727273,0.18367346938775503,0.5,0.0,0.5,0.8472565496786951,-0.48752509320332676,-0.08333333333333333,-0.028571428571428574,0.8648669484883137
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3510_01f5a26f,1,"/**
 * Escapes the given string and appends it to the builder.
 * @param builder the builder
 * @param str the string
 */
private void escape(StringBuilder builder, CharSequence str) {
    final int len = str.length();
    for (int i = 0; i < len; i++) {
        char c = str.charAt(i);
        if (c == '%') {
            builder.append(""%25"");
        } else if (c == ';') {
            builder.append(""%3b"");
        } else {
            builder.append(c);
        }
    }
}","/**
 * Escapes the given string and appends it to the builder.
 * @param builder the builder
 * @param str the string
 */
","private void escape(StringBuilder builder, CharSequence str) {
    final int len = str.length();
    for (int i = 0; i < len; i++) {
        char c = str.charAt(i);
        if (c == '%') {
            builder.append(""%25"");
        } else if (c == ';') {
            builder.append(""%3b"");
        } else {
            builder.append(c);
        }
    }
}",-0.045454545454545456,0.47959183673469385,0.0,0.5,0.08333333333333333,0.34107760751359373,0.04617149412102093,-0.08333333333333333,0.9714285714285714,0.09648750861954507
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3156_786b3d76,0,"@Override
public boolean isVirtualRow() {
    return getPath() == null;
}",,"@Override
public boolean isVirtualRow() {
    return getPath() == null;
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9678806997418987,-0.4166666666666667,2.6,-0.16422749602751402
Cli,22,1,"/**
 * Breaks <code>token</code> into its constituent parts
 * using the following algorithm.
 *
 * <ul>
 *  <li>ignore the first character (""<b>-</b>"")</li>
 *  <li>foreach remaining character check if an {@link Option}
 *  exists with that id.</li>
 *  <li>if an {@link Option} does exist then add that character
 *  prepended with ""<b>-</b>"" to the list of processed tokens.</li>
 *  <li>if the {@link Option} can have an argument value and there
 *  are remaining characters in the token then add the remaining
 *  characters as a token to the list of processed tokens.</li>
 *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>
 *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token
 *  ""<b>--</b>"" followed by the remaining characters and also
 *  the remaining tokens directly to the processed tokens list.</li>
 *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>
 *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that
 *  character prepended with ""<b>-</b>"".</li>
 * </ul>
 *
 * @param token The current token to be <b>burst</b>
 * @param stopAtNonOption Specifies whether to stop processing
 * at the first non-Option encountered.
 */
protected void burstToken(String token, boolean stopAtNonOption) {
    Option currentOption;
    for (int i = 1; i < token.length(); i++) {
        String ch = String.valueOf(token.charAt(i));
        if (options.hasOption(ch)) {
            tokens.add(""-"" + ch);
            currentOption = options.getOption(ch);
            if (currentOption.hasArg() && (token.length() != (i + 1))) {
                tokens.add(token.substring(i + 1));
                break;
            }
        } else if (stopAtNonOption) {
            processNonOptionToken(token.substring(i));
            break;
        } else {
            tokens.add(token);
            break;
        }
    }
}","/**
 * Breaks <code>token</code> into its constituent parts
 * using the following algorithm.
 *
 * <ul>
 *  <li>ignore the first character (""<b>-</b>"")</li>
 *  <li>foreach remaining character check if an {@link Option}
 *  exists with that id.</li>
 *  <li>if an {@link Option} does exist then add that character
 *  prepended with ""<b>-</b>"" to the list of processed tokens.</li>
 *  <li>if the {@link Option} can have an argument value and there
 *  are remaining characters in the token then add the remaining
 *  characters as a token to the list of processed tokens.</li>
 *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>
 *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token
 *  ""<b>--</b>"" followed by the remaining characters and also
 *  the remaining tokens directly to the processed tokens list.</li>
 *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>
 *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that
 *  character prepended with ""<b>-</b>"".</li>
 * </ul>
 *
 * @param token The current token to be <b>burst</b>
 * @param stopAtNonOption Specifies whether to stop processing
 * at the first non-Option encountered.
 */
","protected void burstToken(String token, boolean stopAtNonOption) {
    Option currentOption;
    for (int i = 1; i < token.length(); i++) {
        String ch = String.valueOf(token.charAt(i));
        if (options.hasOption(ch)) {
            tokens.add(""-"" + ch);
            currentOption = options.getOption(ch);
            if (currentOption.hasArg() && (token.length() != (i + 1))) {
                tokens.add(token.substring(i + 1));
                break;
            }
        } else if (stopAtNonOption) {
            processNonOptionToken(token.substring(i));
            break;
        } else {
            tokens.add(token);
            break;
        }
    }
}",0.2727272727272727,0.7755102040816326,0.6666666666666666,0.5,0.5,0.9935739001482948,-0.2644106681961572,0.5833333333333334,-0.028571428571428574,0.7092525730145066
Closure,153,2,"private void scanRoot(Node n, Scope parent) {
    if (n.getType() == Token.FUNCTION) {
        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);
        final Node fnNameNode = n.getFirstChild();
        final Node args = fnNameNode.getNext();
        final Node body = args.getNext();
        // Bleed the function name into the scope, if it hasn't
        // been declared in the outer scope.
        String fnName = fnNameNode.getString();
        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {
            declareVar(fnName, fnNameNode, n, null, null, n);
        }
        // Args: Declare function variables
        Preconditions.checkState(args.getType() == Token.LP);
        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {
            Preconditions.checkState(a.getType() == Token.NAME);
            declareVar(a.getString(), a, args, n, null, n);
        }
        // Body
        scanVars(body, n);
    } else {
        // It's the global block
        Preconditions.checkState(scope.getParent() == null);
        scanVars(n, null);
    }
}",,"private void scanRoot(Node n, Scope parent) {
    if (n.getType() == Token.FUNCTION) {
        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);
        final Node fnNameNode = n.getFirstChild();
        final Node args = fnNameNode.getNext();
        final Node body = args.getNext();
                        String fnName = fnNameNode.getString();
        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {
            declareVar(fnName, fnNameNode, n, null, null, n);
        }
                Preconditions.checkState(args.getType() == Token.LP);
        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {
            Preconditions.checkState(a.getType() == Token.NAME);
            declareVar(a.getString(), a, args, n, null, n);
        }
                scanVars(body, n);
    } else {
                Preconditions.checkState(scope.getParent() == null);
        scanVars(n, null);
    }
}",0.3181818181818182,0.08163265306122457,0.0,0.0,0.3333333333333333,0.6258032624814632,-0.344422139374821,1.25,-0.028571428571428574,0.9571656794343008
flink,remotes/origin/bugs-dot-jar_FLINK-2437_a41bc8cc,3,"/**
 *  Checks if the given field is a valid pojo field:
 *  - it is public
 *  OR
 *   - there are getter and setter methods for the field.
 *
 *  @param f field to check
 *  @param clazz class of field
 *  @param typeHierarchy type hierarchy for materializing generic types
 */
private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {
    if (Modifier.isPublic(f.getModifiers())) {
        return true;
    } else {
        boolean hasGetter = false, hasSetter = false;
        final String fieldNameLow = f.getName().toLowerCase();
        Type fieldType = f.getGenericType();
        TypeVariable<?> fieldTypeGeneric = null;
        if (fieldType instanceof TypeVariable) {
            fieldTypeGeneric = (TypeVariable<?>) fieldType;
            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);
        }
        for (Method m : clazz.getMethods()) {
            // check for getter
            if (// The name should be ""get<FieldName>"" or ""<fieldName>"" (for scala) or ""is<fieldName>"" for boolean fields.
            (m.getName().toLowerCase().equals(""get"" + fieldNameLow) || m.getName().toLowerCase().equals(""is"" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) && // no arguments for the getter
            m.getParameterTypes().length == 0 && // return type is same as field type (or the generic variant of it)
            (m.getGenericReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)))) {
                if (hasGetter) {
                    throw new IllegalStateException(""Detected more than one getter"");
                }
                hasGetter = true;
            }
            // check for setters (<FieldName>_$eq for scala)
            if ((m.getName().toLowerCase().equals(""set"" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + ""_$eq"")) && // one parameter of the field's type
            m.getParameterTypes().length == 1 && (m.getGenericParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) && // return type is void.
            m.getReturnType().equals(Void.TYPE)) {
                if (hasSetter) {
                    throw new IllegalStateException(""Detected more than one setter"");
                }
                hasSetter = true;
            }
        }
        if (hasGetter && hasSetter) {
            return true;
        } else {
            if (!hasGetter) {
                LOG.debug(""Class "" + clazz + "" does not contain a getter for field "" + f.getName());
            }
            if (!hasSetter) {
                LOG.debug(""Class "" + clazz + "" does not contain a setter for field "" + f.getName());
            }
            return false;
        }
    }
}","/**
 *  Checks if the given field is a valid pojo field:
 *  - it is public
 *  OR
 *   - there are getter and setter methods for the field.
 *
 *  @param f field to check
 *  @param clazz class of field
 *  @param typeHierarchy type hierarchy for materializing generic types
 */
","private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {
    if (Modifier.isPublic(f.getModifiers())) {
        return true;
    } else {
        boolean hasGetter = false, hasSetter = false;
        final String fieldNameLow = f.getName().toLowerCase();
        Type fieldType = f.getGenericType();
        TypeVariable<?> fieldTypeGeneric = null;
        if (fieldType instanceof TypeVariable) {
            fieldTypeGeneric = (TypeVariable<?>) fieldType;
            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);
        }
        for (Method m : clazz.getMethods()) {
                        if (            (m.getName().toLowerCase().equals(""get"" + fieldNameLow) || m.getName().toLowerCase().equals(""is"" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) &&             m.getParameterTypes().length == 0 &&             (m.getGenericReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)))) {
                if (hasGetter) {
                    throw new IllegalStateException(""Detected more than one getter"");
                }
                hasGetter = true;
            }
                        if ((m.getName().toLowerCase().equals(""set"" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + ""_$eq"")) &&             m.getParameterTypes().length == 1 && (m.getGenericParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) &&             m.getReturnType().equals(Void.TYPE)) {
                if (hasSetter) {
                    throw new IllegalStateException(""Detected more than one setter"");
                }
                hasSetter = true;
            }
        }
        if (hasGetter && hasSetter) {
            return true;
        } else {
            if (!hasGetter) {
                LOG.debug(""Class "" + clazz + "" does not contain a getter for field "" + f.getName());
            }
            if (!hasSetter) {
                LOG.debug(""Class "" + clazz + "" does not contain a setter for field "" + f.getName());
            }
            return false;
        }
    }
}",1.3636363636363635,0.7346938775510204,1.5,1.0,2.9166666666666665,1.2249134948096887,-0.8468597648408377,2.6666666666666665,-0.028571428571428574,3.31852698934817
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-334_9d8cc45d,1,"@Override
public SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {
    RegExFilter result = new RegExFilter();
    result.setSource(getSource().deepCopy(env));
    result.rowMatcher = copyMatcher(rowMatcher);
    result.colfMatcher = copyMatcher(colfMatcher);
    result.colqMatcher = copyMatcher(colqMatcher);
    result.valueMatcher = copyMatcher(valueMatcher);
    result.orFields = orFields;
    return result;
}",,"@Override
public SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {
    RegExFilter result = new RegExFilter();
    result.setSource(getSource().deepCopy(env));
    result.rowMatcher = copyMatcher(rowMatcher);
    result.colfMatcher = copyMatcher(colfMatcher);
    result.colqMatcher = copyMatcher(colqMatcher);
    result.valueMatcher = copyMatcher(valueMatcher);
    result.orFields = orFields;
    return result;
}",-0.13636363636363635,-0.6326530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.1336392314310295,0.08333333333333333,0.0,-0.16422749602751402
maven,remotes/origin/bugs-dot-jar_MNG-4761_8cdb461f,1,"public List<Artifact> resolve(Plugin plugin, Artifact pluginArtifact, ArtifactResolutionRequest request, ArtifactFilter dependencyFilter) throws PluginResolutionException {
    if (pluginArtifact == null) {
        pluginArtifact = repositorySystem.createPluginArtifact(plugin);
    }
    Set<Artifact> overrideArtifacts = new LinkedHashSet<Artifact>();
    for (Dependency dependency : plugin.getDependencies()) {
        dependency.setScope(Artifact.SCOPE_RUNTIME);
        overrideArtifacts.add(repositorySystem.createDependencyArtifact(dependency));
    }
    ArtifactFilter collectionFilter = new ScopeArtifactFilter(Artifact.SCOPE_RUNTIME_PLUS_SYSTEM);
    ArtifactFilter resolutionFilter = artifactFilterManager.getCoreArtifactFilter();
    PluginDependencyResolutionListener listener = new PluginDependencyResolutionListener(resolutionFilter);
    if (dependencyFilter != null) {
        resolutionFilter = new AndArtifactFilter(Arrays.asList(resolutionFilter, dependencyFilter));
    }
    request.setArtifact(pluginArtifact);
    request.setArtifactDependencies(overrideArtifacts);
    request.setCollectionFilter(collectionFilter);
    request.setResolutionFilter(resolutionFilter);
    request.setResolveRoot(true);
    request.setResolveTransitively(true);
    request.addListener(listener);
    ArtifactResolutionResult result = repositorySystem.resolve(request);
    try {
        resolutionErrorHandler.throwErrors(request, result);
    } catch (ArtifactResolutionException e) {
        throw new PluginResolutionException(plugin, e);
    }
    List<Artifact> pluginArtifacts = new ArrayList<Artifact>(result.getArtifacts());
    listener.removeBannedDependencies(pluginArtifacts);
    addPlexusUtils(pluginArtifacts, plugin, request);
    return pluginArtifacts;
}",,"public List<Artifact> resolve(Plugin plugin, Artifact pluginArtifact, ArtifactResolutionRequest request, ArtifactFilter dependencyFilter) throws PluginResolutionException {
    if (pluginArtifact == null) {
        pluginArtifact = repositorySystem.createPluginArtifact(plugin);
    }
    Set<Artifact> overrideArtifacts = new LinkedHashSet<Artifact>();
    for (Dependency dependency : plugin.getDependencies()) {
        dependency.setScope(Artifact.SCOPE_RUNTIME);
        overrideArtifacts.add(repositorySystem.createDependencyArtifact(dependency));
    }
    ArtifactFilter collectionFilter = new ScopeArtifactFilter(Artifact.SCOPE_RUNTIME_PLUS_SYSTEM);
    ArtifactFilter resolutionFilter = artifactFilterManager.getCoreArtifactFilter();
    PluginDependencyResolutionListener listener = new PluginDependencyResolutionListener(resolutionFilter);
    if (dependencyFilter != null) {
        resolutionFilter = new AndArtifactFilter(Arrays.asList(resolutionFilter, dependencyFilter));
    }
    request.setArtifact(pluginArtifact);
    request.setArtifactDependencies(overrideArtifacts);
    request.setCollectionFilter(collectionFilter);
    request.setResolutionFilter(resolutionFilter);
    request.setResolveRoot(true);
    request.setResolveTransitively(true);
    request.addListener(listener);
    ArtifactResolutionResult result = repositorySystem.resolve(request);
    try {
        resolutionErrorHandler.throwErrors(request, result);
    } catch (ArtifactResolutionException e) {
        throw new PluginResolutionException(plugin, e);
    }
    List<Artifact> pluginArtifacts = new ArrayList<Artifact>(result.getArtifacts());
    listener.removeBannedDependencies(pluginArtifacts);
    addPlexusUtils(pluginArtifacts, plugin, request);
    return pluginArtifacts;
}",0.8636363636363636,-0.5663265306122449,0.3333333333333333,-0.5,-0.08333333333333333,0.006920415224913524,-0.6117006022368799,1.0833333333333333,-0.028571428571428574,0.41712601881951844
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2062_5c4589bd,1,"private PropertyValue currentOakProperty(String oakPropertyName, Integer propertyType) {
    boolean asterisk = oakPropertyName.indexOf('*') >= 0;
    if (asterisk) {
        Tree t = currentTree();
        ArrayList<PropertyValue> list = new ArrayList<PropertyValue>();
        readOakProperties(list, t, oakPropertyName, propertyType);
        if (list.size() == 0) {
            return null;
        } else if (list.size() == 1) {
            return list.get(0);
        }
        Type<?> type = list.get(0).getType();
        for (int i = 1; i < list.size(); i++) {
            Type<?> t2 = list.get(i).getType();
            if (t2 != type) {
                // types don't match
                type = Type.STRING;
                break;
            }
        }
        if (type == Type.STRING) {
            ArrayList<String> strings = new ArrayList<String>();
            for (PropertyValue p : list) {
                Iterables.addAll(strings, p.getValue(Type.STRINGS));
            }
            return PropertyValues.newString(strings);
        }
        @SuppressWarnings(""unchecked"")
        PropertyBuilder<Object> builder = (PropertyBuilder<Object>) PropertyBuilder.array(type);
        builder.setName("""");
        for (PropertyValue v : list) {
            builder.addValue(v.getValue(type));
        }
        PropertyState s = builder.getPropertyState();
        return PropertyValues.create(s);
    }
    boolean relative = oakPropertyName.indexOf('/') >= 0;
    Tree t = currentTree();
    if (relative) {
        for (String p : PathUtils.elements(PathUtils.getParentPath(oakPropertyName))) {
            if (t == null) {
                return null;
            }
            if (p.equals("".."")) {
                t = t.isRoot() ? null : t.getParent();
            } else if (p.equals(""."")) {
            // same node
            } else {
                t = t.getChild(p);
            }
        }
        oakPropertyName = PathUtils.getName(oakPropertyName);
    }
    return currentOakProperty(t, oakPropertyName, propertyType);
}",,"private PropertyValue currentOakProperty(String oakPropertyName, Integer propertyType) {
    boolean asterisk = oakPropertyName.indexOf('*') >= 0;
    if (asterisk) {
        Tree t = currentTree();
        ArrayList<PropertyValue> list = new ArrayList<PropertyValue>();
        readOakProperties(list, t, oakPropertyName, propertyType);
        if (list.size() == 0) {
            return null;
        } else if (list.size() == 1) {
            return list.get(0);
        }
        Type<?> type = list.get(0).getType();
        for (int i = 1; i < list.size(); i++) {
            Type<?> t2 = list.get(i).getType();
            if (t2 != type) {
                                type = Type.STRING;
                break;
            }
        }
        if (type == Type.STRING) {
            ArrayList<String> strings = new ArrayList<String>();
            for (PropertyValue p : list) {
                Iterables.addAll(strings, p.getValue(Type.STRINGS));
            }
            return PropertyValues.newString(strings);
        }
        @SuppressWarnings(""unchecked"")
        PropertyBuilder<Object> builder = (PropertyBuilder<Object>) PropertyBuilder.array(type);
        builder.setName("""");
        for (PropertyValue v : list) {
            builder.addValue(v.getValue(type));
        }
        PropertyState s = builder.getPropertyState();
        return PropertyValues.create(s);
    }
    boolean relative = oakPropertyName.indexOf('/') >= 0;
    Tree t = currentTree();
    if (relative) {
        for (String p : PathUtils.elements(PathUtils.getParentPath(oakPropertyName))) {
            if (t == null) {
                return null;
            }
            if (p.equals("".."")) {
                t = t.isRoot() ? null : t.getParent();
            } else if (p.equals(""."")) {
                        } else {
                t = t.getChild(p);
            }
        }
        oakPropertyName = PathUtils.getName(oakPropertyName);
    }
    return currentOakProperty(t, oakPropertyName, propertyType);
}",1.7727272727272727,0.46428571428571436,2.0,1.0,1.3333333333333333,1.0884824518042513,-0.9618583309435049,2.0833333333333335,-0.028571428571428574,3.2122485341419647
commons-math,remotes/origin/bugs-dot-jar_MATH-343_f6dd42b4,0,"/**
 * Find a zero in the given interval with an initial guess.
 * <p>Throws <code>IllegalArgumentException</code> if the values of the
 * function at the three points have the same sign (note that it is
 * allowed to have endpoints with the same sign if the initial point has
 * opposite sign function-wise).</p>
 *
 * @param f function to solve.
 * @param min the lower bound for the interval.
 * @param max the upper bound for the interval.
 * @param initial the start value to use (must be set to min if no
 * initial point is known).
 * @return the value where the function is zero
 * @throws MaxIterationsExceededException the maximum iteration count
 * is exceeded
 * @throws FunctionEvaluationException if an error occurs evaluating
 *  the function
 * @throws IllegalArgumentException if initial is not between min and max
 * (even if it <em>is</em> a root)
 */
public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {
    clearResult();
    verifySequence(min, initial, max);
    // return the initial guess if it is good enough
    double yInitial = f.value(initial);
    if (Math.abs(yInitial) <= functionValueAccuracy) {
        setResult(initial, 0);
        return result;
    }
    // return the first endpoint if it is good enough
    double yMin = f.value(min);
    if (Math.abs(yMin) <= functionValueAccuracy) {
        setResult(yMin, 0);
        return result;
    }
    // reduce interval if min and initial bracket the root
    if (yInitial * yMin < 0) {
        return solve(f, min, yMin, initial, yInitial, min, yMin);
    }
    // return the second endpoint if it is good enough
    double yMax = f.value(max);
    if (Math.abs(yMax) <= functionValueAccuracy) {
        setResult(yMax, 0);
        return result;
    }
    // reduce interval if initial and max bracket the root
    if (yInitial * yMax < 0) {
        return solve(f, initial, yInitial, max, yMax, initial, yInitial);
    }
    // full Brent algorithm starting with provided initial guess
    return solve(f, min, yMin, max, yMax, initial, yInitial);
}","/**
 * Find a zero in the given interval with an initial guess.
 * <p>Throws <code>IllegalArgumentException</code> if the values of the
 * function at the three points have the same sign (note that it is
 * allowed to have endpoints with the same sign if the initial point has
 * opposite sign function-wise).</p>
 *
 * @param f function to solve.
 * @param min the lower bound for the interval.
 * @param max the upper bound for the interval.
 * @param initial the start value to use (must be set to min if no
 * initial point is known).
 * @return the value where the function is zero
 * @throws MaxIterationsExceededException the maximum iteration count
 * is exceeded
 * @throws FunctionEvaluationException if an error occurs evaluating
 *  the function
 * @throws IllegalArgumentException if initial is not between min and max
 * (even if it <em>is</em> a root)
 */
","public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {
    clearResult();
    verifySequence(min, initial, max);
        double yInitial = f.value(initial);
    if (Math.abs(yInitial) <= functionValueAccuracy) {
        setResult(initial, 0);
        return result;
    }
        double yMin = f.value(min);
    if (Math.abs(yMin) <= functionValueAccuracy) {
        setResult(yMin, 0);
        return result;
    }
        if (yInitial * yMin < 0) {
        return solve(f, min, yMin, initial, yInitial, min, yMin);
    }
        double yMax = f.value(max);
    if (Math.abs(yMax) <= functionValueAccuracy) {
        setResult(yMax, 0);
        return result;
    }
        if (yInitial * yMax < 0) {
        return solve(f, initial, yInitial, max, yMax, initial, yInitial);
    }
        return solve(f, min, yMin, max, yMax, initial, yInitial);
}",0.5454545454545454,-0.36734693877551033,0.3333333333333333,-0.5,0.5833333333333334,1.1260504201680674,-0.42615428735302563,0.6666666666666666,-0.028571428571428574,1.1996350880799722
wicket,remotes/origin/bugs-dot-jar_WICKET-4816_66bfc885,1,"/**
 *  Strip any jsessionid and possibly other redundant info that might be in our way.
 *
 *  @param url
 *             The url to strip
 *  @return The stripped url
 */
public static String stripJSessionId(final String url) {
    if (url == null) {
        return null;
    }
    // http://.../abc;jsessionid=...?param=...
    int ixSemiColon = url.indexOf("";"");
    if (ixSemiColon == -1) {
        return url;
    }
    int ixQuestionMark = url.indexOf(""?"");
    if (ixQuestionMark == -1) {
        // http://.../abc;jsession=...
        return url.substring(0, ixSemiColon);
    }
    if (ixQuestionMark <= ixSemiColon) {
        // ? is before ; - no jsessionid in the url
        return url;
    }
    return url.substring(0, ixSemiColon) + url.substring(ixQuestionMark);
}","/**
 *  Strip any jsessionid and possibly other redundant info that might be in our way.
 *
 *  @param url
 *             The url to strip
 *  @return The stripped url
 */
","public static String stripJSessionId(final String url) {
    if (url == null) {
        return null;
    }
        int ixSemiColon = url.indexOf("";"");
    if (ixSemiColon == -1) {
        return url;
    }
    int ixQuestionMark = url.indexOf(""?"");
    if (ixQuestionMark == -1) {
                return url.substring(0, ixSemiColon);
    }
    if (ixQuestionMark <= ixSemiColon) {
                return url;
    }
    return url.substring(0, ixSemiColon) + url.substring(ixQuestionMark);
}",0.13636363636363635,-0.3520408163265306,0.16666666666666666,-0.5,0.16666666666666666,0.6831438457736037,-0.09922569544020673,-0.08333333333333333,-0.028571428571428574,0.25891186006570127
wicket,remotes/origin/bugs-dot-jar_WICKET-4923_d78132be,1,"private Url decryptUrl(final Request request, final Url encryptedUrl) {
    /*
		 * If the encrypted URL has no segments it is the home page URL,
		 * and does not need decrypting.
		 */
    if (encryptedUrl.getSegments().isEmpty()) {
        return encryptedUrl;
    }
    List<String> encryptedSegments = encryptedUrl.getSegments();
    Url url = new Url(request.getCharset());
    try {
        /*
			 * The first encrypted segment contains an encrypted version of the
			 * entire plain text url.
			 */
        String encryptedUrlString = encryptedSegments.get(0);
        if (Strings.isEmpty(encryptedUrlString)) {
            return null;
        }
        String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);
        if (decryptedUrl == null) {
            return null;
        }
        Url originalUrl = Url.parse(decryptedUrl, request.getCharset());
        int originalNumberOfSegments = originalUrl.getSegments().size();
        int encryptedNumberOfSegments = encryptedUrl.getSegments().size();
        HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);
        int segNo = 1;
        for (; segNo < encryptedNumberOfSegments; segNo++) {
            if (segNo > originalNumberOfSegments) {
                break;
            }
            String next = generator.next();
            String encryptedSegment = encryptedSegments.get(segNo);
            if (!next.equals(encryptedSegment)) {
                /*
					 * This segment received from the browser is not the same as the
					 * expected segment generated by the HashSegmentGenerator. Hence it,
					 * and all subsequent segments are considered plain text siblings of the
					 * original encrypted url.
					 */
                break;
            }
            /*
				 * This segments matches the expected checksum, so we add the corresponding
				 * segment from the original URL.
				 */
            url.getSegments().add(originalUrl.getSegments().get(segNo - 1));
        }
        /*
			 * Add all remaining segments from the encrypted url as plain text segments.
			 */
        for (; segNo < encryptedNumberOfSegments; segNo++) {
            // modified or additional segment
            url.getSegments().add(encryptedUrl.getSegments().get(segNo));
        }
        url.getQueryParameters().addAll(originalUrl.getQueryParameters());
    } catch (Exception e) {
        log.error(""Error decrypting URL"", e);
        url = null;
    }
    return url;
}",,"private Url decryptUrl(final Request request, final Url encryptedUrl) {
        if (encryptedUrl.getSegments().isEmpty()) {
        return encryptedUrl;
    }
    List<String> encryptedSegments = encryptedUrl.getSegments();
    Url url = new Url(request.getCharset());
    try {
                String encryptedUrlString = encryptedSegments.get(0);
        if (Strings.isEmpty(encryptedUrlString)) {
            return null;
        }
        String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);
        if (decryptedUrl == null) {
            return null;
        }
        Url originalUrl = Url.parse(decryptedUrl, request.getCharset());
        int originalNumberOfSegments = originalUrl.getSegments().size();
        int encryptedNumberOfSegments = encryptedUrl.getSegments().size();
        HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);
        int segNo = 1;
        for (; segNo < encryptedNumberOfSegments; segNo++) {
            if (segNo > originalNumberOfSegments) {
                break;
            }
            String next = generator.next();
            String encryptedSegment = encryptedSegments.get(segNo);
            if (!next.equals(encryptedSegment)) {
                                break;
            }
                        url.getSegments().add(originalUrl.getSegments().get(segNo - 1));
        }
                for (; segNo < encryptedNumberOfSegments; segNo++) {
                        url.getSegments().add(encryptedUrl.getSegments().get(segNo));
        }
        url.getQueryParameters().addAll(originalUrl.getQueryParameters());
    } catch (Exception e) {
        log.error(""Error decrypting URL"", e);
        url = null;
    }
    return url;
}",1.2272727272727273,0.31632653061224497,1.1666666666666667,0.5,0.9166666666666666,1.1814137419673754,-0.7505018640665331,1.9166666666666667,-0.028571428571428574,2.255352683944304
maven,remotes/origin/bugs-dot-jar_MNG-1856_faa5cf27,3,"private void assembleDistributionInheritence(Model child, Model parent, String childPathAdjustment, boolean appendPaths) {
    if (parent.getDistributionManagement() != null) {
        DistributionManagement parentDistMgmt = parent.getDistributionManagement();
        DistributionManagement childDistMgmt = child.getDistributionManagement();
        if (childDistMgmt == null) {
            childDistMgmt = new DistributionManagement();
            child.setDistributionManagement(childDistMgmt);
        }
        if (childDistMgmt.getSite() == null) {
            if (parentDistMgmt.getSite() != null) {
                Site site = new Site();
                childDistMgmt.setSite(site);
                site.setId(parentDistMgmt.getSite().getId());
                site.setName(parentDistMgmt.getSite().getName());
                site.setUrl(parentDistMgmt.getSite().getUrl());
                if (site.getUrl() != null) {
                    site.setUrl(appendPath(site.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths));
                }
            }
        }
        if (childDistMgmt.getRepository() == null) {
            if (parentDistMgmt.getRepository() != null) {
                DeploymentRepository repository = new DeploymentRepository();
                childDistMgmt.setRepository(repository);
                repository.setId(parentDistMgmt.getRepository().getId());
                repository.setName(parentDistMgmt.getRepository().getName());
                repository.setUrl(parentDistMgmt.getRepository().getUrl());
                repository.setUniqueVersion(parentDistMgmt.getRepository().isUniqueVersion());
            }
        }
        if (childDistMgmt.getSnapshotRepository() == null) {
            if (parentDistMgmt.getSnapshotRepository() != null) {
                DeploymentRepository repository = new DeploymentRepository();
                childDistMgmt.setSnapshotRepository(repository);
                repository.setId(parentDistMgmt.getSnapshotRepository().getId());
                repository.setName(parentDistMgmt.getSnapshotRepository().getName());
                repository.setUrl(parentDistMgmt.getSnapshotRepository().getUrl());
                repository.setUniqueVersion(parentDistMgmt.getSnapshotRepository().isUniqueVersion());
            }
        }
    }
}",,"private void assembleDistributionInheritence(Model child, Model parent, String childPathAdjustment, boolean appendPaths) {
    if (parent.getDistributionManagement() != null) {
        DistributionManagement parentDistMgmt = parent.getDistributionManagement();
        DistributionManagement childDistMgmt = child.getDistributionManagement();
        if (childDistMgmt == null) {
            childDistMgmt = new DistributionManagement();
            child.setDistributionManagement(childDistMgmt);
        }
        if (childDistMgmt.getSite() == null) {
            if (parentDistMgmt.getSite() != null) {
                Site site = new Site();
                childDistMgmt.setSite(site);
                site.setId(parentDistMgmt.getSite().getId());
                site.setName(parentDistMgmt.getSite().getName());
                site.setUrl(parentDistMgmt.getSite().getUrl());
                if (site.getUrl() != null) {
                    site.setUrl(appendPath(site.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths));
                }
            }
        }
        if (childDistMgmt.getRepository() == null) {
            if (parentDistMgmt.getRepository() != null) {
                DeploymentRepository repository = new DeploymentRepository();
                childDistMgmt.setRepository(repository);
                repository.setId(parentDistMgmt.getRepository().getId());
                repository.setName(parentDistMgmt.getRepository().getName());
                repository.setUrl(parentDistMgmt.getRepository().getUrl());
                repository.setUniqueVersion(parentDistMgmt.getRepository().isUniqueVersion());
            }
        }
        if (childDistMgmt.getSnapshotRepository() == null) {
            if (parentDistMgmt.getSnapshotRepository() != null) {
                DeploymentRepository repository = new DeploymentRepository();
                childDistMgmt.setSnapshotRepository(repository);
                repository.setId(parentDistMgmt.getSnapshotRepository().getId());
                repository.setName(parentDistMgmt.getSnapshotRepository().getName());
                repository.setUrl(parentDistMgmt.getSnapshotRepository().getUrl());
                repository.setUniqueVersion(parentDistMgmt.getSnapshotRepository().isUniqueVersion());
            }
        }
    }
}",1.2727272727272727,0.8775510204081634,1.0,1.0,1.0833333333333333,0.374691052891745,-0.7634069400630918,3.75,-0.028571428571428574,1.0727810828290096
wicket,remotes/origin/bugs-dot-jar_WICKET-4997_ee02c883,1,"/**
 *  Gets a URL for the listener interface (e.g. ILinkListener).
 *
 *  @see RequestCycle#urlFor(IRequestHandler)
 *
 *  @param listener
 *             The listener interface that the URL should call
 *  @param parameters
 *             The parameters that should be rendered into the urls
 *  @return The URL
 */
public final CharSequence urlFor(final RequestListenerInterface listener, final PageParameters parameters) {
    Page page = getPage();
    PageAndComponentProvider provider = new PageAndComponentProvider(page, this, parameters);
    IRequestHandler handler;
    if (page.isBookmarkable()) {
        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener);
    } else {
        handler = new ListenerInterfaceRequestHandler(provider, listener);
    }
    return getRequestCycle().urlFor(handler);
}","/**
 *  Gets a URL for the listener interface (e.g. ILinkListener).
 *
 *  @see RequestCycle#urlFor(IRequestHandler)
 *
 *  @param listener
 *             The listener interface that the URL should call
 *  @param parameters
 *             The parameters that should be rendered into the urls
 *  @return The URL
 */
","public final CharSequence urlFor(final RequestListenerInterface listener, final PageParameters parameters) {
    Page page = getPage();
    PageAndComponentProvider provider = new PageAndComponentProvider(page, this, parameters);
    IRequestHandler handler;
    if (page.isBookmarkable()) {
        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener);
    } else {
        handler = new ListenerInterfaceRequestHandler(provider, listener);
    }
    return getRequestCycle().urlFor(handler);
}",-0.13636363636363635,-0.3112244897959183,-0.3333333333333333,-0.5,-0.25,-0.3806228373702422,0.15858904502437632,-0.16666666666666666,0.31428571428571433,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-5751_bcea89fc,1,"/**
 *  Reconstitute the <tt>HashMap</tt> instance from a stream (i.e., deserialize it).
 *
 *  @param s
 *  @throws IOException
 *  @throws ClassNotFoundException
 */
@SuppressWarnings(""unchecked"")
private void readObject(final java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {
    // Read in the threshold, loadfactor, and any hidden stuff
    s.defaultReadObject();
    // Read in number of buckets and allocate the bucket array;
    int numBuckets = s.readInt();
    table = new Entry[numBuckets];
    // Give subclass a chance to do its thing.
    init();
    // Read in size (number of Mappings)
    int size = s.readInt();
    // Read the keys and values, and put the mappings in the HashMap
    for (int i = 0; i < size; i++) {
        int key = s.readInt();
        V value = (V) s.readObject();
        putForCreate(key, value);
    }
}","/**
 *  Reconstitute the <tt>HashMap</tt> instance from a stream (i.e., deserialize it).
 *
 *  @param s
 *  @throws IOException
 *  @throws ClassNotFoundException
 */
","@SuppressWarnings(""unchecked"")
private void readObject(final java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {
        s.defaultReadObject();
        int numBuckets = s.readInt();
    table = new Entry[numBuckets];
        init();
        int size = s.readInt();
        for (int i = 0; i < size; i++) {
        int key = s.readInt();
        V value = (V) s.readObject();
        putForCreate(key, value);
    }
}",-0.045454545454545456,-0.15306122448979584,-0.3333333333333333,-0.5,-0.16666666666666666,-0.054374691052891735,0.020648121594493807,0.08333333333333333,0.5428571428571429,-0.011225752844985237
Closure,153,2,"void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber);",,"void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber);",-0.5909090909090909,-1.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.4419271580154864,-0.5,-0.028571428571428574,-0.16422749602751402
Math,101,1,"/**
 * Parses a string to produce a {@link Complex} object.
 *
 * @param source the string to parse
 * @param pos input/ouput parsing parameter.
 * @return the parsed {@link Complex} object.
 */
public Complex parse(String source, ParsePosition pos) {
    int initialIndex = pos.getIndex();
    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);
    // parse real
    Number re = parseNumber(source, getRealFormat(), pos);
    if (re == null) {
        // invalid real number
        // set index back to initial, error index should already be set
        // character examined.
        pos.setIndex(initialIndex);
        return null;
    }
    // parse sign
    int startIndex = pos.getIndex();
    char c = parseNextCharacter(source, pos);
    int sign = 0;
    switch(c) {
        case 0:
            // return real only complex number
            return new Complex(re.doubleValue(), 0.0);
        case '-':
            sign = -1;
            break;
        case '+':
            sign = 1;
            break;
        default:
            // invalid sign
            // set index back to initial, error index should be the last
            // character examined.
            pos.setIndex(initialIndex);
            pos.setErrorIndex(startIndex);
            return null;
    }
    // parse whitespace
    parseAndIgnoreWhitespace(source, pos);
    // parse imaginary
    Number im = parseNumber(source, getRealFormat(), pos);
    if (im == null) {
        // invalid imaginary number
        // set index back to initial, error index should already be set
        // character examined.
        pos.setIndex(initialIndex);
        return null;
    }
    // parse imaginary character
    int n = getImaginaryCharacter().length();
    startIndex = pos.getIndex();
    int endIndex = startIndex + n;
    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {
        // set index back to initial, error index should be the start index
        // character examined.
        pos.setIndex(initialIndex);
        pos.setErrorIndex(startIndex);
        return null;
    }
    pos.setIndex(endIndex);
    return new Complex(re.doubleValue(), im.doubleValue() * sign);
}","/**
 * Parses a string to produce a {@link Complex} object.
 *
 * @param source the string to parse
 * @param pos input/ouput parsing parameter.
 * @return the parsed {@link Complex} object.
 */
","public Complex parse(String source, ParsePosition pos) {
    int initialIndex = pos.getIndex();
        parseAndIgnoreWhitespace(source, pos);
        Number re = parseNumber(source, getRealFormat(), pos);
    if (re == null) {
                                pos.setIndex(initialIndex);
        return null;
    }
        int startIndex = pos.getIndex();
    char c = parseNextCharacter(source, pos);
    int sign = 0;
    switch(c) {
        case 0:
                        return new Complex(re.doubleValue(), 0.0);
        case '-':
            sign = -1;
            break;
        case '+':
            sign = 1;
            break;
        default:
                                                pos.setIndex(initialIndex);
            pos.setErrorIndex(startIndex);
            return null;
    }
        parseAndIgnoreWhitespace(source, pos);
        Number im = parseNumber(source, getRealFormat(), pos);
    if (im == null) {
                                pos.setIndex(initialIndex);
        return null;
    }
        int n = getImaginaryCharacter().length();
    startIndex = pos.getIndex();
    int endIndex = startIndex + n;
    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {
                        pos.setIndex(initialIndex);
        pos.setErrorIndex(startIndex);
        return null;
    }
    pos.setIndex(endIndex);
    return new Complex(re.doubleValue(), im.doubleValue() * sign);
}",1.2727272727272727,0.1887755102040817,1.0,0.0,0.5,1.3633217993079587,-0.7347289934040726,1.5833333333333333,-0.028571428571428574,2.1889018806669496
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1372_1d12bf0e,3,"@Override
protected PrettyPrinter newPrettyPrinter() {
    return new DefaultXmlPrettyPrinter();
}",,"@Override
protected PrettyPrinter newPrettyPrinter() {
    return new DefaultXmlPrettyPrinter();
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.0108976197304276,-0.5,1.5714285714285716,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-442_246d53c5,1,"/**
 *  Removes any rendered feedback messages as well as compacts memory. This
 *  method is usually called at the end of the request cycle processing.
 */
final void cleanupFeedbackMessages() {
    int size = feedbackMessages.size();
    feedbackMessages.clearRendered();
    // the session is dirty when the list of feedback messages was changed
    if (size != feedbackMessages.size()) {
        dirty();
    }
}","/**
 *  Removes any rendered feedback messages as well as compacts memory. This
 *  method is usually called at the end of the request cycle processing.
 */
","final void cleanupFeedbackMessages() {
    int size = feedbackMessages.size();
    feedbackMessages.clearRendered();
        if (size != feedbackMessages.size()) {
        dirty();
    }
}",-0.3181818181818182,-0.2346938775510204,-0.3333333333333333,-0.5,-0.16666666666666666,-0.01878398418190801,0.5638084313163179,-0.16666666666666666,2.314285714285714,-0.1336040191707248
camel,remotes/origin/bugs-dot-jar_CAMEL-7429_43956f93,1,"private String createPlaceholderPart(String key, Properties properties, List<String> replaced, String prefixToken, String suffixToken) {
    // keep track of which parts we have replaced
    replaced.add(key);
    String propertyValue = System.getProperty(key);
    if (propertyValue != null) {
        log.debug(""Found a JVM system property: {} with value: {} to be used."", key, propertyValue);
    } else if (properties != null) {
        propertyValue = properties.getProperty(key);
    }
    // we need to check if the propertyValue is nested
    // we need to check if there is cycle dependency of the nested properties
    List<String> visited = new ArrayList<String>();
    while (isNestProperty(propertyValue, prefixToken, suffixToken)) {
        visited.add(key);
        // need to take off the token first
        String value = takeOffNestTokes(propertyValue, prefixToken, suffixToken);
        key = parseUri(value, properties, prefixToken, suffixToken);
        if (visited.contains(key)) {
            throw new IllegalArgumentException(""Circular reference detected with key ["" + key + ""] from text: "" + propertyValue);
        }
        propertyValue = System.getProperty(key);
        if (propertyValue != null) {
            log.debug(""Found a JVM system property: {} with value: {} to be used."", key, propertyValue);
        } else if (properties != null) {
            propertyValue = properties.getProperty(key);
        }
    }
    return parseProperty(key, propertyValue, properties);
}",,"private String createPlaceholderPart(String key, Properties properties, List<String> replaced, String prefixToken, String suffixToken) {
        replaced.add(key);
    String propertyValue = System.getProperty(key);
    if (propertyValue != null) {
        log.debug(""Found a JVM system property: {} with value: {} to be used."", key, propertyValue);
    } else if (properties != null) {
        propertyValue = properties.getProperty(key);
    }
            List<String> visited = new ArrayList<String>();
    while (isNestProperty(propertyValue, prefixToken, suffixToken)) {
        visited.add(key);
                String value = takeOffNestTokes(propertyValue, prefixToken, suffixToken);
        key = parseUri(value, properties, prefixToken, suffixToken);
        if (visited.contains(key)) {
            throw new IllegalArgumentException(""Circular reference detected with key ["" + key + ""] from text: "" + propertyValue);
        }
        propertyValue = System.getProperty(key);
        if (propertyValue != null) {
            log.debug(""Found a JVM system property: {} with value: {} to be used."", key, propertyValue);
        } else if (properties != null) {
            propertyValue = properties.getProperty(key);
        }
    }
    return parseProperty(key, propertyValue, properties);
}",0.5,0.09183673469387764,0.6666666666666666,0.5,0.6666666666666666,0.21848739495798322,-0.44766274734729006,0.5833333333333334,-0.028571428571428574,0.48560696587730906
Cli,1,1,"/**
 * Returns an array of the processed {@link Option}s.
 *
 * @return an array of the processed {@link Option}s.
 */
public Option[] getOptions() {
    Collection processed = options.values();
    // reinitialise array
    Option[] optionsArray = new Option[processed.size()];
    // return the array
    return (Option[]) processed.toArray(optionsArray);
}","/**
 * Returns an array of the processed {@link Option}s.
 *
 * @return an array of the processed {@link Option}s.
 */
","public Option[] getOptions() {
    Collection processed = options.values();
        Option[] optionsArray = new Option[processed.size()];
        return (Option[]) processed.toArray(optionsArray);
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.65672497849154,-0.25,2.742857142857143,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1877_716e1237,0,"private static NodeBuilder postAsyncRunNodeStatus(NodeBuilder builder, String name) {
    String now = now();
    builder.getChildNode(INDEX_DEFINITIONS_NAME).setProperty(name + ""-status"", STATUS_DONE).setProperty(name + ""-done"", now, Type.DATE).removeProperty(name + ""-start"");
    return builder;
}",,"private static NodeBuilder postAsyncRunNodeStatus(NodeBuilder builder, String name) {
    String now = now();
    builder.getChildNode(INDEX_DEFINITIONS_NAME).setProperty(name + ""-status"", STATUS_DONE).setProperty(name + ""-done"", now, Type.DATE).removeProperty(name + ""-start"");
    return builder;
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.06623826000988627,0.5451677659879551,-0.08333333333333333,0.0,-0.07464847246671036
wicket,remotes/origin/bugs-dot-jar_WICKET-3278_60d07288,1,"/**
 *  The localizer will be ask for the property to display Depending on if null is allowed or not
 *  it will ask for:
 *
 *  <ul>
 *  <li>nullValid: when null is valid and by default it will show an empty string as a choice.</li>
 *  <li>null: when null is not a valid choice and it will make a choice with ""Choose One""</li>
 *  </ul>
 *
 *  The choice for null is valid will always be returned. The choice when null is not valid will
 *  only be returned if the selected object is null.
 *
 *  @see org.apache.wicket.markup.html.form.AbstractChoice#getDefaultChoice(Object)
 */
@Override
protected CharSequence getDefaultChoice(final Object selected) {
    // Is null a valid selection value?
    if (isNullValid()) {
        // Null is valid, so look up the value for it
        String option = getLocalizer().getStringIgnoreSettings(getNullValidKey(), this, null, null);
        if (Strings.isEmpty(option)) {
            option = getLocalizer().getString(""nullValid"", this, """");
        }
        // The <option> tag buffer
        final AppendingStringBuffer buffer = new AppendingStringBuffer(64 + option.length());
        // Add option tag
        buffer.append(""\n<option"");
        // If null is selected, indicate that
        if (selected == null) {
            buffer.append("" selected=\""selected\"""");
        }
        // Add body of option tag
        buffer.append("" value=\""\"">"").append(option).append(""</option>"");
        return buffer;
    } else {
        // Null is not valid. Is it selected anyway?
        if ((selected == null) || getNoSelectionValue().equals(selected) || selected.equals(EMPTY_STRING)) {
            // Force the user to pick a non-null value
            String option = getLocalizer().getStringIgnoreSettings(getNullKey(), this, null, null);
            if (Strings.isEmpty(option)) {
                option = getLocalizer().getString(""null"", this, CHOOSE_ONE);
            }
            return ""\n<option selected=\""selected\"" value=\""\"">"" + option + ""</option>"";
        }
    }
    return """";
}","/**
 *  The localizer will be ask for the property to display Depending on if null is allowed or not
 *  it will ask for:
 *
 *  <ul>
 *  <li>nullValid: when null is valid and by default it will show an empty string as a choice.</li>
 *  <li>null: when null is not a valid choice and it will make a choice with ""Choose One""</li>
 *  </ul>
 *
 *  The choice for null is valid will always be returned. The choice when null is not valid will
 *  only be returned if the selected object is null.
 *
 *  @see org.apache.wicket.markup.html.form.AbstractChoice#getDefaultChoice(Object)
 */
","@Override
protected CharSequence getDefaultChoice(final Object selected) {
        if (isNullValid()) {
                String option = getLocalizer().getStringIgnoreSettings(getNullValidKey(), this, null, null);
        if (Strings.isEmpty(option)) {
            option = getLocalizer().getString(""nullValid"", this, """");
        }
                final AppendingStringBuffer buffer = new AppendingStringBuffer(64 + option.length());
                buffer.append(""\n<option"");
                if (selected == null) {
            buffer.append("" selected=\""selected\"""");
        }
                buffer.append("" value=\""\"">"").append(option).append(""</option>"");
        return buffer;
    } else {
                if ((selected == null) || getNoSelectionValue().equals(selected) || selected.equals(EMPTY_STRING)) {
                        String option = getLocalizer().getStringIgnoreSettings(getNullKey(), this, null, null);
            if (Strings.isEmpty(option)) {
                option = getLocalizer().getString(""null"", this, CHOOSE_ONE);
            }
            return ""\n<option selected=\""selected\"" value=\""\"">"" + option + ""</option>"";
        }
    }
    return """";
}",0.5,0.5357142857142858,0.3333333333333333,0.5,0.6666666666666666,0.4695996045477015,-0.4092342988242042,1.3333333333333333,-0.028571428571428574,0.6134503449959525
maven,remotes/origin/bugs-dot-jar_MNG-4695_bb39b480,1,"public void validateRawModel(Model model, ModelBuildingRequest request, ModelProblemCollector problems) {
    Parent parent = model.getParent();
    if (parent != null) {
        validateStringNotEmpty(""parent.groupId"", problems, Severity.FATAL, parent.getGroupId(), parent);
        validateStringNotEmpty(""parent.artifactId"", problems, Severity.FATAL, parent.getArtifactId(), parent);
        validateStringNotEmpty(""parent.version"", problems, Severity.FATAL, parent.getVersion(), parent);
        if (equals(parent.getGroupId(), model.getGroupId()) && equals(parent.getArtifactId(), model.getArtifactId())) {
            addViolation(problems, Severity.FATAL, ""parent.artifactId"", null, ""must be changed"" + "", the parent element cannot have the same groupId:artifactId as the project."", parent);
        }
    }
    if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {
        Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);
        validateEnum(""modelVersion"", problems, Severity.ERROR, model.getModelVersion(), null, model, ""4.0.0"");
        validateStringNoExpression(""groupId"", problems, Severity.WARNING, model.getGroupId(), model);
        validateStringNoExpression(""artifactId"", problems, Severity.WARNING, model.getArtifactId(), model);
        validateStringNoExpression(""version"", problems, Severity.WARNING, model.getVersion(), model);
        validateRawDependencies(problems, model.getDependencies(), ""dependencies.dependency"", request);
        if (model.getDependencyManagement() != null) {
            validateRawDependencies(problems, model.getDependencyManagement().getDependencies(), ""dependencyManagement.dependencies.dependency"", request);
        }
        validateRepositories(problems, model.getRepositories(), ""repositories.repository"", request);
        validateRepositories(problems, model.getPluginRepositories(), ""pluginRepositories.pluginRepository"", request);
        Build build = model.getBuild();
        if (build != null) {
            validateRawPlugins(problems, build.getPlugins(), false, request);
            PluginManagement mngt = build.getPluginManagement();
            if (mngt != null) {
                validateRawPlugins(problems, mngt.getPlugins(), true, request);
            }
        }
        Set<String> profileIds = new HashSet<String>();
        for (Profile profile : model.getProfiles()) {
            if (!profileIds.add(profile.getId())) {
                addViolation(problems, errOn30, ""profiles.profile.id"", null, ""must be unique but found duplicate profile with id "" + profile.getId(), profile);
            }
            validateRawDependencies(problems, profile.getDependencies(), ""profiles.profile["" + profile.getId() + ""].dependencies.dependency"", request);
            if (profile.getDependencyManagement() != null) {
                validateRawDependencies(problems, profile.getDependencyManagement().getDependencies(), ""profiles.profile["" + profile.getId() + ""].dependencyManagement.dependencies.dependency"", request);
            }
            validateRepositories(problems, profile.getRepositories(), ""profiles.profile["" + profile.getId() + ""].repositories.repository"", request);
            validateRepositories(problems, profile.getPluginRepositories(), ""profiles.profile["" + profile.getId() + ""].pluginRepositories.pluginRepository"", request);
        }
    }
}",,"public void validateRawModel(Model model, ModelBuildingRequest request, ModelProblemCollector problems) {
    Parent parent = model.getParent();
    if (parent != null) {
        validateStringNotEmpty(""parent.groupId"", problems, Severity.FATAL, parent.getGroupId(), parent);
        validateStringNotEmpty(""parent.artifactId"", problems, Severity.FATAL, parent.getArtifactId(), parent);
        validateStringNotEmpty(""parent.version"", problems, Severity.FATAL, parent.getVersion(), parent);
        if (equals(parent.getGroupId(), model.getGroupId()) && equals(parent.getArtifactId(), model.getArtifactId())) {
            addViolation(problems, Severity.FATAL, ""parent.artifactId"", null, ""must be changed"" + "", the parent element cannot have the same groupId:artifactId as the project."", parent);
        }
    }
    if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {
        Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);
        validateEnum(""modelVersion"", problems, Severity.ERROR, model.getModelVersion(), null, model, ""4.0.0"");
        validateStringNoExpression(""groupId"", problems, Severity.WARNING, model.getGroupId(), model);
        validateStringNoExpression(""artifactId"", problems, Severity.WARNING, model.getArtifactId(), model);
        validateStringNoExpression(""version"", problems, Severity.WARNING, model.getVersion(), model);
        validateRawDependencies(problems, model.getDependencies(), ""dependencies.dependency"", request);
        if (model.getDependencyManagement() != null) {
            validateRawDependencies(problems, model.getDependencyManagement().getDependencies(), ""dependencyManagement.dependencies.dependency"", request);
        }
        validateRepositories(problems, model.getRepositories(), ""repositories.repository"", request);
        validateRepositories(problems, model.getPluginRepositories(), ""pluginRepositories.pluginRepository"", request);
        Build build = model.getBuild();
        if (build != null) {
            validateRawPlugins(problems, build.getPlugins(), false, request);
            PluginManagement mngt = build.getPluginManagement();
            if (mngt != null) {
                validateRawPlugins(problems, mngt.getPlugins(), true, request);
            }
        }
        Set<String> profileIds = new HashSet<String>();
        for (Profile profile : model.getProfiles()) {
            if (!profileIds.add(profile.getId())) {
                addViolation(problems, errOn30, ""profiles.profile.id"", null, ""must be unique but found duplicate profile with id "" + profile.getId(), profile);
            }
            validateRawDependencies(problems, profile.getDependencies(), ""profiles.profile["" + profile.getId() + ""].dependencies.dependency"", request);
            if (profile.getDependencyManagement() != null) {
                validateRawDependencies(problems, profile.getDependencyManagement().getDependencies(), ""profiles.profile["" + profile.getId() + ""].dependencyManagement.dependencies.dependency"", request);
            }
            validateRepositories(problems, profile.getRepositories(), ""profiles.profile["" + profile.getId() + ""].repositories.repository"", request);
            validateRepositories(problems, profile.getPluginRepositories(), ""profiles.profile["" + profile.getId() + ""].pluginRepositories.pluginRepository"", request);
        }
    }
}",1.3636363636363635,0.2959183673469388,1.0,0.5,1.5,1.2980721700444886,-0.8861485517636941,4.416666666666667,-0.028571428571428574,5.243321726393154
camel,remotes/origin/bugs-dot-jar_CAMEL-7100_00a9b02b,1,"@Override
public void close() throws IOException {
    if (value instanceof Closeable) {
        IOHelper.close((Closeable) value, value.getClass().getName(), LOG);
    } else if (value instanceof Scanner) {
        // special for Scanner as it does not implement Closeable
        Scanner scanner = (Scanner) value;
        scanner.close();
        IOException ioException = scanner.ioException();
        if (ioException != null) {
            throw ioException;
        }
    }
}",,"@Override
public void close() throws IOException {
    if (value instanceof Closeable) {
        IOHelper.close((Closeable) value, value.getClass().getName(), LOG);
    } else if (value instanceof Scanner) {
                Scanner scanner = (Scanner) value;
        scanner.close();
        IOException ioException = scanner.ioException();
        if (ioException != null) {
            throw ioException;
        }
    }
}",-0.045454545454545456,0.34183673469387754,0.16666666666666666,0.5,0.0,0.0286702916460702,0.0791511327788928,-0.08333333333333333,0.14285714285714285,-0.05066793443577851
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2439_beaca1a4,1,"private IndexPlan.Builder getPlanBuilder() {
    log.trace(""Evaluating plan with index definition {}"", defn);
    FullTextExpression ft = filter.getFullTextConstraint();
    if (!defn.getVersion().isAtLeast(IndexFormatVersion.V2)) {
        log.trace(""Index is old format. Not supported"");
        return null;
    }
    // Query Fulltext and Index does not support fulltext
    if (ft != null && !defn.isFullTextEnabled()) {
        return null;
    }
    IndexingRule indexingRule = getApplicableRule();
    if (indexingRule == null) {
        return null;
    }
    // Query Fulltext and indexing rule does not support fulltext
    if (ft != null && !indexingRule.isFulltextEnabled()) {
        return null;
    }
    result = new PlanResult(indexPath, defn, indexingRule);
    if (defn.hasFunctionDefined() && filter.getPropertyRestriction(defn.getFunctionName()) != null) {
        // that lowest cost if returned
        return defaultPlan().setEstimatedEntryCount(1);
    }
    List<String> indexedProps = newArrayListWithCapacity(filter.getPropertyRestrictions().size());
    // for property index
    if (indexingRule.propertyIndexEnabled) {
        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {
            PropertyDefinition pd = indexingRule.getConfig(pr.propertyName);
            if (pd != null && pd.propertyIndexEnabled()) {
                indexedProps.add(pr.propertyName);
                result.propDefns.put(pr.propertyName, pd);
            }
        }
    }
    boolean evalPathRestrictions = canEvalPathRestrictions(indexingRule);
    boolean canEvalAlFullText = canEvalAllFullText(indexingRule, ft);
    if (ft != null && !canEvalAlFullText) {
        return null;
    }
    // Fulltext expression can also be like jcr:contains(jcr:content/metadata/@format, 'image')
    List<OrderEntry> sortOrder = createSortOrder(indexingRule);
    if (!indexedProps.isEmpty() || !sortOrder.isEmpty() || ft != null || evalPathRestrictions) {
        // TODO Need a way to have better cost estimate to indicate that
        // this index can evaluate more propertyRestrictions natively (if more props are indexed)
        // For now we reduce cost per entry
        int costPerEntryFactor = indexedProps.size();
        costPerEntryFactor += sortOrder.size();
        // this index can evaluate more propertyRestrictions natively (if more props are indexed)
        // For now we reduce cost per entry
        IndexPlan.Builder plan = defaultPlan();
        if (!sortOrder.isEmpty()) {
            plan.setSortOrder(sortOrder);
        }
        if (costPerEntryFactor == 0) {
            costPerEntryFactor = 1;
        }
        if (ft == null) {
            result.enableNonFullTextConstraints();
        }
        return plan.setCostPerEntry(defn.getCostPerEntry() / costPerEntryFactor);
    }
    return null;
}",,"private IndexPlan.Builder getPlanBuilder() {
    log.trace(""Evaluating plan with index definition {}"", defn);
    FullTextExpression ft = filter.getFullTextConstraint();
    if (!defn.getVersion().isAtLeast(IndexFormatVersion.V2)) {
        log.trace(""Index is old format. Not supported"");
        return null;
    }
        if (ft != null && !defn.isFullTextEnabled()) {
        return null;
    }
    IndexingRule indexingRule = getApplicableRule();
    if (indexingRule == null) {
        return null;
    }
        if (ft != null && !indexingRule.isFulltextEnabled()) {
        return null;
    }
    result = new PlanResult(indexPath, defn, indexingRule);
    if (defn.hasFunctionDefined() && filter.getPropertyRestriction(defn.getFunctionName()) != null) {
                return defaultPlan().setEstimatedEntryCount(1);
    }
    List<String> indexedProps = newArrayListWithCapacity(filter.getPropertyRestrictions().size());
        if (indexingRule.propertyIndexEnabled) {
        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {
            PropertyDefinition pd = indexingRule.getConfig(pr.propertyName);
            if (pd != null && pd.propertyIndexEnabled()) {
                indexedProps.add(pr.propertyName);
                result.propDefns.put(pr.propertyName, pd);
            }
        }
    }
    boolean evalPathRestrictions = canEvalPathRestrictions(indexingRule);
    boolean canEvalAlFullText = canEvalAllFullText(indexingRule, ft);
    if (ft != null && !canEvalAlFullText) {
        return null;
    }
        List<OrderEntry> sortOrder = createSortOrder(indexingRule);
    if (!indexedProps.isEmpty() || !sortOrder.isEmpty() || ft != null || evalPathRestrictions) {
                                int costPerEntryFactor = indexedProps.size();
        costPerEntryFactor += sortOrder.size();
                        IndexPlan.Builder plan = defaultPlan();
        if (!sortOrder.isEmpty()) {
            plan.setSortOrder(sortOrder);
        }
        if (costPerEntryFactor == 0) {
            costPerEntryFactor = 1;
        }
        if (ft == null) {
            result.enableNonFullTextConstraints();
        }
        return plan.setCostPerEntry(defn.getCostPerEntry() / costPerEntryFactor);
    }
    return null;
}",1.8181818181818181,0.22448979591836732,1.6666666666666667,0.5,2.5833333333333335,1.3395946613939695,-0.9575566389446518,2.3333333333333335,-0.028571428571428574,3.799392670067371
wicket,remotes/origin/bugs-dot-jar_WICKET-2839_15477252,1,"/**
 *  @see org.apache.wicket.util.watch.IModifiable#lastModifiedTime()
 *  @return The last time this resource was modified
 */
@Override
public Time lastModifiedTime() {
    if (file != null) {
        // in case the file has been removed by now
        if (file.exists() == false) {
            return null;
        }
        long lastModified = file.lastModified();
        // if last modified changed update content length and last modified date
        if (lastModified != this.lastModified) {
            this.lastModified = lastModified;
            contentLength = (int) file.length();
        }
    } else {
        try {
            long lastModified = Connections.getLastModified(url);
            // if last modified changed update content length and last modified date
            if (lastModified != this.lastModified) {
                this.lastModified = lastModified;
                URLConnection connection = url.openConnection();
                contentLength = connection.getContentLength();
                Connections.close(connection);
            }
        } catch (IOException e) {
            if (url.toString().indexOf("".jar!"") >= 0) {
                if (log.isDebugEnabled()) {
                    log.debug(""getLastModified for "" + url + "" failed: "" + e.getMessage());
                }
            } else {
                log.warn(""getLastModified for "" + url + "" failed: "" + e.getMessage());
            }
            // allow modification watcher to detect the problem
            return null;
        }
    }
    return Time.milliseconds(lastModified);
}","/**
 *  @see org.apache.wicket.util.watch.IModifiable#lastModifiedTime()
 *  @return The last time this resource was modified
 */
","@Override
public Time lastModifiedTime() {
    if (file != null) {
                if (file.exists() == false) {
            return null;
        }
        long lastModified = file.lastModified();
                if (lastModified != this.lastModified) {
            this.lastModified = lastModified;
            contentLength = (int) file.length();
        }
    } else {
        try {
            long lastModified = Connections.getLastModified(url);
                        if (lastModified != this.lastModified) {
                this.lastModified = lastModified;
                URLConnection connection = url.openConnection();
                contentLength = connection.getContentLength();
                Connections.close(connection);
            }
        } catch (IOException e) {
            if (url.toString().indexOf("".jar!"") >= 0) {
                if (log.isDebugEnabled()) {
                    log.debug(""getLastModified for "" + url + "" failed: "" + e.getMessage());
                }
            } else {
                log.warn(""getLastModified for "" + url + "" failed: "" + e.getMessage());
            }
                        return null;
        }
    }
    return Time.milliseconds(lastModified);
}",0.8636363636363636,1.0765306122448979,0.6666666666666666,1.0,0.5833333333333334,0.39841819080573415,-0.5488958990536279,0.75,-0.028571428571428574,0.5352812434416505
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1959_93c1aa40,1,"private void mergeWithConcurrencyCheck(NodeBuilder builder, final String checkpoint, final long lease) throws CommitFailedException {
    CommitHook concurrentUpdateCheck = new CommitHook() {

        @Override
        @Nonnull
        public NodeState processCommit(NodeState before, NodeState after, CommitInfo info) throws CommitFailedException {
            // check for concurrent updates by this async task
            NodeState async = before.getChildNode(ASYNC);
            if (Objects.equal(checkpoint, async.getString(name)) && lease == async.getLong(name + ""-lease"")) {
                return after;
            } else {
                throw CONCURRENT_UPDATE;
            }
        }
    };
    CompositeHook hooks = new CompositeHook(new ConflictHook(new AnnotatingConflictHandler()), new EditorHook(new ConflictValidatorProvider()), concurrentUpdateCheck);
    store.merge(builder, hooks, CommitInfo.EMPTY);
}",,"private void mergeWithConcurrencyCheck(NodeBuilder builder, final String checkpoint, final long lease) throws CommitFailedException {
    CommitHook concurrentUpdateCheck = new CommitHook() {

        @Override
        @Nonnull
        public NodeState processCommit(NodeState before, NodeState after, CommitInfo info) throws CommitFailedException {
                        NodeState async = before.getChildNode(ASYNC);
            if (Objects.equal(checkpoint, async.getString(name)) && lease == async.getLong(name + ""-lease"")) {
                return after;
            } else {
                throw CONCURRENT_UPDATE;
            }
        }
    };
    CompositeHook hooks = new CompositeHook(new ConflictHook(new AnnotatingConflictHandler()), new EditorHook(new ConflictValidatorProvider()), concurrentUpdateCheck);
    store.merge(builder, hooks, CommitInfo.EMPTY);
}",0.09090909090909091,0.9591836734693879,-0.16666666666666666,0.0,0.25,0.19673751853682656,-0.14138227702896497,-0.08333333333333333,-0.028571428571428574,0.23764674641619657
commons-math,remotes/origin/bugs-dot-jar_MATH-722_95d15eff,3,"/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Tangent.html"" TARGET=""_top"">
 * tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link FastMath#cosh} and {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   tan(1 &plusmn; INFINITY i) = 0 + NaN i
 *   tan(&plusmn;INFINITY + i) = NaN + NaN i
 *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i
 *  </code>
 * </pre>
 *
 * @return the tangent of {@code this}.
 * @since 1.2
 */
public Complex tan() {
    if (isNaN) {
        return NaN;
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);
    return createComplex(FastMath.sin(real2) / d, FastMath.sinh(imaginary2) / d);
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Tangent.html"" TARGET=""_top"">
 * tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link FastMath#cosh} and {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   tan(1 &plusmn; INFINITY i) = 0 + NaN i
 *   tan(&plusmn;INFINITY + i) = NaN + NaN i
 *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i
 *  </code>
 * </pre>
 *
 * @return the tangent of {@code this}.
 * @since 1.2
 */
","public Complex tan() {
    if (isNaN) {
        return NaN;
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);
    return createComplex(FastMath.sin(real2) / d, FastMath.sinh(imaginary2) / d);
}",-0.22727272727272727,-0.3826530612244898,-0.3333333333333333,-0.5,-0.25,0.24814631735046971,0.2423286492687125,-0.08333333333333333,0.2571428571428572,0.04492014339496576
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2864_f51ea2a2,1,"private Expression parseExpression() throws ParseException {
    if (readIf(""@"")) {
        return readProperty();
    } else if (readIf(""true"")) {
        return Expression.Literal.newBoolean(true);
    } else if (readIf(""false"")) {
        return Expression.Literal.newBoolean(false);
    } else if (currentTokenType == VALUE_NUMBER) {
        Expression.Literal l = Expression.Literal.newNumber(currentToken);
        read();
        return l;
    } else if (currentTokenType == VALUE_STRING) {
        Expression.Literal l = Expression.Literal.newString(currentToken);
        read();
        return l;
    } else if (readIf(""-"")) {
        if (currentTokenType != VALUE_NUMBER) {
            throw getSyntaxError();
        }
        Expression.Literal l = Expression.Literal.newNumber('-' + currentToken);
        read();
        return l;
    } else if (readIf(""+"")) {
        if (currentTokenType != VALUE_NUMBER) {
            throw getSyntaxError();
        }
        return parseExpression();
    } else {
        return parsePropertyOrFunction();
    }
}",,"private Expression parseExpression() throws ParseException {
    if (readIf(""@"")) {
        return readProperty();
    } else if (readIf(""true"")) {
        return Expression.Literal.newBoolean(true);
    } else if (readIf(""false"")) {
        return Expression.Literal.newBoolean(false);
    } else if (currentTokenType == VALUE_NUMBER) {
        Expression.Literal l = Expression.Literal.newNumber(currentToken);
        read();
        return l;
    } else if (currentTokenType == VALUE_STRING) {
        Expression.Literal l = Expression.Literal.newString(currentToken);
        read();
        return l;
    } else if (readIf(""-"")) {
        if (currentTokenType != VALUE_NUMBER) {
            throw getSyntaxError();
        }
        Expression.Literal l = Expression.Literal.newNumber('-' + currentToken);
        read();
        return l;
    } else if (readIf(""+"")) {
        if (currentTokenType != VALUE_NUMBER) {
            throw getSyntaxError();
        }
        return parseExpression();
    } else {
        return parsePropertyOrFunction();
    }
}",0.7727272727272727,-0.1173469387755102,1.3333333333333333,3.0,0.8333333333333334,0.702916460701928,-0.5153427014625754,1.0,-0.028571428571428574,0.6278883506580836
commons-math,remotes/origin/bugs-dot-jar_MATH-320_c06cc933,1,"/**
 * Get the pseudo-inverse of the decomposed matrix.
 * @return inverse matrix
 * @throws InvalidMatrixException if decomposed matrix is singular
 */
public RealMatrix getInverse() throws InvalidMatrixException {
    if (!isNonSingular()) {
        throw new SingularMatrixException();
    }
    return solve(MatrixUtils.createRealIdentityMatrix(singularValues.length));
}","/**
 * Get the pseudo-inverse of the decomposed matrix.
 * @return inverse matrix
 * @throws InvalidMatrixException if decomposed matrix is singular
 */
","public RealMatrix getInverse() throws InvalidMatrixException {
    if (!isNonSingular()) {
        throw new SingularMatrixException();
    }
    return solve(MatrixUtils.createRealIdentityMatrix(singularValues.length));
}",-0.36363636363636365,-0.13775510204081634,-0.16666666666666666,-0.5,-0.25,-0.3806228373702422,0.6139948379696014,-0.25,2.7714285714285714,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-8584_dd0f74c0,1,"private boolean rejectExchange(final Exchange exchange, final AsyncCallback callback) {
    exchange.setException(new RejectedExecutionException(""CircuitBreaker Open: failures: "" + failures + "", lastFailure: "" + lastFailure));
    /*
         * If the circuit opens, we have to prevent the execution of any
         * processor. The failures count can be set to 0.
         */
    failures.set(0);
    callback.done(true);
    return true;
}",,"private boolean rejectExchange(final Exchange exchange, final AsyncCallback callback) {
    exchange.setException(new RejectedExecutionException(""CircuitBreaker Open: failures: "" + failures + "", lastFailure: "" + lastFailure));
        failures.set(0);
    callback.done(true);
    return true;
}",-0.36363636363636365,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.5242328649268714,-0.25,1.342857142857143,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1959_93c1aa40,1,"@Override
@Nonnull
public NodeState processCommit(NodeState before, NodeState after, CommitInfo info) throws CommitFailedException {
    // check for concurrent updates by this async task
    NodeState async = before.getChildNode(ASYNC);
    if (Objects.equal(checkpoint, async.getString(name)) && lease == async.getLong(name + ""-lease"")) {
        return after;
    } else {
        throw CONCURRENT_UPDATE;
    }
}",,"@Override
@Nonnull
public NodeState processCommit(NodeState before, NodeState after, CommitInfo info) throws CommitFailedException {
        NodeState async = before.getChildNode(ASYNC);
    if (Objects.equal(checkpoint, async.getString(name)) && lease == async.getLong(name + ""-lease"")) {
        return after;
    } else {
        throw CONCURRENT_UPDATE;
    }
}",-0.18181818181818182,-0.015306122448979493,-0.16666666666666666,-0.5,0.25,0.15916955017301043,0.18095784341841137,-0.16666666666666666,0.05714285714285714,0.022451505689970497
Closure,138,2,"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    if (condition.getType() == CALL && condition.getChildCount() == 2) {
        Node callee = condition.getFirstChild();
        Node param = condition.getLastChild();
        if (callee.getType() == GETPROP && param.isQualifiedName()) {
            JSType paramType = getTypeIfRefinable(param, blindScope);
            if (paramType != null) {
                Node left = callee.getFirstChild();
                Node right = callee.getLastChild();
                if (left.getType() == NAME && ""goog"".equals(left.getString()) && right.getType() == STRING) {
                    Function<TypeRestriction, JSType> restricter = restricters.get(right.getString());
                    if (restricter != null) {
                        return restrictParameter(param, paramType, blindScope, restricter, outcome);
                    }
                }
            }
        }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}",,"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    if (condition.getType() == CALL && condition.getChildCount() == 2) {
        Node callee = condition.getFirstChild();
        Node param = condition.getLastChild();
        if (callee.getType() == GETPROP && param.isQualifiedName()) {
            JSType paramType = getTypeIfRefinable(param, blindScope);
            if (paramType != null) {
                Node left = callee.getFirstChild();
                Node right = callee.getLastChild();
                if (left.getType() == NAME && ""goog"".equals(left.getString()) && right.getType() == STRING) {
                    Function<TypeRestriction, JSType> restricter = restricters.get(right.getString());
                    if (restricter != null) {
                        return restrictParameter(param, paramType, blindScope, restricter, outcome);
                    }
                }
            }
        }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}",0.3181818181818182,2.086734693877551,0.3333333333333333,1.5,1.1666666666666667,0.4221453287197232,-0.34700315457413283,0.9166666666666666,-0.028571428571428574,0.6677459836132276
flink,remotes/origin/bugs-dot-jar_FLINK-2707_3e233a38,1,"@SuppressWarnings(""unchecked"")
@Override
public <S, C extends Serializable> OperatorState<S> getOperatorState(String name, S defaultState, boolean partitioned, StateCheckpointer<S, C> checkpointer) throws IOException {
    if (defaultState == null) {
        throw new RuntimeException(""Cannot set default state to null."");
    }
    StreamOperatorState<S, C> state = (StreamOperatorState<S, C>) getState(name, partitioned);
    state.setDefaultState(defaultState);
    state.setCheckpointer(checkpointer);
    return (OperatorState<S>) state;
}",,"@SuppressWarnings(""unchecked"")
@Override
public <S, C extends Serializable> OperatorState<S> getOperatorState(String name, S defaultState, boolean partitioned, StateCheckpointer<S, C> checkpointer) throws IOException {
    if (defaultState == null) {
        throw new RuntimeException(""Cannot set default state to null."");
    }
    StreamOperatorState<S, C> state = (StreamOperatorState<S, C>) getState(name, partitioned);
    state.setDefaultState(defaultState);
    state.setCheckpointer(checkpointer);
    return (OperatorState<S>) state;
}",-0.13636363636363635,-0.2806122448979591,-0.16666666666666666,-0.5,-0.25,-0.026693030153237728,0.0949240034413537,-0.25,-0.028571428571428574,-0.0019145026790188368
flink,remotes/origin/bugs-dot-jar_FLINK-2713_63d9800e,1,"public StateHandle<Serializable> snapshotState(long checkpointId, long checkpointTimestamp) throws Exception {
    return provider.createStateHandle(checkpointer.snapshotState(value(), checkpointId, checkpointTimestamp));
}",,"public StateHandle<Serializable> snapshotState(long checkpointId, long checkpointTimestamp) throws Exception {
    return provider.createStateHandle(checkpointer.snapshotState(value(), checkpointId, checkpointTimestamp));
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9317464869515348,-0.25,0.0,-0.16422749602751402
Compress,43,3,"private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {
    final boolean encodable = zipEncoding.canEncode(ze.getName());
    final ByteBuffer name = getName(ze);
    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {
        addUnicodeExtraFields(ze, encodable, name);
    }
    final long localHeaderStart = streamCompressor.getTotalBytesWritten();
    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);
    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));
    // At crc offset
    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;
    writeCounted(localHeader);
    entry.dataStart = streamCompressor.getTotalBytesWritten();
}",,"private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {
    final boolean encodable = zipEncoding.canEncode(ze.getName());
    final ByteBuffer name = getName(ze);
    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {
        addUnicodeExtraFields(ze, encodable, name);
    }
    final long localHeaderStart = streamCompressor.getTotalBytesWritten();
    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);
    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));
        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;
    writeCounted(localHeader);
    entry.dataStart = streamCompressor.getTotalBytesWritten();
}",-0.045454545454545456,-0.5714285714285715,-0.3333333333333333,-0.5,-0.25,-0.06228373702422141,-0.025810151993117463,0.4166666666666667,-0.028571428571428574,0.03960921873728484
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-843_65390f8c,3,"@Override
public void compact(String tableName, Text start, Text end, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException {
    throw new NotImplementedException();
}",,"@Override
public void compact(String tableName, Text start, Text end, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException {
    throw new NotImplementedException();
}",-0.45454545454545453,-0.6581632653061225,-0.3333333333333333,-1.0,-0.4166666666666667,-0.3806228373702422,0.7668482936621739,-0.5,-0.028571428571428574,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-412_be2fdba7,1,"/**
 * Iterates over the source until an acceptable key/value pair is found.
 */
protected void findTop() {
    while (getSource().hasTop() && (negate == accept(getSource().getTopKey(), getSource().getTopValue()))) {
        try {
            getSource().next();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}","/**
 * Iterates over the source until an acceptable key/value pair is found.
 */
","protected void findTop() {
    while (getSource().hasTop() && (negate == accept(getSource().getTopKey(), getSource().getTopValue()))) {
        try {
            getSource().next();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}",-0.22727272727272727,0.6326530612244897,0.0,0.0,0.16666666666666666,-0.11764705882352938,0.34958416977344425,0.25,1.4285714285714286,-0.12508940770341057
camel,remotes/origin/bugs-dot-jar_CAMEL-9444_baece126,1,"@Override
public Processor createProcessor(RouteContext routeContext) throws Exception {
    Processor childProcessor = this.createChildProcessor(routeContext, true);
    aggregationStrategy = createAggregationStrategy(routeContext);
    boolean isParallelProcessing = getParallelProcessing() != null && getParallelProcessing();
    boolean isStreaming = getStreaming() != null && getStreaming();
    boolean isShareUnitOfWork = getShareUnitOfWork() != null && getShareUnitOfWork();
    boolean isParallelAggregate = getParallelAggregate() != null && getParallelAggregate();
    boolean shutdownThreadPool = ProcessorDefinitionHelper.willCreateNewThreadPool(routeContext, this, isParallelProcessing);
    ExecutorService threadPool = ProcessorDefinitionHelper.getConfiguredExecutorService(routeContext, ""Split"", this, isParallelProcessing);
    long timeout = getTimeout() != null ? getTimeout() : 0;
    if (timeout > 0 && !isParallelProcessing) {
        throw new IllegalArgumentException(""Timeout is used but ParallelProcessing has not been enabled."");
    }
    if (onPrepareRef != null) {
        onPrepare = CamelContextHelper.mandatoryLookup(routeContext.getCamelContext(), onPrepareRef, Processor.class);
    }
    Expression exp = getExpression().createExpression(routeContext);
    Splitter answer = new Splitter(routeContext.getCamelContext(), exp, childProcessor, aggregationStrategy, isParallelProcessing, threadPool, shutdownThreadPool, isStreaming, isStopOnException(), timeout, onPrepare, isShareUnitOfWork, isParallelAggregate);
    return answer;
}",,"@Override
public Processor createProcessor(RouteContext routeContext) throws Exception {
    Processor childProcessor = this.createChildProcessor(routeContext, true);
    aggregationStrategy = createAggregationStrategy(routeContext);
    boolean isParallelProcessing = getParallelProcessing() != null && getParallelProcessing();
    boolean isStreaming = getStreaming() != null && getStreaming();
    boolean isShareUnitOfWork = getShareUnitOfWork() != null && getShareUnitOfWork();
    boolean isParallelAggregate = getParallelAggregate() != null && getParallelAggregate();
    boolean shutdownThreadPool = ProcessorDefinitionHelper.willCreateNewThreadPool(routeContext, this, isParallelProcessing);
    ExecutorService threadPool = ProcessorDefinitionHelper.getConfiguredExecutorService(routeContext, ""Split"", this, isParallelProcessing);
    long timeout = getTimeout() != null ? getTimeout() : 0;
    if (timeout > 0 && !isParallelProcessing) {
        throw new IllegalArgumentException(""Timeout is used but ParallelProcessing has not been enabled."");
    }
    if (onPrepareRef != null) {
        onPrepare = CamelContextHelper.mandatoryLookup(routeContext.getCamelContext(), onPrepareRef, Processor.class);
    }
    Expression exp = getExpression().createExpression(routeContext);
    Splitter answer = new Splitter(routeContext.getCamelContext(), exp, childProcessor, aggregationStrategy, isParallelProcessing, threadPool, shutdownThreadPool, isStreaming, isStopOnException(), timeout, onPrepare, isShareUnitOfWork, isParallelAggregate);
    return answer;
}",0.3181818181818182,-0.5510204081632654,0.16666666666666666,-0.5,0.25,0.3667820069204153,-0.37912245483223406,1.1666666666666667,-0.028571428571428574,0.8402825069277586
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1648_fdc54465,3,"public Revision create(long lifetimeInMillis, Map<String, String> info) {
    Revision r = nodeStore.getHeadRevision();
    createCounter.getAndIncrement();
    performCleanupIfRequired();
    UpdateOp op = new UpdateOp(ID, false);
    long endTime = BigInteger.valueOf(nodeStore.getClock().getTime()).add(BigInteger.valueOf(lifetimeInMillis)).min(BigInteger.valueOf(Long.MAX_VALUE)).longValue();
    op.setMapEntry(PROP_CHECKPOINT, r, new Info(endTime, info).toString());
    store.createOrUpdate(Collection.SETTINGS, op);
    return r;
}",,"public Revision create(long lifetimeInMillis, Map<String, String> info) {
    Revision r = nodeStore.getHeadRevision();
    createCounter.getAndIncrement();
    performCleanupIfRequired();
    UpdateOp op = new UpdateOp(ID, false);
    long endTime = BigInteger.valueOf(nodeStore.getClock().getTime()).add(BigInteger.valueOf(lifetimeInMillis)).min(BigInteger.valueOf(Long.MAX_VALUE)).longValue();
    op.setMapEntry(PROP_CHECKPOINT, r, new Info(endTime, info).toString());
    store.createOrUpdate(Collection.SETTINGS, op);
    return r;
}",-0.18181818181818182,-0.7244897959183674,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.11385144823630627,0.6666666666666666,-0.028571428571428574,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-843_65390f8c,3,"@Override
public void clearLocatorCache(String tableName) throws TableNotFoundException {
    throw new NotImplementedException();
}",,"@Override
public void clearLocatorCache(String tableName) throws TableNotFoundException {
    throw new NotImplementedException();
}",-0.45454545454545453,-0.6581632653061225,-0.3333333333333333,-1.0,-0.4166666666666667,-0.3806228373702422,0.9260108976197304,-0.5,2.142857142857143,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3897_94c6c575,1,"@Override
public boolean childNodeAdded(String name, NodeState after) {
    String p = PathUtils.concat(path, name);
    ResetDiff diff = new ResetDiff(revision, p, operations);
    UpdateOp op = diff.getUpdateOp();
    NodeDocument.removeDeleted(op, revision);
    return after.compareAgainstBaseState(EMPTY_NODE, diff);
}",,"@Override
public boolean childNodeAdded(String name, NodeState after) {
    String p = PathUtils.concat(path, name);
    ResetDiff diff = new ResetDiff(revision, p, operations);
    UpdateOp op = diff.getUpdateOp();
    NodeDocument.removeDeleted(op, revision);
    return after.compareAgainstBaseState(EMPTY_NODE, diff);
}",-0.2727272727272727,-0.5510204081632654,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.30369945511901364,-0.16666666666666666,0.0,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-5071_a2f848f2,1,"/**
 *  @see org.apache.wicket.request.IRequestMapper#mapRequest(org.apache.wicket.request.Request)
 */
@Override
public IRequestHandler mapRequest(Request request) {
    Url url = request.getUrl();
    if (matches(url)) {
        PageComponentInfo info = getPageComponentInfo(url);
        if (info != null && info.getPageInfo().getPageId() != null) {
            Integer renderCount = info.getComponentInfo() != null ? info.getComponentInfo().getRenderCount() : null;
            if (info.getComponentInfo() == null) {
                PageProvider provider = new PageProvider(info.getPageInfo().getPageId(), renderCount);
                provider.setPageSource(getContext());
                // render page
                return new RenderPageRequestHandler(provider);
            } else {
                ComponentInfo componentInfo = info.getComponentInfo();
                PageAndComponentProvider provider = new PageAndComponentProvider(info.getPageInfo().getPageId(), renderCount, componentInfo.getComponentPath());
                provider.setPageSource(getContext());
                // listener interface
                RequestListenerInterface listenerInterface = requestListenerInterfaceFromString(componentInfo.getListenerInterface());
                return new ListenerInterfaceRequestHandler(provider, listenerInterface, componentInfo.getBehaviorId());
            }
        }
    }
    return null;
}","/**
 *  @see org.apache.wicket.request.IRequestMapper#mapRequest(org.apache.wicket.request.Request)
 */
","@Override
public IRequestHandler mapRequest(Request request) {
    Url url = request.getUrl();
    if (matches(url)) {
        PageComponentInfo info = getPageComponentInfo(url);
        if (info != null && info.getPageInfo().getPageId() != null) {
            Integer renderCount = info.getComponentInfo() != null ? info.getComponentInfo().getRenderCount() : null;
            if (info.getComponentInfo() == null) {
                PageProvider provider = new PageProvider(info.getPageInfo().getPageId(), renderCount);
                provider.setPageSource(getContext());
                                return new RenderPageRequestHandler(provider);
            } else {
                ComponentInfo componentInfo = info.getComponentInfo();
                PageAndComponentProvider provider = new PageAndComponentProvider(info.getPageInfo().getPageId(), renderCount, componentInfo.getComponentPath());
                provider.setPageSource(getContext());
                                RequestListenerInterface listenerInterface = requestListenerInterfaceFromString(componentInfo.getListenerInterface());
                return new ListenerInterfaceRequestHandler(provider, listenerInterface, componentInfo.getBehaviorId());
            }
        }
    }
    return null;
}",0.36363636363636365,1.4540816326530612,0.16666666666666666,0.5,0.4166666666666667,0.44389520514088,-0.3524519644393464,1.3333333333333333,-0.028571428571428574,0.6384288229020777
commons-math,remotes/origin/bugs-dot-jar_MATH-618_2123f780,1,"/**
 * Return the sum of this complex number and the given complex number.
 * <p>
 * Uses the definitional formula
 * <pre>
 * (a + bi) + (c + di) = (a+c) + (b+d)i
 * </pre></p>
 * <p>
 * If either this or <code>rhs</code> has a NaN value in either part,
 * {@link #NaN} is returned; otherwise Infinite and NaN values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic.</p>
 *
 * @param rhs the other complex number
 * @return the complex number sum
 * @throws NullArgumentException if <code>rhs</code> is null
 */
public Complex add(Complex rhs) throws NullArgumentException {
    MathUtils.checkNotNull(rhs);
    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());
}","/**
 * Return the sum of this complex number and the given complex number.
 * <p>
 * Uses the definitional formula
 * <pre>
 * (a + bi) + (c + di) = (a+c) + (b+d)i
 * </pre></p>
 * <p>
 * If either this or <code>rhs</code> has a NaN value in either part,
 * {@link #NaN} is returned; otherwise Infinite and NaN values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic.</p>
 *
 * @param rhs the other complex number
 * @return the complex number sum
 * @throws NullArgumentException if <code>rhs</code> is null
 */
","public Complex add(Complex rhs) throws NullArgumentException {
    MathUtils.checkNotNull(rhs);
    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7505018640665331,-0.16666666666666666,1.2571428571428573,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-537_a8493efc,3,"/**
 * Searches for a given value within this index.
 *
 * @param name the property name
 * @param value the property value (null to check for property existence)
 * @return the set of matched paths
 */
public Set<String> find(String name, PropertyValue value) {
    Set<String> paths = Sets.newHashSet();
    NodeState state = getIndexDefinitionNode(name);
    if (state != null && state.getChildNode("":index"") != null) {
        state = state.getChildNode("":index"");
        if (value == null) {
            paths.addAll(store.find(state, null));
        } else {
            paths.addAll(store.find(state, Property2Index.encode(value)));
        }
    } else {
        // No index available, so first check this node for a match
        PropertyState property = root.getProperty(name);
        if (property != null) {
            if (value == null || value.isArray()) {
                // let query engine handle property existence and
                // multi-valued look ups;
                // simply return all nodes that have this property
                paths.add("""");
            } else {
                // does it match any of the values of this property?
                for (int i = 0; i < property.count(); i++) {
                    if (property.getValue(value.getType(), i).equals(value.getValue(value.getType()))) {
                        paths.add("""");
                        // no need to check for more matches in this property
                        break;
                    }
                }
            }
        }
        // ... and then recursively look up from the rest of the tree
        for (ChildNodeEntry entry : root.getChildNodeEntries()) {
            String base = entry.getName();
            Property2IndexLookup lookup = new Property2IndexLookup(entry.getNodeState());
            for (String path : lookup.find(name, value)) {
                if (path.isEmpty()) {
                    paths.add(base);
                } else {
                    paths.add(base + ""/"" + path);
                }
            }
        }
    }
    return paths;
}","/**
 * Searches for a given value within this index.
 *
 * @param name the property name
 * @param value the property value (null to check for property existence)
 * @return the set of matched paths
 */
","public Set<String> find(String name, PropertyValue value) {
    Set<String> paths = Sets.newHashSet();
    NodeState state = getIndexDefinitionNode(name);
    if (state != null && state.getChildNode("":index"") != null) {
        state = state.getChildNode("":index"");
        if (value == null) {
            paths.addAll(store.find(state, null));
        } else {
            paths.addAll(store.find(state, Property2Index.encode(value)));
        }
    } else {
                PropertyState property = root.getProperty(name);
        if (property != null) {
            if (value == null || value.isArray()) {
                                                                paths.add("""");
            } else {
                                for (int i = 0; i < property.count(); i++) {
                    if (property.getValue(value.getType(), i).equals(value.getValue(value.getType()))) {
                        paths.add("""");
                                                break;
                    }
                }
            }
        }
                for (ChildNodeEntry entry : root.getChildNodeEntries()) {
            String base = entry.getName();
            Property2IndexLookup lookup = new Property2IndexLookup(entry.getNodeState());
            for (String path : lookup.find(name, value)) {
                if (path.isEmpty()) {
                    paths.add(base);
                } else {
                    paths.add(base + ""/"" + path);
                }
            }
        }
    }
    return paths;
}",1.0909090909090908,1.5969387755102042,1.1666666666666667,1.5,1.25,1.525457241720218,-0.7123601950100376,1.6666666666666667,-0.028571428571428574,2.7296182558752107
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-492_a759d8ae,3,"/**
 * Either returns the specified name as is, or returns a quoted value
 * containing the specified name with the special characters (comma, equals,
 * colon, quote, asterisk, or question mark) preceded with a backslash.
 *
 * @param name
 *            the name to escape so it can be used as a value in an
 *            {@link ObjectName}.
 * @return the escaped name
 */
public static String escape(final String name) {
    final StringBuilder sb = new StringBuilder(name.length() * 2);
    boolean needsQuotes = false;
    for (int i = 0; i < name.length(); i++) {
        final char c = name.charAt(i);
        switch(c) {
            case ',':
            case '=':
            case ':':
            case '\\':
            case '*':
            case '?':
                sb.append('\\');
                needsQuotes = true;
        }
        sb.append(c);
    }
    if (needsQuotes) {
        sb.insert(0, '\""');
        sb.append('\""');
    }
    return sb.toString();
}","/**
 * Either returns the specified name as is, or returns a quoted value
 * containing the specified name with the special characters (comma, equals,
 * colon, quote, asterisk, or question mark) preceded with a backslash.
 *
 * @param name
 *            the name to escape so it can be used as a value in an
 *            {@link ObjectName}.
 * @return the escaped name
 */
","public static String escape(final String name) {
    final StringBuilder sb = new StringBuilder(name.length() * 2);
    boolean needsQuotes = false;
    for (int i = 0; i < name.length(); i++) {
        final char c = name.charAt(i);
        switch(c) {
            case ',':
            case '=':
            case ':':
            case '\\':
            case '*':
            case '?':
                sb.append('\\');
                needsQuotes = true;
        }
        sb.append(c);
    }
    if (needsQuotes) {
        sb.insert(0, '\""');
        sb.append('\""');
    }
    return sb.toString();
}",0.4090909090909091,0.7500000000000001,0.8333333333333334,0.5,0.5833333333333334,0.3786455758774099,-0.32492113564668773,0.16666666666666666,0.0,0.28320077436707913
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-43_668f08f2,1,"void apply() throws Exception {
    setProperty(nodePath, propName, propValue);
}",,"void apply() throws Exception {
    setProperty(nodePath, propName, propValue);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.0662460567823349,-0.4166666666666667,0.5714285714285714,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-448_999097e1,1,"@Override
public boolean isModified() {
    if (writeState == null) {
        return false;
    } else {
        NodeState baseState = getBaseState();
        for (Entry<String, MutableNodeState> n : writeState.nodes.entrySet()) {
            if (n.getValue() == null) {
                return true;
            }
            if (baseState == null || !baseState.hasChildNode(n.getKey())) {
                return true;
            }
        }
        for (Entry<String, PropertyState> p : writeState.properties.entrySet()) {
            PropertyState pState = p.getValue();
            if (pState == null) {
                return true;
            }
            if (baseState == null || !pState.equals(baseState.getProperty(p.getKey()))) {
                return true;
            }
        }
        return false;
    }
}",,"@Override
public boolean isModified() {
    if (writeState == null) {
        return false;
    } else {
        NodeState baseState = getBaseState();
        for (Entry<String, MutableNodeState> n : writeState.nodes.entrySet()) {
            if (n.getValue() == null) {
                return true;
            }
            if (baseState == null || !baseState.hasChildNode(n.getKey())) {
                return true;
            }
        }
        for (Entry<String, PropertyState> p : writeState.properties.entrySet()) {
            PropertyState pState = p.getValue();
            if (pState == null) {
                return true;
            }
            if (baseState == null || !pState.equals(baseState.getProperty(p.getKey()))) {
                return true;
            }
        }
        return false;
    }
}",0.5454545454545454,0.9132653061224488,0.6666666666666666,0.5,0.9166666666666666,0.42609985170538817,-0.3903068540292516,0.3333333333333333,-0.028571428571428574,0.36209798655993414
commons-math,remotes/origin/bugs-dot-jar_MATH-290_b01fcc31,1,"/**
 * Create the tableau by itself.
 * @param maximize if true, goal is to maximize the objective function
 * @return created tableau
 */
protected double[][] createTableau(final boolean maximize) {
    // create a matrix of the correct size
    List<LinearConstraint> constraints = getNormalizedConstraints();
    int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() + // + 1 is for RHS
    1;
    int height = constraints.size() + getNumObjectiveFunctions();
    double[][] matrix = new double[height][width];
    // initialize the objective function rows
    if (getNumObjectiveFunctions() == 2) {
        matrix[0][0] = -1;
    }
    int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;
    matrix[zIndex][zIndex] = maximize ? 1 : -1;
    RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();
    copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());
    matrix[zIndex][width - 1] = maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();
    if (!restrictToNonNegative) {
        matrix[zIndex][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(objectiveCoefficients);
    }
    // initialize the constraint rows
    int slackVar = 0;
    int artificialVar = 0;
    for (int i = 0; i < constraints.size(); i++) {
        LinearConstraint constraint = constraints.get(i);
        int row = getNumObjectiveFunctions() + i;
        // decision variable coefficients
        copyArray(constraint.getCoefficients().getData(), matrix[row], 1);
        // x-
        if (!restrictToNonNegative) {
            matrix[row][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(constraint.getCoefficients());
        }
        // RHS
        matrix[row][width - 1] = constraint.getValue();
        // slack variables
        if (constraint.getRelationship() == Relationship.LEQ) {
            // slack
            matrix[row][getSlackVariableOffset() + slackVar++] = 1;
        } else if (constraint.getRelationship() == Relationship.GEQ) {
            // excess
            matrix[row][getSlackVariableOffset() + slackVar++] = -1;
        }
        // artificial variables
        if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) {
            matrix[0][getArtificialVariableOffset() + artificialVar] = 1;
            matrix[row][getArtificialVariableOffset() + artificialVar++] = 1;
        }
    }
    return matrix;
}","/**
 * Create the tableau by itself.
 * @param maximize if true, goal is to maximize the objective function
 * @return created tableau
 */
","protected double[][] createTableau(final boolean maximize) {
        List<LinearConstraint> constraints = getNormalizedConstraints();
    int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() +     1;
    int height = constraints.size() + getNumObjectiveFunctions();
    double[][] matrix = new double[height][width];
        if (getNumObjectiveFunctions() == 2) {
        matrix[0][0] = -1;
    }
    int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;
    matrix[zIndex][zIndex] = maximize ? 1 : -1;
    RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();
    copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());
    matrix[zIndex][width - 1] = maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();
    if (!restrictToNonNegative) {
        matrix[zIndex][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(objectiveCoefficients);
    }
        int slackVar = 0;
    int artificialVar = 0;
    for (int i = 0; i < constraints.size(); i++) {
        LinearConstraint constraint = constraints.get(i);
        int row = getNumObjectiveFunctions() + i;
                copyArray(constraint.getCoefficients().getData(), matrix[row], 1);
                if (!restrictToNonNegative) {
            matrix[row][getSlackVariableOffset() - 1] = getInvertedCoeffiecientSum(constraint.getCoefficients());
        }
                matrix[row][width - 1] = constraint.getValue();
                if (constraint.getRelationship() == Relationship.LEQ) {
                        matrix[row][getSlackVariableOffset() + slackVar++] = 1;
        } else if (constraint.getRelationship() == Relationship.GEQ) {
                        matrix[row][getSlackVariableOffset() + slackVar++] = -1;
        }
                if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) {
            matrix[0][getArtificialVariableOffset() + artificialVar] = 1;
            matrix[row][getArtificialVariableOffset() + artificialVar++] = 1;
        }
    }
    return matrix;
}",1.1363636363636365,0.051020408163265356,1.3333333333333333,0.5,1.0833333333333333,2.2867029164607025,-0.801261829652997,2.3333333333333335,-0.028571428571428574,6.323349651577645
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7,3,"public boolean equals(removeConstraint_result that) {
    if (that == null)
        return false;
    boolean this_present_ouch1 = true && this.isSetOuch1();
    boolean that_present_ouch1 = true && that.isSetOuch1();
    if (this_present_ouch1 || that_present_ouch1) {
        if (!(this_present_ouch1 && that_present_ouch1))
            return false;
        if (!this.ouch1.equals(that.ouch1))
            return false;
    }
    boolean this_present_ouch2 = true && this.isSetOuch2();
    boolean that_present_ouch2 = true && that.isSetOuch2();
    if (this_present_ouch2 || that_present_ouch2) {
        if (!(this_present_ouch2 && that_present_ouch2))
            return false;
        if (!this.ouch2.equals(that.ouch2))
            return false;
    }
    return true;
}",,"public boolean equals(removeConstraint_result that) {
    if (that == null)
        return false;
    boolean this_present_ouch1 = true && this.isSetOuch1();
    boolean that_present_ouch1 = true && that.isSetOuch1();
    if (this_present_ouch1 || that_present_ouch1) {
        if (!(this_present_ouch1 && that_present_ouch1))
            return false;
        if (!this.ouch1.equals(that.ouch1))
            return false;
    }
    boolean this_present_ouch2 = true && this.isSetOuch2();
    boolean that_present_ouch2 = true && that.isSetOuch2();
    if (this_present_ouch2 || that_present_ouch2) {
        if (!(this_present_ouch2 && that_present_ouch2))
            return false;
        if (!this.ouch2.equals(that.ouch2))
            return false;
    }
    return true;
}",0.3181818181818182,0.3061224489795919,0.6666666666666666,-0.5,1.25,0.726643598615917,-0.26641812446228874,0.0,-0.028571428571428574,0.4473725913457626
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-276_1bf5c550,1,"@Override
public boolean markNode(Id id) throws Exception {
    return touch(id, gcStart);
}",,"@Override
public boolean markNode(Id id) throws Exception {
    return touch(id, gcStart);
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8850014338973328,-0.4166666666666667,1.9428571428571428,-0.16422749602751402
Closure,134,2,"/**
 * Adds the node to the sub graph, adding all of its types to the set of
 * types in the sub graph and all of its related types to the related types
 * for the sub graph.
 */
public void addNode(Property prop) {
    typesInSet.or(prop.typesSet);
    typesRelatedToSet.or(getRelated(prop.type));
}","/**
 * Adds the node to the sub graph, adding all of its types to the set of
 * types in the sub graph and all of its related types to the related types
 * for the sub graph.
 */
","public void addNode(Property prop) {
    typesInSet.or(prop.typesSet);
    typesRelatedToSet.or(getRelated(prop.type));
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8150272440493259,-0.25,1.4857142857142858,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-6447_020c451a,1,"public boolean process(Exchange exchange, AsyncCallback callback) {
    Iterator<Processor> processors = next().iterator();
    exchange.setProperty(Exchange.FILTER_MATCHED, false);
    while (continueRouting(processors, exchange)) {
        // get the next processor
        Processor processor = processors.next();
        AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);
        boolean sync = process(exchange, callback, processors, async);
        // continue as long its being processed synchronously
        if (!sync) {
            LOG.trace(""Processing exchangeId: {} is continued being processed asynchronously"", exchange.getExchangeId());
            // so we break out now, then the callback will be invoked which then continue routing from where we left here
            return false;
        }
        LOG.trace(""Processing exchangeId: {} is continued being processed synchronously"", exchange.getExchangeId());
        // check for error if so we should break out
        if (!continueProcessing(exchange, ""so breaking out of content based router"", LOG)) {
            break;
        }
    }
    LOG.trace(""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
    callback.done(true);
    return true;
}",,"public boolean process(Exchange exchange, AsyncCallback callback) {
    Iterator<Processor> processors = next().iterator();
    exchange.setProperty(Exchange.FILTER_MATCHED, false);
    while (continueRouting(processors, exchange)) {
                Processor processor = processors.next();
        AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);
        boolean sync = process(exchange, callback, processors, async);
                if (!sync) {
            LOG.trace(""Processing exchangeId: {} is continued being processed asynchronously"", exchange.getExchangeId());
                        return false;
        }
        LOG.trace(""Processing exchangeId: {} is continued being processed synchronously"", exchange.getExchangeId());
                if (!continueProcessing(exchange, ""so breaking out of content based router"", LOG)) {
            break;
        }
    }
    LOG.trace(""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
    callback.done(true);
    return true;
}",0.2727272727272727,0.21428571428571425,0.16666666666666666,0.0,0.25,0.0029658922392486655,-0.2635503297963866,0.75,-0.028571428571428574,0.11176070001413392
commons-math,remotes/origin/bugs-dot-jar_MATH-358_061f5017,0,"/**
 * {@inheritDoc}
 */
@Override
public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {
    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;
    // create some internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
        System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][y0.length];
    final double[] yTmp = new double[y0.length];
    // set up an interpolator sharing the integrator arrays
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
        rki.reinitialize(this, yTmp, yDotK, forward);
        interpolator = rki;
    } else {
        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);
    }
    interpolator.storeTime(t0);
    // set up integration control objects
    stepStart = t0;
    double hNew = 0;
    boolean firstTime = true;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;
    // main integration loop
    while (!lastStep) {
        interpolator.shift();
        double error = 0;
        for (boolean loop = true; loop; ) {
            if (firstTime || !fsal) {
                // first stage
                computeDerivatives(stepStart, y, yDotK[0]);
            }
            if (firstTime) {
                final double[] scale = new double[y0.length];
                if (vecAbsoluteTolerance == null) {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);
                    }
                } else {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);
                    }
                }
                hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }
            stepSize = hNew;
            // next stages
            for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
            // estimate the error at the end of the step
            error = estimateError(yDotK, y, yTmp, stepSize);
            if (error <= 1.0) {
                // discrete events handling
                interpolator.storeTime(stepStart + stepSize);
                if (manager.evaluateStep(interpolator)) {
                    final double dt = manager.getEventTime() - stepStart;
                    if (Math.abs(dt) <= Math.ulp(stepStart)) {
                        // rejecting the step would lead to a too small next step, we accept it
                        loop = false;
                    } else {
                        // reject the step to match exactly the next switch time
                        hNew = dt;
                    }
                } else {
                    // accept the step
                    loop = false;
                }
            } else {
                // reject the step and attempt to reduce error by stepsize control
                final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            }
        }
        // the step has been accepted
        final double nextStep = stepStart + stepSize;
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        manager.stepAccepted(nextStep, y);
        lastStep = manager.stop();
        // provide the step data to the step handler
        interpolator.storeTime(nextStep);
        for (StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, lastStep);
        }
        stepStart = nextStep;
        if (fsal) {
            // save the last evaluation for the next step
            System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
        }
        if (manager.reset(stepStart, y) && !lastStep) {
            // some event handler has triggered changes that
            // invalidate the derivatives, we need to recompute them
            computeDerivatives(stepStart, y, yDotK[0]);
        }
        if (!lastStep) {
            // in some rare cases we may get here with stepSize = 0, for example
            // when an event occurs at integration start, reducing the first step
            // to zero; we have to reset the step to some safe non zero value
            stepSize = filterStep(stepSize, forward, true);
            // stepsize control for next step
            final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
        }
    }
    final double stopTime = stepStart;
    resetInternalState();
    return stopTime;
}","/**
 * {@inheritDoc}
 */
","@Override
public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {
    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;
        final int stages = c.length + 1;
    if (y != y0) {
        System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][y0.length];
    final double[] yTmp = new double[y0.length];
        AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
        rki.reinitialize(this, yTmp, yDotK, forward);
        interpolator = rki;
    } else {
        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);
    }
    interpolator.storeTime(t0);
        stepStart = t0;
    double hNew = 0;
    boolean firstTime = true;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;
        while (!lastStep) {
        interpolator.shift();
        double error = 0;
        for (boolean loop = true; loop; ) {
            if (firstTime || !fsal) {
                                computeDerivatives(stepStart, y, yDotK[0]);
            }
            if (firstTime) {
                final double[] scale = new double[y0.length];
                if (vecAbsoluteTolerance == null) {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);
                    }
                } else {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);
                    }
                }
                hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }
            stepSize = hNew;
                        for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
                        for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
                        error = estimateError(yDotK, y, yTmp, stepSize);
            if (error <= 1.0) {
                                interpolator.storeTime(stepStart + stepSize);
                if (manager.evaluateStep(interpolator)) {
                    final double dt = manager.getEventTime() - stepStart;
                    if (Math.abs(dt) <= Math.ulp(stepStart)) {
                                                loop = false;
                    } else {
                                                hNew = dt;
                    }
                } else {
                                        loop = false;
                }
            } else {
                                final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            }
        }
                final double nextStep = stepStart + stepSize;
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        manager.stepAccepted(nextStep, y);
        lastStep = manager.stop();
                interpolator.storeTime(nextStep);
        for (StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, lastStep);
        }
        stepStart = nextStep;
        if (fsal) {
                        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
        }
        if (manager.reset(stepStart, y) && !lastStep) {
                                    computeDerivatives(stepStart, y, yDotK[0]);
        }
        if (!lastStep) {
                                                stepSize = filterStep(stepSize, forward, true);
                        final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
        }
    }
    final double stopTime = stepStart;
    resetInternalState();
    return stopTime;
}",4.545454545454546,1.6122448979591835,3.3333333333333335,1.5,3.6666666666666665,5.011369253583787,-1.537998279323201,3.0,-0.028571428571428574,38.00769655774988
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2359_b3071839,0,"@Override
public boolean containsKey(Object key) {
    // the values map does not have null values
    return get(key) != null;
}",,"@Override
public boolean containsKey(Object key) {
        return get(key) != null;
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8850014338973328,-0.4166666666666667,2.7714285714285714,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1348_ef0f6ddc,1,"public int start() throws IOException {
    if (configError)
        return 1;
    String input;
    if (isVerbose())
        printInfo();
    if (execFile != null) {
        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));
        while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());
    } else if (execCommand != null) {
        for (String command : execCommand.split(""\n"")) {
            execCommand(command, true, isVerbose());
        }
        return exitCode;
    }
    while (true) {
        if (hasExited())
            return exitCode;
        reader.setDefaultPrompt(getDefaultPrompt());
        input = reader.readLine();
        if (input == null) {
            reader.printNewline();
            return exitCode;
        }
        // user canceled
        execCommand(input, false, false);
    }
}",,"public int start() throws IOException {
    if (configError)
        return 1;
    String input;
    if (isVerbose())
        printInfo();
    if (execFile != null) {
        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));
        while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());
    } else if (execCommand != null) {
        for (String command : execCommand.split(""\n"")) {
            execCommand(command, true, isVerbose());
        }
        return exitCode;
    }
    while (true) {
        if (hasExited())
            return exitCode;
        reader.setDefaultPrompt(getDefaultPrompt());
        input = reader.readLine();
        if (input == null) {
            reader.printNewline();
            return exitCode;
        }
                execCommand(input, false, false);
    }
}",0.5909090909090909,0.10714285714285712,1.0,0.5,0.8333333333333334,-0.01680672268907558,-0.4278749641525668,0.75,-0.028571428571428574,0.08417387282048648
wicket,remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4,1,"private final Component<?> children_get(int index) {
    if (index == 0) {
        if (children instanceof Component) {
            return (Component) children;
        } else {
            return ((Component[]) children)[index];
        }
    } else {
        return ((Component[]) children)[index];
    }
}",,"private final Component<?> children_get(int index) {
    if (index == 0) {
        if (children instanceof Component) {
            return (Component) children;
        } else {
            return ((Component[]) children)[index];
        }
    } else {
        return ((Component[]) children)[index];
    }
}",-0.13636363636363635,0.47448979591836743,-0.16666666666666666,0.0,-0.08333333333333333,-0.3806228373702422,0.3168913105821623,-0.5,0.7428571428571429,-0.16422749602751402
Math,68,1,"/**
 * {@inheritDoc}
 */
@Override
protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
    // arrays shared with the other private methods
    solvedCols = Math.min(rows, cols);
    diagR = new double[cols];
    jacNorm = new double[cols];
    beta = new double[cols];
    permutation = new int[cols];
    lmDir = new double[cols];
    // local point
    double delta = 0;
    double xNorm = 0;
    double[] diag = new double[cols];
    double[] oldX = new double[cols];
    double[] oldRes = new double[rows];
    double[] work1 = new double[cols];
    double[] work2 = new double[cols];
    double[] work3 = new double[cols];
    // evaluate the function at the starting point and calculate its norm
    updateResidualsAndCost();
    // outer loop
    lmPar = 0;
    boolean firstIteration = true;
    while (true) {
        incrementIterationsCounter();
        // compute the Q.R. decomposition of the jacobian matrix
        updateJacobian();
        qrDecomposition();
        // compute Qt.res
        qTy(residuals);
        // so let jacobian contain the R matrix with its diagonal elements
        for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            jacobian[k][pk] = diagR[pk];
        }
        if (firstIteration) {
            // scale the point according to the norms of the columns
            // of the initial jacobian
            xNorm = 0;
            for (int k = 0; k < cols; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * point[k];
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = Math.sqrt(xNorm);
            // initialize the step bound delta
            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }
        // check orthogonality between function vector and jacobian columns
        double maxCosine = 0;
        if (cost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += jacobian[i][pj] * residuals[i];
                    }
                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
            // convergence has been reached
            return new VectorialPointValuePair(point, objective);
        }
        // rescale if necessary
        for (int j = 0; j < cols; ++j) {
            diag[j] = Math.max(diag[j], jacNorm[j]);
        }
        // inner loop
        for (double ratio = 0; ratio < 1.0e-4; ) {
            // save the state
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = point[pj];
            }
            double previousCost = cost;
            double[] tmpVec = residuals;
            residuals = oldRes;
            oldRes = tmpVec;
            // determine the Levenberg-Marquardt parameter
            determineLMParameter(oldRes, delta, diag, work1, work2, work3);
            // compute the new point and the norm of the evolution direction
            double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                point[pj] = oldX[pj] + lmDir[pj];
                double s = diag[pj] * lmDir[pj];
                lmNorm += s * s;
            }
            lmNorm = Math.sqrt(lmNorm);
            // on the first iteration, adjust the initial step bound.
            if (firstIteration) {
                delta = Math.min(delta, lmNorm);
            }
            // evaluate the function at x + p and calculate its norm
            updateResidualsAndCost();
            // compute the scaled actual reduction
            double actRed = -1.0;
            if (0.1 * cost < previousCost) {
                double r = cost / previousCost;
                actRed = 1.0 - r * r;
            }
            // and the scaled directional derivative
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0; i <= j; ++i) {
                    work1[i] += jacobian[i][pj] * dirJ;
                }
            }
            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                coeff1 += work1[j] * work1[j];
            }
            double pc2 = previousCost * previousCost;
            coeff1 = coeff1 / pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);
            // ratio of the actual to the predicted reduction
            ratio = (preRed == 0) ? 0 : (actRed / preRed);
            // update the step bound
            if (ratio <= 0.25) {
                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                    tmp = 0.1;
                }
                delta = tmp * Math.min(delta, 10.0 * lmNorm);
                lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }
            // test for successful iteration.
            if (ratio >= 1.0e-4) {
                // successful iteration, update the norm
                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double xK = diag[k] * point[k];
                    xNorm += xK * xK;
                }
                xNorm = Math.sqrt(xNorm);
            } else {
                // failed iteration, reset the previous values
                cost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    point[pj] = oldX[pj];
                }
                tmpVec = residuals;
                residuals = oldRes;
                oldRes = tmpVec;
            }
            // we use the Levenberg-Marquardt specific convergence parameters
            if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) {
                return new VectorialPointValuePair(point, objective);
            }
            // (2.2204e-16 is the machine epsilon for IEEE754)
            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                throw new OptimizationException(""cost relative tolerance is too small ({0}),"" + "" no further reduction in the"" + "" sum of squares is possible"", costRelativeTolerance);
            } else if (delta <= 2.2204e-16 * xNorm) {
                throw new OptimizationException(""parameters relative tolerance is too small"" + "" ({0}), no further improvement in"" + "" the approximate solution is possible"", parRelativeTolerance);
            } else if (maxCosine <= 2.2204e-16) {
                throw new OptimizationException(""orthogonality tolerance is too small ({0}),"" + "" solution is orthogonal to the jacobian"", orthoTolerance);
            }
        }
    }
}","/**
 * {@inheritDoc}
 */
","@Override
protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
        solvedCols = Math.min(rows, cols);
    diagR = new double[cols];
    jacNorm = new double[cols];
    beta = new double[cols];
    permutation = new int[cols];
    lmDir = new double[cols];
        double delta = 0;
    double xNorm = 0;
    double[] diag = new double[cols];
    double[] oldX = new double[cols];
    double[] oldRes = new double[rows];
    double[] work1 = new double[cols];
    double[] work2 = new double[cols];
    double[] work3 = new double[cols];
        updateResidualsAndCost();
        lmPar = 0;
    boolean firstIteration = true;
    while (true) {
        incrementIterationsCounter();
                updateJacobian();
        qrDecomposition();
                qTy(residuals);
                for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            jacobian[k][pk] = diagR[pk];
        }
        if (firstIteration) {
                                    xNorm = 0;
            for (int k = 0; k < cols; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * point[k];
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = Math.sqrt(xNorm);
                        delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }
                double maxCosine = 0;
        if (cost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0; i <= j; ++i) {
                        sum += jacobian[i][pj] * residuals[i];
                    }
                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
                        return new VectorialPointValuePair(point, objective);
        }
                for (int j = 0; j < cols; ++j) {
            diag[j] = Math.max(diag[j], jacNorm[j]);
        }
                for (double ratio = 0; ratio < 1.0e-4; ) {
                        for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = point[pj];
            }
            double previousCost = cost;
            double[] tmpVec = residuals;
            residuals = oldRes;
            oldRes = tmpVec;
                        determineLMParameter(oldRes, delta, diag, work1, work2, work3);
                        double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                point[pj] = oldX[pj] + lmDir[pj];
                double s = diag[pj] * lmDir[pj];
                lmNorm += s * s;
            }
            lmNorm = Math.sqrt(lmNorm);
                        if (firstIteration) {
                delta = Math.min(delta, lmNorm);
            }
                        updateResidualsAndCost();
                        double actRed = -1.0;
            if (0.1 * cost < previousCost) {
                double r = cost / previousCost;
                actRed = 1.0 - r * r;
            }
                        for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0; i <= j; ++i) {
                    work1[i] += jacobian[i][pj] * dirJ;
                }
            }
            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                coeff1 += work1[j] * work1[j];
            }
            double pc2 = previousCost * previousCost;
            coeff1 = coeff1 / pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);
                        ratio = (preRed == 0) ? 0 : (actRed / preRed);
                        if (ratio <= 0.25) {
                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                    tmp = 0.1;
                }
                delta = tmp * Math.min(delta, 10.0 * lmNorm);
                lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }
                        if (ratio >= 1.0e-4) {
                                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double xK = diag[k] * point[k];
                    xNorm += xK * xK;
                }
                xNorm = Math.sqrt(xNorm);
            } else {
                                cost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    point[pj] = oldX[pj];
                }
                tmpVec = residuals;
                residuals = oldRes;
                oldRes = tmpVec;
            }
                        if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) {
                return new VectorialPointValuePair(point, objective);
            }
                        if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                throw new OptimizationException(""cost relative tolerance is too small ({0}),"" + "" no further reduction in the"" + "" sum of squares is possible"", costRelativeTolerance);
            } else if (delta <= 2.2204e-16 * xNorm) {
                throw new OptimizationException(""parameters relative tolerance is too small"" + "" ({0}), no further improvement in"" + "" the approximate solution is possible"", parRelativeTolerance);
            } else if (maxCosine <= 2.2204e-16) {
                throw new OptimizationException(""orthogonality tolerance is too small ({0}),"" + "" solution is orthogonal to the jacobian"", orthoTolerance);
            }
        }
    }
}",6.181818181818182,0.933673469387755,5.333333333333333,1.5,4.666666666666667,6.949085516559567,-1.776885574992831,1.0,-0.028571428571428574,64.24234091853299
Closure,54,2,"/**
 * Sets the prototype, creating the prototype object from the given
 * base type.
 * @param baseType The base type.
 */
public void setPrototypeBasedOn(ObjectType baseType) {
    // In the second case, we just use the anonymous object as the prototype.
    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {
        baseType = new PrototypeObjectType(registry, this.getReferenceName() + "".prototype"", baseType);
    }
    setPrototype((PrototypeObjectType) baseType);
}","/**
 * Sets the prototype, creating the prototype object from the given
 * base type.
 * @param baseType The base type.
 */
","public void setPrototypeBasedOn(ObjectType baseType) {
        if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {
        baseType = new PrototypeObjectType(registry, this.getReferenceName() + "".prototype"", baseType);
    }
    setPrototype((PrototypeObjectType) baseType);
}",-0.36363636363636365,-0.13775510204081634,-0.3333333333333333,-0.5,0.4166666666666667,0.2876915472071182,0.4858044164037856,0.0,0.05714285714285714,-0.010167850917205259
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-395_e6c31270,1,"private Property internalSetProperty(final String jcrName, final Value value, final int type, final boolean exactTypeMatch) throws RepositoryException {
    checkStatus();
    checkProtected();
    return sessionDelegate.perform(new SessionOperation<Property>() {

        @Override
        public Property perform() throws RepositoryException {
            if (value == null) {
                Property property = getProperty(jcrName);
                property.remove();
                return property;
            } else {
                String oakName = sessionDelegate.getOakPathOrThrow(jcrName);
                PropertyDefinition definition;
                if (hasProperty(jcrName)) {
                    definition = getProperty(jcrName).getDefinition();
                } else {
                    definition = dlg.sessionDelegate.getDefinitionProvider().getDefinition(NodeImpl.this, oakName, false, type, exactTypeMatch);
                }
                checkProtected(definition);
                if (definition.isMultiple()) {
                    throw new ValueFormatException(""Cannot set single value to multivalued property"");
                }
                int targetType = getTargetType(value, definition);
                Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());
                return new PropertyImpl(dlg.setProperty(oakName, targetValue));
            }
        }
    });
}",,"private Property internalSetProperty(final String jcrName, final Value value, final int type, final boolean exactTypeMatch) throws RepositoryException {
    checkStatus();
    checkProtected();
    return sessionDelegate.perform(new SessionOperation<Property>() {

        @Override
        public Property perform() throws RepositoryException {
            if (value == null) {
                Property property = getProperty(jcrName);
                property.remove();
                return property;
            } else {
                String oakName = sessionDelegate.getOakPathOrThrow(jcrName);
                PropertyDefinition definition;
                if (hasProperty(jcrName)) {
                    definition = getProperty(jcrName).getDefinition();
                } else {
                    definition = dlg.sessionDelegate.getDefinitionProvider().getDefinition(NodeImpl.this, oakName, false, type, exactTypeMatch);
                }
                checkProtected(definition);
                if (definition.isMultiple()) {
                    throw new ValueFormatException(""Cannot set single value to multivalued property"");
                }
                int targetType = getTargetType(value, definition);
                Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());
                return new PropertyImpl(dlg.setProperty(oakName, targetValue));
            }
        }
    });
}",0.6818181818181818,1.4591836734693877,0.16666666666666666,0.5,0.16666666666666666,-0.0247157686604053,-0.47777459133926015,0.9166666666666666,-0.028571428571428574,0.17553890894762314
commons-math,remotes/origin/bugs-dot-jar_MATH-705_645d642b,1,"/**
 * {@inheritDoc}
 */
@Override
public void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {
    sanityChecks(equations, t);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > equations.getTime();
    // create some internal working arrays
    final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp = new double[y.length];
    final double[] yDotTmp = new double[y.length];
    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());
    // set up integration control objects
    stepStart = equations.getTime();
    double hNew = 0;
    boolean firstTime = true;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    setStateInitialized(false);
    // main integration loop
    isLastStep = false;
    do {
        interpolator.shift();
        // iterate over step size, ensuring local normalized error is smaller than 1
        double error = 10;
        while (error >= 1.0) {
            if (firstTime || !fsal) {
                // first stage
                computeDerivatives(stepStart, y, yDotK[0]);
            }
            if (firstTime) {
                final double[] scale = new double[mainSetDimension];
                if (vecAbsoluteTolerance == null) {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
                    }
                } else {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
                    }
                }
                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }
            stepSize = hNew;
            // next stages
            for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
            // estimate the error at the end of the step
            error = estimateError(yDotK, y, yTmp, stepSize);
            if (error >= 1.0) {
                // reject the step and attempt to reduce error by stepsize control
                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            }
        }
        // local error is small enough: accept the step, trigger events and step handlers
        interpolator.storeTime(stepStart + stepSize);
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
        stepStart = acceptStep(interpolator, y, yDotTmp, t);
        if (!isLastStep) {
            // prepare next step
            interpolator.storeTime(stepStart);
            if (fsal) {
                // save the last evaluation for the next step
                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
            }
            // stepsize control for next step
            final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
            final double filteredNextT = stepStart + hNew;
            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
            if (filteredNextIsLast) {
                hNew = t - stepStart;
            }
        }
    } while (!isLastStep);
    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);
    resetInternalState();
}","/**
 * {@inheritDoc}
 */
","@Override
public void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {
    sanityChecks(equations, t);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > equations.getTime();
        final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][y.length];
    final double[] yTmp = new double[y.length];
    final double[] yDotTmp = new double[y.length];
        final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());
        stepStart = equations.getTime();
    double hNew = 0;
    boolean firstTime = true;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    setStateInitialized(false);
        isLastStep = false;
    do {
        interpolator.shift();
                double error = 10;
        while (error >= 1.0) {
            if (firstTime || !fsal) {
                                computeDerivatives(stepStart, y, yDotK[0]);
            }
            if (firstTime) {
                final double[] scale = new double[mainSetDimension];
                if (vecAbsoluteTolerance == null) {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
                    }
                } else {
                    for (int i = 0; i < scale.length; ++i) {
                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
                    }
                }
                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);
                firstTime = false;
            }
            stepSize = hNew;
                        for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
                        for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
                        error = estimateError(yDotK, y, yTmp, stepSize);
            if (error >= 1.0) {
                                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
                hNew = filterStep(stepSize * factor, forward, false);
            }
        }
                interpolator.storeTime(stepStart + stepSize);
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
        stepStart = acceptStep(interpolator, y, yDotTmp, t);
        if (!isLastStep) {
                        interpolator.storeTime(stepStart);
            if (fsal) {
                                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
            }
                        final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
            final double scaledH = stepSize * factor;
            final double nextT = stepStart + scaledH;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            hNew = filterStep(scaledH, forward, nextIsLast);
            final double filteredNextT = stepStart + hNew;
            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
            if (filteredNextIsLast) {
                hNew = t - stepStart;
            }
        }
    } while (!isLastStep);
        equations.setTime(stepStart);
    equations.setCompleteState(y);
    resetInternalState();
}",3.590909090909091,1.5408163265306123,2.6666666666666665,1.5,2.3333333333333335,3.9693524468610977,-1.3969027817608264,2.8333333333333335,-0.028571428571428574,26.73859971475195
camel,remotes/origin/bugs-dot-jar_CAMEL-7213_336663c9,1,"@Converter
public static ByteBuffer toByteBuffer(Double value) {
    ByteBuffer buf = ByteBuffer.allocate(8);
    buf.putDouble(value);
    return buf;
}",,"@Converter
public static ByteBuffer toByteBuffer(Double value) {
    ByteBuffer buf = ByteBuffer.allocate(8);
    buf.putDouble(value);
    return buf;
}",-0.36363636363636365,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.5896185833094353,-0.3333333333333333,1.2285714285714286,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7,3,"public removeConstraint_result getResult(I iface, removeConstraint_args args) throws org.apache.thrift.TException {
    removeConstraint_result result = new removeConstraint_result();
    try {
        iface.removeConstraint(args.login, args.tableName, args.constraint);
    } catch (AccumuloException ouch1) {
        result.ouch1 = ouch1;
    } catch (AccumuloSecurityException ouch2) {
        result.ouch2 = ouch2;
    }
    return result;
}",,"public removeConstraint_result getResult(I iface, removeConstraint_args args) throws org.apache.thrift.TException {
    removeConstraint_result result = new removeConstraint_result();
    try {
        iface.removeConstraint(args.login, args.tableName, args.constraint);
    } catch (AccumuloException ouch1) {
        result.ouch1 = ouch1;
    } catch (AccumuloSecurityException ouch2) {
        result.ouch2 = ouch2;
    }
    return result;
}",-0.13636363636363635,-0.17857142857142863,-0.16666666666666666,-0.5,-0.4166666666666667,-0.3806228373702422,0.13822770289647246,-0.4166666666666667,0.0,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-326_ce185345,1,"/**
 * {@inheritDoc}
 */
public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}","/**
 * {@inheritDoc}
 */
","public double getL1Norm() {
    double sum = 0;
    for (double a : data) {
        sum += Math.abs(a);
    }
    return sum;
}",-0.3181818181818182,-0.2346938775510204,-0.3333333333333333,-0.5,-0.4166666666666667,-0.10776075135936727,0.5486091195870376,-0.4166666666666667,2.7714285714285714,-0.1387950197232323
Lang,46,0,"/**
 * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>
 * <p>Escapes any values it finds into their JavaScript String form.
 * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>
 *
 * <p>So a tab becomes the characters <code>'\\'</code> and
 * <code>'t'</code>.</p>
 *
 * <p>The only difference between Java strings and JavaScript strings
 * is that in JavaScript, a single quote must be escaped.</p>
 *
 * <p>Example:
 * <pre>
 * input string: He didn't say, ""Stop!""
 * output string: He didn\'t say, \""Stop!\""
 * </pre>
 * </p>
 *
 * @param str  String to escape values in, may be null
 * @return String with escaped values, <code>null</code> if null string input
 */
public static String escapeJavaScript(String str) {
    return escapeJavaStyleString(str, true);
}","/**
 * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>
 * <p>Escapes any values it finds into their JavaScript String form.
 * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>
 *
 * <p>So a tab becomes the characters <code>'\\'</code> and
 * <code>'t'</code>.</p>
 *
 * <p>The only difference between Java strings and JavaScript strings
 * is that in JavaScript, a single quote must be escaped.</p>
 *
 * <p>Example:
 * <pre>
 * input string: He didn't say, ""Stop!""
 * output string: He didn\'t say, \""Stop!\""
 * </pre>
 * </p>
 *
 * @param str  String to escape values in, may be null
 * @return String with escaped values, <code>null</code> if null string input
 */
","public static String escapeJavaScript(String str) {
    return escapeJavaStyleString(str, true);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.0585030111843994,-0.4166666666666667,0.3428571428571429,-0.16422749602751402
JxPath,4,1,"protected String getLanguage() {
    Node n = node;
    while (n != null) {
        if (n.getNodeType() == Node.ELEMENT_NODE) {
            Element e = (Element) n;
            String attr = e.getAttribute(""xml:lang"");
            if (attr != null && !attr.equals("""")) {
                return attr;
            }
        }
        n = n.getParentNode();
    }
    return null;
}",,"protected String getLanguage() {
    Node n = node;
    while (n != null) {
        if (n.getNodeType() == Node.ELEMENT_NODE) {
            Element e = (Element) n;
            String attr = e.getAttribute(""xml:lang"");
            if (attr != null && !attr.equals("""")) {
                return attr;
            }
        }
        n = n.getParentNode();
    }
    return null;
}",0.0,0.8826530612244898,0.0,0.5,0.25,0.34107760751359373,0.0017206767995412186,-0.16666666666666666,1.1142857142857143,0.11440331333170578
Compress,6,1,"/* (non-Javadoc)
     * @see java.lang.Object#equals(java.lang.Object)
     */
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    ZipArchiveEntry other = (ZipArchiveEntry) obj;
    if (name == null) {
        if (other.name != null) {
            return false;
        }
    } else if (!name.equals(other.name)) {
        return false;
    }
    return true;
}",,"public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    ZipArchiveEntry other = (ZipArchiveEntry) obj;
    if (name == null) {
        if (other.name != null) {
            return false;
        }
    } else if (!name.equals(other.name)) {
        return false;
    }
    return true;
}",0.13636363636363635,-0.015306122448979493,0.3333333333333333,0.0,0.5833333333333334,0.6258032624814632,-0.0696874103814169,-0.25,1.3142857142857143,0.1497552263353335
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-3077_17654199,0,"/**
 * For testing purposes only -- should not be called by server code
 * <p>
 * Allows mocking of a Writer for testing
 *
 * @param creds
 *          Credentials
 * @param writer
 *          A Writer to use for the given credentials
 */
protected static synchronized void addWriter(Credentials creds, Writer writer) {
    writers.put(creds, writer);
}","/**
 * For testing purposes only -- should not be called by server code
 * <p>
 * Allows mocking of a Writer for testing
 *
 * @param creds
 *          Credentials
 * @param writer
 *          A Writer to use for the given credentials
 */
","protected static synchronized void addWriter(Credentials creds, Writer writer) {
    writers.put(creds, writer);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.003154574132492,-0.4166666666666667,2.8000000000000003,-0.16422749602751402
maven,remotes/origin/bugs-dot-jar_MNG-5655_96337372,1,"public void afterExecutionFailure(MojoExecutionEvent event) {
    for (Object provided : getScopeState().provided.values()) {
        if (provided instanceof WeakMojoExecutionListener) {
            ((WeakMojoExecutionListener) provided).afterExecutionFailure(event);
        }
    }
}",,"public void afterExecutionFailure(MojoExecutionEvent event) {
    for (Object provided : getScopeState().provided.values()) {
        if (provided instanceof WeakMojoExecutionListener) {
            ((WeakMojoExecutionListener) provided).afterExecutionFailure(event);
        }
    }
}",-0.3181818181818182,0.5612244897959184,-0.16666666666666666,0.0,-0.25,-0.3806228373702422,0.5276742185259534,-0.25,0.14285714285714285,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd,1,"/**
 * search the index for the provided PropertyRestriction
 *
 * @param filter
 * @param indexName
 * @param indexMeta
 * @param pr
 * @return the iterable
 */
public Iterable<String> query(final Filter filter, final String indexName, final NodeState indexMeta, final PropertyRestriction pr) {
    return query(filter, indexName, indexMeta, INDEX_CONTENT_NODE_NAME, pr);
}","/**
 * search the index for the provided PropertyRestriction
 *
 * @param filter
 * @param indexName
 * @param indexMeta
 * @param pr
 * @return the iterable
 */
","public Iterable<String> query(final Filter filter, final String indexName, final NodeState indexMeta, final PropertyRestriction pr) {
    return query(filter, indexName, indexMeta, INDEX_CONTENT_NODE_NAME, pr);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.888729566963006,-0.4166666666666667,2.628571428571429,-0.16422749602751402
Closure,74,2,"/**
 * Try to fold comparison nodes, e.g ==
 */
@SuppressWarnings(""fallthrough"")
private Node tryFoldComparison(Node n, Node left, Node right) {
    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {
        // We only handle non-literal operands for LT and GT.
        if (n.getType() != Token.GT && n.getType() != Token.LT) {
            return n;
        }
    }
    int op = n.getType();
    boolean result;
    // TODO(johnlenz): Use the JSType to compare nodes of different types.
    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);
    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(""undefined"")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));
    int lhType = left.getType();
    int rhType = right.getType();
    switch(lhType) {
        case Token.VOID:
            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
                return n;
            } else if (!rightLiteral) {
                return n;
            } else {
                result = compareToUndefined(right, op);
            }
            break;
        case Token.NULL:
        case Token.TRUE:
        case Token.FALSE:
            if (undefinedRight) {
                result = compareToUndefined(left, op);
                break;
            }
            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {
                return n;
            }
            switch(op) {
                case Token.SHEQ:
                case Token.EQ:
                    result = lhType == rhType;
                    break;
                case Token.SHNE:
                case Token.NE:
                    result = lhType != rhType;
                    break;
                case Token.GE:
                case Token.LE:
                case Token.GT:
                case Token.LT:
                    Boolean compareResult = compareAsNumbers(op, left, right);
                    if (compareResult != null) {
                        result = compareResult;
                    } else {
                        return n;
                    }
                    break;
                default:
                    // we only handle == and != here
                    return n;
            }
            break;
        case Token.THIS:
            if (right.getType() != Token.THIS) {
                return n;
            }
            switch(op) {
                case Token.SHEQ:
                case Token.EQ:
                    result = true;
                    break;
                case Token.SHNE:
                case Token.NE:
                    result = false;
                    break;
                // whether it is a string, NaN or other number value.
                default:
                    return n;
            }
            break;
        case Token.STRING:
            if (undefinedRight) {
                result = compareToUndefined(left, op);
                break;
            }
            if (Token.STRING != right.getType()) {
                // Only eval if they are the same type
                return n;
            }
            switch(op) {
                case Token.SHEQ:
                case Token.EQ:
                    result = left.getString().equals(right.getString());
                    break;
                case Token.SHNE:
                case Token.NE:
                    result = !left.getString().equals(right.getString());
                    break;
                default:
                    // we only handle == and != here
                    return n;
            }
            break;
        case Token.NUMBER:
            if (undefinedRight) {
                result = compareToUndefined(left, op);
                break;
            }
            if (Token.NUMBER != right.getType()) {
                // Only eval if they are the same type
                return n;
            }
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
                result = compareResult;
            } else {
                return null;
            }
            break;
        case Token.NAME:
            if (undefinedRight) {
                result = compareToUndefined(left, op);
                break;
            }
            if (rightLiteral) {
                boolean undefinedLeft = (left.getString().equals(""undefined""));
                if (undefinedLeft) {
                    result = compareToUndefined(right, op);
                    break;
                }
            }
            if (Token.NAME != right.getType()) {
                // Only eval if they are the same type
                return n;
            }
            String ln = left.getString();
            String rn = right.getString();
            if (!ln.equals(rn)) {
                // Not the same value name.
                return n;
            }
            switch(op) {
                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
                case Token.LT:
                case Token.GT:
                    result = false;
                    break;
                default:
                    // don't handle that op
                    return n;
            }
            break;
        default:
            // assert, this should cover all consts
            return n;
    }
    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);
    n.getParent().replaceChild(n, newNode);
    reportCodeChange();
    return newNode;
}","/**
 * Try to fold comparison nodes, e.g ==
 */
","@SuppressWarnings(""fallthrough"")
private Node tryFoldComparison(Node n, Node left, Node right) {
    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {
                if (n.getType() != Token.GT && n.getType() != Token.LT) {
            return n;
        }
    }
    int op = n.getType();
    boolean result;
        boolean rightLiteral = NodeUtil.isLiteralValue(right, false);
    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(""undefined"")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));
    int lhType = left.getType();
    int rhType = right.getType();
    switch(lhType) {
        case Token.VOID:
            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
                return n;
            } else if (!rightLiteral) {
                return n;
            } else {
                result = compareToUndefined(right, op);
            }
            break;
        case Token.NULL:
        case Token.TRUE:
        case Token.FALSE:
            if (undefinedRight) {
                result = compareToUndefined(left, op);
                break;
            }
            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {
                return n;
            }
            switch(op) {
                case Token.SHEQ:
                case Token.EQ:
                    result = lhType == rhType;
                    break;
                case Token.SHNE:
                case Token.NE:
                    result = lhType != rhType;
                    break;
                case Token.GE:
                case Token.LE:
                case Token.GT:
                case Token.LT:
                    Boolean compareResult = compareAsNumbers(op, left, right);
                    if (compareResult != null) {
                        result = compareResult;
                    } else {
                        return n;
                    }
                    break;
                default:
                                        return n;
            }
            break;
        case Token.THIS:
            if (right.getType() != Token.THIS) {
                return n;
            }
            switch(op) {
                case Token.SHEQ:
                case Token.EQ:
                    result = true;
                    break;
                case Token.SHNE:
                case Token.NE:
                    result = false;
                    break;
                                default:
                    return n;
            }
            break;
        case Token.STRING:
            if (undefinedRight) {
                result = compareToUndefined(left, op);
                break;
            }
            if (Token.STRING != right.getType()) {
                                return n;
            }
            switch(op) {
                case Token.SHEQ:
                case Token.EQ:
                    result = left.getString().equals(right.getString());
                    break;
                case Token.SHNE:
                case Token.NE:
                    result = !left.getString().equals(right.getString());
                    break;
                default:
                                        return n;
            }
            break;
        case Token.NUMBER:
            if (undefinedRight) {
                result = compareToUndefined(left, op);
                break;
            }
            if (Token.NUMBER != right.getType()) {
                                return n;
            }
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
                result = compareResult;
            } else {
                return null;
            }
            break;
        case Token.NAME:
            if (undefinedRight) {
                result = compareToUndefined(left, op);
                break;
            }
            if (rightLiteral) {
                boolean undefinedLeft = (left.getString().equals(""undefined""));
                if (undefinedLeft) {
                    result = compareToUndefined(right, op);
                    break;
                }
            }
            if (Token.NAME != right.getType()) {
                                return n;
            }
            String ln = left.getString();
            String rn = right.getString();
            if (!ln.equals(rn)) {
                                return n;
            }
            switch(op) {
                                case Token.LT:
                case Token.GT:
                    result = false;
                    break;
                default:
                                        return n;
            }
            break;
        default:
                        return n;
    }
    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);
    n.getParent().replaceChild(n, newNode);
    reportCodeChange();
    return newNode;
}",6.045454545454546,1.0561224489795917,11.0,1.5,5.166666666666667,2.6307464162135448,-1.8786922856323494,3.0,-0.028571428571428574,12.227196217251082
wicket,remotes/origin/bugs-dot-jar_WICKET-5770_cf6172bd,1,"@Override
public PageParameters decodePageParameters(final Url url) {
    PageParameters parameters = new PageParameters();
    int i = 0;
    for (String s : url.getSegments()) {
        parameters.set(i, s);
        ++i;
    }
    for (QueryParameter p : url.getQueryParameters()) {
        parameters.add(p.getName(), p.getValue(), INamedParameters.Type.QUERY_STRING);
    }
    return parameters.isEmpty() ? null : parameters;
}",,"@Override
public PageParameters decodePageParameters(final Url url) {
    PageParameters parameters = new PageParameters();
    int i = 0;
    for (String s : url.getSegments()) {
        parameters.set(i, s);
        ++i;
    }
    for (QueryParameter p : url.getQueryParameters()) {
        parameters.add(p.getName(), p.getValue(), INamedParameters.Type.QUERY_STRING);
    }
    return parameters.isEmpty() ? null : parameters;
}",-0.045454545454545456,-0.15306122448979584,0.0,-0.5,-0.25,-0.07612456747404842,0.028391167192428884,0.08333333333333333,-0.028571428571428574,-0.040080349150466196
commons-math,remotes/origin/bugs-dot-jar_MATH-1257_03178c8b,3,"/**
 * {@inheritDoc}
 *
 * If {@code x} is more than 40 standard deviations from the mean, 0 or 1
 * is returned, as in these cases the actual value is within
 * {@code Double.MIN_VALUE} of 0 or 1.
 */
@Override
public double cumulativeProbability(double x) {
    final double dev = x - mean;
    if (FastMath.abs(dev) > 40 * standardDeviation) {
        return dev < 0 ? 0.0d : 1.0d;
    }
    return 0.5 * (1 + Erf.erf(dev / (standardDeviation * SQRT2)));
}","/**
 * {@inheritDoc}
 *
 * If {@code x} is more than 40 standard deviations from the mean, 0 or 1
 * is returned, as in these cases the actual value is within
 * {@code Double.MIN_VALUE} of 0 or 1.
 */
","@Override
public double cumulativeProbability(double x) {
    final double dev = x - mean;
    if (FastMath.abs(dev) > 40 * standardDeviation) {
        return dev < 0 ? 0.0d : 1.0d;
    }
    return 0.5 * (1 + Erf.erf(dev / (standardDeviation * SQRT2)));
}",-0.2727272727272727,-0.1887755102040817,-0.16666666666666666,-0.5,0.0,0.3766683143845775,0.29566963005448826,-0.3333333333333333,1.7714285714285716,0.07975381294409395
camel,remotes/origin/bugs-dot-jar_CAMEL-3428_320545cd,3,"public <T extends Endpoint> T getEndpoint(String name, Class<T> endpointType) {
    Endpoint endpoint = getEndpoint(name);
    if (endpoint instanceof InterceptSendToEndpoint) {
        endpoint = ((InterceptSendToEndpoint) endpoint).getDelegate();
    }
    if (endpointType.isInstance(endpoint)) {
        return endpointType.cast(endpoint);
    } else {
        throw new IllegalArgumentException(""The endpoint is not of type: "" + endpointType + "" but is: "" + endpoint.getClass().getCanonicalName());
    }
}",,"public <T extends Endpoint> T getEndpoint(String name, Class<T> endpointType) {
    Endpoint endpoint = getEndpoint(name);
    if (endpoint instanceof InterceptSendToEndpoint) {
        endpoint = ((InterceptSendToEndpoint) endpoint).getDelegate();
    }
    if (endpointType.isInstance(endpoint)) {
        return endpointType.cast(endpoint);
    } else {
        throw new IllegalArgumentException(""The endpoint is not of type: "" + endpointType + "" but is: "" + endpoint.getClass().getCanonicalName());
    }
}",-0.13636363636363635,-0.17857142857142863,0.0,-0.5,-0.08333333333333333,-0.01878398418190801,0.13421279036420974,0.0,0.0,-0.04205481388207177
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-579_7d72e6ed,3,public abstract void restrictPushDown(SelectorImpl selectorImpl);,,public abstract void restrictPushDown(SelectorImpl selectorImpl);,-0.5909090909090909,-1.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.7106395182104968,-0.5,2.8000000000000003,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-988_d270055e,1,"/**
 * Get the intersection of the instance and another sub-line.
 * <p>
 * This method is related to the {@link Line#intersection(Line)
 * intersection} method in the {@link Line Line} class, but in addition
 * to compute the point along infinite lines, it also checks the point
 * lies on both sub-line ranges.
 * </p>
 * @param subLine other sub-line which may intersect instance
 * @param includeEndPoints if true, endpoints are considered to belong to
 * instance (i.e. they are closed sets) and may be returned, otherwise endpoints
 * are considered to not belong to instance (i.e. they are open sets) and intersection
 * occurring on endpoints lead to null being returned
 * @return the intersection point if there is one, null if the sub-lines don't intersect
 */
public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {
    // retrieve the underlying lines
    Line line1 = (Line) getHyperplane();
    Line line2 = (Line) subLine.getHyperplane();
    // compute the intersection on infinite line
    Vector2D v2D = line1.intersection(line2);
    // check location of point with respect to first sub-line
    Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));
    // check location of point with respect to second sub-line
    Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));
    if (includeEndPoints) {
        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;
    } else {
        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;
    }
}","/**
 * Get the intersection of the instance and another sub-line.
 * <p>
 * This method is related to the {@link Line#intersection(Line)
 * intersection} method in the {@link Line Line} class, but in addition
 * to compute the point along infinite lines, it also checks the point
 * lies on both sub-line ranges.
 * </p>
 * @param subLine other sub-line which may intersect instance
 * @param includeEndPoints if true, endpoints are considered to belong to
 * instance (i.e. they are closed sets) and may be returned, otherwise endpoints
 * are considered to not belong to instance (i.e. they are open sets) and intersection
 * occurring on endpoints lead to null being returned
 * @return the intersection point if there is one, null if the sub-lines don't intersect
 */
","public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {
        Line line1 = (Line) getHyperplane();
    Line line2 = (Line) subLine.getHyperplane();
        Vector2D v2D = line1.intersection(line2);
        Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));
        Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));
    if (includeEndPoints) {
        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;
    } else {
        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;
    }
}",-0.09090909090909091,-0.3622448979591837,0.0,-0.5,0.25,0.64755313890262,0.0014338973329508797,0.25,-0.028571428571428574,0.47909251716413753
JxPath,11,1,"private Attr getAttribute(Element element, QName name) {
    String testPrefix = name.getPrefix();
    String testNS = null;
    if (testPrefix != null) {
        testNS = parent.getNamespaceURI(testPrefix);
    }
    if (testNS != null) {
        Attr attr = element.getAttributeNodeNS(testNS, name.getName());
        if (attr != null) {
            return attr;
        }
        // This may mean that the parser does not support NS for
        // attributes, example - the version of Crimson bundled
        // with JDK 1.4.0
        NamedNodeMap nnm = element.getAttributes();
        for (int i = 0; i < nnm.getLength(); i++) {
            attr = (Attr) nnm.item(i);
            if (testAttr(attr, name)) {
                return attr;
            }
        }
        return null;
    }
    return element.getAttributeNode(name.getName());
}",,"private Attr getAttribute(Element element, QName name) {
    String testPrefix = name.getPrefix();
    String testNS = null;
    if (testPrefix != null) {
        testNS = parent.getNamespaceURI(testPrefix);
    }
    if (testNS != null) {
        Attr attr = element.getAttributeNodeNS(testNS, name.getName());
        if (attr != null) {
            return attr;
        }
                                NamedNodeMap nnm = element.getAttributes();
        for (int i = 0; i < nnm.getLength(); i++) {
            attr = (Attr) nnm.item(i);
            if (testAttr(attr, name)) {
                return attr;
            }
        }
        return null;
    }
    return element.getAttributeNode(name.getName());
}",0.36363636363636365,0.4948979591836736,0.3333333333333333,0.5,0.5833333333333334,0.4715768660405339,-0.31488385431603116,0.3333333333333333,-0.028571428571428574,0.4513857658653166
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1348_6ff92b12,1,"public int start() throws IOException {
    if (configError)
        return 1;
    String input;
    if (isVerbose())
        printInfo();
    String home = System.getProperty(""HOME"");
    if (home == null)
        home = System.getenv(""HOME"");
    String configDir = home + ""/"" + HISTORY_DIR_NAME;
    String historyPath = configDir + ""/"" + HISTORY_FILE_NAME;
    File accumuloDir = new File(configDir);
    if (!accumuloDir.exists() && !accumuloDir.mkdirs())
        log.warn(""Unable to make directory for history at "" + accumuloDir);
    try {
        History history = new History();
        history.setHistoryFile(new File(historyPath));
        reader.setHistory(history);
    } catch (IOException e) {
        log.warn(""Unable to load history file at "" + historyPath);
    }
    ShellCompletor userCompletor = null;
    if (execFile != null) {
        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));
        try {
            while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());
        } finally {
            scanner.close();
        }
    } else if (execCommand != null) {
        for (String command : execCommand.split(""\n"")) {
            execCommand(command, true, isVerbose());
        }
        return exitCode;
    }
    while (true) {
        if (hasExited())
            return exitCode;
        // If tab completion is true we need to reset
        if (tabCompletion) {
            if (userCompletor != null)
                reader.removeCompletor(userCompletor);
            userCompletor = setupCompletion();
            reader.addCompletor(userCompletor);
        }
        reader.setDefaultPrompt(getDefaultPrompt());
        input = reader.readLine();
        if (input == null) {
            reader.printNewline();
            return exitCode;
        }
        // user canceled
        execCommand(input, disableAuthTimeout, false);
    }
}",,"public int start() throws IOException {
    if (configError)
        return 1;
    String input;
    if (isVerbose())
        printInfo();
    String home = System.getProperty(""HOME"");
    if (home == null)
        home = System.getenv(""HOME"");
    String configDir = home + ""/"" + HISTORY_DIR_NAME;
    String historyPath = configDir + ""/"" + HISTORY_FILE_NAME;
    File accumuloDir = new File(configDir);
    if (!accumuloDir.exists() && !accumuloDir.mkdirs())
        log.warn(""Unable to make directory for history at "" + accumuloDir);
    try {
        History history = new History();
        history.setHistoryFile(new File(historyPath));
        reader.setHistory(history);
    } catch (IOException e) {
        log.warn(""Unable to load history file at "" + historyPath);
    }
    ShellCompletor userCompletor = null;
    if (execFile != null) {
        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));
        try {
            while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());
        } finally {
            scanner.close();
        }
    } else if (execCommand != null) {
        for (String command : execCommand.split(""\n"")) {
            execCommand(command, true, isVerbose());
        }
        return exitCode;
    }
    while (true) {
        if (hasExited())
            return exitCode;
                if (tabCompletion) {
            if (userCompletor != null)
                reader.removeCompletor(userCompletor);
            userCompletor = setupCompletion();
            reader.addCompletor(userCompletor);
        }
        reader.setDefaultPrompt(getDefaultPrompt());
        input = reader.readLine();
        if (input == null) {
            reader.printNewline();
            return exitCode;
        }
                execCommand(input, disableAuthTimeout, false);
    }
}",1.7727272727272727,0.15816326530612249,1.8333333333333333,0.5,1.6666666666666667,0.8057340583292142,-0.9262976770863208,1.75,-0.028571428571428574,2.0805376026314777
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-412_be2fdba7,1,"@Override
public void run() {
    ClientService.Iface client = null;
    try {
        client = ServerClient.getConnection(HdfsZooInstance.getInstance());
        List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);
        attempt.removeAll(fail);
        filesToLoad.removeAll(attempt);
    } catch (Exception ex) {
        log.error(ex, ex);
    } finally {
        ServerClient.close(client);
    }
}",,"@Override
public void run() {
    ClientService.Iface client = null;
    try {
        client = ServerClient.getConnection(HdfsZooInstance.getInstance());
        List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);
        attempt.removeAll(fail);
        filesToLoad.removeAll(attempt);
    } catch (Exception ex) {
        log.error(ex, ex);
    } finally {
        ServerClient.close(client);
    }
}",0.0,0.035714285714285636,-0.3333333333333333,-0.5,-0.4166666666666667,-0.3806228373702422,-0.010037281330656973,0.16666666666666666,-0.028571428571428574,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-4066_4d3d1f85,1,"public int getCompatibilityScore(Request request) {
    return 0;
}",,"public int getCompatibilityScore(Request request) {
    return 0;
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.144536851161457,-0.5,1.8,-0.16422749602751402
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-914_f8a42197,3,"/**
 * Format the stack trace including packaging information.
 *
 * @param ignorePackages
 *        List of packages to be ignored in the trace.
 * @return The formatted stack trace including packaging information.
 */
public String getExtendedStackTraceAsString(final List<String> ignorePackages) {
    final StringBuilder sb = new StringBuilder(this.name);
    final String msg = this.message;
    if (msg != null) {
        sb.append("": "").append(msg);
    }
    sb.append(EOL);
    this.formatElements(sb, 0, this.throwable.getStackTrace(), this.extendedStackTrace, ignorePackages);
    this.formatCause(sb, this.causeProxy, ignorePackages);
    return sb.toString();
}","/**
 * Format the stack trace including packaging information.
 *
 * @param ignorePackages
 *        List of packages to be ignored in the trace.
 * @return The formatted stack trace including packaging information.
 */
","public String getExtendedStackTraceAsString(final List<String> ignorePackages) {
    final StringBuilder sb = new StringBuilder(this.name);
    final String msg = this.message;
    if (msg != null) {
        sb.append("": "").append(msg);
    }
    sb.append(EOL);
    this.formatElements(sb, 0, this.throwable.getStackTrace(), this.extendedStackTrace, ignorePackages);
    this.formatCause(sb, this.causeProxy, ignorePackages);
    return sb.toString();
}",-0.13636363636363635,-0.4897959183673469,-0.3333333333333333,-0.5,-0.25,-0.056351952545724164,0.12675652423286501,0.08333333333333333,0.0,-0.038906806121268955
flink,remotes/origin/bugs-dot-jar_FLINK-1167_259f10c0,3,"public void setNextPartialSolution(OptimizerNode solutionSetDelta, OptimizerNode nextWorkset) {
    // the partial solution (so we can potentially do direct updates)
    if (solutionSetDelta instanceof TwoInputNode) {
        TwoInputNode solutionDeltaTwoInput = (TwoInputNode) solutionSetDelta;
        if (solutionDeltaTwoInput.getFirstPredecessorNode() == this.solutionSetNode || solutionDeltaTwoInput.getSecondPredecessorNode() == this.solutionSetNode) {
            this.solutionDeltaImmediatelyAfterSolutionJoin = true;
        }
    }
    // if the next workset is equal to the workset, we need to inject a no-op node
    if (nextWorkset == worksetNode) {
        NoOpNode noop = new NoOpNode();
        noop.setDegreeOfParallelism(getDegreeOfParallelism());
        PactConnection noOpConn = new PactConnection(nextWorkset, noop);
        noop.setIncomingConnection(noOpConn);
        nextWorkset.addOutgoingConnection(noOpConn);
        nextWorkset = noop;
    }
    // attach an extra node to the solution set delta for the cases where we need to repartition
    UnaryOperatorNode solutionSetDeltaUpdateAux = new UnaryOperatorNode(""Solution-Set Delta"", getSolutionSetKeyFields(), new SolutionSetDeltaOperator(getSolutionSetKeyFields()));
    solutionSetDeltaUpdateAux.setDegreeOfParallelism(getDegreeOfParallelism());
    PactConnection conn = new PactConnection(solutionSetDelta, solutionSetDeltaUpdateAux);
    solutionSetDeltaUpdateAux.setIncomingConnection(conn);
    solutionSetDelta.addOutgoingConnection(conn);
    this.solutionSetDelta = solutionSetDeltaUpdateAux;
    this.nextWorkset = nextWorkset;
    this.singleRoot = new SingleRootJoiner();
    this.solutionSetDeltaRootConnection = new PactConnection(solutionSetDeltaUpdateAux, this.singleRoot);
    this.nextWorksetRootConnection = new PactConnection(nextWorkset, this.singleRoot);
    this.singleRoot.setInputs(this.solutionSetDeltaRootConnection, this.nextWorksetRootConnection);
    solutionSetDeltaUpdateAux.addOutgoingConnection(this.solutionSetDeltaRootConnection);
    nextWorkset.addOutgoingConnection(this.nextWorksetRootConnection);
}",,"public void setNextPartialSolution(OptimizerNode solutionSetDelta, OptimizerNode nextWorkset) {
        if (solutionSetDelta instanceof TwoInputNode) {
        TwoInputNode solutionDeltaTwoInput = (TwoInputNode) solutionSetDelta;
        if (solutionDeltaTwoInput.getFirstPredecessorNode() == this.solutionSetNode || solutionDeltaTwoInput.getSecondPredecessorNode() == this.solutionSetNode) {
            this.solutionDeltaImmediatelyAfterSolutionJoin = true;
        }
    }
        if (nextWorkset == worksetNode) {
        NoOpNode noop = new NoOpNode();
        noop.setDegreeOfParallelism(getDegreeOfParallelism());
        PactConnection noOpConn = new PactConnection(nextWorkset, noop);
        noop.setIncomingConnection(noOpConn);
        nextWorkset.addOutgoingConnection(noOpConn);
        nextWorkset = noop;
    }
        UnaryOperatorNode solutionSetDeltaUpdateAux = new UnaryOperatorNode(""Solution-Set Delta"", getSolutionSetKeyFields(), new SolutionSetDeltaOperator(getSolutionSetKeyFields()));
    solutionSetDeltaUpdateAux.setDegreeOfParallelism(getDegreeOfParallelism());
    PactConnection conn = new PactConnection(solutionSetDelta, solutionSetDeltaUpdateAux);
    solutionSetDeltaUpdateAux.setIncomingConnection(conn);
    solutionSetDelta.addOutgoingConnection(conn);
    this.solutionSetDelta = solutionSetDeltaUpdateAux;
    this.nextWorkset = nextWorkset;
    this.singleRoot = new SingleRootJoiner();
    this.solutionSetDeltaRootConnection = new PactConnection(solutionSetDeltaUpdateAux, this.singleRoot);
    this.nextWorksetRootConnection = new PactConnection(nextWorkset, this.singleRoot);
    this.singleRoot.setInputs(this.solutionSetDeltaRootConnection, this.nextWorksetRootConnection);
    solutionSetDeltaUpdateAux.addOutgoingConnection(this.solutionSetDeltaRootConnection);
    nextWorkset.addOutgoingConnection(this.nextWorksetRootConnection);
}",0.6818181818181818,-0.21428571428571425,0.0,0.0,0.4166666666666667,0.15126050420168072,-0.49698881560080305,0.75,-0.028571428571428574,0.43798853011594086
Closure,134,2,"private void addNonUnionType(JSType newType) {
    if (skipAmbiguating || isInvalidatingType(newType)) {
        skipAmbiguating = true;
        return;
    }
    if (type == null) {
        type = newType;
    } else {
        type = type.getLeastSupertype(newType);
    }
    typesSet.set(getIntForType(newType));
}",,"private void addNonUnionType(JSType newType) {
    if (skipAmbiguating || isInvalidatingType(newType)) {
        skipAmbiguating = true;
        return;
    }
    if (type == null) {
        type = newType;
    } else {
        type = type.getLeastSupertype(newType);
    }
    typesSet.set(getIntForType(newType));
}",-0.09090909090909091,-0.13775510204081634,-0.16666666666666666,-0.5,0.16666666666666666,-0.06030647553138898,0.16030972182391756,-0.16666666666666666,0.6,-0.09227303292344988
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-621_00b4b8a0,1,"@Nonnull
static TreeImpl createRoot(final RootImpl root) {
    return new TreeImpl(root, null, """") {

        @Override
        protected NodeState getBaseState() {
            return root.getBaseState();
        }

        @Override
        protected synchronized NodeBuilder getNodeBuilder() {
            if (nodeBuilder == null) {
                nodeBuilder = root.createRootBuilder();
            }
            return nodeBuilder;
        }
    };
}",,"@Nonnull
static TreeImpl createRoot(final RootImpl root) {
    return new TreeImpl(root, null, """") {

        @Override
        protected NodeState getBaseState() {
            return root.getBaseState();
        }

        @Override
        protected synchronized NodeBuilder getNodeBuilder() {
            if (nodeBuilder == null) {
                nodeBuilder = root.createRootBuilder();
            }
            return nodeBuilder;
        }
    };
}",0.09090909090909091,0.8367346938775511,-0.3333333333333333,0.0,-0.25,-0.06426099851705384,0.030111843991970103,-0.3333333333333333,0.7142857142857143,-0.09139930015718624
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1067_4786a739,3,"@SuppressWarnings(""ThrowableResultOfMethodCallIgnored"")
private void formatCause(final StringBuilder sb, final ThrowableProxy cause, final List<String> ignorePackages) {
    if (cause == null) {
        return;
    }
    sb.append(""Caused by: "").append(cause).append(EOL);
    this.formatElements(sb, cause.commonElementCount, cause.getThrowable().getStackTrace(), cause.extendedStackTrace, ignorePackages);
    this.formatCause(sb, cause.causeProxy, ignorePackages);
}",,"@SuppressWarnings(""ThrowableResultOfMethodCallIgnored"")
private void formatCause(final StringBuilder sb, final ThrowableProxy cause, final List<String> ignorePackages) {
    if (cause == null) {
        return;
    }
    sb.append(""Caused by: "").append(cause).append(EOL);
    this.formatElements(sb, cause.commonElementCount, cause.getThrowable().getStackTrace(), cause.extendedStackTrace, ignorePackages);
    this.formatCause(sb, cause.causeProxy, ignorePackages);
}",-0.22727272727272727,-0.2602040816326532,-0.3333333333333333,-0.5,-0.25,-0.3806228373702422,0.23601950100372832,0.08333333333333333,-0.028571428571428574,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-5728_3cc3fe95,1,"/**
 *  Dequeues components. The default implementation iterates direct children of this container
 *  found in its markup and tries to find matching
 *  components in queues filled by a call to {@link #queue(Component...)}. It then delegates the
 *  dequeueing to these children.
 *
 *  The provided {@link DequeueContext} is used to maintain the place in markup as well as the
 *  stack of components whose queues will be searched. For example, before delegating the call to
 *  a child the container will push the child onto the stack of components.
 *
 *  Certain components that implement custom markup behaviors (such as repeaters and borders)
 *  override this method to bring dequeueing in line with their custom markup handling.
 *
 *  @param dequeue
 */
public void dequeue(DequeueContext dequeue) {
    while (dequeue.isAtOpenOrOpenCloseTag()) {
        ComponentTag tag = dequeue.takeTag();
        // see if child is already added to parent
        Component child = get(tag.getId());
        if (child == null) {
            // the container does not yet have a child with this id, see if we can
            // dequeue
            child = dequeue.findComponentToDequeue(tag);
            if (child != null) {
                addDequeuedComponent(child, tag);
                if (child instanceof IQueueRegion) {
                    ((MarkupContainer) child).dequeue();
                }
            }
        }
        if (child == null || !(child instanceof MarkupContainer)) {
            if (tag.isOpen()) {
                dequeue.skipToCloseTag();
            }
        } else {
            MarkupContainer container = (MarkupContainer) child;
            if (container instanceof IQueueRegion) {
                // itself when it is dequeued for the first time
                if (tag.isOpen()) {
                    dequeue.skipToCloseTag();
                }
            } else if (tag.isOpen()) {
                // this component has more markup and possibly more children to dequeue
                dequeue.pushContainer(container);
                container.dequeue(dequeue);
                dequeue.popContainer();
            }
        }
        if (tag.isOpen() && !tag.hasNoCloseTag()) {
            // pull the close tag off
            ComponentTag close = dequeue.takeTag();
            if (!close.closes(tag)) {
                // sanity check
                throw new IllegalStateException(String.format(""Tag '%s' should be the closing one for '%s'"", close, tag));
            }
        }
    }
}","/**
 *  Dequeues components. The default implementation iterates direct children of this container
 *  found in its markup and tries to find matching
 *  components in queues filled by a call to {@link #queue(Component...)}. It then delegates the
 *  dequeueing to these children.
 *
 *  The provided {@link DequeueContext} is used to maintain the place in markup as well as the
 *  stack of components whose queues will be searched. For example, before delegating the call to
 *  a child the container will push the child onto the stack of components.
 *
 *  Certain components that implement custom markup behaviors (such as repeaters and borders)
 *  override this method to bring dequeueing in line with their custom markup handling.
 *
 *  @param dequeue
 */
","public void dequeue(DequeueContext dequeue) {
    while (dequeue.isAtOpenOrOpenCloseTag()) {
        ComponentTag tag = dequeue.takeTag();
                Component child = get(tag.getId());
        if (child == null) {
                                    child = dequeue.findComponentToDequeue(tag);
            if (child != null) {
                addDequeuedComponent(child, tag);
                if (child instanceof IQueueRegion) {
                    ((MarkupContainer) child).dequeue();
                }
            }
        }
        if (child == null || !(child instanceof MarkupContainer)) {
            if (tag.isOpen()) {
                dequeue.skipToCloseTag();
            }
        } else {
            MarkupContainer container = (MarkupContainer) child;
            if (container instanceof IQueueRegion) {
                                if (tag.isOpen()) {
                    dequeue.skipToCloseTag();
                }
            } else if (tag.isOpen()) {
                                dequeue.pushContainer(container);
                container.dequeue(dequeue);
                dequeue.popContainer();
            }
        }
        if (tag.isOpen() && !tag.hasNoCloseTag()) {
                        ComponentTag close = dequeue.takeTag();
            if (!close.closes(tag)) {
                                throw new IllegalStateException(String.format(""Tag '%s' should be the closing one for '%s'"", close, tag));
            }
        }
    }
}",1.0454545454545454,0.8877551020408162,1.5,1.0,1.25,1.2288680177953537,-0.6481215944938347,1.1666666666666667,-0.028571428571428574,1.4148988568662975
wicket,remotes/origin/bugs-dot-jar_WICKET-5359_61122bab,3,"/**
 *  Convert to boolean, returning default value if text is inconvertible.
 *
 *  @param defaultValue
 *             the default value
 *  @return the converted text as a boolean or the default value if text is empty or inconvertible
 *  @see Strings#isTrue(String)
 */
public final boolean toBoolean(final boolean defaultValue) {
    if (text != null) {
        try {
            return toBoolean();
        } catch (StringValueConversionException x) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(String.format(""An error occurred while converting '%s' to a boolean: %s"", text, x.getMessage()), x);
            }
        }
    }
    return defaultValue;
}","/**
 *  Convert to boolean, returning default value if text is inconvertible.
 *
 *  @param defaultValue
 *             the default value
 *  @return the converted text as a boolean or the default value if text is empty or inconvertible
 *  @see Strings#isTrue(String)
 */
","public final boolean toBoolean(final boolean defaultValue) {
    if (text != null) {
        try {
            return toBoolean();
        } catch (StringValueConversionException x) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(String.format(""An error occurred while converting '%s' to a boolean: %s"", text, x.getMessage()), x);
            }
        }
    }
    return defaultValue;
}",-0.09090909090909091,0.933673469387755,0.0,0.5,-0.08333333333333333,-0.3806228373702422,0.1892744479495267,-0.08333333333333333,1.2285714285714286,-0.16422749602751402
Closure,49,3,"@Override
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    switch(n.getType()) {
        case Token.FUNCTION:
            {
                // Add recursive function name, if needed.
                // NOTE: ""enterScope"" is called after we need to pick up this name.
                Renamer renamer = nameStack.peek().forChildScope();
                // If needed, add the function recursive name.
                String name = n.getFirstChild().getString();
                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {
                    renamer.addDeclaredName(name);
                }
                // Add the function parameters
                // Add the function body declarations
                nameStack.push(renamer);
            }
            break;
        case Token.CATCH:
            {
                Renamer renamer = nameStack.peek().forChildScope();
                String name = n.getFirstChild().getString();
                renamer.addDeclaredName(name);
                nameStack.push(renamer);
            }
            break;
    }
    return true;
}",,"@Override
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
    switch(n.getType()) {
        case Token.FUNCTION:
            {
                                                Renamer renamer = nameStack.peek().forChildScope();
                                String name = n.getFirstChild().getString();
                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {
                    renamer.addDeclaredName(name);
                }
                                                nameStack.push(renamer);
            }
            break;
        case Token.CATCH:
            {
                Renamer renamer = nameStack.peek().forChildScope();
                String name = n.getFirstChild().getString();
                renamer.addDeclaredName(name);
                nameStack.push(renamer);
            }
            break;
    }
    return true;
}",0.45454545454545453,1.4795918367346939,0.3333333333333333,0.5,0.5833333333333334,0.4241225902125558,-0.35790077430456,0.75,-0.028571428571428574,0.42866443093870593
camel,remotes/origin/bugs-dot-jar_CAMEL-6604_4209fabb,1,"public void begin() {
    // we have already acquired and prepare the producer
    LOG.trace(""RecipientProcessorExchangePair #{} begin: {}"", index, exchange);
    exchange.setProperty(Exchange.RECIPIENT_LIST_ENDPOINT, endpoint.getEndpointUri());
}",,"public void begin() {
        LOG.trace(""RecipientProcessorExchangePair #{} begin: {}"", index, exchange);
    exchange.setProperty(Exchange.RECIPIENT_LIST_ENDPOINT, endpoint.getEndpointUri());
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8038428448523088,-0.25,0.4571428571428572,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-7016_4ed448c7,3,"public void updateRouteFromXml(String xml) throws Exception {
    // convert to model from xml
    RouteDefinition def = ModelHelper.createModelFromXml(xml, RouteDefinition.class);
    if (def == null) {
        return;
    }
    // add will remove existing route first
    context.addRouteDefinition(def);
}",,"public void updateRouteFromXml(String xml) throws Exception {
        RouteDefinition def = ModelHelper.createModelFromXml(xml, RouteDefinition.class);
    if (def == null) {
        return;
    }
        context.addRouteDefinition(def);
}",-0.3181818181818182,-0.2346938775510204,-0.3333333333333333,-0.5,-0.25,-0.11764705882352938,0.4794952681388014,-0.3333333333333333,2.314285714285714,-0.12508940770341057
wicket,remotes/origin/bugs-dot-jar_WICKET-5968_8b7946d8,1,"@Override
public int hashCode() {
    int result = super.hashCode();
    result = 31 * result + (extension != null ? extension.hashCode() : 0);
    return result;
}",,"@Override
public int hashCode() {
    int result = super.hashCode();
    result = 31 * result + (extension != null ? extension.hashCode() : 0);
    return result;
}",-0.36363636363636365,-0.5204081632653061,-0.3333333333333333,-1.0,-0.25,0.3114186851211074,0.55205047318612,-0.3333333333333333,1.342857142857143,-0.06212068647984204
wicket,remotes/origin/bugs-dot-jar_WICKET-3713_e1168a57,3,"/**
 *  @param userAgent
 *             The user agent string
 *  @return Whether the user agent matches this enum or not
 */
public boolean matches(String userAgent) {
    if (notAllowedList != null) {
        for (String value : notAllowedList) {
            if (userAgent.contains(value)) {
                return false;
            }
        }
    }
    for (List<String> detectionGroup : detectionStrings) {
        for (String detectionString : detectionGroup) {
            if (!userAgent.contains(detectionString)) {
                return false;
            }
        }
        return true;
    }
    return false;
}","/**
 *  @param userAgent
 *             The user agent string
 *  @return Whether the user agent matches this enum or not
 */
","public boolean matches(String userAgent) {
    if (notAllowedList != null) {
        for (String value : notAllowedList) {
            if (userAgent.contains(value)) {
                return false;
            }
        }
    }
    for (List<String> detectionGroup : detectionStrings) {
        for (String detectionString : detectionGroup) {
            if (!userAgent.contains(detectionString)) {
                return false;
            }
        }
        return true;
    }
    return false;
}",0.18181818181818182,0.8622448979591837,0.5,0.5,0.25,-0.012852199703410724,-0.06538571838256386,-0.3333333333333333,0.8285714285714285,-0.0751410178986727
camel,remotes/origin/bugs-dot-jar_CAMEL-7055_15e1077d,1,"public void close() throws IOException {
    currentStream.close();
    cleanUpTempFile();
}",,"public void close() throws IOException {
    currentStream.close();
    cleanUpTempFile();
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9836535704043596,-0.3333333333333333,1.7428571428571429,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-3535_b56d2962,1,"public void process(Exchange exchange) throws Exception {
    // compute correlation expression
    String key = correlationExpression.evaluate(exchange, String.class);
    if (ObjectHelper.isEmpty(key)) {
        // we have a bad correlation key
        if (isIgnoreInvalidCorrelationKeys()) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Invalid correlation key. This Exchange will be ignored: "" + exchange);
            }
            return;
        } else {
            throw new CamelExchangeException(""Invalid correlation key"", exchange);
        }
    }
    // is the correlation key closed?
    if (closedCorrelationKeys != null && closedCorrelationKeys.containsKey(key)) {
        throw new ClosedCorrelationKeyException(key, exchange);
    }
    // when memory based then its fast using synchronized, but if the aggregation repository is IO
    // bound such as JPA etc then concurrent aggregation per correlation key could
    // improve performance as we can run aggregation repository get/add in parallel
    lock.lock();
    try {
        doAggregation(key, exchange);
    } finally {
        lock.unlock();
    }
}",,"public void process(Exchange exchange) throws Exception {
        String key = correlationExpression.evaluate(exchange, String.class);
    if (ObjectHelper.isEmpty(key)) {
                if (isIgnoreInvalidCorrelationKeys()) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Invalid correlation key. This Exchange will be ignored: "" + exchange);
            }
            return;
        } else {
            throw new CamelExchangeException(""Invalid correlation key"", exchange);
        }
    }
        if (closedCorrelationKeys != null && closedCorrelationKeys.containsKey(key)) {
        throw new ClosedCorrelationKeyException(key, exchange);
    }
                lock.lock();
    try {
        doAggregation(key, exchange);
    } finally {
        lock.unlock();
    }
}",0.36363636363636365,0.5357142857142858,0.5,0.5,0.5,0.23628274839347513,-0.25150559219959845,0.25,-0.028571428571428574,0.1149172737824491
flink,remotes/origin/bugs-dot-jar_FLINK-1820_39d526e6,0,"/**
 *  Static utility to parse a field of type int from a byte sequence that represents text characters
 *  (such as when read from a file stream).
 *
 *  @param bytes The bytes containing the text data that should be parsed.
 *  @param startPos The offset to start the parsing.
 *  @param length The length of the byte sequence (counting from the offset).
 *  @param delimiter The delimiter that terminates the field.
 *
 *  @return The parsed value.
 *
 *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
 */
public static final int parseField(byte[] bytes, int startPos, int length, char delimiter) {
    if (length <= 0) {
        throw new NumberFormatException(""Invalid input: Empty string"");
    }
    long val = 0;
    boolean neg = false;
    if (bytes[startPos] == '-') {
        neg = true;
        startPos++;
        length--;
        if (length == 0 || bytes[startPos] == delimiter) {
            throw new NumberFormatException(""Orphaned minus sign."");
        }
    }
    for (; length > 0; startPos++, length--) {
        if (bytes[startPos] == delimiter) {
            return (int) (neg ? -val : val);
        }
        if (bytes[startPos] < 48 || bytes[startPos] > 57) {
            throw new NumberFormatException(""Invalid character."");
        }
        val *= 10;
        val += bytes[startPos] - 48;
        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {
            throw new NumberFormatException(""Value overflow/underflow"");
        }
    }
    return (int) (neg ? -val : val);
}","/**
 *  Static utility to parse a field of type int from a byte sequence that represents text characters
 *  (such as when read from a file stream).
 *
 *  @param bytes The bytes containing the text data that should be parsed.
 *  @param startPos The offset to start the parsing.
 *  @param length The length of the byte sequence (counting from the offset).
 *  @param delimiter The delimiter that terminates the field.
 *
 *  @return The parsed value.
 *
 *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
 */
","public static final int parseField(byte[] bytes, int startPos, int length, char delimiter) {
    if (length <= 0) {
        throw new NumberFormatException(""Invalid input: Empty string"");
    }
    long val = 0;
    boolean neg = false;
    if (bytes[startPos] == '-') {
        neg = true;
        startPos++;
        length--;
        if (length == 0 || bytes[startPos] == delimiter) {
            throw new NumberFormatException(""Orphaned minus sign."");
        }
    }
    for (; length > 0; startPos++, length--) {
        if (bytes[startPos] == delimiter) {
            return (int) (neg ? -val : val);
        }
        if (bytes[startPos] < 48 || bytes[startPos] > 57) {
            throw new NumberFormatException(""Invalid character."");
        }
        val *= 10;
        val += bytes[startPos] - 48;
        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {
            throw new NumberFormatException(""Value overflow/underflow"");
        }
    }
    return (int) (neg ? -val : val);
}",0.6818181818181818,0.07653061224489792,1.6666666666666667,0.0,1.0,2.9629263470093923,-0.5425867507886437,-0.5,-0.028571428571428574,3.141865933416424
flink,remotes/origin/bugs-dot-jar_FLINK-1214_6ecd0f82,1,"@Override
public void computeInterestingPropertiesForInputs(CostEstimator estimator) {
    // get what we inherit and what is preserved by our user code
    final InterestingProperties props = getInterestingProperties().filterByCodeAnnotations(this, 0);
    // add all properties relevant to this node
    for (OperatorDescriptorSingle dps : getPossibleProperties()) {
        for (RequestedGlobalProperties gp : dps.getPossibleGlobalProperties()) {
            props.addGlobalProperties(gp);
        }
        for (RequestedLocalProperties lp : dps.getPossibleLocalProperties()) {
            props.addLocalProperties(lp);
        }
    }
    this.inConn.setInterestingProperties(props);
    for (PactConnection conn : getBroadcastConnections()) {
        conn.setInterestingProperties(new InterestingProperties());
    }
}",,"@Override
public void computeInterestingPropertiesForInputs(CostEstimator estimator) {
        final InterestingProperties props = getInterestingProperties().filterByCodeAnnotations(this, 0);
        for (OperatorDescriptorSingle dps : getPossibleProperties()) {
        for (RequestedGlobalProperties gp : dps.getPossibleGlobalProperties()) {
            props.addGlobalProperties(gp);
        }
        for (RequestedLocalProperties lp : dps.getPossibleLocalProperties()) {
            props.addLocalProperties(lp);
        }
    }
    this.inConn.setInterestingProperties(props);
    for (PactConnection conn : getBroadcastConnections()) {
        conn.setInterestingProperties(new InterestingProperties());
    }
}",0.09090909090909091,0.3520408163265306,0.16666666666666666,0.0,-0.4166666666666667,-0.3806228373702422,-0.0648121594493836,0.3333333333333333,0.0,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-373_bfe4623c,1,"/**
 * {@inheritDoc}
 */
@Override
public void increment(final double d) {
    if (n == 0) {
        value = d * d;
    } else {
        value += d * d;
    }
    n++;
}","/**
 * {@inheritDoc}
 */
","@Override
public void increment(final double d) {
    if (n == 0) {
        value = d * d;
    } else {
        value += d * d;
    }
    n++;
}",-0.22727272727272727,-0.035714285714285636,-0.3333333333333333,-0.5,-0.25,0.3529411764705883,0.36363636363636354,-0.5,2.8000000000000003,-0.055867500995798375
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1269_b8fe2ded,1,"@Override
public Cursor query(Filter filter, NodeState root) {
    NodeTypeIndexLookup lookup = new NodeTypeIndexLookup(root);
    if (!hasNodeTypeRestriction(filter) || !lookup.isIndexed(filter.getPath())) {
        throw new IllegalStateException(""NodeType index is used even when no index is available for filter "" + filter);
    }
    return Cursors.newPathCursorDistinct(lookup.query(filter));
}",,"@Override
public Cursor query(Filter filter, NodeState root) {
    NodeTypeIndexLookup lookup = new NodeTypeIndexLookup(root);
    if (!hasNodeTypeRestriction(filter) || !lookup.isIndexed(filter.getPath())) {
        throw new IllegalStateException(""NodeType index is used even when no index is available for filter "" + filter);
    }
    return Cursors.newPathCursorDistinct(lookup.query(filter));
}",-0.2727272727272727,-0.1887755102040817,-0.16666666666666666,-0.5,0.08333333333333333,0.22441917943648054,0.3085747060510466,-0.08333333333333333,0.028571428571428574,0.014159610417978337
wicket,remotes/origin/bugs-dot-jar_WICKET-442_246d53c5,1,"/**
 *  Gets the converter instance. This method returns the cached converter for
 *  the current locale. Whenever the locale is changed, the cached value is
 *  cleared and the converter will be recreated for the new locale on a next
 *  request.
 *
 *  @param type
 *             TODO
 *
 *  @return the converter
 */
public final IConverter getConverter(Class type) {
    if (converterSupplier == null) {
        // Let the factory create a new converter
        converterSupplier = getApplication().getApplicationSettings().getConverterLocatorFactory().newConverterLocator();
    }
    return converterSupplier.getConverter(type);
}","/**
 *  Gets the converter instance. This method returns the cached converter for
 *  the current locale. Whenever the locale is changed, the cached value is
 *  cleared and the converter will be recreated for the new locale on a next
 *  request.
 *
 *  @param type
 *             TODO
 *
 *  @return the converter
 */
","public final IConverter getConverter(Class type) {
    if (converterSupplier == null) {
                converterSupplier = getApplication().getApplicationSettings().getConverterLocatorFactory().newConverterLocator();
    }
    return converterSupplier.getConverter(type);
}",-0.36363636363636365,-0.13775510204081634,-0.3333333333333333,-0.5,-0.25,-0.11171527434503209,0.5640952107829081,-0.08333333333333333,0.7142857142857143,-0.12748788980687936
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-478_a7f0e808,1,"@Override
public void childNodeDeleted(String name, NodeState before) {
    childNodeChanged(name, before, EMPTY_NODE);
}",,"@Override
public void childNodeDeleted(String name, NodeState before) {
    childNodeChanged(name, before, EMPTY_NODE);
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8468597648408377,-0.4166666666666667,-0.028571428571428574,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4,1,"private final Component children_set(int index, Component child) {
    final Component replaced;
    if (index < children_size()) {
        if (children == null || children instanceof Component) {
            replaced = (Component) children;
            children = child;
        } else {
            final Component[] children = (Component[]) this.children;
            replaced = children[index];
            children[index] = child;
        }
    } else {
        throw new IndexOutOfBoundsException();
    }
    return replaced != child ? replaced : null;
}",,"private final Component children_set(int index, Component child) {
    final Component replaced;
    if (index < children_size()) {
        if (children == null || children instanceof Component) {
            replaced = (Component) children;
            children = child;
        } else {
            final Component[] children = (Component[]) this.children;
            replaced = children[index];
            children[index] = child;
        }
    } else {
        throw new IndexOutOfBoundsException();
    }
    return replaced != child ? replaced : null;
}",0.09090909090909091,0.5612244897959184,0.16666666666666666,0.0,0.3333333333333333,0.9639149777558084,-0.05792945225121871,-0.4166666666666667,0.028571428571428574,0.3250500040688535
wicket,remotes/origin/bugs-dot-jar_WICKET-4927_8c827e33,1,"@Override
public void write(CharSequence sequence) {
    writeBuffered();
    originalResponse.write(sequence);
}",,"@Override
public void write(CharSequence sequence) {
    writeBuffered();
    originalResponse.write(sequence);
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7912245483223405,-0.3333333333333333,1.5142857142857145,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1877_716e1237,0,"@Override
public synchronized void run() {
    log.debug(""Running background index task {}"", name);
    if (isAlreadyRunning(store, name)) {
        log.debug(""The {} indexer is already running; skipping this update"", name);
        return;
    }
    NodeState before;
    NodeState root = store.getRoot();
    String refCheckpoint = root.getChildNode(ASYNC).getString(name);
    if (refCheckpoint != null) {
        NodeState state = store.retrieve(refCheckpoint);
        if (state == null) {
            log.warn(""Failed to retrieve previously indexed checkpoint {};"" + "" rerunning the initial {} index update"", refCheckpoint, name);
            before = MISSING_NODE;
        } else if (noVisibleChanges(state, root)) {
            log.debug(""No changes since last checkpoint;"" + "" skipping the {} index update"", name);
            return;
        } else {
            before = state;
        }
    } else {
        log.info(""Initial {} index update"", name);
        before = MISSING_NODE;
    }
    String checkpoint = store.checkpoint(lifetime);
    NodeState after = store.retrieve(checkpoint);
    if (after == null) {
        log.warn(""Unable to retrieve newly created checkpoint {},"" + "" skipping the {} index update"", checkpoint, name);
        return;
    }
    NodeBuilder builder = store.getRoot().builder();
    NodeBuilder async = builder.child(ASYNC);
    AsyncUpdateCallback callback = new AsyncUpdateCallback();
    preAsyncRunStatsStats(indexStats);
    IndexUpdate indexUpdate = new IndexUpdate(provider, name, after, builder, callback);
    CommitFailedException exception = EditorDiff.process(indexUpdate, before, after);
    if (exception == null) {
        if (callback.dirty) {
            async.setProperty(name, checkpoint);
            try {
                store.merge(builder, newCommitHook(name, refCheckpoint), CommitInfo.EMPTY);
            } catch (CommitFailedException e) {
                if (e != CONCURRENT_UPDATE) {
                    exception = e;
                }
            }
            if (switchOnSync) {
                reindexedDefinitions.addAll(indexUpdate.getReindexedDefinitions());
            }
        } else if (switchOnSync) {
            log.debug(""No changes detected after diff, will try to switch to synchronous updates on "" + reindexedDefinitions);
            async.setProperty(name, checkpoint);
            // no changes after diff, switch to sync on the async defs
            for (String path : reindexedDefinitions) {
                NodeBuilder c = builder;
                for (String p : elements(path)) {
                    c = c.getChildNode(p);
                }
                if (c.exists() && !c.getBoolean(REINDEX_PROPERTY_NAME)) {
                    c.removeProperty(ASYNC_PROPERTY_NAME);
                }
            }
            try {
                store.merge(builder, newCommitHook(name, refCheckpoint), CommitInfo.EMPTY);
                reindexedDefinitions.clear();
            } catch (CommitFailedException e) {
                if (e != CONCURRENT_UPDATE) {
                    exception = e;
                }
            }
        }
    }
    postAsyncRunStatsStatus(indexStats);
    // checkpoints cleanup
    if (exception != null || (exception == null && !callback.dirty)) {
        log.debug(""The {} index update failed; releasing the related checkpoint {}"", name, checkpoint);
        store.release(checkpoint);
    } else {
        if (refCheckpoint != null) {
            log.debug(""The {} index update succeeded; releasing the previous checkpoint {}"", name, refCheckpoint);
            store.release(refCheckpoint);
        }
    }
    if (exception != null) {
        if (!failing) {
            log.warn(""Index update {} failed"", name, exception);
        }
        failing = true;
    } else {
        if (failing) {
            log.info(""Index update {} no longer fails"", name);
        }
        failing = false;
    }
}",,"@Override
public synchronized void run() {
    log.debug(""Running background index task {}"", name);
    if (isAlreadyRunning(store, name)) {
        log.debug(""The {} indexer is already running; skipping this update"", name);
        return;
    }
    NodeState before;
    NodeState root = store.getRoot();
    String refCheckpoint = root.getChildNode(ASYNC).getString(name);
    if (refCheckpoint != null) {
        NodeState state = store.retrieve(refCheckpoint);
        if (state == null) {
            log.warn(""Failed to retrieve previously indexed checkpoint {};"" + "" rerunning the initial {} index update"", refCheckpoint, name);
            before = MISSING_NODE;
        } else if (noVisibleChanges(state, root)) {
            log.debug(""No changes since last checkpoint;"" + "" skipping the {} index update"", name);
            return;
        } else {
            before = state;
        }
    } else {
        log.info(""Initial {} index update"", name);
        before = MISSING_NODE;
    }
    String checkpoint = store.checkpoint(lifetime);
    NodeState after = store.retrieve(checkpoint);
    if (after == null) {
        log.warn(""Unable to retrieve newly created checkpoint {},"" + "" skipping the {} index update"", checkpoint, name);
        return;
    }
    NodeBuilder builder = store.getRoot().builder();
    NodeBuilder async = builder.child(ASYNC);
    AsyncUpdateCallback callback = new AsyncUpdateCallback();
    preAsyncRunStatsStats(indexStats);
    IndexUpdate indexUpdate = new IndexUpdate(provider, name, after, builder, callback);
    CommitFailedException exception = EditorDiff.process(indexUpdate, before, after);
    if (exception == null) {
        if (callback.dirty) {
            async.setProperty(name, checkpoint);
            try {
                store.merge(builder, newCommitHook(name, refCheckpoint), CommitInfo.EMPTY);
            } catch (CommitFailedException e) {
                if (e != CONCURRENT_UPDATE) {
                    exception = e;
                }
            }
            if (switchOnSync) {
                reindexedDefinitions.addAll(indexUpdate.getReindexedDefinitions());
            }
        } else if (switchOnSync) {
            log.debug(""No changes detected after diff, will try to switch to synchronous updates on "" + reindexedDefinitions);
            async.setProperty(name, checkpoint);
                        for (String path : reindexedDefinitions) {
                NodeBuilder c = builder;
                for (String p : elements(path)) {
                    c = c.getChildNode(p);
                }
                if (c.exists() && !c.getBoolean(REINDEX_PROPERTY_NAME)) {
                    c.removeProperty(ASYNC_PROPERTY_NAME);
                }
            }
            try {
                store.merge(builder, newCommitHook(name, refCheckpoint), CommitInfo.EMPTY);
                reindexedDefinitions.clear();
            } catch (CommitFailedException e) {
                if (e != CONCURRENT_UPDATE) {
                    exception = e;
                }
            }
        }
    }
    postAsyncRunStatsStatus(indexStats);
        if (exception != null || (exception == null && !callback.dirty)) {
        log.debug(""The {} index update failed; releasing the related checkpoint {}"", name, checkpoint);
        store.release(checkpoint);
    } else {
        if (refCheckpoint != null) {
            log.debug(""The {} index update succeeded; releasing the previous checkpoint {}"", name, refCheckpoint);
            store.release(refCheckpoint);
        }
    }
    if (exception != null) {
        if (!failing) {
            log.warn(""Index update {} failed"", name, exception);
        }
        failing = true;
    } else {
        if (failing) {
            log.info(""Index update {} no longer fails"", name);
        }
        failing = false;
    }
}",3.6363636363636362,0.9744897959183673,3.0,1.5,2.5,1.2466633712308457,-1.3386865500430172,2.9166666666666665,-0.028571428571428574,5.863188011015886
flink,remotes/origin/bugs-dot-jar_FLINK-2658_ce68cbd9,1,"/**
 *  Creates a Flink program that uses the specified spouts and bolts.
 */
@SuppressWarnings({ ""rawtypes"", ""unchecked"" })
public FlinkTopology createTopology() {
    final StormTopology stormTopolgoy = this.stormBuilder.createTopology();
    final FlinkTopology env = new FlinkTopology(stormTopolgoy);
    env.setParallelism(1);
    final HashMap<String, HashMap<String, DataStream>> availableInputs = new HashMap<String, HashMap<String, DataStream>>();
    for (final Entry<String, IRichSpout> spout : this.spouts.entrySet()) {
        final String spoutId = spout.getKey();
        final IRichSpout userSpout = spout.getValue();
        final FlinkOutputFieldsDeclarer declarer = new FlinkOutputFieldsDeclarer();
        userSpout.declareOutputFields(declarer);
        final HashMap<String, Fields> sourceStreams = declarer.outputStreams;
        this.outputStreams.put(spoutId, sourceStreams);
        declarers.put(spoutId, declarer);
        AbstractStormSpoutWrapper spoutWrapper;
        if (userSpout instanceof FiniteStormSpout) {
            spoutWrapper = new FiniteStormSpoutWrapper((FiniteStormSpout) userSpout);
        } else {
            spoutWrapper = new StormSpoutWrapper(userSpout);
        }
        DataStreamSource source;
        HashMap<String, DataStream> outputStreams = new HashMap<String, DataStream>();
        if (sourceStreams.size() == 1) {
            final String outputStreamId = (String) sourceStreams.keySet().toArray()[0];
            source = env.addSource(spoutWrapper, spoutId, declarer.getOutputType(outputStreamId));
            outputStreams.put(outputStreamId, source);
        } else {
            source = env.addSource(spoutWrapper, spoutId, TypeExtractor.getForClass(SplitStreamType.class));
            SplitDataStream splitSource = source.split(new FlinkStormStreamSelector());
            for (String streamId : sourceStreams.keySet()) {
                outputStreams.put(streamId, splitSource.select(streamId));
            }
        }
        availableInputs.put(spoutId, outputStreams);
        int dop = 1;
        final ComponentCommon common = stormTopolgoy.get_spouts().get(spoutId).get_common();
        if (common.is_set_parallelism_hint()) {
            dop = common.get_parallelism_hint();
            source.setParallelism(dop);
        }
        env.increaseNumberOfTasks(dop);
    }
    final HashMap<String, IRichBolt> unprocessedBolts = new HashMap<String, IRichBolt>();
    unprocessedBolts.putAll(this.bolts);
    final HashMap<String, Set<Entry<GlobalStreamId, Grouping>>> unprocessdInputsPerBolt = new HashMap<String, Set<Entry<GlobalStreamId, Grouping>>>();
    /* Because we do not know the order in which an iterator steps over a set, we might process a consumer before
		 * its producer
		 * ->thus, we might need to repeat multiple times
		 */
    boolean makeProgress = true;
    while (unprocessedBolts.size() > 0) {
        if (!makeProgress) {
            throw new RuntimeException(""Unable to build Topology. Could not connect the following bolts: "" + unprocessedBolts.keySet());
        }
        makeProgress = false;
        final Iterator<Entry<String, IRichBolt>> boltsIterator = unprocessedBolts.entrySet().iterator();
        while (boltsIterator.hasNext()) {
            final Entry<String, IRichBolt> bolt = boltsIterator.next();
            final String boltId = bolt.getKey();
            final IRichBolt userBolt = bolt.getValue();
            final ComponentCommon common = stormTopolgoy.get_bolts().get(boltId).get_common();
            Set<Entry<GlobalStreamId, Grouping>> unprocessedInputs = unprocessdInputsPerBolt.get(boltId);
            if (unprocessedInputs == null) {
                unprocessedInputs = new HashSet<Entry<GlobalStreamId, Grouping>>();
                unprocessedInputs.addAll(common.get_inputs().entrySet());
                unprocessdInputsPerBolt.put(boltId, unprocessedInputs);
            }
            // connect each available producer to the current bolt
            final Iterator<Entry<GlobalStreamId, Grouping>> inputStreamsIterator = unprocessedInputs.iterator();
            while (inputStreamsIterator.hasNext()) {
                final Entry<GlobalStreamId, Grouping> stormInputStream = inputStreamsIterator.next();
                final String producerId = stormInputStream.getKey().get_componentId();
                final String inputStreamId = stormInputStream.getKey().get_streamId();
                HashMap<String, DataStream> producer = availableInputs.get(producerId);
                if (producer != null) {
                    makeProgress = true;
                    DataStream inputStream = producer.get(inputStreamId);
                    if (inputStream != null) {
                        final FlinkOutputFieldsDeclarer declarer = new FlinkOutputFieldsDeclarer();
                        userBolt.declareOutputFields(declarer);
                        final HashMap<String, Fields> boltOutputStreams = declarer.outputStreams;
                        this.outputStreams.put(boltId, boltOutputStreams);
                        this.declarers.put(boltId, declarer);
                        // if producer was processed already
                        final Grouping grouping = stormInputStream.getValue();
                        if (grouping.is_set_shuffle()) {
                            // Storm uses a round-robin shuffle strategy
                            inputStream = inputStream.rebalance();
                        } else if (grouping.is_set_fields()) {
                            // global grouping is emulated in Storm via an empty fields grouping list
                            final List<String> fields = grouping.get_fields();
                            if (fields.size() > 0) {
                                FlinkOutputFieldsDeclarer prodDeclarer = this.declarers.get(producerId);
                                inputStream = inputStream.groupBy(prodDeclarer.getGroupingFieldIndexes(inputStreamId, grouping.get_fields()));
                            } else {
                                inputStream = inputStream.global();
                            }
                        } else if (grouping.is_set_all()) {
                            inputStream = inputStream.broadcast();
                        } else if (!grouping.is_set_local_or_shuffle()) {
                            throw new UnsupportedOperationException(""Flink only supports (local-or-)shuffle, fields, all, and global grouping"");
                        }
                        SingleOutputStreamOperator outputStream;
                        if (boltOutputStreams.size() < 2) {
                            // single output stream or sink
                            String outputStreamId = null;
                            if (boltOutputStreams.size() == 1) {
                                outputStreamId = (String) boltOutputStreams.keySet().toArray()[0];
                            }
                            final TypeInformation<?> outType = declarer.getOutputType(outputStreamId);
                            outputStream = inputStream.transform(boltId, outType, new StormBoltWrapper(userBolt, this.outputStreams.get(producerId).get(inputStreamId)));
                            if (outType != null) {
                                // only for non-sink nodes
                                HashMap<String, DataStream> op = new HashMap<String, DataStream>();
                                op.put(outputStreamId, outputStream);
                                availableInputs.put(boltId, op);
                            }
                        } else {
                            final TypeInformation<?> outType = TypeExtractor.getForClass(SplitStreamType.class);
                            outputStream = inputStream.transform(boltId, outType, new StormBoltWrapper(userBolt, this.outputStreams.get(producerId).get(inputStreamId)));
                            SplitDataStream splitStreams = outputStream.split(new FlinkStormStreamSelector());
                            HashMap<String, DataStream> op = new HashMap<String, DataStream>();
                            for (String outputStreamId : boltOutputStreams.keySet()) {
                                op.put(outputStreamId, splitStreams.select(outputStreamId));
                            }
                            availableInputs.put(boltId, op);
                        }
                        int dop = 1;
                        if (common.is_set_parallelism_hint()) {
                            dop = common.get_parallelism_hint();
                            outputStream.setParallelism(dop);
                        }
                        env.increaseNumberOfTasks(dop);
                        inputStreamsIterator.remove();
                    } else {
                        throw new RuntimeException(""Cannot connect '"" + boltId + ""' to '"" + producerId + ""'. Stream '"" + inputStreamId + ""' not found."");
                    }
                }
            }
            if (unprocessedInputs.size() == 0) {
                // all inputs are connected; processing bolt completed
                boltsIterator.remove();
            }
        }
    }
    return env;
}","/**
 *  Creates a Flink program that uses the specified spouts and bolts.
 */
","@SuppressWarnings({ ""rawtypes"", ""unchecked"" })
public FlinkTopology createTopology() {
    final StormTopology stormTopolgoy = this.stormBuilder.createTopology();
    final FlinkTopology env = new FlinkTopology(stormTopolgoy);
    env.setParallelism(1);
    final HashMap<String, HashMap<String, DataStream>> availableInputs = new HashMap<String, HashMap<String, DataStream>>();
    for (final Entry<String, IRichSpout> spout : this.spouts.entrySet()) {
        final String spoutId = spout.getKey();
        final IRichSpout userSpout = spout.getValue();
        final FlinkOutputFieldsDeclarer declarer = new FlinkOutputFieldsDeclarer();
        userSpout.declareOutputFields(declarer);
        final HashMap<String, Fields> sourceStreams = declarer.outputStreams;
        this.outputStreams.put(spoutId, sourceStreams);
        declarers.put(spoutId, declarer);
        AbstractStormSpoutWrapper spoutWrapper;
        if (userSpout instanceof FiniteStormSpout) {
            spoutWrapper = new FiniteStormSpoutWrapper((FiniteStormSpout) userSpout);
        } else {
            spoutWrapper = new StormSpoutWrapper(userSpout);
        }
        DataStreamSource source;
        HashMap<String, DataStream> outputStreams = new HashMap<String, DataStream>();
        if (sourceStreams.size() == 1) {
            final String outputStreamId = (String) sourceStreams.keySet().toArray()[0];
            source = env.addSource(spoutWrapper, spoutId, declarer.getOutputType(outputStreamId));
            outputStreams.put(outputStreamId, source);
        } else {
            source = env.addSource(spoutWrapper, spoutId, TypeExtractor.getForClass(SplitStreamType.class));
            SplitDataStream splitSource = source.split(new FlinkStormStreamSelector());
            for (String streamId : sourceStreams.keySet()) {
                outputStreams.put(streamId, splitSource.select(streamId));
            }
        }
        availableInputs.put(spoutId, outputStreams);
        int dop = 1;
        final ComponentCommon common = stormTopolgoy.get_spouts().get(spoutId).get_common();
        if (common.is_set_parallelism_hint()) {
            dop = common.get_parallelism_hint();
            source.setParallelism(dop);
        }
        env.increaseNumberOfTasks(dop);
    }
    final HashMap<String, IRichBolt> unprocessedBolts = new HashMap<String, IRichBolt>();
    unprocessedBolts.putAll(this.bolts);
    final HashMap<String, Set<Entry<GlobalStreamId, Grouping>>> unprocessdInputsPerBolt = new HashMap<String, Set<Entry<GlobalStreamId, Grouping>>>();
        boolean makeProgress = true;
    while (unprocessedBolts.size() > 0) {
        if (!makeProgress) {
            throw new RuntimeException(""Unable to build Topology. Could not connect the following bolts: "" + unprocessedBolts.keySet());
        }
        makeProgress = false;
        final Iterator<Entry<String, IRichBolt>> boltsIterator = unprocessedBolts.entrySet().iterator();
        while (boltsIterator.hasNext()) {
            final Entry<String, IRichBolt> bolt = boltsIterator.next();
            final String boltId = bolt.getKey();
            final IRichBolt userBolt = bolt.getValue();
            final ComponentCommon common = stormTopolgoy.get_bolts().get(boltId).get_common();
            Set<Entry<GlobalStreamId, Grouping>> unprocessedInputs = unprocessdInputsPerBolt.get(boltId);
            if (unprocessedInputs == null) {
                unprocessedInputs = new HashSet<Entry<GlobalStreamId, Grouping>>();
                unprocessedInputs.addAll(common.get_inputs().entrySet());
                unprocessdInputsPerBolt.put(boltId, unprocessedInputs);
            }
                        final Iterator<Entry<GlobalStreamId, Grouping>> inputStreamsIterator = unprocessedInputs.iterator();
            while (inputStreamsIterator.hasNext()) {
                final Entry<GlobalStreamId, Grouping> stormInputStream = inputStreamsIterator.next();
                final String producerId = stormInputStream.getKey().get_componentId();
                final String inputStreamId = stormInputStream.getKey().get_streamId();
                HashMap<String, DataStream> producer = availableInputs.get(producerId);
                if (producer != null) {
                    makeProgress = true;
                    DataStream inputStream = producer.get(inputStreamId);
                    if (inputStream != null) {
                        final FlinkOutputFieldsDeclarer declarer = new FlinkOutputFieldsDeclarer();
                        userBolt.declareOutputFields(declarer);
                        final HashMap<String, Fields> boltOutputStreams = declarer.outputStreams;
                        this.outputStreams.put(boltId, boltOutputStreams);
                        this.declarers.put(boltId, declarer);
                                                final Grouping grouping = stormInputStream.getValue();
                        if (grouping.is_set_shuffle()) {
                                                        inputStream = inputStream.rebalance();
                        } else if (grouping.is_set_fields()) {
                                                        final List<String> fields = grouping.get_fields();
                            if (fields.size() > 0) {
                                FlinkOutputFieldsDeclarer prodDeclarer = this.declarers.get(producerId);
                                inputStream = inputStream.groupBy(prodDeclarer.getGroupingFieldIndexes(inputStreamId, grouping.get_fields()));
                            } else {
                                inputStream = inputStream.global();
                            }
                        } else if (grouping.is_set_all()) {
                            inputStream = inputStream.broadcast();
                        } else if (!grouping.is_set_local_or_shuffle()) {
                            throw new UnsupportedOperationException(""Flink only supports (local-or-)shuffle, fields, all, and global grouping"");
                        }
                        SingleOutputStreamOperator outputStream;
                        if (boltOutputStreams.size() < 2) {
                                                        String outputStreamId = null;
                            if (boltOutputStreams.size() == 1) {
                                outputStreamId = (String) boltOutputStreams.keySet().toArray()[0];
                            }
                            final TypeInformation<?> outType = declarer.getOutputType(outputStreamId);
                            outputStream = inputStream.transform(boltId, outType, new StormBoltWrapper(userBolt, this.outputStreams.get(producerId).get(inputStreamId)));
                            if (outType != null) {
                                                                HashMap<String, DataStream> op = new HashMap<String, DataStream>();
                                op.put(outputStreamId, outputStream);
                                availableInputs.put(boltId, op);
                            }
                        } else {
                            final TypeInformation<?> outType = TypeExtractor.getForClass(SplitStreamType.class);
                            outputStream = inputStream.transform(boltId, outType, new StormBoltWrapper(userBolt, this.outputStreams.get(producerId).get(inputStreamId)));
                            SplitDataStream splitStreams = outputStream.split(new FlinkStormStreamSelector());
                            HashMap<String, DataStream> op = new HashMap<String, DataStream>();
                            for (String outputStreamId : boltOutputStreams.keySet()) {
                                op.put(outputStreamId, splitStreams.select(outputStreamId));
                            }
                            availableInputs.put(boltId, op);
                        }
                        int dop = 1;
                        if (common.is_set_parallelism_hint()) {
                            dop = common.get_parallelism_hint();
                            outputStream.setParallelism(dop);
                        }
                        env.increaseNumberOfTasks(dop);
                        inputStreamsIterator.remove();
                    } else {
                        throw new RuntimeException(""Cannot connect '"" + boltId + ""' to '"" + producerId + ""'. Stream '"" + inputStreamId + ""' not found."");
                    }
                }
            }
            if (unprocessedInputs.size() == 0) {
                                boltsIterator.remove();
            }
        }
    }
    return env;
}",5.545454545454546,3.1632653061224496,3.8333333333333335,3.5,2.75,1.7528423133959465,-1.6638944651562955,7.583333333333333,-0.028571428571428574,17.569194067183197
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_add180fb,1,"@Override
public void delete(String tableName) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {
    acu.tables.remove(tableName);
}",,"@Override
public void delete(String tableName) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {
    acu.tables.remove(tableName);
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8210496128477202,-0.4166666666666667,0.20000000000000004,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-393_d4b02f6a,3,"/**
 * Get the number of evaluations of the objective function.
 * <p>
 * The number of evaluations corresponds to the last call to the
 * {@link #optimize(UnivariateRealFunction, GoalType, double, double) optimize}
 * method. It is 0 if the method has not been called yet.
 * </p>
 * @return number of evaluations of the objective function
 */
int getEvaluations();","/**
 * Get the number of evaluations of the objective function.
 * <p>
 * The number of evaluations corresponds to the last call to the
 * {@link #optimize(UnivariateRealFunction, GoalType, double, double) optimize}
 * method. It is 0 if the method has not been called yet.
 * </p>
 * @return number of evaluations of the objective function
 */
",int getEvaluations();,-0.5909090909090909,-1.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.9174075136220248,-0.5,2.742857142857143,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1081_4ce4e3c9,3,"@Override
public boolean apply(Tree tree) {
    return !tree.getName().startsWith("":"");
}",,"@Override
public boolean apply(Tree tree) {
    return !tree.getName().startsWith("":"");
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8611987381703473,-0.3333333333333333,1.6285714285714286,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1227_117b0a3d,1,"@Override
public boolean hasProperty(String relPath) throws RepositoryException {
    final String oakPath = getOakPathOrThrow(relPath);
    return perform(new NodeOperation<Boolean>(dlg) {

        @Override
        public Boolean perform() throws RepositoryException {
            return node.getPropertyOrNull(oakPath) != null;
        }
    });
}",,"@Override
public boolean hasProperty(String relPath) throws RepositoryException {
    final String oakPath = getOakPathOrThrow(relPath);
    return perform(new NodeOperation<Boolean>(dlg) {

        @Override
        public Boolean perform() throws RepositoryException {
            return node.getPropertyOrNull(oakPath) != null;
        }
    });
}",-0.18181818181818182,0.4591836734693877,-0.5,-0.5,-0.4166666666666667,-0.08996539792387542,0.266991683395469,-0.25,1.6857142857142857,-0.10260363798339052
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-846_7acb091a,3,"@Override
void uncommittedModification(Revision uncommitted) {
    if (collisions.get() == null) {
        collisions.set(new ArrayList<Revision>());
    }
    collisions.get().add(uncommitted);
}",,"@Override
void uncommittedModification(Revision uncommitted) {
    if (collisions.get() == null) {
        collisions.set(new ArrayList<Revision>());
    }
    collisions.get().add(uncommitted);
}",-0.3181818181818182,-0.11224489795918377,-0.3333333333333333,-0.5,-0.25,-0.3806228373702422,0.49698881560080305,-0.16666666666666666,0.4857142857142857,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-428_4a6a573b,3,"public Object next() {
    // Find next key
    i = nextKey(nextIndex(i));
    // Just in case... (WICKET-428)
    if (!hasNext()) {
        throw new NoSuchElementException();
    }
    // Get key
    return keys[i];
}",,"public Object next() {
        i = nextKey(nextIndex(i));
        if (!hasNext()) {
        throw new NoSuchElementException();
    }
        return keys[i];
}",-0.3181818181818182,-0.2346938775510204,-0.16666666666666666,-0.5,-0.25,-0.1393969352446861,0.5357040435904789,-0.25,2.7714285714285714,-0.140683824379714
Math,6,1,"/**
 * {@inheritDoc}
 */
@Override
protected PointValuePair doOptimize() {
    checkParameters();
    // Indirect call to ""computeObjectiveValue"" in order to update the
    // evaluations counter.
    final MultivariateFunction evalFunc = new MultivariateFunction() {

        public double value(double[] point) {
            return computeObjectiveValue(point);
        }
    };
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final Comparator<PointValuePair> comparator = new Comparator<PointValuePair>() {

        public int compare(final PointValuePair o1, final PointValuePair o2) {
            final double v1 = o1.getValue();
            final double v2 = o2.getValue();
            return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);
        }
    };
    // Initialize search.
    simplex.build(getStartPoint());
    simplex.evaluate(evalFunc, comparator);
    PointValuePair[] previous = null;
    int iteration = 0;
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    while (true) {
        if (iteration > 0) {
            boolean converged = true;
            for (int i = 0; i < simplex.getSize(); i++) {
                PointValuePair prev = previous[i];
                converged = converged && checker.converged(iteration, prev, simplex.getPoint(i));
            }
            if (converged) {
                // We have found an optimum.
                return simplex.getPoint(0);
            }
        }
        // We still need to search.
        previous = simplex.getPoints();
        simplex.iterate(evalFunc, comparator);
        ++iteration;
    }
}","/**
 * {@inheritDoc}
 */
","@Override
protected PointValuePair doOptimize() {
    checkParameters();
            final MultivariateFunction evalFunc = new MultivariateFunction() {

        public double value(double[] point) {
            return computeObjectiveValue(point);
        }
    };
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final Comparator<PointValuePair> comparator = new Comparator<PointValuePair>() {

        public int compare(final PointValuePair o1, final PointValuePair o2) {
            final double v1 = o1.getValue();
            final double v2 = o2.getValue();
            return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);
        }
    };
        simplex.build(getStartPoint());
    simplex.evaluate(evalFunc, comparator);
    PointValuePair[] previous = null;
    int iteration = 0;
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    while (true) {
        if (iteration > 0) {
            boolean converged = true;
            for (int i = 0; i < simplex.getSize(); i++) {
                PointValuePair prev = previous[i];
                converged = converged && checker.converged(iteration, prev, simplex.getPoint(i));
            }
            if (converged) {
                                return simplex.getPoint(0);
            }
        }
                previous = simplex.getPoints();
        simplex.iterate(evalFunc, comparator);
        ++iteration;
    }
}",1.0454545454545454,0.7244897959183676,0.3333333333333333,0.5,0.4166666666666667,0.9322787938704895,-0.6501290507599659,0.9166666666666666,-0.028571428571428574,1.6154505077500954
commons-math,remotes/origin/bugs-dot-jar_MATH-949_f83bbc1d,1,"/**
 * {@inheritDoc}
 */
@Override
protected PointValuePair doOptimize() {
    checkParameters();
    // Indirect call to ""computeObjectiveValue"" in order to update the
    // evaluations counter.
    final MultivariateFunction evalFunc = new MultivariateFunction() {

        public double value(double[] point) {
            return computeObjectiveValue(point);
        }
    };
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final Comparator<PointValuePair> comparator = new Comparator<PointValuePair>() {

        public int compare(final PointValuePair o1, final PointValuePair o2) {
            final double v1 = o1.getValue();
            final double v2 = o2.getValue();
            return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);
        }
    };
    // Initialize search.
    simplex.build(getStartPoint());
    simplex.evaluate(evalFunc, comparator);
    PointValuePair[] previous = null;
    int iteration = 0;
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    while (true) {
        if (iteration > 0) {
            boolean converged = true;
            for (int i = 0; i < simplex.getSize(); i++) {
                PointValuePair prev = previous[i];
                converged = converged && checker.converged(iteration, prev, simplex.getPoint(i));
            }
            if (converged) {
                // We have found an optimum.
                return simplex.getPoint(0);
            }
        }
        // We still need to search.
        previous = simplex.getPoints();
        simplex.iterate(evalFunc, comparator);
        ++iteration;
    }
}","/**
 * {@inheritDoc}
 */
","@Override
protected PointValuePair doOptimize() {
    checkParameters();
            final MultivariateFunction evalFunc = new MultivariateFunction() {

        public double value(double[] point) {
            return computeObjectiveValue(point);
        }
    };
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final Comparator<PointValuePair> comparator = new Comparator<PointValuePair>() {

        public int compare(final PointValuePair o1, final PointValuePair o2) {
            final double v1 = o1.getValue();
            final double v2 = o2.getValue();
            return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);
        }
    };
        simplex.build(getStartPoint());
    simplex.evaluate(evalFunc, comparator);
    PointValuePair[] previous = null;
    int iteration = 0;
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    while (true) {
        if (iteration > 0) {
            boolean converged = true;
            for (int i = 0; i < simplex.getSize(); i++) {
                PointValuePair prev = previous[i];
                converged = converged && checker.converged(iteration, prev, simplex.getPoint(i));
            }
            if (converged) {
                                return simplex.getPoint(0);
            }
        }
                previous = simplex.getPoints();
        simplex.iterate(evalFunc, comparator);
        ++iteration;
    }
}",1.0454545454545454,0.7244897959183676,0.3333333333333333,0.5,0.4166666666666667,0.9322787938704895,-0.6501290507599659,0.9166666666666666,-0.028571428571428574,1.6154505077500954
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1122_5286861d,3,"public String commit(String path, String jsonDiff, String revisionId, String message) throws MicroKernelException {
    if (rep == null) {
        throw new IllegalStateException(""this instance has already been disposed"");
    }
    if (path.length() > 0 && !PathUtils.isAbsolute(path)) {
        throw new IllegalArgumentException(""absolute path expected: "" + path);
    }
    if (jsonDiff == null || jsonDiff.length() == 0) {
        return getHeadRevision();
    }
    Id revId = revisionId == null ? getHeadRevisionId() : Id.fromString(revisionId);
    try {
        JsopTokenizer t = new JsopTokenizer(jsonDiff);
        CommitBuilder cb = rep.getCommitBuilder(revId, message);
        while (true) {
            int r = t.read();
            if (r == JsopReader.END) {
                break;
            }
            // used for error reporting
            int pos;
            switch(r) {
                case '+':
                    {
                        pos = t.getLastPos();
                        String subPath = t.readString();
                        t.read(':');
                        t.read('{');
                        String nodePath = PathUtils.concat(path, subPath);
                        if (!PathUtils.isAbsolute(nodePath)) {
                            throw new Exception(""absolute path expected: "" + nodePath + "", pos: "" + pos);
                        }
                        String parentPath = PathUtils.getParentPath(nodePath);
                        String nodeName = PathUtils.getName(nodePath);
                        cb.addNode(parentPath, nodeName, JsonObject.create(t));
                        break;
                    }
                case '-':
                    {
                        pos = t.getLastPos();
                        String subPath = t.readString();
                        String targetPath = PathUtils.concat(path, subPath);
                        if (!PathUtils.isAbsolute(targetPath)) {
                            throw new Exception(""absolute path expected: "" + targetPath + "", pos: "" + pos);
                        }
                        cb.removeNode(targetPath);
                        break;
                    }
                case '^':
                    {
                        pos = t.getLastPos();
                        String subPath = t.readString();
                        t.read(':');
                        String value;
                        if (t.matches(JsopReader.NULL)) {
                            value = null;
                        } else {
                            value = t.readRawValue().trim();
                        }
                        String targetPath = PathUtils.concat(path, subPath);
                        if (!PathUtils.isAbsolute(targetPath)) {
                            throw new Exception(""absolute path expected: "" + targetPath + "", pos: "" + pos);
                        }
                        String parentPath = PathUtils.getParentPath(targetPath);
                        String propName = PathUtils.getName(targetPath);
                        cb.setProperty(parentPath, propName, value);
                        break;
                    }
                case '>':
                    {
                        pos = t.getLastPos();
                        String subPath = t.readString();
                        String srcPath = PathUtils.concat(path, subPath);
                        if (!PathUtils.isAbsolute(srcPath)) {
                            throw new Exception(""absolute path expected: "" + srcPath + "", pos: "" + pos);
                        }
                        t.read(':');
                        pos = t.getLastPos();
                        String targetPath = t.readString();
                        if (!PathUtils.isAbsolute(targetPath)) {
                            targetPath = PathUtils.concat(path, targetPath);
                            if (!PathUtils.isAbsolute(targetPath)) {
                                throw new Exception(""absolute path expected: "" + targetPath + "", pos: "" + pos);
                            }
                        }
                        cb.moveNode(srcPath, targetPath);
                        break;
                    }
                case '*':
                    {
                        pos = t.getLastPos();
                        String subPath = t.readString();
                        String srcPath = PathUtils.concat(path, subPath);
                        if (!PathUtils.isAbsolute(srcPath)) {
                            throw new Exception(""absolute path expected: "" + srcPath + "", pos: "" + pos);
                        }
                        t.read(':');
                        pos = t.getLastPos();
                        String targetPath = t.readString();
                        if (!PathUtils.isAbsolute(targetPath)) {
                            targetPath = PathUtils.concat(path, targetPath);
                            if (!PathUtils.isAbsolute(targetPath)) {
                                throw new Exception(""absolute path expected: "" + targetPath + "", pos: "" + pos);
                            }
                        }
                        cb.copyNode(srcPath, targetPath);
                        break;
                    }
                default:
                    throw new IllegalArgumentException(""jsonDiff: illegal token '"" + t.getToken() + ""' at pos: "" + t.getLastPos());
            }
        }
        Id newHead = cb.doCommit();
        if (!newHead.equals(revId)) {
            // non-empty commit
            if (rep.getCommit(newHead).getBranchRootId() == null) {
                // OAK-265: only trigger commit gate for non-branch commits
                gate.commit(newHead.toString());
            }
        }
        return newHead.toString();
    } catch (Exception e) {
        throw new MicroKernelException(e);
    }
}",,"public String commit(String path, String jsonDiff, String revisionId, String message) throws MicroKernelException {
    if (rep == null) {
        throw new IllegalStateException(""this instance has already been disposed"");
    }
    if (path.length() > 0 && !PathUtils.isAbsolute(path)) {
        throw new IllegalArgumentException(""absolute path expected: "" + path);
    }
    if (jsonDiff == null || jsonDiff.length() == 0) {
        return getHeadRevision();
    }
    Id revId = revisionId == null ? getHeadRevisionId() : Id.fromString(revisionId);
    try {
        JsopTokenizer t = new JsopTokenizer(jsonDiff);
        CommitBuilder cb = rep.getCommitBuilder(revId, message);
        while (true) {
            int r = t.read();
            if (r == JsopReader.END) {
                break;
            }
                        int pos;
            switch(r) {
                case '+':
                    {
                        pos = t.getLastPos();
                        String subPath = t.readString();
                        t.read(':');
                        t.read('{');
                        String nodePath = PathUtils.concat(path, subPath);
                        if (!PathUtils.isAbsolute(nodePath)) {
                            throw new Exception(""absolute path expected: "" + nodePath + "", pos: "" + pos);
                        }
                        String parentPath = PathUtils.getParentPath(nodePath);
                        String nodeName = PathUtils.getName(nodePath);
                        cb.addNode(parentPath, nodeName, JsonObject.create(t));
                        break;
                    }
                case '-':
                    {
                        pos = t.getLastPos();
                        String subPath = t.readString();
                        String targetPath = PathUtils.concat(path, subPath);
                        if (!PathUtils.isAbsolute(targetPath)) {
                            throw new Exception(""absolute path expected: "" + targetPath + "", pos: "" + pos);
                        }
                        cb.removeNode(targetPath);
                        break;
                    }
                case '^':
                    {
                        pos = t.getLastPos();
                        String subPath = t.readString();
                        t.read(':');
                        String value;
                        if (t.matches(JsopReader.NULL)) {
                            value = null;
                        } else {
                            value = t.readRawValue().trim();
                        }
                        String targetPath = PathUtils.concat(path, subPath);
                        if (!PathUtils.isAbsolute(targetPath)) {
                            throw new Exception(""absolute path expected: "" + targetPath + "", pos: "" + pos);
                        }
                        String parentPath = PathUtils.getParentPath(targetPath);
                        String propName = PathUtils.getName(targetPath);
                        cb.setProperty(parentPath, propName, value);
                        break;
                    }
                case '>':
                    {
                        pos = t.getLastPos();
                        String subPath = t.readString();
                        String srcPath = PathUtils.concat(path, subPath);
                        if (!PathUtils.isAbsolute(srcPath)) {
                            throw new Exception(""absolute path expected: "" + srcPath + "", pos: "" + pos);
                        }
                        t.read(':');
                        pos = t.getLastPos();
                        String targetPath = t.readString();
                        if (!PathUtils.isAbsolute(targetPath)) {
                            targetPath = PathUtils.concat(path, targetPath);
                            if (!PathUtils.isAbsolute(targetPath)) {
                                throw new Exception(""absolute path expected: "" + targetPath + "", pos: "" + pos);
                            }
                        }
                        cb.moveNode(srcPath, targetPath);
                        break;
                    }
                case '*':
                    {
                        pos = t.getLastPos();
                        String subPath = t.readString();
                        String srcPath = PathUtils.concat(path, subPath);
                        if (!PathUtils.isAbsolute(srcPath)) {
                            throw new Exception(""absolute path expected: "" + srcPath + "", pos: "" + pos);
                        }
                        t.read(':');
                        pos = t.getLastPos();
                        String targetPath = t.readString();
                        if (!PathUtils.isAbsolute(targetPath)) {
                            targetPath = PathUtils.concat(path, targetPath);
                            if (!PathUtils.isAbsolute(targetPath)) {
                                throw new Exception(""absolute path expected: "" + targetPath + "", pos: "" + pos);
                            }
                        }
                        cb.copyNode(srcPath, targetPath);
                        break;
                    }
                default:
                    throw new IllegalArgumentException(""jsonDiff: illegal token '"" + t.getToken() + ""' at pos: "" + t.getLastPos());
            }
        }
        Id newHead = cb.doCommit();
        if (!newHead.equals(revId)) {
                        if (rep.getCommit(newHead).getBranchRootId() == null) {
                                gate.commit(newHead.toString());
            }
        }
        return newHead.toString();
    } catch (Exception e) {
        throw new MicroKernelException(e);
    }
}",4.909090909090909,2.5051020408163267,6.5,2.0,3.1666666666666665,2.0,-1.6486951534270151,4.916666666666667,-0.028571428571428574,12.195467725425196
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2487_f2920c26,0,"/**
 * @return the current size of the buffer.
 */
public int getSize() {
    if (this.value == null) {
        throw new IllegalStateException(""Uninitialized. Null constructor "" + ""called w/o accompanying readFields invocation"");
    }
    return this.value.length;
}","/**
 * @return the current size of the buffer.
 */
","public int getSize() {
    if (this.value == null) {
        throw new IllegalStateException(""Uninitialized. Null constructor "" + ""called w/o accompanying readFields invocation"");
    }
    return this.value.length;
}",-0.36363636363636365,-0.13775510204081634,-0.16666666666666666,-0.5,-0.25,-0.15916955017301035,0.6383710926297677,-0.5,2.7142857142857144,-0.14662006758579926
wicket,remotes/origin/bugs-dot-jar_WICKET-4519_e62ded51,3,"/**
 * {@inheritDoc}
 */
public boolean visitObject(final Object object) {
    return clazz.isAssignableFrom(object.getClass());
}","/**
 * {@inheritDoc}
 */
","public boolean visitObject(final Object object) {
    return clazz.isAssignableFrom(object.getClass());
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.046171494121021,-0.3333333333333333,2.8285714285714287,-0.16422749602751402
Math,80,1,"/**
 * Flip qd array if warranted.
 * @param n number of rows in the block
 * @param step within the array (1 for flipping all elements, 2 for flipping
 * only every other element)
 * @return true if qd array was flipped
 */
private boolean flipIfWarranted(final int n, final int step) {
    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
        // flip array
        int j = 4 * n - 1;
        for (int i = 0; i < j; i += 4) {
            for (int k = 0; k < 4; k += step) {
                final double tmp = work[i + k];
                work[i + k] = work[j - k];
                work[j - k] = tmp;
            }
            j -= 4;
        }
        return true;
    }
    return false;
}","/**
 * Flip qd array if warranted.
 * @param n number of rows in the block
 * @param step within the array (1 for flipping all elements, 2 for flipping
 * only every other element)
 * @return true if qd array was flipped
 */
","private boolean flipIfWarranted(final int n, final int step) {
    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
                int j = 4 * n - 1;
        for (int i = 0; i < j; i += 4) {
            for (int k = 0; k < 4; k += step) {
                final double tmp = work[i + k];
                work[i + k] = work[j - k];
                work[j - k] = tmp;
            }
            j -= 4;
        }
        return true;
    }
    return false;
}",0.045454545454545456,1.1326530612244898,0.0,0.5,0.08333333333333333,1.32377656945131,-0.11155721250358479,-0.5,1.0571428571428572,0.9720833815171257
wicket,remotes/origin/bugs-dot-jar_WICKET-4292_9cb617ae,1,"/**
 *  Add a cookie to the response.
 *
 *  @param cookie
 *             The cookie to add
 */
@Override
public void addCookie(final Cookie cookie) {
    // remove any potential duplicates
    cookies.remove(cookie);
    cookies.add(cookie);
}","/**
 *  Add a cookie to the response.
 *
 *  @param cookie
 *             The cookie to add
 */
","@Override
public void addCookie(final Cookie cookie) {
        cookies.remove(cookie);
    cookies.add(cookie);
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7516489819328936,-0.3333333333333333,2.742857142857143,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4,1,"/**
 *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL OR
 *  OVERRIDE.
 *
 *  Called when a request begins.
 */
@Override
public void internalAttach() {
    // Handle begin request for the container itself
    try {
        super.internalAttach();
        // Loop through child components
        final int size = children_size();
        for (int i = 0; i < size; i++) {
            // Get next child
            final Component child = children_get(i);
            // Ignore feedback as that was done in Page
            if (!(child instanceof IFeedback)) {
                // Call begin request on the child
                child.internalAttach();
            }
        }
    } catch (RuntimeException ex) {
        if (ex instanceof WicketRuntimeException) {
            throw ex;
        } else {
            throw new WicketRuntimeException(""Error attaching this container for rendering: "" + this, ex);
        }
    }
}","/**
 *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL OR
 *  OVERRIDE.
 *
 *  Called when a request begins.
 */
","@Override
public void internalAttach() {
        try {
        super.internalAttach();
                final int size = children_size();
        for (int i = 0; i < size; i++) {
                        final Component child = children_get(i);
                        if (!(child instanceof IFeedback)) {
                                child.internalAttach();
            }
        }
    } catch (RuntimeException ex) {
        if (ex instanceof WicketRuntimeException) {
            throw ex;
        } else {
            throw new WicketRuntimeException(""Error attaching this container for rendering: "" + this, ex);
        }
    }
}",0.22727272727272727,0.7448979591836737,0.5,0.5,0.16666666666666666,0.33119130004943165,-0.13105821623171807,-0.16666666666666666,1.0571428571428572,0.062343402675164146
commons-math,remotes/origin/bugs-dot-jar_MATH-343_f6dd42b4,0,"/**
 * Find a zero in the given interval.
 * <p>
 * Requires that the values of the function at the endpoints have opposite
 * signs. An <code>IllegalArgumentException</code> is thrown if this is not
 * the case.</p>
 *
 * @param f the function to solve
 * @param min the lower bound for the interval.
 * @param max the upper bound for the interval.
 * @return the value where the function is zero
 * @throws MaxIterationsExceededException if the maximum iteration count is exceeded
 * @throws FunctionEvaluationException if an error occurs evaluating the
 * function
 * @throws IllegalArgumentException if min is not less than max or the
 * signs of the values of the function at the endpoints are not opposites
 */
public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {
    clearResult();
    verifyInterval(min, max);
    double ret = Double.NaN;
    double yMin = f.value(min);
    double yMax = f.value(max);
    // Verify bracketing
    double sign = yMin * yMax;
    if (sign > 0) {
        // check if either value is close to a zero
        if (Math.abs(yMin) <= functionValueAccuracy) {
            setResult(min, 0);
            ret = min;
        } else if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(max, 0);
            ret = max;
        } else {
            // neither value is close to zero and min and max do not bracket root.
            throw MathRuntimeException.createIllegalArgumentException(""function values at endpoints do not have different signs.  "" + ""Endpoints: [{0}, {1}], Values: [{2}, {3}]"", min, max, yMin, yMax);
        }
    } else if (sign < 0) {
        // solve using only the first endpoint as initial guess
        ret = solve(f, min, yMin, max, yMax, min, yMin);
    } else {
        // either min or max is a root
        if (yMin == 0.0) {
            ret = min;
        } else {
            ret = max;
        }
    }
    return ret;
}","/**
 * Find a zero in the given interval.
 * <p>
 * Requires that the values of the function at the endpoints have opposite
 * signs. An <code>IllegalArgumentException</code> is thrown if this is not
 * the case.</p>
 *
 * @param f the function to solve
 * @param min the lower bound for the interval.
 * @param max the upper bound for the interval.
 * @return the value where the function is zero
 * @throws MaxIterationsExceededException if the maximum iteration count is exceeded
 * @throws FunctionEvaluationException if an error occurs evaluating the
 * function
 * @throws IllegalArgumentException if min is not less than max or the
 * signs of the values of the function at the endpoints are not opposites
 */
","public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {
    clearResult();
    verifyInterval(min, max);
    double ret = Double.NaN;
    double yMin = f.value(min);
    double yMax = f.value(max);
        double sign = yMin * yMax;
    if (sign > 0) {
                if (Math.abs(yMin) <= functionValueAccuracy) {
            setResult(min, 0);
            ret = min;
        } else if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(max, 0);
            ret = max;
        } else {
                        throw MathRuntimeException.createIllegalArgumentException(""function values at endpoints do not have different signs.  "" + ""Endpoints: [{0}, {1}], Values: [{2}, {3}]"", min, max, yMin, yMax);
        }
    } else if (sign < 0) {
                ret = solve(f, min, yMin, max, yMax, min, yMin);
    } else {
                if (yMin == 0.0) {
            ret = min;
        } else {
            ret = max;
        }
    }
    return ret;
}",0.6363636363636364,0.3367346938775511,0.5,0.5,0.5,1.2011863568956997,-0.47720103240607986,0.3333333333333333,-0.028571428571428574,1.369760280279766
wicket,remotes/origin/bugs-dot-jar_WICKET-5724_b92591f6,1,"@Override
protected MarkupElement onComponentTag(final ComponentTag tag) throws ParseException {
    // We only need ComponentTags
    if (tag instanceof WicketTag) {
        return tag;
    }
    // Has wicket:enclosure attribute?
    String enclosureAttr = getAttribute(tag, null);
    if (enclosureAttr != null) {
        if (tag.isOpen()) {
            // Make sure 'wicket:id' and 'id' are consistent
            String htmlId = tag.getAttribute(""id"");
            if ((tag.getId() != null) && !Strings.isEmpty(htmlId) && !htmlId.equals(tag.getId())) {
                throw new ParseException(""Make sure that 'id' and 'wicket:id' are the same if both are provided. Tag:"" + tag.toString(), tag.getPos());
            }
            // if it doesn't have a wicket-id already, then assign one now.
            if (Strings.isEmpty(tag.getId())) {
                if (Strings.isEmpty(htmlId)) {
                    String id = getWicketNamespace() + ""_"" + INLINE_ENCLOSURE_ID_PREFIX + (counter++);
                    tag.setId(id);
                } else {
                    tag.setId(htmlId);
                }
                tag.setAutoComponentTag(true);
                tag.setAutoComponentFactory(new ComponentTag.IAutoComponentFactory() {

                    @Override
                    public Component newComponent(ComponentTag tag) {
                        String attributeName = getInlineEnclosureAttributeName(null);
                        String childId = tag.getAttribute(attributeName);
                        return new InlineEnclosure(tag.getId(), childId);
                    }
                });
                tag.setModified(true);
            }
            // Put the enclosure on the stack. The most current one will be on top
            if (enclosures == null) {
                enclosures = new ArrayDeque<>();
            }
            enclosures.push(tag);
        } else {
            throw new ParseException(""Open-close tags don't make sense for InlineEnclosure. Tag:"" + tag.toString(), tag.getPos());
        }
    } else // Are we within an enclosure?
    if ((enclosures != null) && (enclosures.size() > 0)) {
        // first ComponentTag's id found as the controlling child to the enclosure.
        if (tag.isOpen() && (tag.getId() != null) && !(tag instanceof WicketTag) && !tag.isAutoComponentTag()) {
            Iterator<ComponentTag> componentTagIterator = enclosures.descendingIterator();
            while (componentTagIterator.hasNext()) {
                ComponentTag lastEnclosure = componentTagIterator.next();
                String attr = getAttribute(lastEnclosure, null);
                if (Strings.isEmpty(attr) == true) {
                    lastEnclosure.getAttributes().put(getInlineEnclosureAttributeName(null), tag.getId());
                    lastEnclosure.setModified(true);
                }
            }
        } else if (tag.isClose() && tag.closes(enclosures.peek())) {
            ComponentTag lastEnclosure = enclosures.pop();
            String attr = getAttribute(lastEnclosure, null);
            if (Strings.isEmpty(attr) == true) {
                throw new ParseException(""Did not find any child for InlineEnclosure. Tag:"" + lastEnclosure.toString(), tag.getPos());
            }
        }
    }
    return tag;
}",,"@Override
protected MarkupElement onComponentTag(final ComponentTag tag) throws ParseException {
        if (tag instanceof WicketTag) {
        return tag;
    }
        String enclosureAttr = getAttribute(tag, null);
    if (enclosureAttr != null) {
        if (tag.isOpen()) {
                        String htmlId = tag.getAttribute(""id"");
            if ((tag.getId() != null) && !Strings.isEmpty(htmlId) && !htmlId.equals(tag.getId())) {
                throw new ParseException(""Make sure that 'id' and 'wicket:id' are the same if both are provided. Tag:"" + tag.toString(), tag.getPos());
            }
                        if (Strings.isEmpty(tag.getId())) {
                if (Strings.isEmpty(htmlId)) {
                    String id = getWicketNamespace() + ""_"" + INLINE_ENCLOSURE_ID_PREFIX + (counter++);
                    tag.setId(id);
                } else {
                    tag.setId(htmlId);
                }
                tag.setAutoComponentTag(true);
                tag.setAutoComponentFactory(new ComponentTag.IAutoComponentFactory() {

                    @Override
                    public Component newComponent(ComponentTag tag) {
                        String attributeName = getInlineEnclosureAttributeName(null);
                        String childId = tag.getAttribute(attributeName);
                        return new InlineEnclosure(tag.getId(), childId);
                    }
                });
                tag.setModified(true);
            }
                        if (enclosures == null) {
                enclosures = new ArrayDeque<>();
            }
            enclosures.push(tag);
        } else {
            throw new ParseException(""Open-close tags don't make sense for InlineEnclosure. Tag:"" + tag.toString(), tag.getPos());
        }
    } else     if ((enclosures != null) && (enclosures.size() > 0)) {
                if (tag.isOpen() && (tag.getId() != null) && !(tag instanceof WicketTag) && !tag.isAutoComponentTag()) {
            Iterator<ComponentTag> componentTagIterator = enclosures.descendingIterator();
            while (componentTagIterator.hasNext()) {
                ComponentTag lastEnclosure = componentTagIterator.next();
                String attr = getAttribute(lastEnclosure, null);
                if (Strings.isEmpty(attr) == true) {
                    lastEnclosure.getAttributes().put(getInlineEnclosureAttributeName(null), tag.getId());
                    lastEnclosure.setModified(true);
                }
            }
        } else if (tag.isClose() && tag.closes(enclosures.peek())) {
            ComponentTag lastEnclosure = enclosures.pop();
            String attr = getAttribute(lastEnclosure, null);
            if (Strings.isEmpty(attr) == true) {
                throw new ParseException(""Did not find any child for InlineEnclosure. Tag:"" + lastEnclosure.toString(), tag.getPos());
            }
        }
    }
    return tag;
}",2.0454545454545454,1.5816326530612246,2.1666666666666665,1.5,2.6666666666666665,1.8991596638655466,-1.0395755663894468,3.3333333333333335,-0.028571428571428574,5.884521652725489
camel,remotes/origin/bugs-dot-jar_CAMEL-3448_b345dd82,0,"@Override
public String toString() {
    return ""ExceptionPolicyKey["" + exceptionClass + (when != null ? "" "" + when : """") + ""]"";
}",,"@Override
public String toString() {
    return ""ExceptionPolicyKey["" + exceptionClass + (when != null ? "" "" + when : """") + ""]"";
}",-0.45454545454545453,-0.6581632653061225,-0.3333333333333333,-1.0,-0.25,-0.16510133465150764,0.7711499856610269,-0.5,2.7714285714285714,-0.13829390828375757
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5,3,"@Override
public void write(org.apache.thrift.protocol.TProtocol prot, update_result struct) throws org.apache.thrift.TException {
    TTupleProtocol oprot = (TTupleProtocol) prot;
    BitSet optionals = new BitSet();
    if (struct.isSetOuch1()) {
        optionals.set(0);
    }
    if (struct.isSetOuch2()) {
        optionals.set(1);
    }
    oprot.writeBitSet(optionals, 2);
    if (struct.isSetOuch1()) {
        struct.ouch1.write(oprot);
    }
    if (struct.isSetOuch2()) {
        struct.ouch2.write(oprot);
    }
}",,"@Override
public void write(org.apache.thrift.protocol.TProtocol prot, update_result struct) throws org.apache.thrift.TException {
    TTupleProtocol oprot = (TTupleProtocol) prot;
    BitSet optionals = new BitSet();
    if (struct.isSetOuch1()) {
        optionals.set(0);
    }
    if (struct.isSetOuch2()) {
        optionals.set(1);
    }
    oprot.writeBitSet(optionals, 2);
    if (struct.isSetOuch1()) {
        struct.ouch1.write(oprot);
    }
    if (struct.isSetOuch2()) {
        struct.ouch2.write(oprot);
    }
}",0.18181818181818182,-0.2755102040816327,0.16666666666666666,-0.5,0.08333333333333333,-0.3806228373702422,-0.16260395755663903,0.25,-0.028571428571428574,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-5853_b80f6640,3,"/**
 *  @see org.apache.wicket.util.convert.IConverter#convertToObject(String, java.util.Locale)
 */
@Override
public Double convertToObject(final String value, final Locale locale) {
    final Number number = parse(value, -Double.MAX_VALUE, Double.MAX_VALUE, locale);
    if (number == null) {
        return null;
    }
    return number.doubleValue();
}","/**
 *  @see org.apache.wicket.util.convert.IConverter#convertToObject(String, java.util.Locale)
 */
","@Override
public Double convertToObject(final String value, final Locale locale) {
    final Number number = parse(value, -Double.MAX_VALUE, Double.MAX_VALUE, locale);
    if (number == null) {
        return null;
    }
    return number.doubleValue();
}",-0.2727272727272727,-0.1887755102040817,-0.3333333333333333,-0.5,-0.25,-0.07019278299555112,0.35790077430456,-0.3333333333333333,0.2571428571428572,-0.09545102171054604
wicket,remotes/origin/bugs-dot-jar_WICKET-4256_09166ea8,1,"/**
 */
private final void internalBeforeRender() {
    configure();
    if ((determineVisibility()) && !getFlag(FLAG_RENDERING) && !getFlag(FLAG_PREPARED_FOR_RENDER)) {
        setRequestFlag(RFLAG_BEFORE_RENDER_SUPER_CALL_VERIFIED, false);
        getApplication().getComponentPreOnBeforeRenderListeners().onBeforeRender(this);
        onBeforeRender();
        getApplication().getComponentPostOnBeforeRenderListeners().onBeforeRender(this);
        if (!getRequestFlag(RFLAG_BEFORE_RENDER_SUPER_CALL_VERIFIED)) {
            throw new IllegalStateException(Component.class.getName() + "" has not been properly rendered. Something in the hierarchy of "" + getClass().getName() + "" has not called super.onBeforeRender() in the override of onBeforeRender() method"");
        }
    }
}","/**
 */
","private final void internalBeforeRender() {
    configure();
    if ((determineVisibility()) && !getFlag(FLAG_RENDERING) && !getFlag(FLAG_PREPARED_FOR_RENDER)) {
        setRequestFlag(RFLAG_BEFORE_RENDER_SUPER_CALL_VERIFIED, false);
        getApplication().getComponentPreOnBeforeRenderListeners().onBeforeRender(this);
        onBeforeRender();
        getApplication().getComponentPostOnBeforeRenderListeners().onBeforeRender(this);
        if (!getRequestFlag(RFLAG_BEFORE_RENDER_SUPER_CALL_VERIFIED)) {
            throw new IllegalStateException(Component.class.getName() + "" has not been properly rendered. Something in the hierarchy of "" + getClass().getName() + "" has not called super.onBeforeRender() in the override of onBeforeRender() method"");
        }
    }
}",-0.09090909090909091,0.22448979591836732,0.0,0.0,0.25,-0.1255561047948591,0.10238026957269843,0.8333333333333334,-0.028571428571428574,-0.08343291317066485
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-843_65390f8c,3,"@Override
public void offline(String tableName) throws AccumuloSecurityException, AccumuloException {
    throw new NotImplementedException();
}",,"@Override
public void offline(String tableName) throws AccumuloSecurityException, AccumuloException {
    throw new NotImplementedException();
}",-0.45454545454545453,-0.6581632653061225,-0.3333333333333333,-1.0,-0.4166666666666667,-0.3806228373702422,0.8961858330943507,-0.5,1.5999999999999999,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-9217_e7ac45b6,3,"/**
 * Strategy for validation of the uri when creating the endpoint.
 *
 * @param uri        the uri
 * @param path       the path - part after the scheme
 * @param parameters the parameters, an empty map if no parameters given
 * @throws ResolveEndpointFailedException should be thrown if the URI validation failed
 */
protected void validateURI(String uri, String path, Map<String, Object> parameters) {
    // check for uri containing & but no ? marker
    if (uri.contains(""&"") && !uri.contains(""?"")) {
        throw new ResolveEndpointFailedException(uri, ""Invalid uri syntax: no ? marker however the uri "" + ""has & parameter separators. Check the uri if its missing a ? marker."");
    }
    // check for uri containing double && markers without include by RAW
    if (uri.contains(""&&"")) {
        Pattern pattern = Pattern.compile(""RAW(.*&&.*)"");
        Matcher m = pattern.matcher(uri);
        // we should skip the RAW part
        if (!m.find()) {
            throw new ResolveEndpointFailedException(uri, ""Invalid uri syntax: Double && marker found. "" + ""Check the uri and remove the duplicate & marker."");
        }
    }
    // if we have a trailing & then that is invalid as well
    if (uri.endsWith(""&"")) {
        throw new ResolveEndpointFailedException(uri, ""Invalid uri syntax: Trailing & marker found. "" + ""Check the uri and remove the trailing & marker."");
    }
}","/**
 * Strategy for validation of the uri when creating the endpoint.
 *
 * @param uri        the uri
 * @param path       the path - part after the scheme
 * @param parameters the parameters, an empty map if no parameters given
 * @throws ResolveEndpointFailedException should be thrown if the URI validation failed
 */
","protected void validateURI(String uri, String path, Map<String, Object> parameters) {
        if (uri.contains(""&"") && !uri.contains(""?"")) {
        throw new ResolveEndpointFailedException(uri, ""Invalid uri syntax: no ? marker however the uri "" + ""has & parameter separators. Check the uri if its missing a ? marker."");
    }
        if (uri.contains(""&&"")) {
        Pattern pattern = Pattern.compile(""RAW(.*&&.*)"");
        Matcher m = pattern.matcher(uri);
                if (!m.find()) {
            throw new ResolveEndpointFailedException(uri, ""Invalid uri syntax: Double && marker found. "" + ""Check the uri and remove the duplicate & marker."");
        }
    }
        if (uri.endsWith(""&"")) {
        throw new ResolveEndpointFailedException(uri, ""Invalid uri syntax: Trailing & marker found. "" + ""Check the uri and remove the trailing & marker."");
    }
}",0.045454545454545456,0.09183673469387764,0.6666666666666666,0.0,0.5,0.2698961937716264,-0.11843991970174926,0.08333333333333333,-0.028571428571428574,0.21573489919950659
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1429_c2f5ca6c,1,"private void diffManyChildren(JsopWriter w, String path, Revision fromRev, Revision toRev) {
    long minTimestamp = Math.min(fromRev.getTimestamp(), toRev.getTimestamp());
    long minValue = Commit.getModified(minTimestamp);
    String fromKey = Utils.getKeyLowerLimit(path);
    String toKey = Utils.getKeyUpperLimit(path);
    Set<String> paths = Sets.newHashSet();
    for (NodeDocument doc : store.query(Collection.NODES, fromKey, toKey, NodeDocument.MODIFIED, minValue, Integer.MAX_VALUE)) {
        paths.add(Utils.getPathFromId(doc.getId()));
    }
    // also consider nodes with not yet stored modifications (OAK-1107)
    Revision minRev = new Revision(minTimestamp, 0, getClusterId());
    addPathsForDiff(path, paths, getPendingModifications(), minRev);
    for (Revision r : new Revision[] { fromRev, toRev }) {
        if (r.isBranch()) {
            Branch b = getBranches().getBranch(fromRev);
            if (b != null) {
                addPathsForDiff(path, paths, b.getModifications(r), r);
            }
        }
    }
    for (String p : paths) {
        DocumentNodeState fromNode = getNode(p, fromRev);
        DocumentNodeState toNode = getNode(p, toRev);
        if (fromNode != null) {
            // exists in fromRev
            if (toNode != null) {
                // check if different
                if (!fromNode.getLastRevision().equals(toNode.getLastRevision())) {
                    w.tag('^').key(p).object().endObject().newline();
                }
            } else {
                // does not exist in toRev -> was removed
                w.tag('-').value(p).newline();
            }
        } else {
            // does not exist in fromRev
            if (toNode != null) {
                // exists in toRev
                w.tag('+').key(p).object().endObject().newline();
            } else {
            // does not exist in either revisions
            // -> do nothing
            }
        }
    }
}",,"private void diffManyChildren(JsopWriter w, String path, Revision fromRev, Revision toRev) {
    long minTimestamp = Math.min(fromRev.getTimestamp(), toRev.getTimestamp());
    long minValue = Commit.getModified(minTimestamp);
    String fromKey = Utils.getKeyLowerLimit(path);
    String toKey = Utils.getKeyUpperLimit(path);
    Set<String> paths = Sets.newHashSet();
    for (NodeDocument doc : store.query(Collection.NODES, fromKey, toKey, NodeDocument.MODIFIED, minValue, Integer.MAX_VALUE)) {
        paths.add(Utils.getPathFromId(doc.getId()));
    }
        Revision minRev = new Revision(minTimestamp, 0, getClusterId());
    addPathsForDiff(path, paths, getPendingModifications(), minRev);
    for (Revision r : new Revision[] { fromRev, toRev }) {
        if (r.isBranch()) {
            Branch b = getBranches().getBranch(fromRev);
            if (b != null) {
                addPathsForDiff(path, paths, b.getModifications(r), r);
            }
        }
    }
    for (String p : paths) {
        DocumentNodeState fromNode = getNode(p, fromRev);
        DocumentNodeState toNode = getNode(p, toRev);
        if (fromNode != null) {
                        if (toNode != null) {
                                if (!fromNode.getLastRevision().equals(toNode.getLastRevision())) {
                    w.tag('^').key(p).object().endObject().newline();
                }
            } else {
                                w.tag('-').value(p).newline();
            }
        } else {
                        if (toNode != null) {
                                w.tag('+').key(p).object().endObject().newline();
            } else {
                                    }
        }
    }
}",1.0909090909090908,0.9897959183673469,1.0,1.0,0.5833333333333334,0.0187839841819081,-0.742758818468598,2.5833333333333335,-0.028571428571428574,0.6107863166595997
commons-math,remotes/origin/bugs-dot-jar_MATH-757_76b7413d,1,"/**
 * Discards the <code>i</code> initial elements of the array.  For example,
 * if the array contains the elements 1,2,3,4, invoking
 * <code>discardFrontElements(2)</code> will cause the first two elements
 * to be discarded, leaving 3,4 in the array.  Throws illegalArgumentException
 * if i exceeds numElements.
 *
 * @param i  the number of elements to discard from the front of the array
 * @throws MathIllegalArgumentException if i is greater than numElements.
 * @since 2.0
 */
public synchronized void discardFrontElements(int i) throws MathIllegalArgumentException {
    discardExtremeElements(i, true);
}","/**
 * Discards the <code>i</code> initial elements of the array.  For example,
 * if the array contains the elements 1,2,3,4, invoking
 * <code>discardFrontElements(2)</code> will cause the first two elements
 * to be discarded, leaving 3,4 in the array.  Throws illegalArgumentException
 * if i exceeds numElements.
 *
 * @param i  the number of elements to discard from the front of the array
 * @throws MathIllegalArgumentException if i is greater than numElements.
 * @since 2.0
 */
","public synchronized void discardFrontElements(int i) throws MathIllegalArgumentException {
    discardExtremeElements(i, true);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.0785775738457126,-0.4166666666666667,0.05714285714285714,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-209_76d727f0,1,"@Override
public void init(SortedKeyValueIterator<Key, Value> source, Map<String, String> options, IteratorEnvironment env) throws IOException {
    super.init(source, options, env);
    if (options.containsKey(ROW_REGEX)) {
        rowMatcher = Pattern.compile(options.get(ROW_REGEX)).matcher("""");
    } else {
        rowMatcher = null;
    }
    if (options.containsKey(COLF_REGEX)) {
        colfMatcher = Pattern.compile(options.get(COLF_REGEX)).matcher("""");
    } else {
        colfMatcher = null;
    }
    if (options.containsKey(COLQ_REGEX)) {
        colqMatcher = Pattern.compile(options.get(COLQ_REGEX)).matcher("""");
    } else {
        colqMatcher = null;
    }
    if (options.containsKey(VALUE_REGEX)) {
        valueMatcher = Pattern.compile(options.get(VALUE_REGEX)).matcher("""");
    } else {
        valueMatcher = null;
    }
    if (options.containsKey(OR_FIELDS)) {
        orFields = Boolean.parseBoolean(options.get(OR_FIELDS));
    } else {
        orFields = false;
    }
}",,"@Override
public void init(SortedKeyValueIterator<Key, Value> source, Map<String, String> options, IteratorEnvironment env) throws IOException {
    super.init(source, options, env);
    if (options.containsKey(ROW_REGEX)) {
        rowMatcher = Pattern.compile(options.get(ROW_REGEX)).matcher("""");
    } else {
        rowMatcher = null;
    }
    if (options.containsKey(COLF_REGEX)) {
        colfMatcher = Pattern.compile(options.get(COLF_REGEX)).matcher("""");
    } else {
        colfMatcher = null;
    }
    if (options.containsKey(COLQ_REGEX)) {
        colqMatcher = Pattern.compile(options.get(COLQ_REGEX)).matcher("""");
    } else {
        colqMatcher = null;
    }
    if (options.containsKey(VALUE_REGEX)) {
        valueMatcher = Pattern.compile(options.get(VALUE_REGEX)).matcher("""");
    } else {
        valueMatcher = null;
    }
    if (options.containsKey(OR_FIELDS)) {
        orFields = Boolean.parseBoolean(options.get(OR_FIELDS));
    } else {
        orFields = false;
    }
}",0.6818181818181818,-0.2653061224489796,0.3333333333333333,-0.5,0.4166666666666667,-0.3806228373702422,-0.49211356466876977,1.1666666666666667,-0.028571428571428574,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3324_5f863af6,1,"@Override
public boolean apply(@Nullable PermissionEntry entry) {
    if (entry == null) {
        return false;
    }
    if (tree != null) {
        return entry.matches(tree, property) || applyToParent(entry);
    } else if (path != null) {
        return entry.matches(path) || applyToParent(entry);
    } else {
        return entry.matches();
    }
}",,"@Override
public boolean apply(@Nullable PermissionEntry entry) {
    if (entry == null) {
        return false;
    }
    if (tree != null) {
        return entry.matches(tree, property) || applyToParent(entry);
    } else if (path != null) {
        return entry.matches(path) || applyToParent(entry);
    } else {
        return entry.matches();
    }
}",-0.045454545454545456,-0.051020408163265356,0.0,0.0,0.08333333333333333,0.01482946119624324,0.09033553197591031,-0.08333333333333333,0.14285714285714285,-0.05800900287389552
Lang,32,1,"/**
 * <p>
 * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid
 * infinite loops.
 * </p>
 *
 * @param value
 *            The object to lookup in the registry.
 * @return boolean <code>true</code> if the registry contains the given object.
 * @since 2.3
 */
static boolean isRegistered(Object value) {
    return getRegistry().contains(new IDKey(value));
}","/**
 * <p>
 * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid
 * infinite loops.
 * </p>
 *
 * @param value
 *            The object to lookup in the registry.
 * @return boolean <code>true</code> if the registry contains the given object.
 * @since 2.3
 */
","static boolean isRegistered(Object value) {
    return getRegistry().contains(new IDKey(value));
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.046171494121021,-0.3333333333333333,2.542857142857143,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-2079_ceac38b1,3,"/**
 *  Throw an exception if not all components rendered.
 *
 *  @param renderedContainer
 *             The page itself if it was a full page render or the container that was rendered
 *             standalone
 */
private final void checkRendering(final MarkupContainer renderedContainer) {
    // If the application wants component uses checked and
    // the response is not a redirect
    final IDebugSettings debugSettings = Application.get().getDebugSettings();
    if (debugSettings.getComponentUseCheck() && !getResponse().isRedirect()) {
        final List<Component> unrenderedComponents = new ArrayList<Component>();
        final StringBuffer buffer = new StringBuffer();
        renderedContainer.visitChildren(new IVisitor<Component>() {

            public Object component(final Component component) {
                // If component never rendered
                if (renderedComponents == null || !renderedComponents.contains(component)) {
                    // If auto component ...
                    if (!component.isAuto() && component.isVisibleInHierarchy()) {
                        // Increase number of unrendered components
                        unrenderedComponents.add(component);
                        // Add to explanatory string to buffer
                        buffer.append(Integer.toString(unrenderedComponents.size()) + "". "" + component + ""\n"");
                        String metadata = component.getMetaData(Component.CONSTRUCTED_AT_KEY);
                        if (metadata != null) {
                            buffer.append(metadata);
                        }
                        metadata = component.getMetaData(Component.ADDED_AT_KEY);
                        if (metadata != null) {
                            buffer.append(metadata);
                        }
                    } else {
                        // not visible
                        return CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;
                    }
                }
                return CONTINUE_TRAVERSAL;
            }
        });
        // Throw exception if any errors were found
        if (unrenderedComponents.size() > 0) {
            // Get rid of set
            renderedComponents = null;
            Iterator<Component> iterator = unrenderedComponents.iterator();
            while (iterator.hasNext()) {
                Component component = iterator.next();
                // Now first test if the component has a sibling that is a transparent resolver.
                Iterator<? extends Component> iterator2 = component.getParent().iterator();
                while (iterator2.hasNext()) {
                    Component sibling = iterator2.next();
                    if (!sibling.isVisible()) {
                        boolean isTransparentMarkupContainer = sibling instanceof MarkupContainer && ((MarkupContainer) sibling).isTransparentResolver();
                        boolean isComponentResolver = sibling instanceof IComponentResolver;
                        if (isTransparentMarkupContainer || isComponentResolver) {
                            // we found a transparent container that isn't visible
                            // then ignore this component and only do a debug statement here.
                            log.debug(""Component {} wasn't rendered but most likely it has a transparent parent: {}"", component, sibling);
                            iterator.remove();
                            break;
                        }
                    }
                }
            }
            // if still > 0
            if (unrenderedComponents.size() > 0) {
                // Throw exception
                throw new WicketRuntimeException(""The component(s) below failed to render. A common problem is that you have added a component in code but forgot to reference it in the markup (thus the component will never be rendered).\n\n"" + buffer.toString());
            }
        }
    }
    // Get rid of set
    renderedComponents = null;
}","/**
 *  Throw an exception if not all components rendered.
 *
 *  @param renderedContainer
 *             The page itself if it was a full page render or the container that was rendered
 *             standalone
 */
","private final void checkRendering(final MarkupContainer renderedContainer) {
            final IDebugSettings debugSettings = Application.get().getDebugSettings();
    if (debugSettings.getComponentUseCheck() && !getResponse().isRedirect()) {
        final List<Component> unrenderedComponents = new ArrayList<Component>();
        final StringBuffer buffer = new StringBuffer();
        renderedContainer.visitChildren(new IVisitor<Component>() {

            public Object component(final Component component) {
                                if (renderedComponents == null || !renderedComponents.contains(component)) {
                                        if (!component.isAuto() && component.isVisibleInHierarchy()) {
                                                unrenderedComponents.add(component);
                                                buffer.append(Integer.toString(unrenderedComponents.size()) + "". "" + component + ""\n"");
                        String metadata = component.getMetaData(Component.CONSTRUCTED_AT_KEY);
                        if (metadata != null) {
                            buffer.append(metadata);
                        }
                        metadata = component.getMetaData(Component.ADDED_AT_KEY);
                        if (metadata != null) {
                            buffer.append(metadata);
                        }
                    } else {
                                                return CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;
                    }
                }
                return CONTINUE_TRAVERSAL;
            }
        });
                if (unrenderedComponents.size() > 0) {
                        renderedComponents = null;
            Iterator<Component> iterator = unrenderedComponents.iterator();
            while (iterator.hasNext()) {
                Component component = iterator.next();
                                Iterator<? extends Component> iterator2 = component.getParent().iterator();
                while (iterator2.hasNext()) {
                    Component sibling = iterator2.next();
                    if (!sibling.isVisible()) {
                        boolean isTransparentMarkupContainer = sibling instanceof MarkupContainer && ((MarkupContainer) sibling).isTransparentResolver();
                        boolean isComponentResolver = sibling instanceof IComponentResolver;
                        if (isTransparentMarkupContainer || isComponentResolver) {
                                                                                    log.debug(""Component {} wasn't rendered but most likely it has a transparent parent: {}"", component, sibling);
                            iterator.remove();
                            break;
                        }
                    }
                }
            }
                        if (unrenderedComponents.size() > 0) {
                                throw new WicketRuntimeException(""The component(s) below failed to render. A common problem is that you have added a component in code but forgot to reference it in the markup (thus the component will never be rendered).\n\n"" + buffer.toString());
            }
        }
    }
        renderedComponents = null;
}",1.7272727272727273,2.4795918367346936,1.6666666666666667,2.0,2.0,1.3336628769154724,-0.9260108976197309,2.0833333333333335,-0.028571428571428574,3.4285787708635826
commons-math,remotes/origin/bugs-dot-jar_MATH-373_bfe4623c,1,"/**
 * The weighted sum of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Uses the formula, <pre>
 *    weighted sum = &Sigma;(values[i] * weights[i])
 * </pre></p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the sum of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */
public double evaluate(final double[] values, final double[] weights, final int begin, final int length) {
    double sum = Double.NaN;
    if (test(values, weights, begin, length)) {
        sum = 0.0;
        for (int i = begin; i < begin + length; i++) {
            sum += values[i] * weights[i];
        }
    }
    return sum;
}","/**
 * The weighted sum of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Uses the formula, <pre>
 *    weighted sum = &Sigma;(values[i] * weights[i])
 * </pre></p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the sum of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */
","public double evaluate(final double[] values, final double[] weights, final int begin, final int length) {
    double sum = Double.NaN;
    if (test(values, weights, begin, length)) {
        sum = 0.0;
        for (int i = begin; i < begin + length; i++) {
            sum += values[i] * weights[i];
        }
    }
    return sum;
}",-0.18181818181818182,0.2959183673469388,-0.16666666666666666,0.0,0.25,1.003460207612457,0.19042156581588765,-0.4166666666666667,-0.028571428571428574,0.28583910468089474
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2047_a0a495f0,0,"@SuppressWarnings(""deprecation"")
private void copyPrivileges(NodeBuilder root) throws RepositoryException {
    PrivilegeRegistry registry = source.getPrivilegeRegistry();
    NodeBuilder privileges = root.child(JCR_SYSTEM).child(REP_PRIVILEGES);
    privileges.setProperty(JCR_PRIMARYTYPE, NT_REP_PRIVILEGES, NAME);
    PrivilegeBits next = PrivilegeBits.NEXT_AFTER_BUILT_INS;
    logger.info(""Copying registered privileges"");
    for (Privilege privilege : registry.getRegisteredPrivileges()) {
        String name = privilege.getName();
        NodeBuilder def = privileges.child(name);
        def.setProperty(JCR_PRIMARYTYPE, NT_REP_PRIVILEGE, NAME);
        if (privilege.isAbstract()) {
            def.setProperty(REP_IS_ABSTRACT, true);
        }
        Privilege[] aggregate = privilege.getDeclaredAggregatePrivileges();
        if (aggregate.length > 0) {
            List<String> names = newArrayListWithCapacity(aggregate.length);
            for (Privilege p : aggregate) {
                names.add(p.getName());
            }
            def.setProperty(REP_AGGREGATES, names, NAMES);
        }
        PrivilegeBits bits = PrivilegeBits.BUILT_IN.get(name);
        if (bits != null) {
            def.setProperty(bits.asPropertyState(REP_BITS));
        } else if (aggregate.length == 0) {
            bits = next;
            next = next.nextBits();
            def.setProperty(bits.asPropertyState(REP_BITS));
        }
    }
    privileges.setProperty(next.asPropertyState(REP_NEXT));
    // resolve privilege bits also for all aggregates
    for (String name : privileges.getChildNodeNames()) {
        resolvePrivilegeBits(privileges, name);
    }
}",,"@SuppressWarnings(""deprecation"")
private void copyPrivileges(NodeBuilder root) throws RepositoryException {
    PrivilegeRegistry registry = source.getPrivilegeRegistry();
    NodeBuilder privileges = root.child(JCR_SYSTEM).child(REP_PRIVILEGES);
    privileges.setProperty(JCR_PRIMARYTYPE, NT_REP_PRIVILEGES, NAME);
    PrivilegeBits next = PrivilegeBits.NEXT_AFTER_BUILT_INS;
    logger.info(""Copying registered privileges"");
    for (Privilege privilege : registry.getRegisteredPrivileges()) {
        String name = privilege.getName();
        NodeBuilder def = privileges.child(name);
        def.setProperty(JCR_PRIMARYTYPE, NT_REP_PRIVILEGE, NAME);
        if (privilege.isAbstract()) {
            def.setProperty(REP_IS_ABSTRACT, true);
        }
        Privilege[] aggregate = privilege.getDeclaredAggregatePrivileges();
        if (aggregate.length > 0) {
            List<String> names = newArrayListWithCapacity(aggregate.length);
            for (Privilege p : aggregate) {
                names.add(p.getName());
            }
            def.setProperty(REP_AGGREGATES, names, NAMES);
        }
        PrivilegeBits bits = PrivilegeBits.BUILT_IN.get(name);
        if (bits != null) {
            def.setProperty(bits.asPropertyState(REP_BITS));
        } else if (aggregate.length == 0) {
            bits = next;
            next = next.nextBits();
            def.setProperty(bits.asPropertyState(REP_BITS));
        }
    }
    privileges.setProperty(next.asPropertyState(REP_NEXT));
        for (String name : privileges.getChildNodeNames()) {
        resolvePrivilegeBits(privileges, name);
    }
}",1.0,0.44897959183673464,0.6666666666666666,0.5,0.16666666666666666,0.43203163618388546,-0.6816747920848868,1.6666666666666667,-0.028571428571428574,1.1914031548605668
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1926_9225a3e2,1,"/**
 * Initialize with un-merged branches from <code>store</code> for this
 * <code>clusterId</code>.
 *
 * @param store the document store.
 * @param context the revision context.
 */
void init(DocumentStore store, RevisionContext context) {
    if (!initialized.compareAndSet(false, true)) {
        throw new IllegalStateException(""already initialized"");
    }
    NodeDocument doc = store.find(Collection.NODES, Utils.getIdFromPath(""/""));
    if (doc == null) {
        return;
    }
    SortedMap<Revision, Revision> revisions = doc.getUncommittedRevisions(context);
    while (!revisions.isEmpty()) {
        SortedSet<Revision> commits = new TreeSet<Revision>(comparator);
        Revision head = revisions.lastKey();
        commits.add(head);
        Revision base = revisions.remove(head).asTrunkRevision();
        while (revisions.containsKey(base)) {
            commits.add(base);
            base = revisions.remove(base).asTrunkRevision();
        }
        branches.add(new Branch(commits, base));
    }
}","/**
 * Initialize with un-merged branches from <code>store</code> for this
 * <code>clusterId</code>.
 *
 * @param store the document store.
 * @param context the revision context.
 */
","void init(DocumentStore store, RevisionContext context) {
    if (!initialized.compareAndSet(false, true)) {
        throw new IllegalStateException(""already initialized"");
    }
    NodeDocument doc = store.find(Collection.NODES, Utils.getIdFromPath(""/""));
    if (doc == null) {
        return;
    }
    SortedMap<Revision, Revision> revisions = doc.getUncommittedRevisions(context);
    while (!revisions.isEmpty()) {
        SortedSet<Revision> commits = new TreeSet<Revision>(comparator);
        Revision head = revisions.lastKey();
        commits.add(head);
        Revision base = revisions.remove(head).asTrunkRevision();
        while (revisions.containsKey(base)) {
            commits.add(base);
            base = revisions.remove(base).asTrunkRevision();
        }
        branches.add(new Branch(commits, base));
    }
}",0.3181818181818182,0.08163265306122457,0.3333333333333333,0.0,0.3333333333333333,-0.040533860603064735,-0.3237740177803272,0.6666666666666666,-0.028571428571428574,0.13731310042358905
wicket,remotes/origin/bugs-dot-jar_WICKET-4777_eccb3b11,3,"/**
 *  Write a reference to a javascript file to the response object
 *
 *  @param response
 *             The HTTP response
 *  @param url
 *             The javascript file URL
 *  @param id
 *             Unique identifier of element
 *  @param defer
 *             specifies that the execution of a script should be deferred (delayed) until after
 *             the page has been loaded.
 *  @param charset
 *             a non null value specifies the charset attribute of the script tag
 */
public static void writeJavaScriptUrl(final Response response, final CharSequence url, final String id, boolean defer, String charset) {
    response.write(""<script type=\""text/javascript\"" "");
    if (id != null) {
        response.write(""id=\"""" + Strings.escapeMarkup(id) + ""\"" "");
    }
    if (defer) {
        response.write(""defer=\""defer\"" "");
    }
    if (charset != null) {
        response.write(""charset=\"""" + Strings.escapeMarkup(charset) + ""\"" "");
    }
    response.write(""src=\"""");
    response.write(Strings.escapeMarkup(url));
    response.write(""\""></script>"");
    response.write(""\n"");
}","/**
 *  Write a reference to a javascript file to the response object
 *
 *  @param response
 *             The HTTP response
 *  @param url
 *             The javascript file URL
 *  @param id
 *             Unique identifier of element
 *  @param defer
 *             specifies that the execution of a script should be deferred (delayed) until after
 *             the page has been loaded.
 *  @param charset
 *             a non null value specifies the charset attribute of the script tag
 */
","public static void writeJavaScriptUrl(final Response response, final CharSequence url, final String id, boolean defer, String charset) {
    response.write(""<script type=\""text/javascript\"" "");
    if (id != null) {
        response.write(""id=\"""" + Strings.escapeMarkup(id) + ""\"" "");
    }
    if (defer) {
        response.write(""defer=\""defer\"" "");
    }
    if (charset != null) {
        response.write(""charset=\"""" + Strings.escapeMarkup(charset) + ""\"" "");
    }
    response.write(""src=\"""");
    response.write(Strings.escapeMarkup(url));
    response.write(""\""></script>"");
    response.write(""\n"");
}",0.09090909090909091,-0.40816326530612235,0.0,-0.5,0.08333333333333333,0.06821552150271878,-0.1092629767708633,0.4166666666666667,-0.028571428571428574,0.07677712533353893
Closure,134,2,"public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExterns());
    NodeTraversal.traverse(compiler, root, new ProcessProperties());
    Set<String> reservedNames = new HashSet<String>(externedNames.size() + quotedNames.size());
    reservedNames.addAll(externedNames);
    reservedNames.addAll(quotedNames);
    int numRenamedPropertyNames = 0;
    int numSkippedPropertyNames = 0;
    Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);
    for (Property p : propertyMap.values()) {
        if (!p.skipAmbiguating) {
            ++numRenamedPropertyNames;
            computeRelatedTypes(p.type);
            propsByFreq.add(p);
        } else {
            ++numSkippedPropertyNames;
            reservedNames.add(p.oldName);
        }
    }
    PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq));
    GraphColoring<Property, Void> coloring = new GreedyGraphColoring<Property, Void>(graph, FREQUENCY_COMPARATOR);
    int numNewPropertyNames = coloring.color();
    NameGenerator nameGen = new NameGenerator(reservedNames, """", reservedCharacters);
    for (int i = 0; i < numNewPropertyNames; ++i) {
        colorMap.put(i, nameGen.generateNextName());
    }
    for (GraphNode<Property, Void> node : graph.getNodes()) {
        node.getValue().newName = colorMap.get(node.getAnnotation().hashCode());
        renamingMap.put(node.getValue().oldName, node.getValue().newName);
    }
    // Update the string nodes.
    for (Node n : stringNodesToRename) {
        String oldName = n.getString();
        Property p = propertyMap.get(oldName);
        if (p != null && p.newName != null) {
            Preconditions.checkState(oldName.equals(p.oldName));
            if (!p.newName.equals(oldName)) {
                n.setString(p.newName);
                compiler.reportCodeChange();
            }
        }
    }
    logger.info(""Collapsed "" + numRenamedPropertyNames + "" properties into "" + numNewPropertyNames + "" and skipped renaming "" + numSkippedPropertyNames + "" properties."");
}",,"public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExterns());
    NodeTraversal.traverse(compiler, root, new ProcessProperties());
    Set<String> reservedNames = new HashSet<String>(externedNames.size() + quotedNames.size());
    reservedNames.addAll(externedNames);
    reservedNames.addAll(quotedNames);
    int numRenamedPropertyNames = 0;
    int numSkippedPropertyNames = 0;
    Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);
    for (Property p : propertyMap.values()) {
        if (!p.skipAmbiguating) {
            ++numRenamedPropertyNames;
            computeRelatedTypes(p.type);
            propsByFreq.add(p);
        } else {
            ++numSkippedPropertyNames;
            reservedNames.add(p.oldName);
        }
    }
    PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq));
    GraphColoring<Property, Void> coloring = new GreedyGraphColoring<Property, Void>(graph, FREQUENCY_COMPARATOR);
    int numNewPropertyNames = coloring.color();
    NameGenerator nameGen = new NameGenerator(reservedNames, """", reservedCharacters);
    for (int i = 0; i < numNewPropertyNames; ++i) {
        colorMap.put(i, nameGen.generateNextName());
    }
    for (GraphNode<Property, Void> node : graph.getNodes()) {
        node.getValue().newName = colorMap.get(node.getAnnotation().hashCode());
        renamingMap.put(node.getValue().oldName, node.getValue().newName);
    }
        for (Node n : stringNodesToRename) {
        String oldName = n.getString();
        Property p = propertyMap.get(oldName);
        if (p != null && p.newName != null) {
            Preconditions.checkState(oldName.equals(p.oldName));
            if (!p.newName.equals(oldName)) {
                n.setString(p.newName);
                compiler.reportCodeChange();
            }
        }
    }
    logger.info(""Collapsed "" + numRenamedPropertyNames + "" properties into "" + numNewPropertyNames + "" and skipped renaming "" + numSkippedPropertyNames + "" properties."");
}",1.3181818181818181,0.4540816326530613,0.6666666666666666,0.5,0.5833333333333334,0.8610973801285222,-0.8230570691138518,2.0,-0.028571428571428574,2.9137874173915654
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3769_306a9e00,1,"/**
 * Following logic is taken from org.apache.jackrabbit.core.query.lucene.JackrabbitQueryParser#parse(java.lang.String)
 */
private static String rewriteQueryText(String textsearch) {
    // replace escaped ' with just '
    StringBuilder rewritten = new StringBuilder();
    // the default lucene query parser recognizes 'AND' and 'NOT' as
    // keywords.
    textsearch = textsearch.replaceAll(""AND"", ""and"");
    textsearch = textsearch.replaceAll(""NOT"", ""not"");
    boolean escaped = false;
    for (int i = 0; i < textsearch.length(); i++) {
        if (textsearch.charAt(i) == '\\') {
            if (escaped) {
                rewritten.append(""\\\\"");
                escaped = false;
            } else {
                escaped = true;
            }
        } else if (textsearch.charAt(i) == '\'') {
            if (escaped) {
                escaped = false;
            }
            rewritten.append(textsearch.charAt(i));
        } else if (textsearch.charAt(i) == ':') {
            // fields as known in lucene are not supported
            rewritten.append(""\\:"");
        } else {
            if (escaped) {
                rewritten.append('\\');
                escaped = false;
            }
            rewritten.append(textsearch.charAt(i));
        }
    }
    return rewritten.toString();
}","/**
 * Following logic is taken from org.apache.jackrabbit.core.query.lucene.JackrabbitQueryParser#parse(java.lang.String)
 */
","private static String rewriteQueryText(String textsearch) {
        StringBuilder rewritten = new StringBuilder();
            textsearch = textsearch.replaceAll(""AND"", ""and"");
    textsearch = textsearch.replaceAll(""NOT"", ""not"");
    boolean escaped = false;
    for (int i = 0; i < textsearch.length(); i++) {
        if (textsearch.charAt(i) == '\\') {
            if (escaped) {
                rewritten.append(""\\\\"");
                escaped = false;
            } else {
                escaped = true;
            }
        } else if (textsearch.charAt(i) == '\'') {
            if (escaped) {
                escaped = false;
            }
            rewritten.append(textsearch.charAt(i));
        } else if (textsearch.charAt(i) == ':') {
                        rewritten.append(""\\:"");
        } else {
            if (escaped) {
                rewritten.append('\\');
                escaped = false;
            }
            rewritten.append(textsearch.charAt(i));
        }
    }
    return rewritten.toString();
}",0.7272727272727273,0.9591836734693879,0.6666666666666666,1.5,0.5,0.726643598615917,-0.5021508459994267,0.6666666666666666,-0.028571428571428574,0.8145202393342499
JxPath,4,1,"public Object getValue() {
    return stringValue(node);
}",,"public Object getValue() {
    return stringValue(node);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.144536851161457,-0.4166666666666667,2.6,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-442_246d53c5,1,"/**
 *  Clean up the request cycle.
 */
private void detach() {
    // furthermore, the targets will be cg-ed with this cycle too
    for (Iterator iter = requestTargets.iterator(); iter.hasNext(); ) {
        IRequestTarget target = (IRequestTarget) iter.next();
        if (target != null) {
            try {
                target.detach(this);
            } catch (RuntimeException e) {
                log.error(""there was an error cleaning up target "" + target + ""."", e);
            }
        }
    }
    // remove any rendered feedback messages from the session
    try {
        session.cleanupFeedbackMessages();
    } catch (RuntimeException re) {
        log.error(""there was an error cleaning up the feedback messages"", re);
    }
    if (updateSession) {
        // attributes that might be required to update the cluster
        try {
            session.update();
        } catch (RuntimeException re) {
            log.error(""there was an error updating the session "" + session + ""."", re);
        }
    }
    try {
        IRequestLogger requestLogger = getApplication().getRequestLogger();
        if (requestLogger != null) {
            requestLogger.requestTime((System.currentTimeMillis() - startTime));
        }
    } catch (RuntimeException re) {
        log.error(""there was an error in the RequestLogger ending."", re);
    }
    // clear the used pagemap for this thread,
    try {
        session.requestDetached();
    } catch (RuntimeException re) {
        log.error(""there was an error detaching the request from the session "" + session + ""."", re);
    }
    if (getResponse() instanceof BufferedWebResponse) {
        try {
            ((BufferedWebResponse) getResponse()).filter();
        } catch (RuntimeException re) {
            log.error(""there was an error filtering the response."", re);
        }
    }
    try {
        onEndRequest();
    } catch (RuntimeException e) {
        log.error(""Exception occurred during onEndRequest"", e);
    }
    // Release thread local resources
    try {
        threadDetach();
    } catch (RuntimeException re) {
        log.error(""Exception occurred during threadDetach"", re);
    }
}","/**
 *  Clean up the request cycle.
 */
","private void detach() {
        for (Iterator iter = requestTargets.iterator(); iter.hasNext(); ) {
        IRequestTarget target = (IRequestTarget) iter.next();
        if (target != null) {
            try {
                target.detach(this);
            } catch (RuntimeException e) {
                log.error(""there was an error cleaning up target "" + target + ""."", e);
            }
        }
    }
        try {
        session.cleanupFeedbackMessages();
    } catch (RuntimeException re) {
        log.error(""there was an error cleaning up the feedback messages"", re);
    }
    if (updateSession) {
                try {
            session.update();
        } catch (RuntimeException re) {
            log.error(""there was an error updating the session "" + session + ""."", re);
        }
    }
    try {
        IRequestLogger requestLogger = getApplication().getRequestLogger();
        if (requestLogger != null) {
            requestLogger.requestTime((System.currentTimeMillis() - startTime));
        }
    } catch (RuntimeException re) {
        log.error(""there was an error in the RequestLogger ending."", re);
    }
        try {
        session.requestDetached();
    } catch (RuntimeException re) {
        log.error(""there was an error detaching the request from the session "" + session + ""."", re);
    }
    if (getResponse() instanceof BufferedWebResponse) {
        try {
            ((BufferedWebResponse) getResponse()).filter();
        } catch (RuntimeException re) {
            log.error(""there was an error filtering the response."", re);
        }
    }
    try {
        onEndRequest();
    } catch (RuntimeException e) {
        log.error(""Exception occurred during onEndRequest"", e);
    }
        try {
        threadDetach();
    } catch (RuntimeException re) {
        log.error(""Exception occurred during threadDetach"", re);
    }
}",1.8181818181818181,0.25510204081632654,1.6666666666666667,0.5,0.4166666666666667,0.5032130499258528,-0.8680814453685117,1.5,-0.028571428571428574,0.951152342160604
camel,remotes/origin/bugs-dot-jar_CAMEL-6667_1fc7bd7a,1,"@Override
public boolean process(Exchange exchange, AsyncCallback callback) {
    // use atomic integer to be able to pass reference and keep track on the values
    AtomicInteger index = new AtomicInteger();
    AtomicInteger count = new AtomicInteger();
    // Intermediate conversion to String is needed when direct conversion to Integer is not available
    // but evaluation result is a textual representation of a numeric value.
    String text = expression.evaluate(exchange, String.class);
    try {
        int num = ExchangeHelper.convertToMandatoryType(exchange, Integer.class, text);
        count.set(num);
    } catch (NoTypeConversionAvailableException e) {
        exchange.setException(e);
        callback.done(true);
        return true;
    }
    Exchange target = exchange;
    // set the size before we start
    exchange.setProperty(Exchange.LOOP_SIZE, count);
    // loop synchronously
    while (index.get() < count.get()) {
        // and prepare for next iteration
        target = prepareExchange(exchange, index.get());
        boolean sync = process(target, callback, index, count);
        if (!sync) {
            LOG.trace(""Processing exchangeId: {} is continued being processed asynchronously"", target.getExchangeId());
            // so we break out now, then the callback will be invoked which then continue routing from where we left here
            return false;
        }
        LOG.trace(""Processing exchangeId: {} is continued being processed synchronously"", target.getExchangeId());
        // increment counter before next loop
        index.getAndIncrement();
    }
    // we are done so prepare the result
    ExchangeHelper.copyResults(exchange, target);
    LOG.trace(""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
    callback.done(true);
    return true;
}",,"@Override
public boolean process(Exchange exchange, AsyncCallback callback) {
        AtomicInteger index = new AtomicInteger();
    AtomicInteger count = new AtomicInteger();
            String text = expression.evaluate(exchange, String.class);
    try {
        int num = ExchangeHelper.convertToMandatoryType(exchange, Integer.class, text);
        count.set(num);
    } catch (NoTypeConversionAvailableException e) {
        exchange.setException(e);
        callback.done(true);
        return true;
    }
    Exchange target = exchange;
        exchange.setProperty(Exchange.LOOP_SIZE, count);
        while (index.get() < count.get()) {
                target = prepareExchange(exchange, index.get());
        boolean sync = process(target, callback, index, count);
        if (!sync) {
            LOG.trace(""Processing exchangeId: {} is continued being processed asynchronously"", target.getExchangeId());
                        return false;
        }
        LOG.trace(""Processing exchangeId: {} is continued being processed synchronously"", target.getExchangeId());
                index.getAndIncrement();
    }
        ExchangeHelper.copyResults(exchange, target);
    LOG.trace(""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
    callback.done(true);
    return true;
}",0.7272727272727273,0.005102040816326422,0.0,0.0,0.0,0.06623826000988631,-0.5127616862632636,1.1666666666666667,-0.028571428571428574,0.34126545628980515
flink,remotes/origin/bugs-dot-jar_FLINK-1922_ccd574a4,1,"public void deployToSlot(final SimpleSlot slot) throws JobException {
    // sanity checks
    if (slot == null) {
        throw new NullPointerException();
    }
    if (!slot.isAlive()) {
        throw new JobException(""Target slot for deployment is not alive."");
    }
    // make sure exactly one deployment call happens from the correct state
    // note: the transition from CREATED to DEPLOYING is for testing purposes only
    ExecutionState previous = this.state;
    if (previous == SCHEDULED || previous == CREATED) {
        if (!transitionState(previous, DEPLOYING)) {
            // this should actually not happen and indicates a race somewhere else
            throw new IllegalStateException(""Cannot deploy task: Concurrent deployment call race."");
        }
    } else {
        // vertex may have been cancelled, or it was already scheduled
        throw new IllegalStateException(""The vertex must be in CREATED or SCHEDULED state to be deployed. Found state "" + previous);
    }
    try {
        // good, we are allowed to deploy
        if (!slot.setExecutedVertex(this)) {
            throw new JobException(""Could not assign the ExecutionVertex to the slot "" + slot);
        }
        this.assignedResource = slot;
        this.assignedResourceLocation = slot.getInstance().getInstanceConnectionInfo();
        // race double check, did we fail/cancel and do we need to release the slot?
        if (this.state != DEPLOYING) {
            slot.releaseSlot();
            return;
        }
        if (LOG.isInfoEnabled()) {
            LOG.info(String.format(""Deploying %s (attempt #%d) to %s"", vertex.getSimpleName(), attemptNumber, slot.getInstance().getInstanceConnectionInfo().getHostname()));
        }
        final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(attemptId, slot);
        // register this execution at the execution graph, to receive call backs
        vertex.getExecutionGraph().registerExecution(this);
        Instance instance = slot.getInstance();
        Future<Object> deployAction = Patterns.ask(instance.getTaskManager(), new SubmitTask(deployment), new Timeout(timeout));
        deployAction.onComplete(new OnComplete<Object>() {

            @Override
            public void onComplete(Throwable failure, Object success) throws Throwable {
                if (failure != null) {
                    if (failure instanceof TimeoutException) {
                        markFailed(new Exception(""Cannot deploy task - TaskManager not responding."", failure));
                    } else {
                        markFailed(failure);
                    }
                } else {
                    if (success == null) {
                        markFailed(new Exception(""Failed to deploy the task to slot "" + slot + "": TaskOperationResult was null""));
                    }
                    if (success instanceof TaskOperationResult) {
                        TaskOperationResult result = (TaskOperationResult) success;
                        if (!result.executionID().equals(attemptId)) {
                            markFailed(new Exception(""Answer execution id does not match the request execution id.""));
                        } else if (result.success()) {
                            switchToRunning();
                        } else {
                            // deployment failed :(
                            markFailed(new Exception(""Failed to deploy the task "" + getVertexWithAttempt() + "" to slot "" + slot + "": "" + result.description()));
                        }
                    } else {
                        markFailed(new Exception(""Failed to deploy the task to slot "" + slot + "": Response was not of type TaskOperationResult""));
                    }
                }
            }
        }, AkkaUtils.globalExecutionContext());
    } catch (Throwable t) {
        markFailed(t);
        ExceptionUtils.rethrow(t);
    }
}",,"public void deployToSlot(final SimpleSlot slot) throws JobException {
        if (slot == null) {
        throw new NullPointerException();
    }
    if (!slot.isAlive()) {
        throw new JobException(""Target slot for deployment is not alive."");
    }
            ExecutionState previous = this.state;
    if (previous == SCHEDULED || previous == CREATED) {
        if (!transitionState(previous, DEPLOYING)) {
                        throw new IllegalStateException(""Cannot deploy task: Concurrent deployment call race."");
        }
    } else {
                throw new IllegalStateException(""The vertex must be in CREATED or SCHEDULED state to be deployed. Found state "" + previous);
    }
    try {
                if (!slot.setExecutedVertex(this)) {
            throw new JobException(""Could not assign the ExecutionVertex to the slot "" + slot);
        }
        this.assignedResource = slot;
        this.assignedResourceLocation = slot.getInstance().getInstanceConnectionInfo();
                if (this.state != DEPLOYING) {
            slot.releaseSlot();
            return;
        }
        if (LOG.isInfoEnabled()) {
            LOG.info(String.format(""Deploying %s (attempt #%d) to %s"", vertex.getSimpleName(), attemptNumber, slot.getInstance().getInstanceConnectionInfo().getHostname()));
        }
        final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(attemptId, slot);
                vertex.getExecutionGraph().registerExecution(this);
        Instance instance = slot.getInstance();
        Future<Object> deployAction = Patterns.ask(instance.getTaskManager(), new SubmitTask(deployment), new Timeout(timeout));
        deployAction.onComplete(new OnComplete<Object>() {

            @Override
            public void onComplete(Throwable failure, Object success) throws Throwable {
                if (failure != null) {
                    if (failure instanceof TimeoutException) {
                        markFailed(new Exception(""Cannot deploy task - TaskManager not responding."", failure));
                    } else {
                        markFailed(failure);
                    }
                } else {
                    if (success == null) {
                        markFailed(new Exception(""Failed to deploy the task to slot "" + slot + "": TaskOperationResult was null""));
                    }
                    if (success instanceof TaskOperationResult) {
                        TaskOperationResult result = (TaskOperationResult) success;
                        if (!result.executionID().equals(attemptId)) {
                            markFailed(new Exception(""Answer execution id does not match the request execution id.""));
                        } else if (result.success()) {
                            switchToRunning();
                        } else {
                                                        markFailed(new Exception(""Failed to deploy the task "" + getVertexWithAttempt() + "" to slot "" + slot + "": "" + result.description()));
                        }
                    } else {
                        markFailed(new Exception(""Failed to deploy the task to slot "" + slot + "": Response was not of type TaskOperationResult""));
                    }
                }
            }
        }, AkkaUtils.globalExecutionContext());
    } catch (Throwable t) {
        markFailed(t);
        ExceptionUtils.rethrow(t);
    }
}",2.3181818181818183,2.4285714285714284,2.6666666666666665,2.0,1.75,0.6831438457736037,-1.0880412962431893,2.4166666666666665,-0.028571428571428574,2.3651646172493694
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-579_7d72e6ed,3,"@Override
public void restrict(FilterImpl f) {
    if (f.getSelector() == selector1) {
        String p2 = selector2.currentPath();
        if (p2 != null) {
            if (selector2Path.equals(""."")) {
                f.restrictPath(p2, Filter.PathRestriction.EXACT);
            } else {
                // TODO normalize paths; support more complex relative path ("".."" and so on)
                String p = PathUtils.concat(p2, selector2Path);
                f.restrictPath(p, Filter.PathRestriction.EXACT);
            }
        }
    }
    if (f.getSelector() == selector2) {
        String p1 = selector1.currentPath();
        if (p1 != null) {
            if (selector2Path.equals(""."")) {
                f.restrictPath(p1, Filter.PathRestriction.EXACT);
            } else {
            // TODO normalize paths; support relative path ("".."" and so on)
            }
        }
    }
}",,"@Override
public void restrict(FilterImpl f) {
    if (f.getSelector() == selector1) {
        String p2 = selector2.currentPath();
        if (p2 != null) {
            if (selector2Path.equals(""."")) {
                f.restrictPath(p2, Filter.PathRestriction.EXACT);
            } else {
                                String p = PathUtils.concat(p2, selector2Path);
                f.restrictPath(p, Filter.PathRestriction.EXACT);
            }
        }
    }
    if (f.getSelector() == selector2) {
        String p1 = selector1.currentPath();
        if (p1 != null) {
            if (selector2Path.equals(""."")) {
                f.restrictPath(p1, Filter.PathRestriction.EXACT);
            } else {
                        }
        }
    }
}",0.4090909090909091,1.0561224489795917,0.5,0.5,0.5833333333333334,0.07414730598121602,-0.3168913105821623,0.3333333333333333,0.0,0.11412063508379697
Compress,4,1,"/**
 * Closes this output stream and releases any system resources
 * associated with the stream.
 *
 * @exception  IOException  if an I/O error occurs.
 */
public void close() throws IOException {
    finish();
    if (raf != null) {
        raf.close();
    }
    if (out != null) {
        out.close();
    }
}","/**
 * Closes this output stream and releases any system resources
 * associated with the stream.
 *
 * @exception  IOException  if an I/O error occurs.
 */
","public void close() throws IOException {
    finish();
    if (raf != null) {
        raf.close();
    }
    if (out != null) {
        out.close();
    }
}",-0.22727272727272727,-0.17857142857142863,-0.16666666666666666,-0.5,-0.08333333333333333,-0.3806228373702422,0.4293088614855177,-0.25,2.7714285714285714,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-9444_baece126,1,"private AggregationStrategy createAggregationStrategy(RouteContext routeContext) {
    AggregationStrategy strategy = getAggregationStrategy();
    if (strategy == null && strategyRef != null) {
        Object aggStrategy = routeContext.lookup(strategyRef, Object.class);
        if (aggStrategy instanceof AggregationStrategy) {
            strategy = (AggregationStrategy) aggStrategy;
        } else if (aggStrategy != null) {
            AggregationStrategyBeanAdapter adapter = new AggregationStrategyBeanAdapter(aggStrategy, getStrategyMethodName());
            if (getStrategyMethodAllowNull() != null) {
                adapter.setAllowNullNewExchange(getStrategyMethodAllowNull());
                adapter.setAllowNullOldExchange(getStrategyMethodAllowNull());
            }
            strategy = adapter;
        } else {
            throw new IllegalArgumentException(""Cannot find AggregationStrategy in Registry with name: "" + strategyRef);
        }
    }
    if (strategy == null) {
        // fallback to use latest
        strategy = new UseLatestAggregationStrategy();
    }
    if (strategy instanceof CamelContextAware) {
        ((CamelContextAware) strategy).setCamelContext(routeContext.getCamelContext());
    }
    return strategy;
}",,"private AggregationStrategy createAggregationStrategy(RouteContext routeContext) {
    AggregationStrategy strategy = getAggregationStrategy();
    if (strategy == null && strategyRef != null) {
        Object aggStrategy = routeContext.lookup(strategyRef, Object.class);
        if (aggStrategy instanceof AggregationStrategy) {
            strategy = (AggregationStrategy) aggStrategy;
        } else if (aggStrategy != null) {
            AggregationStrategyBeanAdapter adapter = new AggregationStrategyBeanAdapter(aggStrategy, getStrategyMethodName());
            if (getStrategyMethodAllowNull() != null) {
                adapter.setAllowNullNewExchange(getStrategyMethodAllowNull());
                adapter.setAllowNullOldExchange(getStrategyMethodAllowNull());
            }
            strategy = adapter;
        } else {
            throw new IllegalArgumentException(""Cannot find AggregationStrategy in Registry with name: "" + strategyRef);
        }
    }
    if (strategy == null) {
                strategy = new UseLatestAggregationStrategy();
    }
    if (strategy instanceof CamelContextAware) {
        ((CamelContextAware) strategy).setCamelContext(routeContext.getCamelContext());
    }
    return strategy;
}",0.5,0.6887755102040817,0.6666666666666666,1.0,0.5,0.5249629263470095,-0.386005162030399,0.3333333333333333,-0.028571428571428574,0.48424925368659544
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-193_8ad5a888,3,"public String toString() {
    String labelString = new ColumnVisibility(colVisibility).toString();
    String s = toPrintableString(row, 0, row.length, Constants.MAX_DATA_TO_PRINT) + "" "" + toPrintableString(colFamily, 0, colFamily.length, Constants.MAX_DATA_TO_PRINT) + "":"" + toPrintableString(colQualifier, 0, colQualifier.length, Constants.MAX_DATA_TO_PRINT) + "" "" + labelString + "" "" + Long.toString(timestamp) + "" "" + deleted;
    return s;
}",,"public String toString() {
    String labelString = new ColumnVisibility(colVisibility).toString();
    String s = toPrintableString(row, 0, row.length, Constants.MAX_DATA_TO_PRINT) + "" "" + toPrintableString(colFamily, 0, colFamily.length, Constants.MAX_DATA_TO_PRINT) + "":"" + toPrintableString(colQualifier, 0, colQualifier.length, Constants.MAX_DATA_TO_PRINT) + "" "" + labelString + "" "" + Long.toString(timestamp) + "" "" + deleted;
    return s;
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,0.03460207612456753,0.48236306280470315,-0.08333333333333333,-0.028571428571428574,0.016266848266025938
Closure,108,2,"@Override
public void exitScope(NodeTraversal t) {
    if (t.getScopeDepth() > 2) {
        findNamespaceShadows(t);
    }
    if (t.getScopeDepth() == 2) {
        renameNamespaceShadows(t);
        aliases.clear();
        forbiddenLocals.clear();
        transformation = null;
        hasNamespaceShadows = false;
    }
}",,"@Override
public void exitScope(NodeTraversal t) {
    if (t.getScopeDepth() > 2) {
        findNamespaceShadows(t);
    }
    if (t.getScopeDepth() == 2) {
        renameNamespaceShadows(t);
        aliases.clear();
        forbiddenLocals.clear();
        transformation = null;
        hasNamespaceShadows = false;
    }
}",-0.045454545454545456,0.09183673469387764,-0.16666666666666666,-0.5,-0.16666666666666666,-0.0958971824023727,0.10868941783768263,0.0,0.4857142857142857,-0.09361361309913868
wicket,remotes/origin/bugs-dot-jar_WICKET-208_b224bad8,3,"/**
 *  @see wicket.behavior.AbstractAjaxBehavior#renderHead(wicket.markup.html.IHeaderResponse)
 */
public void renderHead(IHeaderResponse response) {
    super.renderHead(response);
    if (this.attachedBodyOnLoadModifier == false) {
        this.attachedBodyOnLoadModifier = true;
        ((WebPage) getComponent().getPage()).getBodyContainer().addOnLoadModifier(getJsTimeoutCall(updateInterval), getComponent());
    }
}","/**
 *  @see wicket.behavior.AbstractAjaxBehavior#renderHead(wicket.markup.html.IHeaderResponse)
 */
","public void renderHead(IHeaderResponse response) {
    super.renderHead(response);
    if (this.attachedBodyOnLoadModifier == false) {
        this.attachedBodyOnLoadModifier = true;
        ((WebPage) getComponent().getPage()).getBodyContainer().addOnLoadModifier(getJsTimeoutCall(updateInterval), getComponent());
    }
}",-0.3181818181818182,0.0,-0.3333333333333333,-0.5,-0.25,-0.1255561047948591,0.45655291081158605,0.08333333333333333,0.4571428571428572,-0.1201725193912995
wicket,remotes/origin/bugs-dot-jar_WICKET-3834_747bccb5,1,"/**
 *  Parses the given URL string.
 *
 *  @param url
 *  @return Url object
 */
public static Url parse(final String url) {
    return parse(url, null);
}","/**
 *  Parses the given URL string.
 *
 *  @param url
 *  @return Url object
 */
","public static Url parse(final String url) {
    return parse(url, null);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.0585030111843994,-0.4166666666666667,2.8285714285714287,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-855_ac597cc1,3,"/**
 * {@inheritDoc}
 */
@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();
    // Optional additional convergence criteria.
    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();
    double a;
    double b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }
    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;
    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;
        // Default stopping criterion.
        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (!stop) {
            double p = 0;
            double q = 0;
            double r = 0;
            double u = 0;
            if (FastMath.abs(e) > tol1) {
                // Fit parabola.
                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);
                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }
                r = e;
                e = d;
                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                    // Parabolic interpolation step.
                    d = p / q;
                    u = x + d;
                    // f must not be evaluated too close to a or b.
                    if (u - a < tol2 || b - u < tol2) {
                        if (x <= m) {
                            d = tol1;
                        } else {
                            d = -tol1;
                        }
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }
            } else {
                // Golden section step.
                if (x < m) {
                    e = b - x;
                } else {
                    e = a - x;
                }
                d = GOLDEN_SECTION * e;
            }
            // Update by at least ""tol1"".
            if (FastMath.abs(d) < tol1) {
                if (d >= 0) {
                    u = x + tol1;
                } else {
                    u = x - tol1;
                }
            } else {
                u = x + d;
            }
            double fu = computeObjectiveValue(u);
            if (!isMinim) {
                fu = -fu;
            }
            // User-defined convergence checker.
            previous = current;
            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);
            if (checker != null) {
                if (checker.converged(iter, previous, current)) {
                    return best(current, previous, isMinim);
                }
            }
            // Update a, b, v, w and x.
            if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || Precision.equals(w, x)) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                    v = u;
                    fv = fu;
                }
            }
        } else {
            // Default termination (Brent's criterion).
            return best(current, previous, isMinim);
        }
        ++iter;
    }
}","/**
 * {@inheritDoc}
 */
","@Override
protected UnivariatePointValuePair doOptimize() {
    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
    final double lo = getMin();
    final double mid = getStartValue();
    final double hi = getMax();
        final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();
    double a;
    double b;
    if (lo < hi) {
        a = lo;
        b = hi;
    } else {
        a = hi;
        b = lo;
    }
    double x = mid;
    double v = x;
    double w = x;
    double d = 0;
    double e = 0;
    double fx = computeObjectiveValue(x);
    if (!isMinim) {
        fx = -fx;
    }
    double fv = fx;
    double fw = fx;
    UnivariatePointValuePair previous = null;
    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
    int iter = 0;
    while (true) {
        final double m = 0.5 * (a + b);
        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
        final double tol2 = 2 * tol1;
                final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
        if (!stop) {
            double p = 0;
            double q = 0;
            double r = 0;
            double u = 0;
            if (FastMath.abs(e) > tol1) {
                                r = (x - w) * (fx - fv);
                q = (x - v) * (fx - fw);
                p = (x - v) * q - (x - w) * r;
                q = 2 * (q - r);
                if (q > 0) {
                    p = -p;
                } else {
                    q = -q;
                }
                r = e;
                e = d;
                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                                        d = p / q;
                    u = x + d;
                                        if (u - a < tol2 || b - u < tol2) {
                        if (x <= m) {
                            d = tol1;
                        } else {
                            d = -tol1;
                        }
                    }
                } else {
                                        if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }
            } else {
                                if (x < m) {
                    e = b - x;
                } else {
                    e = a - x;
                }
                d = GOLDEN_SECTION * e;
            }
                        if (FastMath.abs(d) < tol1) {
                if (d >= 0) {
                    u = x + tol1;
                } else {
                    u = x - tol1;
                }
            } else {
                u = x + d;
            }
            double fu = computeObjectiveValue(u);
            if (!isMinim) {
                fu = -fu;
            }
                        previous = current;
            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);
            if (checker != null) {
                if (checker.converged(iter, previous, current)) {
                    return best(current, previous, isMinim);
                }
            }
                        if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || Precision.equals(w, x)) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {
                    v = u;
                    fv = fu;
                }
            }
        } else {
                        return best(current, previous, isMinim);
        }
        ++iter;
    }
}",5.363636363636363,1.7500000000000002,3.3333333333333335,2.0,4.833333333333333,6.897676717745924,-1.5744192715801555,1.0833333333333333,-0.028571428571428574,41.445141146388785
Closure,148,2,"/**
 * Adds a mapping for the given node.  Mappings must be added in order.
 *
 * @param node The node that the new mapping represents.
 * @param startPosition The position on the starting line
 * @param endPosition The position on the ending line.
 */
void addMapping(Node node, Position startPosition, Position endPosition) {
    String sourceFile = (String) node.getProp(Node.SOURCEFILE_PROP);
    // information for a mapping to be useful.
    if (sourceFile == null || node.getLineno() < 0) {
        return;
    }
    String escapedSourceFile;
    if (lastSourceFile != sourceFile) {
        // yes, ""s1 != s2"" not ""!s1.equals(s2)""
        lastSourceFile = sourceFile;
        lastSourceFileEscaped = escapeString(sourceFile);
    }
    escapedSourceFile = lastSourceFileEscaped;
    // Create the new mapping.
    Mapping mapping = new Mapping();
    mapping.id = mappings.size();
    mapping.sourceFile = escapedSourceFile;
    mapping.originalPosition = new Position(node.getLineno(), node.getCharno());
    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);
    if (originalName != null) {
        mapping.originalName = escapeString(originalName);
    }
    // If the mapping is found on the first line, we need to offset
    // its character position by the number of characters found on
    // the *last* line of the source file to which the code is
    // being generated.
    int offsetLine = offsetPosition.getLineNumber();
    int startOffsetPosition = offsetPosition.getCharacterIndex();
    int endOffsetPosition = offsetPosition.getCharacterIndex();
    if (startPosition.getLineNumber() > 0) {
        startOffsetPosition = 0;
    }
    if (endPosition.getLineNumber() > 0) {
        endOffsetPosition = 0;
    }
    mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition);
    mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition);
    mappings.add(mapping);
}","/**
 * Adds a mapping for the given node.  Mappings must be added in order.
 *
 * @param node The node that the new mapping represents.
 * @param startPosition The position on the starting line
 * @param endPosition The position on the ending line.
 */
","void addMapping(Node node, Position startPosition, Position endPosition) {
    String sourceFile = (String) node.getProp(Node.SOURCEFILE_PROP);
        if (sourceFile == null || node.getLineno() < 0) {
        return;
    }
    String escapedSourceFile;
    if (lastSourceFile != sourceFile) {
                lastSourceFile = sourceFile;
        lastSourceFileEscaped = escapeString(sourceFile);
    }
    escapedSourceFile = lastSourceFileEscaped;
        Mapping mapping = new Mapping();
    mapping.id = mappings.size();
    mapping.sourceFile = escapedSourceFile;
    mapping.originalPosition = new Position(node.getLineno(), node.getCharno());
    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);
    if (originalName != null) {
        mapping.originalName = escapeString(originalName);
    }
                    int offsetLine = offsetPosition.getLineNumber();
    int startOffsetPosition = offsetPosition.getCharacterIndex();
    int endOffsetPosition = offsetPosition.getCharacterIndex();
    if (startPosition.getLineNumber() > 0) {
        startOffsetPosition = 0;
    }
    if (endPosition.getLineNumber() > 0) {
        endOffsetPosition = 0;
    }
    mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition);
    mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition);
    mappings.add(mapping);
}",0.8181818181818182,-0.5510204081632654,0.3333333333333333,-0.5,0.5833333333333334,1.3811171527434507,-0.5973616289073703,1.0,-0.028571428571428574,2.473734479465139
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2544_7ec60f1b,1,"@Override
public void deleteRows(String tableName, Text start, Text end) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {
    if (!exists(tableName))
        throw new TableNotFoundException(tableName, tableName, """");
    MockTable t = acu.tables.get(tableName);
    Set<Key> keep = new TreeSet<Key>(t.table.tailMap(new Key(start)).headMap(new Key(end)).keySet());
    t.table.keySet().removeAll(keep);
}",,"@Override
public void deleteRows(String tableName, Text start, Text end) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {
    if (!exists(tableName))
        throw new TableNotFoundException(tableName, tableName, """");
    MockTable t = acu.tables.get(tableName);
    Set<Key> keep = new TreeSet<Key>(t.table.tailMap(new Key(start)).headMap(new Key(end)).keySet());
    t.table.keySet().removeAll(keep);
}",-0.2727272727272727,-0.1887755102040817,-0.16666666666666666,-1.0,-0.16666666666666666,-0.06623826000988627,0.23458560367077702,0.08333333333333333,-0.028571428571428574,-0.011799675348315285
commons-math,remotes/origin/bugs-dot-jar_MATH-757_76b7413d,1,"/**
 * Sets the {@link ExpansionMode expansion mode}.
 *
 * @param expansionMode Expansion mode to use for resizing the array.
 * @deprecated As of 3.1 (to be removed in 4.0 as field will become ""final"").
 */
@Deprecated
public void setExpansionMode(ExpansionMode expansionMode) {
    this.expansionMode = expansionMode;
}","/**
 * Sets the {@link ExpansionMode expansion mode}.
 *
 * @param expansionMode Expansion mode to use for resizing the array.
 * @deprecated As of 3.1 (to be removed in 4.0 as field will become ""final"").
 */
","@Deprecated
public void setExpansionMode(ExpansionMode expansionMode) {
    this.expansionMode = expansionMode;
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9248637797533699,-0.5,2.542857142857143,-0.16422749602751402
Closure,53,2,"/**
 * Replaces an assignment like x = {...} with t1=a,t2=b,t3=c,true.
 * Note that the resulting expression will always evaluate to
 * true, as would the x = {...} expression.
 */
private void replaceAssignmentExpression(Var v, Reference ref, Map<String, String> varmap) {
    // Compute all of the assignments necessary
    List<Node> nodes = Lists.newArrayList();
    Node val = ref.getAssignedValue();
    blacklistVarReferencesInTree(val, v.scope);
    Preconditions.checkState(val.getType() == Token.OBJECTLIT);
    Set<String> all = Sets.newLinkedHashSet(varmap.keySet());
    for (Node key = val.getFirstChild(); key != null; key = key.getNext()) {
        String var = key.getString();
        Node value = key.removeFirstChild();
        // TODO(user): Copy type information.
        nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), value));
        all.remove(var);
    }
    // TODO(user): Better source information.
    for (String var : all) {
        nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), NodeUtil.newUndefinedNode(null)));
    }
    Node replacement;
    // All assignments evaluate to true, so make sure that the
    // expr statement evaluates to true in case it matters.
    nodes.add(new Node(Token.TRUE));
    // Join these using COMMA.  A COMMA node must have 2 children, so we
    // create a tree. In the tree the first child be the COMMA to match
    // the parser, otherwise tree equality tests fail.
    nodes = Lists.reverse(nodes);
    replacement = new Node(Token.COMMA);
    Node cur = replacement;
    int i;
    for (i = 0; i < nodes.size() - 2; i++) {
        cur.addChildToFront(nodes.get(i));
        Node t = new Node(Token.COMMA);
        cur.addChildToFront(t);
        cur = t;
    }
    cur.addChildToFront(nodes.get(i));
    cur.addChildToFront(nodes.get(i + 1));
    Node replace = ref.getParent();
    replacement.copyInformationFromForTree(replace);
    if (replace.getType() == Token.VAR) {
        replace.getParent().replaceChild(replace, NodeUtil.newExpr(replacement));
    } else {
        replace.getParent().replaceChild(replace, replacement);
    }
}","/**
 * Replaces an assignment like x = {...} with t1=a,t2=b,t3=c,true.
 * Note that the resulting expression will always evaluate to
 * true, as would the x = {...} expression.
 */
","private void replaceAssignmentExpression(Var v, Reference ref, Map<String, String> varmap) {
        List<Node> nodes = Lists.newArrayList();
    Node val = ref.getAssignedValue();
    blacklistVarReferencesInTree(val, v.scope);
    Preconditions.checkState(val.getType() == Token.OBJECTLIT);
    Set<String> all = Sets.newLinkedHashSet(varmap.keySet());
    for (Node key = val.getFirstChild(); key != null; key = key.getNext()) {
        String var = key.getString();
        Node value = key.removeFirstChild();
                nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), value));
        all.remove(var);
    }
        for (String var : all) {
        nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), NodeUtil.newUndefinedNode(null)));
    }
    Node replacement;
            nodes.add(new Node(Token.TRUE));
                nodes = Lists.reverse(nodes);
    replacement = new Node(Token.COMMA);
    Node cur = replacement;
    int i;
    for (i = 0; i < nodes.size() - 2; i++) {
        cur.addChildToFront(nodes.get(i));
        Node t = new Node(Token.COMMA);
        cur.addChildToFront(t);
        cur = t;
    }
    cur.addChildToFront(nodes.get(i));
    cur.addChildToFront(nodes.get(i + 1));
    Node replace = ref.getParent();
    replacement.copyInformationFromForTree(replace);
    if (replace.getType() == Token.VAR) {
        replace.getParent().replaceChild(replace, NodeUtil.newExpr(replacement));
    } else {
        replace.getParent().replaceChild(replace, replacement);
    }
}",1.0454545454545454,-0.43877551020408156,0.16666666666666666,-0.5,0.16666666666666666,1.1695501730103808,-0.7301405219386297,2.5833333333333335,-0.028571428571428574,3.5887888093677858
JxPath,4,1,"public Object getValue() {
    if (node instanceof Element) {
        return ((Element) node).getTextTrim();
    }
    if (node instanceof Comment) {
        String text = ((Comment) node).getText();
        if (text != null) {
            text = text.trim();
        }
        return text;
    }
    if (node instanceof Text) {
        return ((Text) node).getTextTrim();
    }
    if (node instanceof CDATA) {
        return ((CDATA) node).getTextTrim();
    }
    if (node instanceof ProcessingInstruction) {
        String text = ((ProcessingInstruction) node).getData();
        if (text != null) {
            text = text.trim();
        }
        return text;
    }
    return null;
}",,"public Object getValue() {
    if (node instanceof Element) {
        return ((Element) node).getTextTrim();
    }
    if (node instanceof Comment) {
        String text = ((Comment) node).getText();
        if (text != null) {
            text = text.trim();
        }
        return text;
    }
    if (node instanceof Text) {
        return ((Text) node).getTextTrim();
    }
    if (node instanceof CDATA) {
        return ((CDATA) node).getTextTrim();
    }
    if (node instanceof ProcessingInstruction) {
        String text = ((ProcessingInstruction) node).getData();
        if (text != null) {
            text = text.trim();
        }
        return text;
    }
    return null;
}",0.5454545454545454,-0.015306122448979493,0.6666666666666666,0.0,0.3333333333333333,0.17498764211566986,-0.33839977057642673,0.08333333333333333,0.0,0.09194752463797912
commons-math,remotes/origin/bugs-dot-jar_MATH-1136_cc4ab51e,3,"/**
 * {@inheritDoc} *
 */
@Override
public double logProbability(int x) {
    double ret;
    if (x < 0 || x > numberOfTrials) {
        ret = Double.NEGATIVE_INFINITY;
    } else {
        ret = SaddlePointExpansion.logBinomialProbability(x, numberOfTrials, probabilityOfSuccess, 1.0 - probabilityOfSuccess);
    }
    return ret;
}","/**
 * {@inheritDoc} *
 */
","@Override
public double logProbability(int x) {
    double ret;
    if (x < 0 || x > numberOfTrials) {
        ret = Double.NEGATIVE_INFINITY;
    } else {
        ret = SaddlePointExpansion.logBinomialProbability(x, numberOfTrials, probabilityOfSuccess, 1.0 - probabilityOfSuccess);
    }
    return ret;
}",-0.18181818181818182,-0.11224489795918377,-0.3333333333333333,-0.5,-0.08333333333333333,0.2580326248146318,0.2397476340694007,-0.4166666666666667,1.2571428571428573,-0.008433234395946565
wicket,remotes/origin/bugs-dot-jar_WICKET-4616_dd1df04b,1,"@Override
public void component(final Component component, final IVisit<Void> visit) {
    final Form<?> form = (Form<?>) component;
    if (!form.isEnabledInHierarchy() || !form.isVisibleInHierarchy()) {
        visit.dontGoDeeper();
        return;
    }
    if (form.hasError()) {
        form.onError();
    }
}",,"@Override
public void component(final Component component, final IVisit<Void> visit) {
    final Form<?> form = (Form<?>) component;
    if (!form.isEnabledInHierarchy() || !form.isVisibleInHierarchy()) {
        visit.dontGoDeeper();
        return;
    }
    if (form.hasError()) {
        form.onError();
    }
}",-0.13636363636363635,-0.035714285714285636,-0.16666666666666666,-0.5,0.08333333333333333,-0.07019278299555112,0.19759105248064246,-0.08333333333333333,-0.028571428571428574,-0.09270133329906931
wicket,remotes/origin/bugs-dot-jar_WICKET-2882_ebe56869,1,"/**
 *  @see org.apache.wicket.application.IComponentOnBeforeRenderListener#onBeforeRender(org.apache.wicket.Component)
 */
public void onAfterRender(final Component component) {
    if (log.isWarnEnabled()) {
        if ((component instanceof FormComponent) || (component instanceof IFormSubmittingComponent) || (component instanceof Form)) {
            log.warn(""Please note that onBeforeRender() and validate() might be called on invisible components inside an Enclosure. "" + ""Please see EnclosureContainer for an alternative. Enclosure: "" + enclosure.toString());
        }
    }
}","/**
 *  @see org.apache.wicket.application.IComponentOnBeforeRenderListener#onBeforeRender(org.apache.wicket.Component)
 */
","public void onAfterRender(final Component component) {
    if (log.isWarnEnabled()) {
        if ((component instanceof FormComponent) || (component instanceof IFormSubmittingComponent) || (component instanceof Form)) {
            log.warn(""Please note that onBeforeRender() and validate() might be called on invisible components inside an Enclosure. "" + ""Please see EnclosureContainer for an alternative. Enclosure: "" + enclosure.toString());
        }
    }
}",-0.3181818181818182,0.5612244897959184,-0.16666666666666666,0.0,0.08333333333333333,-0.1255561047948591,0.44995698308001153,-0.25,0.05714285714285714,-0.1201725193912995
Closure,165,2,"/**
 * Returns whether the given property can possibly be set on the given type.
 */
public boolean canPropertyBeDefined(JSType type, String propertyName) {
    if (typesIndexedByProperty.containsKey(propertyName)) {
        for (JSType alt : typesIndexedByProperty.get(propertyName).getAlternates()) {
            JSType greatestSubtype = alt.getGreatestSubtype(type);
            if (!greatestSubtype.isEmptyType()) {
                return true;
            }
        }
    }
    return false;
}","/**
 * Returns whether the given property can possibly be set on the given type.
 */
","public boolean canPropertyBeDefined(JSType type, String propertyName) {
    if (typesIndexedByProperty.containsKey(propertyName)) {
        for (JSType alt : typesIndexedByProperty.get(propertyName).getAlternates()) {
            JSType greatestSubtype = alt.getGreatestSubtype(type);
            if (!greatestSubtype.isEmptyType()) {
                return true;
            }
        }
    }
    return false;
}",-0.13636363636363635,1.040816326530612,0.0,0.5,0.0,-0.08403361344537813,0.18812733008316615,-0.08333333333333333,0.7142857142857143,-0.09457300594052621
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1829_ca36450e,1,"@Override
public PropertyValue currentProperty() {
    PropertyValue p = operand.currentProperty();
    if (p == null) {
        return null;
    }
    // TODO what is the expected result of LOWER(x) for an array property?
    // currently throws an exception
    String value = p.getValue(STRING);
    // TODO toLowerCase(): document the Turkish locale problem
    return PropertyValues.newString(value.toLowerCase());
}",,"@Override
public PropertyValue currentProperty() {
    PropertyValue p = operand.currentProperty();
    if (p == null) {
        return null;
    }
            String value = p.getValue(STRING);
        return PropertyValues.newString(value.toLowerCase());
}",-0.22727272727272727,-0.2602040816326532,-0.3333333333333333,-0.5,-0.25,-0.09787444389520514,0.3188987668482939,-0.16666666666666666,2.4571428571428573,-0.10793597765985241
camel,remotes/origin/bugs-dot-jar_CAMEL-5357_4cf7e80e,1,"public static String encode(String s) {
    int n = s == null ? 0 : s.length();
    if (n == 0) {
        return s;
    }
    // First check whether we actually need to encode
    char[] chars = s.toCharArray();
    for (int i = 0; ; ) {
        // just deal with the ascii character
        if (chars[i] > 0 && chars[i] < 128) {
            if (unsafeCharacters.get(chars[i])) {
                break;
            }
        }
        if (++i >= chars.length) {
            return s;
        }
    }
    // okay there are some unsafe characters so we do need to encode
    StringBuilder sb = new StringBuilder();
    for (char ch : chars) {
        if (ch > 0 && ch < 128 && unsafeCharacters.get(ch)) {
            appendEscape(sb, (byte) ch);
        } else {
            sb.append(ch);
        }
    }
    return sb.toString();
}",,"public static String encode(String s) {
    int n = s == null ? 0 : s.length();
    if (n == 0) {
        return s;
    }
        char[] chars = s.toCharArray();
    for (int i = 0; ; ) {
                if (chars[i] > 0 && chars[i] < 128) {
            if (unsafeCharacters.get(chars[i])) {
                break;
            }
        }
        if (++i >= chars.length) {
            return s;
        }
    }
        StringBuilder sb = new StringBuilder();
    for (char ch : chars) {
        if (ch > 0 && ch < 128 && unsafeCharacters.get(ch)) {
            appendEscape(sb, (byte) ch);
        } else {
            sb.append(ch);
        }
    }
    return sb.toString();
}",0.5454545454545454,0.46428571428571436,1.0,0.5,0.9166666666666666,1.1913000494315376,-0.4141095497562375,0.08333333333333333,0.14285714285714285,0.936714336498473
wicket,remotes/origin/bugs-dot-jar_WICKET-428_4a6a573b,3,"public Iterator iterator() {
    return new Iterator() {

        public boolean hasNext() {
            return i < size;
        }

        public Object next() {
            // Find next key
            i = nextKey(nextIndex(i));
            // Just in case... (WICKET-428)
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            // Get key
            return keys[i];
        }

        public void remove() {
            keys[i] = null;
            values[i] = null;
            size--;
        }

        int i = -1;
    };
}",,"public Iterator iterator() {
    return new Iterator() {

        public boolean hasNext() {
            return i < size;
        }

        public Object next() {
                        i = nextKey(nextIndex(i));
                        if (!hasNext()) {
                throw new NoSuchElementException();
            }
                        return keys[i];
        }

        public void remove() {
            keys[i] = null;
            values[i] = null;
            size--;
        }

        int i = -1;
    };
}",0.2727272727272727,0.5612244897959184,-0.16666666666666666,0.0,-0.25,0.2876915472071182,-0.13507312876398075,-0.25,2.6,0.05799187085887076
Math,76,1,"/**
 * {@inheritDoc}
 */
public RealMatrix getU() throws InvalidMatrixException {
    if (cachedU == null) {
        final int p = singularValues.length;
        if (m >= n) {
            // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
            final double[][] eData = e.getData();
            final double[][] wData = new double[m][p];
            double[] ei1 = eData[0];
            for (int i = 0; i < p - 1; ++i) {
                // compute W = B.E.S^(-1) where E is the eigenvectors matrix
                final double mi = mainBidiagonal[i];
                final double[] ei0 = ei1;
                final double[] wi = wData[i];
                ei1 = eData[i + 1];
                final double si = secondaryBidiagonal[i];
                for (int j = 0; j < p; ++j) {
                    wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                }
            }
            for (int j = 0; j < p; ++j) {
                wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
            }
            for (int i = p; i < m; ++i) {
                wData[i] = new double[p];
            }
            cachedU = transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));
        } else {
            // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
            cachedU = transformer.getU().multiply(e);
        }
    }
    // return the cached matrix
    return cachedU;
}","/**
 * {@inheritDoc}
 */
","public RealMatrix getU() throws InvalidMatrixException {
    if (cachedU == null) {
        final int p = singularValues.length;
        if (m >= n) {
                        final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
            final double[][] eData = e.getData();
            final double[][] wData = new double[m][p];
            double[] ei1 = eData[0];
            for (int i = 0; i < p - 1; ++i) {
                                final double mi = mainBidiagonal[i];
                final double[] ei0 = ei1;
                final double[] wi = wData[i];
                ei1 = eData[i + 1];
                final double si = secondaryBidiagonal[i];
                for (int j = 0; j < p; ++j) {
                    wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                }
            }
            for (int j = 0; j < p; ++j) {
                wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
            }
            for (int i = p; i < m; ++i) {
                wData[i] = new double[p];
            }
            cachedU = transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));
        } else {
                        final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
            cachedU = transformer.getU().multiply(e);
        }
    }
        return cachedU;
}",0.8181818181818182,0.9132653061224488,0.5,1.0,0.5833333333333334,2.3756796836381615,-0.6363636363636365,0.3333333333333333,-0.028571428571428574,4.954535915127997
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-498_f2a2edec,1,"@Override
public boolean name(String name, int index) {
    return true;
}",,"@Override
public boolean name(String name, int index) {
    return true;
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9446515629480932,-0.5,1.8285714285714287,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2799_3979fa8d,1,"@Override
public OakIndexInput clone() {
    return new OakIndexInput(this);
}",,"@Override
public OakIndexInput clone() {
    return new OakIndexInput(this);
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.0332664181244626,-0.5,2.0571428571428574,-0.16422749602751402
Closure,167,2,"private FlowScope caseNameOrGetProp(Node name, FlowScope blindScope, boolean outcome) {
    JSType type = getTypeIfRefinable(name, blindScope);
    if (type != null) {
        JSType restrictedType = type.getRestrictedTypeGivenToBooleanOutcome(outcome);
        FlowScope informed = blindScope.createChildFlowScope();
        declareNameInScope(informed, name, restrictedType);
        return informed;
    }
    return blindScope;
}",,"private FlowScope caseNameOrGetProp(Node name, FlowScope blindScope, boolean outcome) {
    JSType type = getTypeIfRefinable(name, blindScope);
    if (type != null) {
        JSType restrictedType = type.getRestrictedTypeGivenToBooleanOutcome(outcome);
        FlowScope informed = blindScope.createChildFlowScope();
        declareNameInScope(informed, name, restrictedType);
        return informed;
    }
    return blindScope;
}",-0.18181818181818182,-0.015306122448979493,-0.3333333333333333,-0.5,-0.25,-0.00889767671774591,0.20562087754516786,-0.16666666666666666,0.0,-0.0503724071766011
wicket,remotes/origin/bugs-dot-jar_WICKET-5176_34634266,3,"/**
 *  @see org.apache.wicket.model.IDetachable#detach()
 */
@Override
protected final void onDetach() {
    super.onDetach();
    // detach any model
    if (model != null) {
        model.detach();
    }
    // some parameters can be detachable
    if (parameters != null) {
        for (Object parameter : parameters) {
            if (parameter instanceof IDetachable) {
                ((IDetachable) parameter).detach();
            }
        }
    }
    if (defaultValue != null) {
        defaultValue.detach();
    }
}","/**
 *  @see org.apache.wicket.model.IDetachable#detach()
 */
","@Override
protected final void onDetach() {
    super.onDetach();
        if (model != null) {
        model.detach();
    }
        if (parameters != null) {
        for (Object parameter : parameters) {
            if (parameter instanceof IDetachable) {
                ((IDetachable) parameter).detach();
            }
        }
    }
    if (defaultValue != null) {
        defaultValue.detach();
    }
}",0.13636363636363635,0.6836734693877553,0.3333333333333333,0.5,0.25,-0.3806228373702422,0.0008603383997706093,-0.16666666666666666,0.6285714285714287,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-705_645d642b,1,"/**
 * Reinitialize the instance
 * <p>Some Runge-Kutta integrators need fewer functions evaluations
 * than their counterpart step interpolators. So the interpolator
 * should perform the last evaluations they need by themselves. The
 * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link
 * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}
 * abstract classes call this method in order to let the step
 * interpolator perform the evaluations it needs. These evaluations
 * will be performed during the call to <code>doFinalize</code> if
 * any, i.e. only if the step handler either calls the {@link
 * AbstractStepInterpolator#finalizeStep finalizeStep} method or the
 * {@link AbstractStepInterpolator#getInterpolatedState
 * getInterpolatedState} method (for an interpolator which needs a
 * finalization) or if it clones the step interpolator.</p>
 * @param rkIntegrator integrator being used
 * @param y reference to the integrator array holding the state at
 * the end of the step
 * @param yDotArray reference to the integrator array holding all the
 * intermediate slopes
 * @param forward integration direction indicator
 * @param primaryMapper equations mapper for the primary equations set
 * @param secondaryMappers equations mappers for the secondary equations sets
 */
public void reinitialize(final AbstractIntegrator rkIntegrator, final double[] y, final double[][] yDotArray, final boolean forward, final EquationsMapper primaryMapper, final EquationsMapper[] secondaryMappers) {
    reinitialize(y, forward, primaryMapper, secondaryMappers);
    this.yDotK = yDotArray;
    this.integrator = rkIntegrator;
}","/**
 * Reinitialize the instance
 * <p>Some Runge-Kutta integrators need fewer functions evaluations
 * than their counterpart step interpolators. So the interpolator
 * should perform the last evaluations they need by themselves. The
 * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link
 * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}
 * abstract classes call this method in order to let the step
 * interpolator perform the evaluations it needs. These evaluations
 * will be performed during the call to <code>doFinalize</code> if
 * any, i.e. only if the step handler either calls the {@link
 * AbstractStepInterpolator#finalizeStep finalizeStep} method or the
 * {@link AbstractStepInterpolator#getInterpolatedState
 * getInterpolatedState} method (for an interpolator which needs a
 * finalization) or if it clones the step interpolator.</p>
 * @param rkIntegrator integrator being used
 * @param y reference to the integrator array holding the state at
 * the end of the step
 * @param yDotArray reference to the integrator array holding all the
 * intermediate slopes
 * @param forward integration direction indicator
 * @param primaryMapper equations mapper for the primary equations set
 * @param secondaryMappers equations mappers for the secondary equations sets
 */
","public void reinitialize(final AbstractIntegrator rkIntegrator, final double[] y, final double[][] yDotArray, final boolean forward, final EquationsMapper primaryMapper, final EquationsMapper[] secondaryMappers) {
    reinitialize(y, forward, primaryMapper, secondaryMappers);
    this.yDotK = yDotArray;
    this.integrator = rkIntegrator;
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.6168626326355032,-0.4166666666666667,-0.028571428571428574,-0.16422749602751402
Math,98,1,"/**
 * @param v vector to operate on
 * @throws IllegalArgumentException if columnDimension != v.length
 * @return resulting vector
 */
public double[] operate(double[] v) throws IllegalArgumentException {
    final int nRows = this.getRowDimension();
    final int nCols = this.getColumnDimension();
    if (v.length != nCols) {
        throw new IllegalArgumentException(""vector has wrong length"");
    }
    final double[] out = new double[v.length];
    for (int row = 0; row < nRows; row++) {
        final double[] dataRow = data[row];
        double sum = 0;
        for (int i = 0; i < nCols; i++) {
            sum += dataRow[i] * v[i];
        }
        out[row] = sum;
    }
    return out;
}","/**
 * @param v vector to operate on
 * @throws IllegalArgumentException if columnDimension != v.length
 * @return resulting vector
 */
","public double[] operate(double[] v) throws IllegalArgumentException {
    final int nRows = this.getRowDimension();
    final int nCols = this.getColumnDimension();
    if (v.length != nCols) {
        throw new IllegalArgumentException(""vector has wrong length"");
    }
    final double[] out = new double[v.length];
    for (int row = 0; row < nRows; row++) {
        final double[] dataRow = data[row];
        double sum = 0;
        for (int i = 0; i < nCols; i++) {
            sum += dataRow[i] * v[i];
        }
        out[row] = sum;
    }
    return out;
}",0.13636363636363635,0.015306122448979493,0.16666666666666666,0.0,0.25,1.0153237765694514,-0.14453685116145706,-0.3333333333333333,1.342857142857143,0.5879579066390841
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1932_913c2f53,1,"public void compact() {
    long start = System.nanoTime();
    log.info(""TarMK compaction started"");
    SegmentWriter writer = new SegmentWriter(this, tracker);
    Compactor compactor = new Compactor(writer);
    SegmentNodeState before = getHead();
    SegmentNodeState after = compactor.compact(EMPTY_NODE, before);
    while (!setHead(before, after)) {
        // Some other concurrent changes have been made.
        // Rebase (and compact) those changes on top of the
        // compacted state before retrying to set the head.
        SegmentNodeState head = getHead();
        after = compactor.compact(before, head);
        before = head;
    }
    tracker.setCompactionMap(compactor.getCompactionMap());
    log.info(""TarMK compaction completed in {}ms"", MILLISECONDS.convert(System.nanoTime() - start, NANOSECONDS));
    cleanupNeeded.set(true);
}",,"public void compact() {
    long start = System.nanoTime();
    log.info(""TarMK compaction started"");
    SegmentWriter writer = new SegmentWriter(this, tracker);
    Compactor compactor = new Compactor(writer);
    SegmentNodeState before = getHead();
    SegmentNodeState after = compactor.compact(EMPTY_NODE, before);
    while (!setHead(before, after)) {
                                SegmentNodeState head = getHead();
        after = compactor.compact(before, head);
        before = head;
    }
    tracker.setCompactionMap(compactor.getCompactionMap());
    log.info(""TarMK compaction completed in {}ms"", MILLISECONDS.convert(System.nanoTime() - start, NANOSECONDS));
    cleanupNeeded.set(true);
}",0.09090909090909091,-0.40816326530612235,-0.3333333333333333,-0.5,-0.08333333333333333,-0.012852199703410724,-0.13421279036421016,0.5833333333333334,-0.028571428571428574,0.0909795657890792
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2430_be3a9114,1,"@Override
public boolean propertyChanged(PropertyState before, PropertyState after) {
    if (!loader.isRunning()) {
        return false;
    }
    builder.setProperty(binaryCheck(after));
    return true;
}",,"@Override
public boolean propertyChanged(PropertyState before, PropertyState after) {
    if (!loader.isRunning()) {
        return false;
    }
    builder.setProperty(binaryCheck(after));
    return true;
}",-0.2727272727272727,-0.1887755102040817,-0.3333333333333333,-0.5,-0.25,-0.3806228373702422,0.4350444508173216,-0.25,0.4571428571428572,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-520_ec961a38,1,"@Override
public void remove(NodeBuilder index, String key, Iterable<String> values) {
    if (!index.hasChildNode(key)) {
        return;
    }
    NodeBuilder child = index.child(key);
    Queue<NodeBuilder> parentQueue = new LinkedList<NodeBuilder>();
    for (String rm : values) {
        if (PathUtils.denotesRoot(rm)) {
            child.removeProperty(""match"");
        } else {
            NodeBuilder indexEntry = child;
            Iterator<String> segments = PathUtils.elements(rm).iterator();
            while (segments.hasNext()) {
                String segment = segments.next();
                if (segments.hasNext()) {
                    parentQueue.add(indexEntry);
                    indexEntry = indexEntry.child(segment);
                } else {
                    // last segment
                    if (indexEntry.hasChildNode(segment)) {
                        indexEntry.removeNode(segment);
                    }
                }
            }
        }
    }
    // finally remove the index node if empty
    if (child.getChildNodeCount() == 0) {
        index.removeNode(key);
    }
}",,"@Override
public void remove(NodeBuilder index, String key, Iterable<String> values) {
    if (!index.hasChildNode(key)) {
        return;
    }
    NodeBuilder child = index.child(key);
    Queue<NodeBuilder> parentQueue = new LinkedList<NodeBuilder>();
    for (String rm : values) {
        if (PathUtils.denotesRoot(rm)) {
            child.removeProperty(""match"");
        } else {
            NodeBuilder indexEntry = child;
            Iterator<String> segments = PathUtils.elements(rm).iterator();
            while (segments.hasNext()) {
                String segment = segments.next();
                if (segments.hasNext()) {
                    parentQueue.add(indexEntry);
                    indexEntry = indexEntry.child(segment);
                } else {
                                        if (indexEntry.hasChildNode(segment)) {
                        indexEntry.removeNode(segment);
                    }
                }
            }
        }
    }
        if (child.getChildNodeCount() == 0) {
        index.removeNode(key);
    }
}",0.7272727272727273,1.903061224489796,0.6666666666666666,1.5,0.75,0.06030647553138907,-0.4961284772010325,0.75,-0.028571428571428574,0.20922045048633506
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1025_a96b455c,1,"/*
     * TODO consider making public.
     */
private void mapLog4jToJul(Level level, java.util.logging.Level julLevel) {
    log4jToJul.put(level, julLevel);
}",,"private void mapLog4jToJul(Level level, java.util.logging.Level julLevel) {
    log4jToJul.put(level, julLevel);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9486664754803554,-0.4166666666666667,2.4,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-3998_b76f9c44,3,"/**
 *  Check if the credit card is a Visa. A Visa number has to start with a 4 and has to have a
 *  length of 13 or 16 digits. The number has to be validated with the Luhn algorithm.
 *
 *  @param creditCardNumber
 *             the credit card number as a string
 *  @return The credit card id of the issuer
 */
private CreditCard isVisa(String creditCardNumber) {
    if (creditCardNumber.length() == 13 || creditCardNumber.length() == 16) {
        if (creditCardNumber.startsWith(""4"")) {
            return CreditCard.SWITCH;
        }
    }
    return CreditCard.INVALID;
}","/**
 *  Check if the credit card is a Visa. A Visa number has to start with a 4 and has to have a
 *  length of 13 or 16 digits. The number has to be validated with the Luhn algorithm.
 *
 *  @param creditCardNumber
 *             the credit card number as a string
 *  @return The credit card id of the issuer
 */
","private CreditCard isVisa(String creditCardNumber) {
    if (creditCardNumber.length() == 13 || creditCardNumber.length() == 16) {
        if (creditCardNumber.startsWith(""4"")) {
            return CreditCard.SWITCH;
        }
    }
    return CreditCard.INVALID;
}",-0.2727272727272727,0.43367346938775514,-0.16666666666666666,0.0,0.0,-0.08403361344537813,0.3880126182965301,-0.25,2.0571428571428574,-0.11286143197947585
Closure,175,2,"/**
 * @param t  The traversal use to reach the call site.
 * @param callNode The CALL node.
 * @param fnNode The function to evaluate for inlining.
 * @param needAliases A set of function parameter names that can not be
 *     used without aliasing. Returned by getUnsafeParameterNames().
 * @param mode Inlining mode to be used.
 * @param referencesThis Whether fnNode contains references to its this
 *     object.
 * @param containsFunctions Whether fnNode contains inner functions.
 * @return Whether the inlining can occur.
 */
CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set<String> needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) {
    // Allow direct function calls or ""fn.call"" style calls.
    if (!isSupportedCallType(callNode)) {
        return CanInlineResult.NO;
    }
    // last until explicitly cleared.
    if (containsFunctions) {
        if (!assumeMinimumCapture && !t.inGlobalScope()) {
            // inner functions.
            return CanInlineResult.NO;
        } else if (NodeUtil.isWithinLoop(callNode)) {
            // single iteration through a loop.
            return CanInlineResult.NO;
        }
    }
    // TODO(johnlenz): Add support for 'apply'
    if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {
        // global 'this' object.
        return CanInlineResult.NO;
    }
    if (mode == InliningMode.DIRECT) {
        return canInlineReferenceDirectly(callNode, fnNode);
    } else {
        return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);
    }
}","/**
 * @param t  The traversal use to reach the call site.
 * @param callNode The CALL node.
 * @param fnNode The function to evaluate for inlining.
 * @param needAliases A set of function parameter names that can not be
 *     used without aliasing. Returned by getUnsafeParameterNames().
 * @param mode Inlining mode to be used.
 * @param referencesThis Whether fnNode contains references to its this
 *     object.
 * @param containsFunctions Whether fnNode contains inner functions.
 * @return Whether the inlining can occur.
 */
","CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set<String> needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) {
        if (!isSupportedCallType(callNode)) {
        return CanInlineResult.NO;
    }
        if (containsFunctions) {
        if (!assumeMinimumCapture && !t.inGlobalScope()) {
                        return CanInlineResult.NO;
        } else if (NodeUtil.isWithinLoop(callNode)) {
                        return CanInlineResult.NO;
        }
    }
        if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {
                return CanInlineResult.NO;
    }
    if (mode == InliningMode.DIRECT) {
        return canInlineReferenceDirectly(callNode, fnNode);
    } else {
        return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);
    }
}",0.2727272727272727,0.10204081632653071,0.5,0.5,1.0,-0.0009886307464161926,-0.2423286492687125,0.0,-0.028571428571428574,0.053203472659445535
Closure,68,2,"/**
 * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName
 *     | FunctionType | UnionType | RecordType | ArrayType
 */
private Node parseBasicTypeExpression(JsDocToken token) {
    if (token == JsDocToken.STAR) {
        return newNode(Token.STAR);
    } else if (token == JsDocToken.LB) {
        skipEOLs();
        return parseArrayType(next());
    } else if (token == JsDocToken.LC) {
        skipEOLs();
        return parseRecordType(next());
    } else if (token == JsDocToken.LP) {
        skipEOLs();
        return parseUnionType(next());
    } else if (token == JsDocToken.STRING) {
        String string = stream.getString();
        if (""function"".equals(string)) {
            skipEOLs();
            return parseFunctionType(next());
        } else if (""null"".equals(string) || ""undefined"".equals(string)) {
            return newStringNode(string);
        } else {
            return parseTypeName(token);
        }
    }
    return reportGenericTypeSyntaxWarning();
}","/**
 * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName
 *     | FunctionType | UnionType | RecordType | ArrayType
 */
","private Node parseBasicTypeExpression(JsDocToken token) {
    if (token == JsDocToken.STAR) {
        return newNode(Token.STAR);
    } else if (token == JsDocToken.LB) {
        skipEOLs();
        return parseArrayType(next());
    } else if (token == JsDocToken.LC) {
        skipEOLs();
        return parseRecordType(next());
    } else if (token == JsDocToken.LP) {
        skipEOLs();
        return parseUnionType(next());
    } else if (token == JsDocToken.STRING) {
        String string = stream.getString();
        if (""function"".equals(string)) {
            skipEOLs();
            return parseFunctionType(next());
        } else if (""null"".equals(string) || ""undefined"".equals(string)) {
            return newStringNode(string);
        } else {
            return parseTypeName(token);
        }
    }
    return reportGenericTypeSyntaxWarning();
}",0.5,0.14285714285714277,0.6666666666666666,2.5,0.6666666666666666,-0.01878398418190801,-0.37166618870088936,1.1666666666666667,0.0,0.07060103391710673
wicket,remotes/origin/bugs-dot-jar_WICKET-4927_8c827e33,1,"@Override
public void clearCookie(Cookie cookie) {
    checkHeader();
    bufferedResponse.clearCookie(cookie);
}",,"@Override
public void clearCookie(Cookie cookie) {
    checkHeader();
    bufferedResponse.clearCookie(cookie);
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7912245483223405,-0.3333333333333333,1.5999999999999999,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd,1,"public double getCost(Filter filter, String propertyName, PropertyValue value) {
    NodeState indexMeta = getIndexNode(root, propertyName, filter);
    if (indexMeta == null) {
        return Double.POSITIVE_INFINITY;
    }
    return COST_OVERHEAD + getStrategy(indexMeta).count(indexMeta, encode(value), MAX_COST);
}",,"public double getCost(Filter filter, String propertyName, PropertyValue value) {
    NodeState indexMeta = getIndexNode(root, propertyName, filter);
    if (indexMeta == null) {
        return Double.POSITIVE_INFINITY;
    }
    return COST_OVERHEAD + getStrategy(indexMeta).count(indexMeta, encode(value), MAX_COST);
}",-0.3181818181818182,-0.2346938775510204,-0.3333333333333333,-0.5,-0.25,-0.12357884330202666,0.38285058789790644,-0.16666666666666666,0.0,-0.09118514996937653
Math,53,1,"/**
 * Return the sum of this complex number and the given complex number.
 * <p>
 * Uses the definitional formula
 * <pre>
 * (a + bi) + (c + di) = (a+c) + (b+d)i
 * </pre></p>
 * <p>
 * If either this or <code>rhs</code> has a NaN value in either part,
 * {@link #NaN} is returned; otherwise Infinite and NaN values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic.</p>
 *
 * @param rhs the other complex number
 * @return the complex number sum
 * @throws NullArgumentException if <code>rhs</code> is null
 */
public Complex add(Complex rhs) throws NullArgumentException {
    MathUtils.checkNotNull(rhs);
    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());
}","/**
 * Return the sum of this complex number and the given complex number.
 * <p>
 * Uses the definitional formula
 * <pre>
 * (a + bi) + (c + di) = (a+c) + (b+d)i
 * </pre></p>
 * <p>
 * If either this or <code>rhs</code> has a NaN value in either part,
 * {@link #NaN} is returned; otherwise Infinite and NaN values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic.</p>
 *
 * @param rhs the other complex number
 * @return the complex number sum
 * @throws NullArgumentException if <code>rhs</code> is null
 */
","public Complex add(Complex rhs) throws NullArgumentException {
    MathUtils.checkNotNull(rhs);
    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7505018640665331,-0.16666666666666666,1.2571428571428573,-0.16422749602751402
Closure,148,2,"private void addCharEntry(String id) throws IOException {
    if (firstChar) {
        firstChar = false;
    } else {
        out.append("","");
    }
    out.append(id);
}",,"private void addCharEntry(String id) throws IOException {
    if (firstChar) {
        firstChar = false;
    } else {
        out.append("","");
    }
    out.append(id);
}",-0.2727272727272727,-0.09693877551020405,-0.3333333333333333,-0.5,-0.25,-0.3806228373702422,0.4591339260108975,-0.3333333333333333,1.7714285714285716,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-7429_43956f93,1,"private String doParseUri(String uri, Properties properties, List<String> replaced, String prefixToken, String suffixToken, String propertyPrefix, String propertySuffix, boolean fallbackToUnaugmentedProperty) {
    StringBuilder sb = new StringBuilder();
    int pivot = 0;
    int size = uri.length();
    while (pivot < size) {
        int idx = findTokenPosition(uri, pivot, prefixToken);
        if (idx < 0) {
            sb.append(createConstantPart(uri, pivot, size));
            break;
        } else {
            if (pivot < idx) {
                sb.append(createConstantPart(uri, pivot, idx));
            }
            pivot = idx + prefixToken.length();
            int endIdx = findTokenPosition(uri, pivot, suffixToken);
            if (endIdx < 0) {
                throw new IllegalArgumentException(""Expecting "" + suffixToken + "" but found end of string from text: "" + uri);
            }
            String key = uri.substring(pivot, endIdx);
            String augmentedKey = key;
            if (propertyPrefix != null) {
                log.debug(""Augmenting property key [{}] with prefix: {}"", key, propertyPrefix);
                augmentedKey = propertyPrefix + augmentedKey;
            }
            if (propertySuffix != null) {
                log.debug(""Augmenting property key [{}] with suffix: {}"", key, propertySuffix);
                augmentedKey = augmentedKey + propertySuffix;
            }
            String part = createPlaceholderPart(augmentedKey, properties, replaced, prefixToken, suffixToken);
            // Note: Only fallback to unaugmented when the original key was actually augmented
            if (part == null && fallbackToUnaugmentedProperty && (propertyPrefix != null || propertySuffix != null)) {
                log.debug(""Property wth key [{}] not found, attempting with unaugmented key: {}"", augmentedKey, key);
                part = createPlaceholderPart(key, properties, replaced, prefixToken, suffixToken);
            }
            if (part == null) {
                StringBuilder esb = new StringBuilder();
                esb.append(""Property with key ["").append(augmentedKey).append(""] "");
                if (fallbackToUnaugmentedProperty && (propertyPrefix != null || propertySuffix != null)) {
                    esb.append(""(and original key ["").append(key).append(""]) "");
                }
                esb.append(""not found in properties from text: "").append(uri);
                throw new IllegalArgumentException(esb.toString());
            }
            sb.append(part);
            pivot = endIdx + suffixToken.length();
        }
    }
    return sb.toString();
}",,"private String doParseUri(String uri, Properties properties, List<String> replaced, String prefixToken, String suffixToken, String propertyPrefix, String propertySuffix, boolean fallbackToUnaugmentedProperty) {
    StringBuilder sb = new StringBuilder();
    int pivot = 0;
    int size = uri.length();
    while (pivot < size) {
        int idx = findTokenPosition(uri, pivot, prefixToken);
        if (idx < 0) {
            sb.append(createConstantPart(uri, pivot, size));
            break;
        } else {
            if (pivot < idx) {
                sb.append(createConstantPart(uri, pivot, idx));
            }
            pivot = idx + prefixToken.length();
            int endIdx = findTokenPosition(uri, pivot, suffixToken);
            if (endIdx < 0) {
                throw new IllegalArgumentException(""Expecting "" + suffixToken + "" but found end of string from text: "" + uri);
            }
            String key = uri.substring(pivot, endIdx);
            String augmentedKey = key;
            if (propertyPrefix != null) {
                log.debug(""Augmenting property key [{}] with prefix: {}"", key, propertyPrefix);
                augmentedKey = propertyPrefix + augmentedKey;
            }
            if (propertySuffix != null) {
                log.debug(""Augmenting property key [{}] with suffix: {}"", key, propertySuffix);
                augmentedKey = augmentedKey + propertySuffix;
            }
            String part = createPlaceholderPart(augmentedKey, properties, replaced, prefixToken, suffixToken);
                        if (part == null && fallbackToUnaugmentedProperty && (propertyPrefix != null || propertySuffix != null)) {
                log.debug(""Property wth key [{}] not found, attempting with unaugmented key: {}"", augmentedKey, key);
                part = createPlaceholderPart(key, properties, replaced, prefixToken, suffixToken);
            }
            if (part == null) {
                StringBuilder esb = new StringBuilder();
                esb.append(""Property with key ["").append(augmentedKey).append(""] "");
                if (fallbackToUnaugmentedProperty && (propertyPrefix != null || propertySuffix != null)) {
                    esb.append(""(and original key ["").append(key).append(""]) "");
                }
                esb.append(""not found in properties from text: "").append(uri);
                throw new IllegalArgumentException(esb.toString());
            }
            sb.append(part);
            pivot = endIdx + suffixToken.length();
        }
    }
    return sb.toString();
}",1.5454545454545454,0.8010204081632653,1.5,1.0,1.4166666666666667,1.7686604053386064,-0.9059363349584173,1.6666666666666667,-0.028571428571428574,5.115435517236949
commons-math,remotes/origin/bugs-dot-jar_MATH-1058_4ebd967c,3,"/**
 * Returns the regularized beta function I(x, a, b).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedBetaFunction.html"">
 * Regularized Beta Function</a>.</li>
 * <li>
 * <a href=""http://functions.wolfram.com/06.21.10.0001.01"">
 * Regularized Beta Function</a>.</li>
 * </ul>
 *
 * @param x the value.
 * @param a Parameter {@code a}.
 * @param b Parameter {@code b}.
 * @param epsilon When the absolute value of the nth item in the
 * series is less than epsilon the approximation ceases to calculate
 * further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized beta function I(x, a, b)
 * @throws org.apache.commons.math3.exception.MaxCountExceededException
 * if the algorithm fails to converge.
 */
public static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations) {
    double ret;
    if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || x < 0 || x > 1 || a <= 0.0 || b <= 0.0) {
        ret = Double.NaN;
    } else if (x > (a + 1.0) / (a + b + 2.0)) {
        ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);
    } else {
        ContinuedFraction fraction = new ContinuedFraction() {

            @Override
            protected double getB(int n, double x) {
                double ret;
                double m;
                if (n % 2 == 0) {
                    // even
                    m = n / 2.0;
                    ret = (m * (b - m) * x) / ((a + (2 * m) - 1) * (a + (2 * m)));
                } else {
                    m = (n - 1.0) / 2.0;
                    ret = -((a + m) * (a + b + m) * x) / ((a + (2 * m)) * (a + (2 * m) + 1.0));
                }
                return ret;
            }

            @Override
            protected double getA(int n, double x) {
                return 1.0;
            }
        };
        ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log(1.0 - x)) - FastMath.log(a) - logBeta(a, b)) * 1.0 / fraction.evaluate(x, epsilon, maxIterations);
    }
    return ret;
}","/**
 * Returns the regularized beta function I(x, a, b).
 *
 * The implementation of this method is based on:
 * <ul>
 * <li>
 * <a href=""http://mathworld.wolfram.com/RegularizedBetaFunction.html"">
 * Regularized Beta Function</a>.</li>
 * <li>
 * <a href=""http://functions.wolfram.com/06.21.10.0001.01"">
 * Regularized Beta Function</a>.</li>
 * </ul>
 *
 * @param x the value.
 * @param a Parameter {@code a}.
 * @param b Parameter {@code b}.
 * @param epsilon When the absolute value of the nth item in the
 * series is less than epsilon the approximation ceases to calculate
 * further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete.
 * @return the regularized beta function I(x, a, b)
 * @throws org.apache.commons.math3.exception.MaxCountExceededException
 * if the algorithm fails to converge.
 */
","public static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations) {
    double ret;
    if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || x < 0 || x > 1 || a <= 0.0 || b <= 0.0) {
        ret = Double.NaN;
    } else if (x > (a + 1.0) / (a + b + 2.0)) {
        ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);
    } else {
        ContinuedFraction fraction = new ContinuedFraction() {

            @Override
            protected double getB(int n, double x) {
                double ret;
                double m;
                if (n % 2 == 0) {
                                        m = n / 2.0;
                    ret = (m * (b - m) * x) / ((a + (2 * m) - 1) * (a + (2 * m)));
                } else {
                    m = (n - 1.0) / 2.0;
                    ret = -((a + m) * (a + b + m) * x) / ((a + (2 * m)) * (a + (2 * m) + 1.0));
                }
                return ret;
            }

            @Override
            protected double getA(int n, double x) {
                return 1.0;
            }
        };
        ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log(1.0 - x)) - FastMath.log(a) - logBeta(a, b)) * 1.0 / fraction.evaluate(x, epsilon, maxIterations);
    }
    return ret;
}",0.7272727272727273,1.5306122448979589,0.0,1.0,0.9166666666666666,3.6767177459218985,-0.5970748494407804,0.3333333333333333,-0.028571428571428574,7.926405146457315
commons-math,remotes/origin/bugs-dot-jar_MATH-867_bfbb156d,1,"/**
 * Checks dimensions and values of boundaries and inputSigma if defined.
 */
private void checkParameters() {
    final double[] init = getStartPoint();
    final double[] lB = getLowerBound();
    final double[] uB = getUpperBound();
    // Checks whether there is at least one finite bound value.
    boolean hasFiniteBounds = false;
    for (int i = 0; i < lB.length; i++) {
        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {
            hasFiniteBounds = true;
            break;
        }
    }
    // Checks whether there is at least one infinite bound value.
    boolean hasInfiniteBounds = false;
    if (hasFiniteBounds) {
        for (int i = 0; i < lB.length; i++) {
            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {
                hasInfiniteBounds = true;
                break;
            }
        }
        if (hasInfiniteBounds) {
            // because mixed cases are not supported by the current code.
            throw new MathUnsupportedOperationException();
        } else {
            // Convert API to internal handling of boundaries.
            boundaries = new double[2][];
            boundaries[0] = lB;
            boundaries[1] = uB;
            // Abort early if the normalization will overflow (cf. ""encode"" method).
            for (int i = 0; i < lB.length; i++) {
                if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {
                    final double max = Double.MAX_VALUE + boundaries[0][i];
                    final NumberIsTooLargeException e = new NumberIsTooLargeException(boundaries[1][i], max, true);
                    e.getContext().addMessage(LocalizedFormats.OVERFLOW);
                    e.getContext().addMessage(LocalizedFormats.INDEX, i);
                    throw e;
                }
            }
        }
    } else {
        // Convert API to internal handling of boundaries.
        boundaries = null;
    }
    if (inputSigma != null) {
        if (inputSigma.length != init.length) {
            throw new DimensionMismatchException(inputSigma.length, init.length);
        }
        for (int i = 0; i < init.length; i++) {
            if (inputSigma[i] < 0) {
                throw new NotPositiveException(inputSigma[i]);
            }
            if (boundaries != null) {
                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {
                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);
                }
            }
        }
    }
}","/**
 * Checks dimensions and values of boundaries and inputSigma if defined.
 */
","private void checkParameters() {
    final double[] init = getStartPoint();
    final double[] lB = getLowerBound();
    final double[] uB = getUpperBound();
        boolean hasFiniteBounds = false;
    for (int i = 0; i < lB.length; i++) {
        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {
            hasFiniteBounds = true;
            break;
        }
    }
        boolean hasInfiniteBounds = false;
    if (hasFiniteBounds) {
        for (int i = 0; i < lB.length; i++) {
            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {
                hasInfiniteBounds = true;
                break;
            }
        }
        if (hasInfiniteBounds) {
                        throw new MathUnsupportedOperationException();
        } else {
                        boundaries = new double[2][];
            boundaries[0] = lB;
            boundaries[1] = uB;
                        for (int i = 0; i < lB.length; i++) {
                if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {
                    final double max = Double.MAX_VALUE + boundaries[0][i];
                    final NumberIsTooLargeException e = new NumberIsTooLargeException(boundaries[1][i], max, true);
                    e.getContext().addMessage(LocalizedFormats.OVERFLOW);
                    e.getContext().addMessage(LocalizedFormats.INDEX, i);
                    throw e;
                }
            }
        }
    } else {
                boundaries = null;
    }
    if (inputSigma != null) {
        if (inputSigma.length != init.length) {
            throw new DimensionMismatchException(inputSigma.length, init.length);
        }
        for (int i = 0; i < init.length; i++) {
            if (inputSigma[i] < 0) {
                throw new NotPositiveException(inputSigma[i]);
            }
            if (boundaries != null) {
                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {
                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);
                }
            }
        }
    }
}",1.8181818181818181,1.2244897959183674,3.0,1.0,1.8333333333333333,2.7829955511616413,-0.9968454258675084,0.5,-0.028571428571428574,6.4951837622761595
wicket,remotes/origin/bugs-dot-jar_WICKET-5724_b92591f6,1,"@Override
protected final MarkupElement onComponentTag(ComponentTag tag) throws ParseException {
    if (tag.isClose()) {
        return tag;
    }
    String wicketIdAttr = getWicketNamespace() + "":"" + ""id"";
    // Don't touch any wicket:id component and any auto-components
    if ((tag instanceof WicketTag) || (tag.isAutolinkEnabled() == true) || (tag.getAttributes().get(wicketIdAttr) != null)) {
        return tag;
    }
    // behavior that prepends the relative path.
    for (String attrName : attributeNames) {
        String attrValue = tag.getAttributes().getString(attrName);
        if ((attrValue != null) && (attrValue.startsWith(""/"") == false) && (!attrValue.contains("":"")) && !(attrValue.startsWith(""#""))) {
            if (tag.getId() == null) {
                tag.setId(getWicketRelativePathPrefix(null));
                tag.setAutoComponentTag(true);
            }
            tag.addBehavior(RELATIVE_PATH_BEHAVIOR);
            tag.setModified(true);
            break;
        }
    }
    return tag;
}",,"@Override
protected final MarkupElement onComponentTag(ComponentTag tag) throws ParseException {
    if (tag.isClose()) {
        return tag;
    }
    String wicketIdAttr = getWicketNamespace() + "":"" + ""id"";
        if ((tag instanceof WicketTag) || (tag.isAutolinkEnabled() == true) || (tag.getAttributes().get(wicketIdAttr) != null)) {
        return tag;
    }
        for (String attrName : attributeNames) {
        String attrValue = tag.getAttributes().getString(attrName);
        if ((attrValue != null) && (attrValue.startsWith(""/"") == false) && (!attrValue.contains("":"")) && !(attrValue.startsWith(""#""))) {
            if (tag.getId() == null) {
                tag.setId(getWicketRelativePathPrefix(null));
                tag.setAutoComponentTag(true);
            }
            tag.addBehavior(RELATIVE_PATH_BEHAVIOR);
            tag.setModified(true);
            break;
        }
    }
    return tag;
}",0.4090909090909091,0.8622448979591837,0.5,0.5,1.1666666666666667,0.7048937221947604,-0.37281330656724987,0.8333333333333334,-0.028571428571428574,0.7986474274137939
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1429_279bb3ce,1,"/**
 * Returns the commit root path for the given <code>revision</code> or
 * <code>null</code> if this document does not have a commit root entry for
 * the given <code>revision</code>.
 *
 * @param revision a revision.
 * @return the commit root path or <code>null</code>.
 */
@CheckForNull
public String getCommitRootPath(Revision revision) {
    // check local map first
    Map<Revision, String> local = getLocalCommitRoot();
    String depth = local.get(revision);
    if (depth != null) {
        if (depth.equals(""0"")) {
            return ""/"";
        }
        String p = Utils.getPathFromId(getId());
        return PathUtils.getAncestorPath(p, PathUtils.getDepth(p) - Integer.parseInt(depth));
    }
    // check previous
    for (NodeDocument prev : getPreviousDocs(COMMIT_ROOT, revision)) {
        String path = prev.getCommitRootPath(revision);
        if (path != null) {
            return path;
        }
    }
    return null;
}","/**
 * Returns the commit root path for the given <code>revision</code> or
 * <code>null</code> if this document does not have a commit root entry for
 * the given <code>revision</code>.
 *
 * @param revision a revision.
 * @return the commit root path or <code>null</code>.
 */
","@CheckForNull
public String getCommitRootPath(Revision revision) {
        Map<Revision, String> local = getLocalCommitRoot();
    String depth = local.get(revision);
    if (depth != null) {
        if (depth.equals(""0"")) {
            return ""/"";
        }
        String p = Utils.getPathFromId(getId());
        return PathUtils.getAncestorPath(p, PathUtils.getDepth(p) - Integer.parseInt(depth));
    }
        for (NodeDocument prev : getPreviousDocs(COMMIT_ROOT, revision)) {
        String path = prev.getCommitRootPath(revision);
        if (path != null) {
            return path;
        }
    }
    return null;
}",0.22727272727272727,0.2499999999999999,0.16666666666666666,0.0,0.08333333333333333,-0.040533860603064735,-0.21651849727559505,0.3333333333333333,0.028571428571428574,0.046230742544361214
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-185_7fe28a0e,3,"/**
 * @see Node#setProperty(String, javax.jcr.Value, int)
 */
@Override
@Nonnull
public Property setProperty(String jcrName, Value value, int type) throws RepositoryException {
    checkStatus();
    int targetType = getTargetType(value, type);
    Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());
    if (value == null) {
        Property p = getProperty(jcrName);
        p.remove();
        return p;
    } else {
        String oakName = sessionDelegate.getOakPathOrThrow(jcrName);
        CoreValue oakValue = ValueConverter.toCoreValue(targetValue, sessionDelegate);
        return new PropertyImpl(dlg.setProperty(oakName, oakValue));
    }
}","/**
 * @see Node#setProperty(String, javax.jcr.Value, int)
 */
","@Override
@Nonnull
public Property setProperty(String jcrName, Value value, int type) throws RepositoryException {
    checkStatus();
    int targetType = getTargetType(value, type);
    Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());
    if (value == null) {
        Property p = getProperty(jcrName);
        p.remove();
        return p;
    } else {
        String oakName = sessionDelegate.getOakPathOrThrow(jcrName);
        CoreValue oakValue = ValueConverter.toCoreValue(targetValue, sessionDelegate);
        return new PropertyImpl(dlg.setProperty(oakName, oakValue));
    }
}",0.09090909090909091,0.051020408163265356,-0.3333333333333333,-0.5,-0.25,-0.07414730598121598,-0.11012331517063391,0.25,0.0,0.016421036401248913
camel,remotes/origin/bugs-dot-jar_CAMEL-3878_b9094cb5,1,"@Override
protected void doStop() throws Exception {
    ServiceHelper.stopServices(deadLetter, output, outputAsync);
}",,"@Override
protected void doStop() throws Exception {
    ServiceHelper.stopServices(deadLetter, output, outputAsync);
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8769716088328073,-0.4166666666666667,0.4857142857142857,-0.16422749602751402
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1406_a523dcd5,0,"private void initThrowable(final Object[] params, final int argCount, final int usedParams) {
    if (usedParams < argCount && this.throwable == null && params[argCount - 1] instanceof Throwable) {
        this.throwable = (Throwable) params[argCount - 1];
    }
}",,"private void initThrowable(final Object[] params, final int argCount, final int usedParams) {
    if (usedParams < argCount && this.throwable == null && params[argCount - 1] instanceof Throwable) {
        this.throwable = (Throwable) params[argCount - 1];
    }
}",-0.4090909090909091,-0.015306122448979493,-0.3333333333333333,-0.5,0.08333333333333333,0.37073652990608014,0.5772870662460569,-0.5,0.17142857142857146,0.0010964489615857404
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1789_9f7c1df0,1,"private Map<String, PropertyState> createProperties(NodePropBundle bundle) {
    Map<String, PropertyState> properties = newHashMap();
    String primary;
    if (bundle.getNodeTypeName() != null) {
        primary = createName(bundle.getNodeTypeName());
    } else {
        warn(""Missing primary node type; defaulting to nt:unstructured"");
        primary = NT_UNSTRUCTURED;
    }
    properties.put(JCR_PRIMARYTYPE, PropertyStates.createProperty(JCR_PRIMARYTYPE, primary, Type.NAME));
    Set<String> mixins = newLinkedHashSet();
    if (bundle.getMixinTypeNames() != null) {
        for (Name mixin : bundle.getMixinTypeNames()) {
            mixins.add(createName(mixin));
        }
    }
    if (!mixins.isEmpty()) {
        properties.put(JCR_MIXINTYPES, PropertyStates.createProperty(JCR_MIXINTYPES, mixins, Type.NAMES));
    }
    if (bundle.isReferenceable() || isReferenceable.apply(primary, mixins)) {
        properties.put(JCR_UUID, PropertyStates.createProperty(JCR_UUID, bundle.getId().toString()));
    }
    if (isOrderable.apply(primary, mixins)) {
        properties.put(OAK_CHILD_ORDER, PropertyStates.createProperty(OAK_CHILD_ORDER, nodes.keySet(), Type.NAMES));
    }
    for (PropertyEntry property : bundle.getPropertyEntries()) {
        String name = createName(property.getName());
        try {
            int type = property.getType();
            if (property.isMultiValued()) {
                properties.put(name, createProperty(name, type, property.getValues()));
            } else {
                properties.put(name, createProperty(name, type, property.getValues()[0]));
            }
        } catch (Exception e) {
            warn(""Skipping broken property entry "" + name, e);
        }
    }
    // OAK-1789: Convert the jcr:frozenUuid of a non-referenceable
    // frozen node from UUID to a path identifier
    PropertyState frozenUuid = properties.get(JCR_FROZENUUID);
    if (frozenUuid != null && frozenUuid.getType() == STRING && isFrozenNode.apply(primary, mixins)) {
        String frozenPrimary = NT_UNSTRUCTURED;
        Set<String> frozenMixins = newHashSet();
        PropertyState property = properties.get(JCR_FROZENPRIMARYTYPE);
        if (property != null && property.getType() == NAME) {
            primary = property.getValue(NAME);
        }
        property = properties.get(JCR_FROZENMIXINTYPES);
        if (property != null && property.getType() == NAMES) {
            addAll(frozenMixins, property.getValue(NAMES));
        }
        if (!isReferenceable.apply(frozenPrimary, frozenMixins)) {
            frozenUuid = PropertyStates.createProperty(JCR_FROZENUUID, parent.getString(JCR_FROZENUUID) + ""/"" + name);
            properties.put(JCR_FROZENUUID, frozenUuid);
        }
    }
    return properties;
}",,"private Map<String, PropertyState> createProperties(NodePropBundle bundle) {
    Map<String, PropertyState> properties = newHashMap();
    String primary;
    if (bundle.getNodeTypeName() != null) {
        primary = createName(bundle.getNodeTypeName());
    } else {
        warn(""Missing primary node type; defaulting to nt:unstructured"");
        primary = NT_UNSTRUCTURED;
    }
    properties.put(JCR_PRIMARYTYPE, PropertyStates.createProperty(JCR_PRIMARYTYPE, primary, Type.NAME));
    Set<String> mixins = newLinkedHashSet();
    if (bundle.getMixinTypeNames() != null) {
        for (Name mixin : bundle.getMixinTypeNames()) {
            mixins.add(createName(mixin));
        }
    }
    if (!mixins.isEmpty()) {
        properties.put(JCR_MIXINTYPES, PropertyStates.createProperty(JCR_MIXINTYPES, mixins, Type.NAMES));
    }
    if (bundle.isReferenceable() || isReferenceable.apply(primary, mixins)) {
        properties.put(JCR_UUID, PropertyStates.createProperty(JCR_UUID, bundle.getId().toString()));
    }
    if (isOrderable.apply(primary, mixins)) {
        properties.put(OAK_CHILD_ORDER, PropertyStates.createProperty(OAK_CHILD_ORDER, nodes.keySet(), Type.NAMES));
    }
    for (PropertyEntry property : bundle.getPropertyEntries()) {
        String name = createName(property.getName());
        try {
            int type = property.getType();
            if (property.isMultiValued()) {
                properties.put(name, createProperty(name, type, property.getValues()));
            } else {
                properties.put(name, createProperty(name, type, property.getValues()[0]));
            }
        } catch (Exception e) {
            warn(""Skipping broken property entry "" + name, e);
        }
    }
            PropertyState frozenUuid = properties.get(JCR_FROZENUUID);
    if (frozenUuid != null && frozenUuid.getType() == STRING && isFrozenNode.apply(primary, mixins)) {
        String frozenPrimary = NT_UNSTRUCTURED;
        Set<String> frozenMixins = newHashSet();
        PropertyState property = properties.get(JCR_FROZENPRIMARYTYPE);
        if (property != null && property.getType() == NAME) {
            primary = property.getValue(NAME);
        }
        property = properties.get(JCR_FROZENMIXINTYPES);
        if (property != null && property.getType() == NAMES) {
            addAll(frozenMixins, property.getValue(NAMES));
        }
        if (!isReferenceable.apply(frozenPrimary, frozenMixins)) {
            frozenUuid = PropertyStates.createProperty(JCR_FROZENUUID, parent.getString(JCR_FROZENUUID) + ""/"" + name);
            properties.put(JCR_FROZENUUID, frozenUuid);
        }
    }
    return properties;
}",1.9545454545454546,0.27040816326530603,1.6666666666666667,0.5,2.25,1.2782995551161644,-1.0229423573272156,3.8333333333333335,-0.028571428571428574,4.843246345527045
wicket,remotes/origin/bugs-dot-jar_WICKET-2839_15477252,1,"@Override
public void write(byte[] b, int off, int len) throws IOException {
    if (off == 0 || len == b.length) {
        write(b);
    } else {
        byte[] copy = new byte[len];
        System.arraycopy(b, off, copy, 0, len);
        write(copy);
    }
}",,"@Override
public void write(byte[] b, int off, int len) throws IOException {
    if (off == 0 || len == b.length) {
        write(b);
    } else {
        byte[] copy = new byte[len];
        System.arraycopy(b, off, copy, 0, len);
        write(copy);
    }
}",-0.18181818181818182,0.15306122448979584,-0.3333333333333333,-0.5,0.0,0.030647553138902675,0.23888729566963007,-0.25,0.08571428571428572,-0.0631314753663039
Closure,163,1,"@Override
public void exitScope(NodeTraversal t) {
}",,"@Override
public void exitScope(NodeTraversal t) {
}",-0.5,-1.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.144536851161457,-0.5,2.5142857142857147,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443,1,"@Override
public Set<String> listIterators(String tableName) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {
    Set<String> result = new HashSet<String>();
    Set<String> lifecycles = new HashSet<String>();
    for (IteratorScope scope : IteratorScope.values()) lifecycles.add(scope.name().toLowerCase());
    for (Entry<String, String> property : this.getProperties(tableName)) {
        String name = property.getKey();
        String[] parts = name.split(""\\."");
        if (parts.length == 4) {
            if (parts[0].equals(""table"") && parts[1].equals(""iterator"") && lifecycles.contains(parts[2]))
                result.add(parts[3]);
        }
    }
    return result;
}",,"@Override
public Set<String> listIterators(String tableName) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {
    Set<String> result = new HashSet<String>();
    Set<String> lifecycles = new HashSet<String>();
    for (IteratorScope scope : IteratorScope.values()) lifecycles.add(scope.name().toLowerCase());
    for (Entry<String, String> property : this.getProperties(tableName)) {
        String name = property.getKey();
        String[] parts = name.split(""\\."");
        if (parts.length == 4) {
            if (parts[0].equals(""table"") && parts[1].equals(""iterator"") && lifecycles.contains(parts[2]))
                result.add(parts[3]);
        }
    }
    return result;
}",0.045454545454545456,0.6683673469387755,0.16666666666666666,0.0,0.25,-0.01878398418190801,-0.14453685116145706,0.4166666666666667,-0.028571428571428574,0.12347471528732532
Closure,136,2,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (n.getType() != Token.NAME) {
        return;
    }
    String name = n.getString();
    // Ignore anonymous functions
    if (name.length() == 0) {
        return;
    }
    // Is this local or Global?
    Scope.Var var = t.getScope().getVar(name);
    boolean local = (var != null) && var.isLocal();
    // Are we renaming global variables?
    if (!local && localRenamingOnly) {
        reservedNames.add(name);
        return;
    }
    // Are we renaming anonymous function names?
    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {
        reservedNames.add(name);
        return;
    }
    // Check if we can rename this.
    if (!okToRenameVar(name, local)) {
        // Blindly de-uniquify for the Prototype library for issue 103.
        return;
    }
    if (isExternsPass_) {
        // Keep track of extern globals.
        if (!local) {
            externNames.add(name);
        }
        return;
    }
    if (local) {
        // Local var: assign a new name
        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();
        incCount(tempName, null);
        localNameNodes.add(n);
        localTempNames.add(tempName);
    } else if (var != null) {
        // Not an extern
        // If it's global, increment global count
        incCount(name, var.input);
        globalNameNodes.add(n);
    }
}",,"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    if (n.getType() != Token.NAME) {
        return;
    }
    String name = n.getString();
        if (name.length() == 0) {
        return;
    }
        Scope.Var var = t.getScope().getVar(name);
    boolean local = (var != null) && var.isLocal();
        if (!local && localRenamingOnly) {
        reservedNames.add(name);
        return;
    }
        if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {
        reservedNames.add(name);
        return;
    }
        if (!okToRenameVar(name, local)) {
                return;
    }
    if (isExternsPass_) {
                if (!local) {
            externNames.add(name);
        }
        return;
    }
    if (local) {
                String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();
        incCount(tempName, null);
        localNameNodes.add(n);
        localTempNames.add(tempName);
    } else if (var != null) {
                        incCount(name, var.input);
        globalNameNodes.add(n);
    }
}",1.0909090909090908,-0.17346938775510198,1.0,0.0,1.5,0.7345526445872468,-0.6659019214224263,1.0,-0.028571428571428574,1.1315738753902886
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-43_668f08f2,1,"public void serialize(Binding binding) throws Exception {
    binding.write(""rootNodeId"", rootNodeId.getBytes());
    binding.write(""commitTS"", commitTS);
    binding.write(""msg"", msg == null ? """" : msg);
    binding.write(""parentId"", parentId == null ? """" : parentId.toString());
}",,"public void serialize(Binding binding) throws Exception {
    binding.write(""rootNodeId"", rootNodeId.getBytes());
    binding.write(""commitTS"", commitTS);
    binding.write(""msg"", msg == null ? """" : msg);
    binding.write(""parentId"", parentId == null ? """" : parentId.toString());
}",-0.36363636363636365,-0.576530612244898,-0.16666666666666666,-1.0,-0.08333333333333333,-0.3806228373702422,0.45970748494407815,0.0,-0.028571428571428574,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-4997_ee02c883,1,"/**
 *  Gets a URL for the listener interface on a behavior (e.g. IBehaviorListener on
 *  AjaxPagingNavigationBehavior).
 *
 *  @param behaviour
 *             The behavior that the URL should point to
 *  @param listener
 *             The listener interface that the URL should call
 *  @param parameters
 *             The parameters that should be rendered into the urls
 *  @return The URL
 */
public final CharSequence urlFor(final Behavior behaviour, final RequestListenerInterface listener, final PageParameters parameters) {
    int id = getBehaviorId(behaviour);
    Page page = getPage();
    PageAndComponentProvider provider = new PageAndComponentProvider(page, this, parameters);
    IRequestHandler handler;
    if (page.isBookmarkable()) {
        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener, id);
    } else {
        handler = new ListenerInterfaceRequestHandler(provider, listener, id);
    }
    return getRequestCycle().urlFor(handler);
}","/**
 *  Gets a URL for the listener interface on a behavior (e.g. IBehaviorListener on
 *  AjaxPagingNavigationBehavior).
 *
 *  @param behaviour
 *             The behavior that the URL should point to
 *  @param listener
 *             The listener interface that the URL should call
 *  @param parameters
 *             The parameters that should be rendered into the urls
 *  @return The URL
 */
","public final CharSequence urlFor(final Behavior behaviour, final RequestListenerInterface listener, final PageParameters parameters) {
    int id = getBehaviorId(behaviour);
    Page page = getPage();
    PageAndComponentProvider provider = new PageAndComponentProvider(page, this, parameters);
    IRequestHandler handler;
    if (page.isBookmarkable()) {
        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener, id);
    } else {
        handler = new ListenerInterfaceRequestHandler(provider, listener, id);
    }
    return getRequestCycle().urlFor(handler);
}",-0.09090909090909091,-0.3622448979591837,-0.3333333333333333,-0.5,-0.25,-0.3806228373702422,0.07714367651276165,-0.08333333333333333,0.20000000000000004,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-5043_2b1ce91d,1,"/**
 *  @see org.apache.wicket.core.request.mapper.AbstractBookmarkableMapper#pageMustHaveBeenCreatedBookmarkable()
 */
@Override
protected boolean pageMustHaveBeenCreatedBookmarkable() {
    return true;
}","/**
 *  @see org.apache.wicket.core.request.mapper.AbstractBookmarkableMapper#pageMustHaveBeenCreatedBookmarkable()
 */
","@Override
protected boolean pageMustHaveBeenCreatedBookmarkable() {
    return true;
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.0665328362489248,-0.5,2.314285714285714,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-434_133cbc2d,1,"/**
 * {@inheritDoc}
 */
@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof SimplexTableau) {
        SimplexTableau rhs = (SimplexTableau) other;
        return (restrictToNonNegative == rhs.restrictToNonNegative) && (numDecisionVariables == rhs.numDecisionVariables) && (numSlackVariables == rhs.numSlackVariables) && (numArtificialVariables == rhs.numArtificialVariables) && (epsilon == rhs.epsilon) && f.equals(rhs.f) && constraints.equals(rhs.constraints) && tableau.equals(rhs.tableau);
    }
    return false;
}","/**
 * {@inheritDoc}
 */
","@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof SimplexTableau) {
        SimplexTableau rhs = (SimplexTableau) other;
        return (restrictToNonNegative == rhs.restrictToNonNegative) && (numDecisionVariables == rhs.numDecisionVariables) && (numSlackVariables == rhs.numSlackVariables) && (numArtificialVariables == rhs.numArtificialVariables) && (epsilon == rhs.epsilon) && f.equals(rhs.f) && constraints.equals(rhs.constraints) && tableau.equals(rhs.tableau);
    }
    return false;
}",-0.13636363636363635,-0.035714285714285636,-0.16666666666666666,-0.5,-0.16666666666666666,0.09589718240237279,0.0949240034413537,-0.25,0.20000000000000004,0.05452692082010956
Lang,58,1,"// -----------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
// BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// new Float(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// new Integer(String)
// new Double(String)
// new Byte(String)
// new Long(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// new Short(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>First, the value is examined for a type qualifier on the end
 * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can represent the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it
 * will be interpreted as a hexadecimal integer.  Values with leading
 * <code>0</code>'s will not be interpreted as octal.</p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * <p>This method does not trim the input string, i.e., strings with leading
 * or trailing spaces will generate NumberFormatExceptions.</p>
 *
 * @param str  String containing a number, may be null
 * @return Number created from the string
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
        // a wrong value.
        return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = str.indexOf('e') + str.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar)) {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
        // Requesting a specific type..
        String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                    // Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        // has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                // ignore the bad number
                }
            // Fall through
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                // ignore the bad number
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                // ignore the bad number
                }
            // Fall through
            default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
        // small and go from there...
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            // Must be an int,long,bigint
            try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            try {
                return createLong(str);
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            return createBigInteger(str);
        } else {
            // Must be a float,double,BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
            // ignore the bad number
            }
            return createBigDecimal(str);
        }
    }
}","/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>First, the value is examined for a type qualifier on the end
 * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can represent the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it
 * will be interpreted as a hexadecimal integer.  Values with leading
 * <code>0</code>'s will not be interpreted as octal.</p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * <p>This method does not trim the input string, i.e., strings with leading
 * or trailing spaces will generate NumberFormatExceptions.</p>
 *
 * @param str  String containing a number, may be null
 * @return Number created from the string
 * @throws NumberFormatException if the value cannot be converted
 */
","public static Number createNumber(String str) throws NumberFormatException {
    if (str == null) {
        return null;
    }
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    if (str.startsWith(""--"")) {
                return null;
    }
    if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
        return createInteger(str);
    }
    char lastChar = str.charAt(str.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = str.indexOf('.');
    int expPos = str.indexOf('e') + str.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(str + "" is not a valid number."");
            }
            dec = str.substring(decPos + 1, expPos);
        } else {
            dec = str.substring(decPos + 1);
        }
        mant = str.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = str.substring(0, expPos);
        } else {
            mant = str;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar)) {
        if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length() - 1);
        } else {
            exp = null;
        }
                String numeric = str.substring(0, str.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                                        }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(str + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                                                return f;
                    }
                } catch (NumberFormatException nfe) {
                                }
                        case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                                }
                        default:
                throw new NumberFormatException(str + "" is not a valid number."");
        }
    } else {
                if (expPos > -1 && expPos < str.length() - 1) {
            exp = str.substring(expPos + 1, str.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
                        try {
                return createInteger(str);
            } catch (NumberFormatException nfe) {
                        }
            try {
                return createLong(str);
            } catch (NumberFormatException nfe) {
                        }
            return createBigInteger(str);
        } else {
                        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                        }
            try {
                Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
                        }
            return createBigDecimal(str);
        }
    }
}",4.681818181818182,1.270408163265306,5.5,1.5,4.666666666666667,3.0004943153732087,-1.563234872383138,3.75,-0.028571428571428574,14.544292683344683
Closure,129,2,"/**
 * There are two types of calls we are interested in calls without explicit
 * ""this"" values (what we are call ""free"" calls) and direct call to eval.
 */
private void annotateCalls(Node n) {
    Preconditions.checkState(n.isCall());
    // Keep track of of the ""this"" context of a call.  A call without an
    // explicit ""this"" is a free call.
    Node first = n.getFirstChild();
    if (!NodeUtil.isGet(first)) {
        n.putBooleanProp(Node.FREE_CALL, true);
    }
    // to distinguish between ""(0, eval)()"" and ""eval()"".
    if (first.isName() && ""eval"".equals(first.getString())) {
        first.putBooleanProp(Node.DIRECT_EVAL, true);
    }
}","/**
 * There are two types of calls we are interested in calls without explicit
 * ""this"" values (what we are call ""free"" calls) and direct call to eval.
 */
","private void annotateCalls(Node n) {
    Preconditions.checkState(n.isCall());
            Node first = n.getFirstChild();
    if (!NodeUtil.isGet(first)) {
        n.putBooleanProp(Node.FREE_CALL, true);
    }
        if (first.isName() && ""eval"".equals(first.getString())) {
        first.putBooleanProp(Node.DIRECT_EVAL, true);
    }
}",-0.18181818181818182,-0.2500000000000001,-0.16666666666666666,-0.5,0.25,-0.05832921403855659,0.18898766848293677,0.25,0.31428571428571433,-0.058274549106779566
wicket,remotes/origin/bugs-dot-jar_WICKET-5426_fb45a781,3,"/**
 *  @see org.apache.wicket.request.component.IRequestablePage#renderPage()
 */
@Override
public void renderPage() {
    // page id is frozen during the render
    final boolean frozen = setFreezePageId(true);
    try {
        ++renderCount;
        render();
    } finally {
        setFreezePageId(frozen);
    }
}","/**
 *  @see org.apache.wicket.request.component.IRequestablePage#renderPage()
 */
","@Override
public void renderPage() {
        final boolean frozen = setFreezePageId(true);
    try {
        ++renderCount;
        render();
    } finally {
        setFreezePageId(frozen);
    }
}",-0.18181818181818182,0.04081632653061228,-0.5,-0.5,-0.4166666666666667,-0.1334651507661888,0.40120447375967877,-0.25,2.142857142857143,-0.14288528831039785
commons-math,remotes/origin/bugs-dot-jar_MATH-949_f83bbc1d,1,"/**
 * {@inheritDoc}
 */
@Override
protected PointValuePair doOptimize() {
    // -------------------- Initialization --------------------------------
    isMinimize = getGoalType().equals(GoalType.MINIMIZE);
    final FitnessFunction fitfun = new FitnessFunction();
    final double[] guess = getStartPoint();
    // number of objective variables/problem dimension
    dimension = guess.length;
    initializeCMA(guess);
    iterations = 0;
    double bestValue = fitfun.value(guess);
    push(fitnessHistory, bestValue);
    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);
    PointValuePair lastResult = null;
    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {
        // Generate and evaluate lambda offspring
        final RealMatrix arz = randn1(dimension, lambda);
        final RealMatrix arx = zeros(dimension, lambda);
        final double[] fitness = new double[lambda];
        // generate random offspring
        for (int k = 0; k < lambda; k++) {
            RealMatrix arxk = null;
            for (int i = 0; i < checkFeasableCount + 1; i++) {
                if (diagonalOnly <= 0) {
                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(// m + sig * Normal(0,C)
                    sigma));
                } else {
                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));
                }
                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {
                    break;
                }
                // regenerate random arguments for row
                arz.setColumn(k, randn(dimension));
            }
            copyColumn(arxk, 0, arx, k);
            try {
                // compute fitness
                fitness[k] = fitfun.value(arx.getColumn(k));
            } catch (TooManyEvaluationsException e) {
                break generationLoop;
            }
        }
        // Sort by fitness and compute weighted mean into xmean
        final int[] arindex = sortedIndices(fitness);
        // Calculate new xmean, this is selection and recombination
        // for speed up of Eq. (2) and (3)
        final RealMatrix xold = xmean;
        final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));
        xmean = bestArx.multiply(weights);
        final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));
        final RealMatrix zmean = bestArz.multiply(weights);
        final boolean hsig = updateEvolutionPaths(zmean, xold);
        if (diagonalOnly <= 0) {
            updateCovariance(hsig, bestArx, arz, arindex, xold);
        } else {
            updateCovarianceDiagonalOnly(hsig, bestArz);
        }
        // Adapt step size sigma - Eq. (5)
        sigma *= Math.exp(Math.min(1, (normps / chiN - 1) * cs / damps));
        final double bestFitness = fitness[arindex[0]];
        final double worstFitness = fitness[arindex[arindex.length - 1]];
        if (bestValue > bestFitness) {
            bestValue = bestFitness;
            lastResult = optimum;
            optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);
            if (getConvergenceChecker() != null && lastResult != null) {
                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {
                    break generationLoop;
                }
            }
        }
        // Break, if fitness is good enough
        if (stopFitness != 0) {
            // only if stopFitness is defined
            if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {
                break generationLoop;
            }
        }
        final double[] sqrtDiagC = sqrt(diagC).getColumn(0);
        final double[] pcCol = pc.getColumn(0);
        for (int i = 0; i < dimension; i++) {
            if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {
                break;
            }
            if (i >= dimension - 1) {
                break generationLoop;
            }
        }
        for (int i = 0; i < dimension; i++) {
            if (sigma * sqrtDiagC[i] > stopTolUpX) {
                break generationLoop;
            }
        }
        final double historyBest = min(fitnessHistory);
        final double historyWorst = max(fitnessHistory);
        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {
            break generationLoop;
        }
        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {
            break generationLoop;
        }
        // condition number of the covariance matrix exceeds 1e14
        if (max(diagD) / min(diagD) > 1e7) {
            break generationLoop;
        }
        // user defined termination
        if (getConvergenceChecker() != null) {
            final PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);
            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {
                break generationLoop;
            }
            lastResult = current;
        }
        // Adjust step size in case of equal function values (flat fitness)
        if (bestValue == fitness[arindex[(int) (0.1 + lambda / 4.)]]) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
        // store best in history
        push(fitnessHistory, bestFitness);
        fitfun.setValueRange(worstFitness - bestFitness);
        if (generateStatistics) {
            statisticsSigmaHistory.add(sigma);
            statisticsFitnessHistory.add(bestFitness);
            statisticsMeanHistory.add(xmean.transpose());
            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));
        }
    }
    return optimum;
}","/**
 * {@inheritDoc}
 */
","@Override
protected PointValuePair doOptimize() {
        isMinimize = getGoalType().equals(GoalType.MINIMIZE);
    final FitnessFunction fitfun = new FitnessFunction();
    final double[] guess = getStartPoint();
        dimension = guess.length;
    initializeCMA(guess);
    iterations = 0;
    double bestValue = fitfun.value(guess);
    push(fitnessHistory, bestValue);
    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);
    PointValuePair lastResult = null;
    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {
                final RealMatrix arz = randn1(dimension, lambda);
        final RealMatrix arx = zeros(dimension, lambda);
        final double[] fitness = new double[lambda];
                for (int k = 0; k < lambda; k++) {
            RealMatrix arxk = null;
            for (int i = 0; i < checkFeasableCount + 1; i++) {
                if (diagonalOnly <= 0) {
                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(                    sigma));
                } else {
                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));
                }
                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {
                    break;
                }
                                arz.setColumn(k, randn(dimension));
            }
            copyColumn(arxk, 0, arx, k);
            try {
                                fitness[k] = fitfun.value(arx.getColumn(k));
            } catch (TooManyEvaluationsException e) {
                break generationLoop;
            }
        }
                final int[] arindex = sortedIndices(fitness);
                        final RealMatrix xold = xmean;
        final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));
        xmean = bestArx.multiply(weights);
        final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));
        final RealMatrix zmean = bestArz.multiply(weights);
        final boolean hsig = updateEvolutionPaths(zmean, xold);
        if (diagonalOnly <= 0) {
            updateCovariance(hsig, bestArx, arz, arindex, xold);
        } else {
            updateCovarianceDiagonalOnly(hsig, bestArz);
        }
                sigma *= Math.exp(Math.min(1, (normps / chiN - 1) * cs / damps));
        final double bestFitness = fitness[arindex[0]];
        final double worstFitness = fitness[arindex[arindex.length - 1]];
        if (bestValue > bestFitness) {
            bestValue = bestFitness;
            lastResult = optimum;
            optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);
            if (getConvergenceChecker() != null && lastResult != null) {
                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {
                    break generationLoop;
                }
            }
        }
                if (stopFitness != 0) {
                        if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {
                break generationLoop;
            }
        }
        final double[] sqrtDiagC = sqrt(diagC).getColumn(0);
        final double[] pcCol = pc.getColumn(0);
        for (int i = 0; i < dimension; i++) {
            if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {
                break;
            }
            if (i >= dimension - 1) {
                break generationLoop;
            }
        }
        for (int i = 0; i < dimension; i++) {
            if (sigma * sqrtDiagC[i] > stopTolUpX) {
                break generationLoop;
            }
        }
        final double historyBest = min(fitnessHistory);
        final double historyWorst = max(fitnessHistory);
        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {
            break generationLoop;
        }
        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {
            break generationLoop;
        }
                if (max(diagD) / min(diagD) > 1e7) {
            break generationLoop;
        }
                if (getConvergenceChecker() != null) {
            final PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);
            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {
                break generationLoop;
            }
            lastResult = current;
        }
                if (bestValue == fitness[arindex[(int) (0.1 + lambda / 4.)]]) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {
            sigma = sigma * Math.exp(0.2 + cs / damps);
        }
                push(fitnessHistory, bestFitness);
        fitfun.setValueRange(worstFitness - bestFitness);
        if (generateStatistics) {
            statisticsSigmaHistory.add(sigma);
            statisticsFitnessHistory.add(bestFitness);
            statisticsMeanHistory.add(xmean.transpose());
            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));
        }
    }
    return optimum;
}",4.681818181818182,0.6377551020408161,6.166666666666667,1.0,5.583333333333333,4.171033119130005,-1.6624605678233442,5.25,-0.028571428571428574,32.09659030070969
wicket,remotes/origin/bugs-dot-jar_WICKET-5724_b92591f6,1,"/**
 *  Creates a new instance of auto component to be queued
 */
Component newComponent(ComponentTag tag);","/**
 *  Creates a new instance of auto component to be queued
 */
",Component newComponent(ComponentTag tag);,-0.5909090909090909,-1.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.6550043016919995,-0.5,2.8285714285714287,-0.16422749602751402
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1153_9f924f10,1,"@Override
public PropertiesConfiguration getConfiguration(ConfigurationSource source) {
    final InputStream configStream = source.getInputStream();
    Properties properties = new Properties();
    try {
        properties.load(configStream);
    } catch (IOException ioe) {
        throw new ConfigurationException(""Unable to load "" + source.toString(), ioe);
    }
    ConfigurationBuilder<PropertiesConfiguration> builder = newConfigurationBuilder(PropertiesConfiguration.class);
    String value = properties.getProperty(STATUS_KEY);
    if (value != null) {
        builder.setStatusLevel(Level.toLevel(value, Level.ERROR));
    } else {
        builder.setStatusLevel(Level.ERROR);
    }
    value = properties.getProperty(SHUTDOWN_HOOK);
    if (value != null) {
        builder.setShutdownHook(value);
    }
    value = properties.getProperty(VERBOSE);
    if (value != null) {
        builder.setVerbosity(value);
    }
    value = properties.getProperty(PACKAGES);
    if (value != null) {
        builder.setPackages(value);
    }
    value = properties.getProperty(CONFIG_NAME);
    if (value != null) {
        builder.setConfigurationName(value);
    }
    value = properties.getProperty(MONITOR_INTERVAL);
    if (value != null) {
        builder.setMonitorInterval(value);
    }
    value = properties.getProperty(ADVERTISER_KEY);
    if (value != null) {
        builder.setAdvertiser(value);
    }
    Properties props = PropertiesUtil.extractSubset(properties, ""property"");
    for (String key : props.stringPropertyNames()) {
        builder.addProperty(key, props.getProperty(key));
    }
    Properties levelProps = PropertiesUtil.extractSubset(properties, ""customLevel"");
    if (levelProps.size() > 0) {
        for (String key : levelProps.stringPropertyNames()) {
            builder.add(builder.newCustomLevel(key, Integer.parseInt(props.getProperty(key))));
        }
    }
    String filterProp = properties.getProperty(""filters"");
    if (filterProp != null) {
        String[] filterNames = filterProp.split("","");
        for (String filterName : filterNames) {
            String name = filterName.trim();
            builder.add(createFilter(builder, name, PropertiesUtil.extractSubset(properties, ""filter."" + name)));
        }
    }
    String appenderProp = properties.getProperty(""appenders"");
    if (appenderProp != null) {
        String[] appenderNames = appenderProp.split("","");
        for (String appenderName : appenderNames) {
            String name = appenderName.trim();
            builder.add(createAppender(builder, name, PropertiesUtil.extractSubset(properties, ""appender."" + name)));
        }
    }
    String loggerProp = properties.getProperty(""loggers"");
    if (appenderProp != null) {
        String[] loggerNames = loggerProp.split("","");
        for (String loggerName : loggerNames) {
            String name = loggerName.trim();
            if (!name.equals(LoggerConfig.ROOT)) {
                builder.add(createLogger(builder, name, PropertiesUtil.extractSubset(properties, ""logger."" + name)));
            }
        }
    }
    props = PropertiesUtil.extractSubset(properties, ""rootLogger"");
    if (props.size() > 0) {
        builder.add(createRootLogger(builder, props));
    }
    return builder.build();
}",,"@Override
public PropertiesConfiguration getConfiguration(ConfigurationSource source) {
    final InputStream configStream = source.getInputStream();
    Properties properties = new Properties();
    try {
        properties.load(configStream);
    } catch (IOException ioe) {
        throw new ConfigurationException(""Unable to load "" + source.toString(), ioe);
    }
    ConfigurationBuilder<PropertiesConfiguration> builder = newConfigurationBuilder(PropertiesConfiguration.class);
    String value = properties.getProperty(STATUS_KEY);
    if (value != null) {
        builder.setStatusLevel(Level.toLevel(value, Level.ERROR));
    } else {
        builder.setStatusLevel(Level.ERROR);
    }
    value = properties.getProperty(SHUTDOWN_HOOK);
    if (value != null) {
        builder.setShutdownHook(value);
    }
    value = properties.getProperty(VERBOSE);
    if (value != null) {
        builder.setVerbosity(value);
    }
    value = properties.getProperty(PACKAGES);
    if (value != null) {
        builder.setPackages(value);
    }
    value = properties.getProperty(CONFIG_NAME);
    if (value != null) {
        builder.setConfigurationName(value);
    }
    value = properties.getProperty(MONITOR_INTERVAL);
    if (value != null) {
        builder.setMonitorInterval(value);
    }
    value = properties.getProperty(ADVERTISER_KEY);
    if (value != null) {
        builder.setAdvertiser(value);
    }
    Properties props = PropertiesUtil.extractSubset(properties, ""property"");
    for (String key : props.stringPropertyNames()) {
        builder.addProperty(key, props.getProperty(key));
    }
    Properties levelProps = PropertiesUtil.extractSubset(properties, ""customLevel"");
    if (levelProps.size() > 0) {
        for (String key : levelProps.stringPropertyNames()) {
            builder.add(builder.newCustomLevel(key, Integer.parseInt(props.getProperty(key))));
        }
    }
    String filterProp = properties.getProperty(""filters"");
    if (filterProp != null) {
        String[] filterNames = filterProp.split("","");
        for (String filterName : filterNames) {
            String name = filterName.trim();
            builder.add(createFilter(builder, name, PropertiesUtil.extractSubset(properties, ""filter."" + name)));
        }
    }
    String appenderProp = properties.getProperty(""appenders"");
    if (appenderProp != null) {
        String[] appenderNames = appenderProp.split("","");
        for (String appenderName : appenderNames) {
            String name = appenderName.trim();
            builder.add(createAppender(builder, name, PropertiesUtil.extractSubset(properties, ""appender."" + name)));
        }
    }
    String loggerProp = properties.getProperty(""loggers"");
    if (appenderProp != null) {
        String[] loggerNames = loggerProp.split("","");
        for (String loggerName : loggerNames) {
            String name = loggerName.trim();
            if (!name.equals(LoggerConfig.ROOT)) {
                builder.add(createLogger(builder, name, PropertiesUtil.extractSubset(properties, ""logger."" + name)));
            }
        }
    }
    props = PropertiesUtil.extractSubset(properties, ""rootLogger"");
    if (props.size() > 0) {
        builder.add(createRootLogger(builder, props));
    }
    return builder.build();
}",3.090909090909091,0.025510204081632563,2.8333333333333335,0.5,1.1666666666666667,0.7721206129510629,-1.279609979925438,4.083333333333333,-0.028571428571428574,4.430634612666555
wicket,remotes/origin/bugs-dot-jar_WICKET-3647_1b57b51c,1,"/**
 *  Get the markupId
 *
 *  @return MarkupId
 */
public final Object getMarkupIdImpl() {
    String id = getMarkupIdFromMarkup();
    if (id != null) {
        return id;
    }
    if (generatedMarkupId != -1) {
        return generatedMarkupId;
    }
    return getMetaData(MARKUP_ID_KEY);
}","/**
 *  Get the markupId
 *
 *  @return MarkupId
 */
","public final Object getMarkupIdImpl() {
    String id = getMarkupIdFromMarkup();
    if (id != null) {
        return id;
    }
    if (generatedMarkupId != -1) {
        return generatedMarkupId;
    }
    return getMetaData(MARKUP_ID_KEY);
}",-0.18181818181818182,-0.2500000000000001,-0.16666666666666666,-0.5,-0.08333333333333333,-0.12951062778052397,0.307427588184686,-0.3333333333333333,2.742857142857143,-0.1268711372659874
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-392_731c84b5,1,"/**
 * Tear down the configuration.
 */
@Override
public void stop() {
    this.setStopping();
    LOGGER.trace(""Stopping {}..."", this);
    // LOG4J2-392 first stop AsyncLogger Disruptor thread
    final LoggerContextFactory factory = LogManager.getFactory();
    if (factory instanceof Log4jContextFactory) {
        ContextSelector selector = ((Log4jContextFactory) factory).getSelector();
        if (selector instanceof AsyncLoggerContextSelector) {
        // all loggers are async
        // TODO until LOG4J2-493 is fixed we can only stop AsyncLogger once!
        // but LoggerContext.setConfiguration will call config.stop()
        // every time the configuration changes...
        // 
        // Uncomment the line below after LOG4J2-493 is fixed
        // AsyncLogger.stop();
        // LOGGER.trace(""AbstractConfiguration stopped AsyncLogger disruptor."");
        }
    }
    // similarly, first stop AsyncLoggerConfig Disruptor thread(s)
    Set<LoggerConfig> alreadyStopped = new HashSet<LoggerConfig>();
    int asyncLoggerConfigCount = 0;
    for (final LoggerConfig logger : loggers.values()) {
        if (logger instanceof AsyncLoggerConfig) {
            // LOG4J2-520, LOG4J2-392:
            // Important: do not clear appenders until after all AsyncLoggerConfigs
            // have been stopped! Stopping the last AsyncLoggerConfig will
            // shut down the disruptor and wait for all enqueued events to be processed.
            // Only *after this* the appenders can be cleared or events will be lost.
            logger.stop();
            asyncLoggerConfigCount++;
            alreadyStopped.add(logger);
        }
    }
    if (root instanceof AsyncLoggerConfig) {
        root.stop();
        asyncLoggerConfigCount++;
        alreadyStopped.add(root);
    }
    LOGGER.trace(""AbstractConfiguration stopped {} AsyncLoggerConfigs."", asyncLoggerConfigCount);
    // Stop the appenders in reverse order in case they still have activity.
    final Appender[] array = appenders.values().toArray(new Appender[appenders.size()]);
    // LOG4J2-511, LOG4J2-392 stop AsyncAppenders first
    int asyncAppenderCount = 0;
    for (int i = array.length - 1; i >= 0; --i) {
        if (array[i] instanceof AsyncAppender) {
            array[i].stop();
            asyncAppenderCount++;
        }
    }
    LOGGER.trace(""AbstractConfiguration stopped {} AsyncAppenders."", asyncAppenderCount);
    int appenderCount = 0;
    for (int i = array.length - 1; i >= 0; --i) {
        if (array[i].isStarted()) {
            // then stop remaining Appenders
            array[i].stop();
            appenderCount++;
        }
    }
    LOGGER.trace(""AbstractConfiguration stopped {} Appenders."", appenderCount);
    int loggerCount = 0;
    for (final LoggerConfig logger : loggers.values()) {
        // clear appenders, even if this logger is already stopped.
        logger.clearAppenders();
        // the shared Disruptor may be shut down prematurely, resulting in NPE or other errors.
        if (alreadyStopped.contains(logger)) {
            continue;
        }
        logger.stop();
        loggerCount++;
    }
    LOGGER.trace(""AbstractConfiguration stopped {} Loggers."", loggerCount);
    // the shared Disruptor may be shut down prematurely, resulting in NPE or other errors.
    if (!alreadyStopped.contains(root)) {
        root.stop();
    }
    super.stop();
    if (advertiser != null && advertisement != null) {
        advertiser.unadvertise(advertisement);
    }
    LOGGER.debug(""Stopped {} OK"", this);
}","/**
 * Tear down the configuration.
 */
","@Override
public void stop() {
    this.setStopping();
    LOGGER.trace(""Stopping {}..."", this);
        final LoggerContextFactory factory = LogManager.getFactory();
    if (factory instanceof Log4jContextFactory) {
        ContextSelector selector = ((Log4jContextFactory) factory).getSelector();
        if (selector instanceof AsyncLoggerContextSelector) {
                                                                        }
    }
        Set<LoggerConfig> alreadyStopped = new HashSet<LoggerConfig>();
    int asyncLoggerConfigCount = 0;
    for (final LoggerConfig logger : loggers.values()) {
        if (logger instanceof AsyncLoggerConfig) {
                                                                        logger.stop();
            asyncLoggerConfigCount++;
            alreadyStopped.add(logger);
        }
    }
    if (root instanceof AsyncLoggerConfig) {
        root.stop();
        asyncLoggerConfigCount++;
        alreadyStopped.add(root);
    }
    LOGGER.trace(""AbstractConfiguration stopped {} AsyncLoggerConfigs."", asyncLoggerConfigCount);
        final Appender[] array = appenders.values().toArray(new Appender[appenders.size()]);
        int asyncAppenderCount = 0;
    for (int i = array.length - 1; i >= 0; --i) {
        if (array[i] instanceof AsyncAppender) {
            array[i].stop();
            asyncAppenderCount++;
        }
    }
    LOGGER.trace(""AbstractConfiguration stopped {} AsyncAppenders."", asyncAppenderCount);
    int appenderCount = 0;
    for (int i = array.length - 1; i >= 0; --i) {
        if (array[i].isStarted()) {
                        array[i].stop();
            appenderCount++;
        }
    }
    LOGGER.trace(""AbstractConfiguration stopped {} Appenders."", appenderCount);
    int loggerCount = 0;
    for (final LoggerConfig logger : loggers.values()) {
                logger.clearAppenders();
                if (alreadyStopped.contains(logger)) {
            continue;
        }
        logger.stop();
        loggerCount++;
    }
    LOGGER.trace(""AbstractConfiguration stopped {} Loggers."", loggerCount);
        if (!alreadyStopped.contains(root)) {
        root.stop();
    }
    super.stop();
    if (advertiser != null && advertisement != null) {
        advertiser.unadvertise(advertisement);
    }
    LOGGER.debug(""Stopped {} OK"", this);
}",2.1363636363636362,0.051020408163265356,1.8333333333333333,0.0,1.4166666666666667,1.6045477014335146,-1.0020074562661316,1.8333333333333333,-0.028571428571428574,3.864335856022546
Math,82,1,"/**
 * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).
 * @param tableau simple tableau for the problem
 * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}
 * @return row with the minimum ratio
 */
private Integer getPivotRow(final int col, final SimplexTableau tableau) {
    double minRatio = Double.MAX_VALUE;
    Integer minRatioPos = null;
    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
        final double entry = tableau.getEntry(i, col);
        if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {
            final double ratio = rhs / entry;
            if (ratio < minRatio) {
                minRatio = ratio;
                minRatioPos = i;
            }
        }
    }
    return minRatioPos;
}","/**
 * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).
 * @param tableau simple tableau for the problem
 * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}
 * @return row with the minimum ratio
 */
","private Integer getPivotRow(final int col, final SimplexTableau tableau) {
    double minRatio = Double.MAX_VALUE;
    Integer minRatioPos = null;
    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
        final double entry = tableau.getEntry(i, col);
        if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {
            final double ratio = rhs / entry;
            if (ratio < minRatio) {
                minRatio = ratio;
                minRatioPos = i;
            }
        }
    }
    return minRatioPos;
}",0.09090909090909091,0.9438775510204083,0.0,0.5,0.4166666666666667,0.782006920415225,-0.13736736449670225,0.0,0.028571428571428574,0.5889429975030088
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7,3,"public int compareTo(removeConstraint_result other) {
    if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
    }
    int lastComparison = 0;
    removeConstraint_result typedOther = (removeConstraint_result) other;
    lastComparison = Boolean.valueOf(isSetOuch1()).compareTo(typedOther.isSetOuch1());
    if (lastComparison != 0) {
        return lastComparison;
    }
    if (isSetOuch1()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch1, typedOther.ouch1);
        if (lastComparison != 0) {
            return lastComparison;
        }
    }
    lastComparison = Boolean.valueOf(isSetOuch2()).compareTo(typedOther.isSetOuch2());
    if (lastComparison != 0) {
        return lastComparison;
    }
    if (isSetOuch2()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch2, typedOther.ouch2);
        if (lastComparison != 0) {
            return lastComparison;
        }
    }
    return 0;
}",,"public int compareTo(removeConstraint_result other) {
    if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
    }
    int lastComparison = 0;
    removeConstraint_result typedOther = (removeConstraint_result) other;
    lastComparison = Boolean.valueOf(isSetOuch1()).compareTo(typedOther.isSetOuch1());
    if (lastComparison != 0) {
        return lastComparison;
    }
    if (isSetOuch1()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch1, typedOther.ouch1);
        if (lastComparison != 0) {
            return lastComparison;
        }
    }
    lastComparison = Boolean.valueOf(isSetOuch2()).compareTo(typedOther.isSetOuch2());
    if (lastComparison != 0) {
        return lastComparison;
    }
    if (isSetOuch2()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch2, typedOther.ouch2);
        if (lastComparison != 0) {
            return lastComparison;
        }
    }
    return 0;
}",0.6363636363636364,-0.06122448979591842,0.6666666666666666,0.0,0.5833333333333334,0.28175976272862097,-0.4482363062804703,1.1666666666666667,-0.028571428571428574,0.3420278309584077
wicket,remotes/origin/bugs-dot-jar_WICKET-5247_44a4132f,3,"/**
 *  @see AbstractBookmarkableMapper#buildUrl(AbstractBookmarkableMapper.UrlInfo)
 */
@Override
protected Url buildUrl(UrlInfo info) {
    Url url = new Url();
    for (String s : mountSegments) {
        url.getSegments().add(s);
    }
    encodePageComponentInfo(url, info.getPageComponentInfo());
    PageParameters copy = new PageParameters(info.getPageParameters());
    int dropped = 0;
    for (int i = 0; i < mountSegments.length; ++i) {
        String placeholder = getPlaceholder(mountSegments[i]);
        String optionalPlaceholder = getOptionalPlaceholder(mountSegments[i]);
        if (placeholder != null) {
            url.getSegments().set(i - dropped, copy.get(placeholder).toString(""""));
            copy.remove(placeholder);
        } else if (optionalPlaceholder != null) {
            if (copy.getNamedKeys().contains(optionalPlaceholder)) {
                url.getSegments().set(i - dropped, copy.get(optionalPlaceholder).toString(""""));
                copy.remove(optionalPlaceholder);
            } else {
                url.getSegments().remove(i - dropped);
                dropped++;
            }
        }
    }
    return encodePageParameters(url, copy, pageParametersEncoder);
}","/**
 *  @see AbstractBookmarkableMapper#buildUrl(AbstractBookmarkableMapper.UrlInfo)
 */
","@Override
protected Url buildUrl(UrlInfo info) {
    Url url = new Url();
    for (String s : mountSegments) {
        url.getSegments().add(s);
    }
    encodePageComponentInfo(url, info.getPageComponentInfo());
    PageParameters copy = new PageParameters(info.getPageParameters());
    int dropped = 0;
    for (int i = 0; i < mountSegments.length; ++i) {
        String placeholder = getPlaceholder(mountSegments[i]);
        String optionalPlaceholder = getOptionalPlaceholder(mountSegments[i]);
        if (placeholder != null) {
            url.getSegments().set(i - dropped, copy.get(placeholder).toString(""""));
            copy.remove(placeholder);
        } else if (optionalPlaceholder != null) {
            if (copy.getNamedKeys().contains(optionalPlaceholder)) {
                url.getSegments().set(i - dropped, copy.get(optionalPlaceholder).toString(""""));
                copy.remove(optionalPlaceholder);
            } else {
                url.getSegments().remove(i - dropped);
                dropped++;
            }
        }
    }
    return encodePageParameters(url, copy, pageParametersEncoder);
}",0.5909090909090909,1.0000000000000002,0.3333333333333333,1.0,0.3333333333333333,0.6020761245674742,-0.48092916547175224,1.3333333333333333,-0.028571428571428574,0.9802853337102376
wicket,remotes/origin/bugs-dot-jar_WICKET-4116_4624ab3d,1,"/**
 *  The page instance is new only if there is no cached instance or the data stores doesn't have
 *  a page with that id with the same {@linkplain #pageClass}.
 *
 *  @see org.apache.wicket.request.handler.IPageProvider#isNewPageInstance()
 */
public boolean isNewPageInstance() {
    boolean isNew = pageInstance == null;
    if (isNew && pageId != null) {
        IRequestablePage storedPageInstance = getStoredPage(pageId);
        if (storedPageInstance != null) {
            pageInstance = storedPageInstance;
            isNew = false;
        }
    }
    return isNew;
}","/**
 *  The page instance is new only if there is no cached instance or the data stores doesn't have
 *  a page with that id with the same {@linkplain #pageClass}.
 *
 *  @see org.apache.wicket.request.handler.IPageProvider#isNewPageInstance()
 */
","public boolean isNewPageInstance() {
    boolean isNew = pageInstance == null;
    if (isNew && pageId != null) {
        IRequestablePage storedPageInstance = getStoredPage(pageId);
        if (storedPageInstance != null) {
            pageInstance = storedPageInstance;
            isNew = false;
        }
    }
    return isNew;
}",-0.13636363636363635,0.47448979591836743,-0.16666666666666666,0.0,0.08333333333333333,0.37073652990608014,0.20246630341267577,-0.4166666666666667,2.142857142857143,0.0030794797007036964
commons-math,remotes/origin/bugs-dot-jar_MATH-320_c06cc933,1,"/**
 * {@inheritDoc}
 */
public RealMatrix getV() throws InvalidMatrixException {
    if (cachedV == null) {
        if (m >= n) {
            // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
            cachedV = transformer.getV().multiply(eigenDecomposition.getV());
        } else {
            // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
            final double[][] eData = eigenDecomposition.getV().getData();
            final double[][] iData = new double[n][];
            double[] ei1 = eData[0];
            iData[0] = ei1;
            for (int i = 0; i < m - 1; ++i) {
                // compute Bt.E.S^(-1) where E is the eigenvectors matrix
                // we reuse the array from matrix E to store the result
                final double mi = mainBidiagonal[i];
                final double si = secondaryBidiagonal[i];
                final double[] ei0 = ei1;
                ei1 = eData[i + 1];
                iData[i + 1] = ei1;
                for (int j = 0; j < m; ++j) {
                    ei0[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                }
            }
            // last row
            final double lastMain = mainBidiagonal[m - 1];
            for (int j = 0; j < m; ++j) {
                ei1[j] *= lastMain / singularValues[j];
            }
            for (int i = m; i < n; ++i) {
                iData[i] = new double[m];
            }
            cachedV = transformer.getV().multiply(MatrixUtils.createRealMatrix(iData));
        }
    }
    // return the cached matrix
    return cachedV;
}","/**
 * {@inheritDoc}
 */
","public RealMatrix getV() throws InvalidMatrixException {
    if (cachedV == null) {
        if (m >= n) {
                        cachedV = transformer.getV().multiply(eigenDecomposition.getV());
        } else {
                        final double[][] eData = eigenDecomposition.getV().getData();
            final double[][] iData = new double[n][];
            double[] ei1 = eData[0];
            iData[0] = ei1;
            for (int i = 0; i < m - 1; ++i) {
                                                final double mi = mainBidiagonal[i];
                final double si = secondaryBidiagonal[i];
                final double[] ei0 = ei1;
                ei1 = eData[i + 1];
                iData[i + 1] = ei1;
                for (int j = 0; j < m; ++j) {
                    ei0[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                }
            }
                        final double lastMain = mainBidiagonal[m - 1];
            for (int j = 0; j < m; ++j) {
                ei1[j] *= lastMain / singularValues[j];
            }
            for (int i = m; i < n; ++i) {
                iData[i] = new double[m];
            }
            cachedV = transformer.getV().multiply(MatrixUtils.createRealMatrix(iData));
        }
    }
        return cachedV;
}",0.7727272727272727,0.933673469387755,0.5,1.0,0.5,2.9036085022244196,-0.5884714654430743,0.16666666666666666,-0.028571428571428574,4.725699307438292
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1731_024e5d37,1,"/**
 * Copies the full content from the source to the target repository.
 * <p>
 * The source repository <strong>must not be modified</strong> while
 * the copy operation is running to avoid an inconsistent copy.
 * <p>
 * Note that both the source and the target repository must be closed
 * during the copy operation as this method requires exclusive access
 * to the repositories.
 *
 * @param initializer optional extra repository initializer to use
 * @throws RepositoryException if the copy operation fails
 */
public void copy(RepositoryInitializer initializer) throws RepositoryException {
    RepositoryConfig config = source.getRepositoryConfig();
    logger.info(""Copying repository content from {} to Oak"", config.getHomeDir());
    try {
        NodeBuilder builder = target.getRoot().builder();
        String workspace = source.getRepositoryConfig().getDefaultWorkspaceName();
        SecurityProviderImpl security = new SecurityProviderImpl(mapSecurityConfig(config.getSecurityConfig()));
        // init target repository first
        new InitialContent().initialize(builder);
        if (initializer != null) {
            initializer.initialize(builder);
        }
        for (SecurityConfiguration sc : security.getConfigurations()) {
            sc.getWorkspaceInitializer().initialize(builder, workspace);
        }
        Map<String, String> uriToPrefix = newHashMap();
        Map<Integer, String> idxToPrefix = newHashMap();
        copyNamespaces(builder, uriToPrefix, idxToPrefix);
        copyNodeTypes(builder);
        copyPrivileges(builder);
        NodeState root = builder.getNodeState();
        copyVersionStore(builder, root, uriToPrefix, idxToPrefix);
        copyWorkspace(builder, root, workspace, uriToPrefix, idxToPrefix);
        logger.info(""Applying default commit hooks"");
        // TODO: default hooks?
        List<CommitHook> hooks = newArrayList();
        UserConfiguration userConf = security.getConfiguration(UserConfiguration.class);
        String groupsPath = userConf.getParameters().getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);
        // hooks specific to the upgrade, need to run first
        hooks.add(new EditorHook(new CompositeEditorProvider(new RestrictionEditorProvider(), new GroupEditorProvider(groupsPath))));
        // security-related hooks
        for (SecurityConfiguration sc : security.getConfigurations()) {
            hooks.addAll(sc.getCommitHooks(workspace));
        }
        // type validation, reference and indexing hooks
        hooks.add(new EditorHook(new CompositeEditorProvider(new TypeEditorProvider(false), new IndexUpdateProvider(new CompositeIndexEditorProvider(new ReferenceEditorProvider(), new PropertyIndexEditorProvider())))));
        target.merge(builder, CompositeHook.compose(hooks), CommitInfo.EMPTY);
    } catch (Exception e) {
        throw new RepositoryException(""Failed to copy content"", e);
    }
}","/**
 * Copies the full content from the source to the target repository.
 * <p>
 * The source repository <strong>must not be modified</strong> while
 * the copy operation is running to avoid an inconsistent copy.
 * <p>
 * Note that both the source and the target repository must be closed
 * during the copy operation as this method requires exclusive access
 * to the repositories.
 *
 * @param initializer optional extra repository initializer to use
 * @throws RepositoryException if the copy operation fails
 */
","public void copy(RepositoryInitializer initializer) throws RepositoryException {
    RepositoryConfig config = source.getRepositoryConfig();
    logger.info(""Copying repository content from {} to Oak"", config.getHomeDir());
    try {
        NodeBuilder builder = target.getRoot().builder();
        String workspace = source.getRepositoryConfig().getDefaultWorkspaceName();
        SecurityProviderImpl security = new SecurityProviderImpl(mapSecurityConfig(config.getSecurityConfig()));
                new InitialContent().initialize(builder);
        if (initializer != null) {
            initializer.initialize(builder);
        }
        for (SecurityConfiguration sc : security.getConfigurations()) {
            sc.getWorkspaceInitializer().initialize(builder, workspace);
        }
        Map<String, String> uriToPrefix = newHashMap();
        Map<Integer, String> idxToPrefix = newHashMap();
        copyNamespaces(builder, uriToPrefix, idxToPrefix);
        copyNodeTypes(builder);
        copyPrivileges(builder);
        NodeState root = builder.getNodeState();
        copyVersionStore(builder, root, uriToPrefix, idxToPrefix);
        copyWorkspace(builder, root, workspace, uriToPrefix, idxToPrefix);
        logger.info(""Applying default commit hooks"");
                List<CommitHook> hooks = newArrayList();
        UserConfiguration userConf = security.getConfiguration(UserConfiguration.class);
        String groupsPath = userConf.getParameters().getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);
                hooks.add(new EditorHook(new CompositeEditorProvider(new RestrictionEditorProvider(), new GroupEditorProvider(groupsPath))));
                for (SecurityConfiguration sc : security.getConfigurations()) {
            hooks.addAll(sc.getCommitHooks(workspace));
        }
                hooks.add(new EditorHook(new CompositeEditorProvider(new TypeEditorProvider(false), new IndexUpdateProvider(new CompositeIndexEditorProvider(new ReferenceEditorProvider(), new PropertyIndexEditorProvider())))));
        target.merge(builder, CompositeHook.compose(hooks), CommitInfo.EMPTY);
    } catch (Exception e) {
        throw new RepositoryException(""Failed to copy content"", e);
    }
}",1.0,-0.22448979591836732,0.3333333333333333,0.0,-0.25,-0.030647553138902585,-0.7008890163464297,2.3333333333333335,-0.028571428571428574,0.5623883742146042
commons-math,remotes/origin/bugs-dot-jar_MATH-358_061f5017,0,"/**
 * {@inheritDoc}
 */
public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {
    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;
    // create some internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
        System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][];
    for (int i = 0; i < stages; ++i) {
        yDotK[i] = new double[y0.length];
    }
    final double[] yTmp = new double[y0.length];
    // set up an interpolator sharing the integrator arrays
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
        rki.reinitialize(this, yTmp, yDotK, forward);
        interpolator = rki;
    } else {
        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);
    }
    interpolator.storeTime(t0);
    // set up integration control objects
    stepStart = t0;
    stepSize = forward ? step : -step;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;
    // main integration loop
    while (!lastStep) {
        interpolator.shift();
        for (boolean loop = true; loop; ) {
            // first stage
            computeDerivatives(stepStart, y, yDotK[0]);
            // next stages
            for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
            // estimate the state at the end of the step
            for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
            // discrete events handling
            interpolator.storeTime(stepStart + stepSize);
            if (manager.evaluateStep(interpolator)) {
                final double dt = manager.getEventTime() - stepStart;
                if (Math.abs(dt) <= Math.ulp(stepStart)) {
                    // rejecting the step would lead to a too small next step, we accept it
                    loop = false;
                } else {
                    // reject the step to match exactly the next switch time
                    stepSize = dt;
                }
            } else {
                loop = false;
            }
        }
        // the step has been accepted
        final double nextStep = stepStart + stepSize;
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        manager.stepAccepted(nextStep, y);
        lastStep = manager.stop();
        // provide the step data to the step handler
        interpolator.storeTime(nextStep);
        for (StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, lastStep);
        }
        stepStart = nextStep;
        if (manager.reset(stepStart, y) && !lastStep) {
            // some events handler has triggered changes that
            // invalidate the derivatives, we need to recompute them
            computeDerivatives(stepStart, y, yDotK[0]);
        }
        // make sure step size is set to default before next step
        stepSize = forward ? step : -step;
    }
    final double stopTime = stepStart;
    stepStart = Double.NaN;
    stepSize = Double.NaN;
    return stopTime;
}","/**
 * {@inheritDoc}
 */
","public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {
    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;
        final int stages = c.length + 1;
    if (y != y0) {
        System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][];
    for (int i = 0; i < stages; ++i) {
        yDotK[i] = new double[y0.length];
    }
    final double[] yTmp = new double[y0.length];
        AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
        rki.reinitialize(this, yTmp, yDotK, forward);
        interpolator = rki;
    } else {
        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);
    }
    interpolator.storeTime(t0);
        stepStart = t0;
    stepSize = forward ? step : -step;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;
        while (!lastStep) {
        interpolator.shift();
        for (boolean loop = true; loop; ) {
                        computeDerivatives(stepStart, y, yDotK[0]);
                        for (int k = 1; k < stages; ++k) {
                for (int j = 0; j < y0.length; ++j) {
                    double sum = a[k - 1][0] * yDotK[0][j];
                    for (int l = 1; l < k; ++l) {
                        sum += a[k - 1][l] * yDotK[l][j];
                    }
                    yTmp[j] = y[j] + stepSize * sum;
                }
                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
            }
                        for (int j = 0; j < y0.length; ++j) {
                double sum = b[0] * yDotK[0][j];
                for (int l = 1; l < stages; ++l) {
                    sum += b[l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
                        interpolator.storeTime(stepStart + stepSize);
            if (manager.evaluateStep(interpolator)) {
                final double dt = manager.getEventTime() - stepStart;
                if (Math.abs(dt) <= Math.ulp(stepStart)) {
                                        loop = false;
                } else {
                                        stepSize = dt;
                }
            } else {
                loop = false;
            }
        }
                final double nextStep = stepStart + stepSize;
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        manager.stepAccepted(nextStep, y);
        lastStep = manager.stop();
                interpolator.storeTime(nextStep);
        for (StepHandler handler : stepHandlers) {
            handler.handleStep(interpolator, lastStep);
        }
        stepStart = nextStep;
        if (manager.reset(stepStart, y) && !lastStep) {
                                    computeDerivatives(stepStart, y, yDotK[0]);
        }
                stepSize = forward ? step : -step;
    }
    final double stopTime = stepStart;
    stepStart = Double.NaN;
    stepSize = Double.NaN;
    return stopTime;
}",3.090909090909091,1.3469387755102042,2.3333333333333335,1.5,2.6666666666666665,3.9476025704399413,-1.2824777745913396,1.6666666666666667,-0.028571428571428574,19.910249656288947
camel,remotes/origin/bugs-dot-jar_CAMEL-3281_f7dd2fff,1,"/**
 * <a href=""http://camel.apache.org/exception-clause.html"">Exception clause</a>
 * for catching certain exceptions and handling them.
 *
 * @param exception exception to catch
 * @return the builder
 */
public OnExceptionDefinition onException(Class exception) {
    routeCollection.setCamelContext(getContext());
    return routeCollection.onException(exception);
}","/**
 * <a href=""http://camel.apache.org/exception-clause.html"">Exception clause</a>
 * for catching certain exceptions and handling them.
 *
 * @param exception exception to catch
 * @return the builder
 */
","public OnExceptionDefinition onException(Class exception) {
    routeCollection.setCamelContext(getContext());
    return routeCollection.onException(exception);
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.855176369371953,-0.25,2.6,-0.16422749602751402
flink,remotes/origin/bugs-dot-jar_FLINK-2109_d594d024,1,"/**
 *  Marks task execution failed for an external reason (a reason other than th task code itself
 *  throwing an exception). If the task is already in a terminal state
 *  (such as FINISHED, CANCELED, FAILED), or if the task is already canceling this does nothing.
 *  Otherwise it sets the state to FAILED, and, if the invokable code is running,
 *  starts an asynchronous thread that aborts that code.
 *
 *  <p>This method never blocks.</p>
 */
public void failExternally(Throwable cause) {
    LOG.info(""Attempting to fail task externally "" + taskNameWithSubtask);
    cancelOrFailAndCancelInvokable(ExecutionState.FAILED, cause);
}","/**
 *  Marks task execution failed for an external reason (a reason other than th task code itself
 *  throwing an exception). If the task is already in a terminal state
 *  (such as FINISHED, CANCELED, FAILED), or if the task is already canceling this does nothing.
 *  Otherwise it sets the state to FAILED, and, if the invokable code is running,
 *  starts an asynchronous thread that aborts that code.
 *
 *  <p>This method never blocks.</p>
 */
","public void failExternally(Throwable cause) {
    LOG.info(""Attempting to fail task externally "" + taskNameWithSubtask);
    cancelOrFailAndCancelInvokable(ExecutionState.FAILED, cause);
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8038428448523088,-0.3333333333333333,1.0285714285714287,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-189_cd7feb4d,3,"@Override
public SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {
    RegExFilter result = new RegExFilter();
    result.setSource(getSource().deepCopy(env));
    result.rowMatcher = rowMatcher.pattern().matcher("""");
    result.colfMatcher = colfMatcher.pattern().matcher("""");
    result.colqMatcher = colqMatcher.pattern().matcher("""");
    result.valueMatcher = valueMatcher.pattern().matcher("""");
    result.orFields = orFields;
    return result;
}",,"@Override
public SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {
    RegExFilter result = new RegExFilter();
    result.setSource(getSource().deepCopy(env));
    result.rowMatcher = rowMatcher.pattern().matcher("""");
    result.colfMatcher = colfMatcher.pattern().matcher("""");
    result.colqMatcher = colqMatcher.pattern().matcher("""");
    result.valueMatcher = valueMatcher.pattern().matcher("""");
    result.orFields = orFields;
    return result;
}",-0.13636363636363635,-0.6326530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.10266704903928876,0.4166666666666667,-0.028571428571428574,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5,3,"@Override
public void updateAndFlush(ByteBuffer login, String tableName, Map<ByteBuffer, List<ColumnUpdate>> cells) throws TException {
    try {
        BatchWriter writer = getWriter(login, tableName, null);
        addCellsToWriter(cells, writer);
        writer.flush();
        writer.close();
    } catch (Exception e) {
        throw translateException(e);
    }
}",,"@Override
public void updateAndFlush(ByteBuffer login, String tableName, Map<ByteBuffer, List<ColumnUpdate>> cells) throws TException {
    try {
        BatchWriter writer = getWriter(login, tableName, null);
        addCellsToWriter(cells, writer);
        writer.flush();
        writer.close();
    } catch (Exception e) {
        throw translateException(e);
    }
}",-0.13636363636363635,0.15816326530612249,-0.16666666666666666,-0.5,-0.4166666666666667,-0.3806228373702422,0.15629480929165485,-0.08333333333333333,0.028571428571428574,-0.16422749602751402
Closure,66,2,"/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.LP:
            // ignored here.
            if (parent.getType() != Token.FUNCTION) {
                ensureTyped(t, n, getJSType(n.getFirstChild()));
            } else {
                typeable = false;
            }
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.REF_SPECIAL:
            ensureTyped(t, n);
            break;
        case Token.GET_REF:
            ensureTyped(t, n, getJSType(n.getFirstChild()));
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            // Object literal keys are handled with OBJECTLIT
            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
                ensureTyped(t, n, STRING_TYPE);
            // Object literal keys are not typeable
            }
            break;
        case Token.GET:
        case Token.SET:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.getType() == Token.ASSIGN && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            typeable = true;
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !NodeUtil.isExpressionNode(parent);
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
            {
                leftType = getJSType(n.getFirstChild());
                rightType = getJSType(n.getLastChild());
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                if (result != TernaryValue.UNKNOWN) {
                    if (n.getType() == Token.NE) {
                        result = result.not();
                    }
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.SHEQ:
        case Token.SHNE:
            {
                leftType = getJSType(n.getFirstChild());
                rightType = getJSType(n.getLastChild());
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
            // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            left = n.getFirstChild();
            right = n.getLastChild();
            leftType = getJSType(left);
            rightType = getJSType(right);
            validator.expectObject(t, n, rightType, ""'in' requires an object"");
            validator.expectString(t, left, leftType, ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            leftType = getJSType(left);
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, leftType, ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            if (!isReference(n.getFirstChild())) {
                report(t, n, BAD_DELETE);
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.getType() == Token.OBJECTLIT) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.getType() == Token.OBJECTLIT) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */
","public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
        boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.LP:
                        if (parent.getType() != Token.FUNCTION) {
                ensureTyped(t, n, getJSType(n.getFirstChild()));
            } else {
                typeable = false;
            }
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.REF_SPECIAL:
            ensureTyped(t, n);
            break;
        case Token.GET_REF:
            ensureTyped(t, n, getJSType(n.getFirstChild()));
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
                        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
                ensureTyped(t, n, STRING_TYPE);
                        }
            break;
        case Token.GET:
        case Token.SET:
                        break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.getType() == Token.ASSIGN && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
                                                typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            typeable = true;
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !NodeUtil.isExpressionNode(parent);
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
            {
                leftType = getJSType(n.getFirstChild());
                rightType = getJSType(n.getLastChild());
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                if (result != TernaryValue.UNKNOWN) {
                    if (n.getType() == Token.NE) {
                        result = result.not();
                    }
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.SHEQ:
        case Token.SHNE:
            {
                leftType = getJSType(n.getFirstChild());
                rightType = getJSType(n.getLastChild());
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                        } else {
                                                                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            left = n.getFirstChild();
            right = n.getLastChild();
            leftType = getJSType(left);
            rightType = getJSType(right);
            validator.expectObject(t, n, rightType, ""'in' requires an object"");
            validator.expectString(t, left, leftType, ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            leftType = getJSType(left);
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, leftType, ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            if (!isReference(n.getFirstChild())) {
                report(t, n, BAD_DELETE);
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
                case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
                case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
                case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                                ensureTyped(t, n);
            } else {
                                if ((n.getType() == Token.OBJECTLIT) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.getType() == Token.OBJECTLIT) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
        typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}",11.909090909090908,0.25510204081632654,23.5,1.5,9.75,1.0390509144834406,-2.827358761112705,11.25,-0.028571428571428574,17.068857851388337
Closure,158,2,"CommandLineConfig setJscompWarning(List<String> jscompWarning) {
    this.jscompWarning.clear();
    this.jscompWarning.addAll(jscompWarning);
    return this;
}",,"CommandLineConfig setJscompWarning(List<String> jscompWarning) {
    this.jscompWarning.clear();
    this.jscompWarning.addAll(jscompWarning);
    return this;
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7516489819328936,-0.3333333333333333,0.08571428571428572,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7,3,"@Override
public void write(org.apache.thrift.protocol.TProtocol prot, removeTableProperty_result struct) throws org.apache.thrift.TException {
    TTupleProtocol oprot = (TTupleProtocol) prot;
    BitSet optionals = new BitSet();
    if (struct.isSetOuch1()) {
        optionals.set(0);
    }
    if (struct.isSetOuch2()) {
        optionals.set(1);
    }
    oprot.writeBitSet(optionals, 2);
    if (struct.isSetOuch1()) {
        struct.ouch1.write(oprot);
    }
    if (struct.isSetOuch2()) {
        struct.ouch2.write(oprot);
    }
}",,"@Override
public void write(org.apache.thrift.protocol.TProtocol prot, removeTableProperty_result struct) throws org.apache.thrift.TException {
    TTupleProtocol oprot = (TTupleProtocol) prot;
    BitSet optionals = new BitSet();
    if (struct.isSetOuch1()) {
        optionals.set(0);
    }
    if (struct.isSetOuch2()) {
        optionals.set(1);
    }
    oprot.writeBitSet(optionals, 2);
    if (struct.isSetOuch1()) {
        struct.ouch1.write(oprot);
    }
    if (struct.isSetOuch2()) {
        struct.ouch2.write(oprot);
    }
}",0.18181818181818182,-0.2755102040816327,0.16666666666666666,-0.5,0.08333333333333333,-0.3806228373702422,-0.16260395755663903,0.25,-0.028571428571428574,-0.16422749602751402
Closure,13,2,"private void traverse(Node node) {
    // and revisit immediately.
    if (!shouldVisit(node)) {
        return;
    }
    int visits = 0;
    do {
        Node c = node.getFirstChild();
        while (c != null) {
            traverse(c);
            Node next = c.getNext();
            c = next;
        }
        visit(node);
        visits++;
        Preconditions.checkState(visits < 10000, ""too many interations"");
    } while (shouldRetraverse(node));
    exitNode(node);
}",,"private void traverse(Node node) {
        if (!shouldVisit(node)) {
        return;
    }
    int visits = 0;
    do {
        Node c = node.getFirstChild();
        while (c != null) {
            traverse(c);
            Node next = c.getNext();
            c = next;
        }
        visit(node);
        visits++;
        Preconditions.checkState(visits < 10000, ""too many interations"");
    } while (shouldRetraverse(node));
    exitNode(node);
}",0.18181818181818182,0.2755102040816327,0.0,0.0,0.16666666666666666,0.3272367770637668,-0.12646974476627468,0.16666666666666666,0.20000000000000004,0.13095283984564057
Closure,159,2,"/**
 * @see #findCalledFunctions(Node)
 */
private void findCalledFunctions(Node node, Set<String> changed) {
    Preconditions.checkArgument(changed != null);
    // For each referenced function, add a new reference
    if (node.getType() == Token.CALL) {
        Node child = node.getFirstChild();
        if (child.getType() == Token.NAME) {
            changed.add(child.getString());
        }
    }
    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {
        findCalledFunctions(c, changed);
    }
}","/**
 * @see #findCalledFunctions(Node)
 */
","private void findCalledFunctions(Node node, Set<String> changed) {
    Preconditions.checkArgument(changed != null);
        if (node.getType() == Token.CALL) {
        Node child = node.getFirstChild();
        if (child.getType() == Token.NAME) {
            changed.add(child.getString());
        }
    }
    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {
        findCalledFunctions(c, changed);
    }
}",-0.09090909090909091,0.1938775510204081,0.0,0.0,0.08333333333333333,0.004943153732081095,0.05047318611987357,0.25,0.6285714285714287,0.009559664383825661
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1199_813109d7,3,"public boolean equals(removeTableProperty_result that) {
    if (that == null)
        return false;
    boolean this_present_ouch1 = true && this.isSetOuch1();
    boolean that_present_ouch1 = true && that.isSetOuch1();
    if (this_present_ouch1 || that_present_ouch1) {
        if (!(this_present_ouch1 && that_present_ouch1))
            return false;
        if (!this.ouch1.equals(that.ouch1))
            return false;
    }
    boolean this_present_ouch2 = true && this.isSetOuch2();
    boolean that_present_ouch2 = true && that.isSetOuch2();
    if (this_present_ouch2 || that_present_ouch2) {
        if (!(this_present_ouch2 && that_present_ouch2))
            return false;
        if (!this.ouch2.equals(that.ouch2))
            return false;
    }
    return true;
}",,"public boolean equals(removeTableProperty_result that) {
    if (that == null)
        return false;
    boolean this_present_ouch1 = true && this.isSetOuch1();
    boolean that_present_ouch1 = true && that.isSetOuch1();
    if (this_present_ouch1 || that_present_ouch1) {
        if (!(this_present_ouch1 && that_present_ouch1))
            return false;
        if (!this.ouch1.equals(that.ouch1))
            return false;
    }
    boolean this_present_ouch2 = true && this.isSetOuch2();
    boolean that_present_ouch2 = true && that.isSetOuch2();
    if (this_present_ouch2 || that_present_ouch2) {
        if (!(this_present_ouch2 && that_present_ouch2))
            return false;
        if (!this.ouch2.equals(that.ouch2))
            return false;
    }
    return true;
}",0.3181818181818182,0.3061224489795919,0.6666666666666666,-0.5,1.25,0.726643598615917,-0.26641812446228874,0.0,-0.028571428571428574,0.4473725913457626
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-139_50e19247,1,"/**
 * @param host The name of the host to connect to.
 * @param portNum The port to connect to on the target host.
 * @param protocol The Protocol to use.
 * @param delay The interval in which failed writes should be retried.
 * @param immediateFail True if the write should fail if no socket is immediately available.
 * @param name The name of the Appender.
 * @param immediateFlush ""true"" if data should be flushed on each write.
 * @param suppress ""true"" if exceptions should be hidden from the application, ""false"" otherwise.
 * The default is ""true"".
 * @param layout The layout to use (defaults to SerializedLayout).
 * @param filter The Filter or null.
 * @param advertise ""true"" if the appender configuration should be advertised, ""false"" otherwise.
 * @param config The Configuration
 * @return A SocketAppender.
 */
@PluginFactory
public static <S extends Serializable> SocketAppender<S> createAppender(@PluginAttr(""host"") final String host, @PluginAttr(""port"") final String portNum, @PluginAttr(""protocol"") final String protocol, @PluginAttr(""reconnectionDelay"") final String delay, @PluginAttr(""immediateFail"") final String immediateFail, @PluginAttr(""name"") final String name, @PluginAttr(""immediateFlush"") final String immediateFlush, @PluginAttr(""suppressExceptions"") final String suppress, @PluginElement(""layout"") Layout<S> layout, @PluginElement(""filters"") final Filter filter, @PluginAttr(""advertise"") final String advertise, @PluginConfiguration final Configuration config) {
    boolean isFlush = immediateFlush == null ? true : Boolean.valueOf(immediateFlush);
    boolean isAdvertise = advertise == null ? false : Boolean.valueOf(advertise);
    final boolean handleExceptions = suppress == null ? true : Boolean.valueOf(suppress);
    final boolean fail = immediateFail == null ? true : Boolean.valueOf(immediateFail);
    final int reconnectDelay = delay == null ? 0 : Integer.parseInt(delay);
    final int port = portNum == null ? 0 : Integer.parseInt(portNum);
    if (layout == null) {
        @SuppressWarnings({ ""unchecked"", ""UnnecessaryLocalVariable"" })
        Layout<S> l = (Layout<S>) SerializedLayout.createLayout();
        layout = l;
    }
    if (name == null) {
        LOGGER.error(""No name provided for SocketAppender"");
        return null;
    }
    final String prot = protocol != null ? protocol : Protocol.TCP.name();
    final Protocol p = EnglishEnums.valueOf(Protocol.class, protocol);
    if (p.equals(Protocol.UDP)) {
        isFlush = true;
    }
    final AbstractSocketManager manager = createSocketManager(p, host, port, reconnectDelay, fail, layout);
    if (manager == null) {
        return null;
    }
    return new SocketAppender<S>(name, layout, filter, manager, handleExceptions, isFlush, isAdvertise ? config.getAdvertiser() : null);
}","/**
 * @param host The name of the host to connect to.
 * @param portNum The port to connect to on the target host.
 * @param protocol The Protocol to use.
 * @param delay The interval in which failed writes should be retried.
 * @param immediateFail True if the write should fail if no socket is immediately available.
 * @param name The name of the Appender.
 * @param immediateFlush ""true"" if data should be flushed on each write.
 * @param suppress ""true"" if exceptions should be hidden from the application, ""false"" otherwise.
 * The default is ""true"".
 * @param layout The layout to use (defaults to SerializedLayout).
 * @param filter The Filter or null.
 * @param advertise ""true"" if the appender configuration should be advertised, ""false"" otherwise.
 * @param config The Configuration
 * @return A SocketAppender.
 */
","@PluginFactory
public static <S extends Serializable> SocketAppender<S> createAppender(@PluginAttr(""host"") final String host, @PluginAttr(""port"") final String portNum, @PluginAttr(""protocol"") final String protocol, @PluginAttr(""reconnectionDelay"") final String delay, @PluginAttr(""immediateFail"") final String immediateFail, @PluginAttr(""name"") final String name, @PluginAttr(""immediateFlush"") final String immediateFlush, @PluginAttr(""suppressExceptions"") final String suppress, @PluginElement(""layout"") Layout<S> layout, @PluginElement(""filters"") final Filter filter, @PluginAttr(""advertise"") final String advertise, @PluginConfiguration final Configuration config) {
    boolean isFlush = immediateFlush == null ? true : Boolean.valueOf(immediateFlush);
    boolean isAdvertise = advertise == null ? false : Boolean.valueOf(advertise);
    final boolean handleExceptions = suppress == null ? true : Boolean.valueOf(suppress);
    final boolean fail = immediateFail == null ? true : Boolean.valueOf(immediateFail);
    final int reconnectDelay = delay == null ? 0 : Integer.parseInt(delay);
    final int port = portNum == null ? 0 : Integer.parseInt(portNum);
    if (layout == null) {
        @SuppressWarnings({ ""unchecked"", ""UnnecessaryLocalVariable"" })
        Layout<S> l = (Layout<S>) SerializedLayout.createLayout();
        layout = l;
    }
    if (name == null) {
        LOGGER.error(""No name provided for SocketAppender"");
        return null;
    }
    final String prot = protocol != null ? protocol : Protocol.TCP.name();
    final Protocol p = EnglishEnums.valueOf(Protocol.class, protocol);
    if (p.equals(Protocol.UDP)) {
        isFlush = true;
    }
    final AbstractSocketManager manager = createSocketManager(p, host, port, reconnectDelay, fail, layout);
    if (manager == null) {
        return null;
    }
    return new SocketAppender<S>(name, layout, filter, manager, handleExceptions, isFlush, isAdvertise ? config.getAdvertiser() : null);
}",0.6363636363636364,-0.35714285714285726,1.5,-0.5,1.5833333333333333,0.1334651507661889,-0.6512761686263268,0.5833333333333334,-0.028571428571428574,1.0615210659539749
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2691_d2da7499,0,"/**
 * Retrieves the {# CLUSTER_ID_PROP}
 *
 * @param store the NodeStore instance
 * @return the repository id
 */
public static String getId(NodeStore store) {
    return store.getRoot().getChildNode(CLUSTER_CONFIG_NODE).getProperty(CLUSTER_ID_PROP).getValue(Type.STRING);
}","/**
 * Retrieves the {# CLUSTER_ID_PROP}
 *
 * @param store the NodeStore instance
 * @return the repository id
 */
","public static String getId(NodeStore store) {
    return store.getRoot().getChildNode(CLUSTER_CONFIG_NODE).getProperty(CLUSTER_ID_PROP).getValue(Type.STRING);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9217092056208774,-0.16666666666666666,2.8000000000000003,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-9641_9a6e6d8a,1,"private Expression createSimpleExpression(String function, boolean strict) {
    // return the function directly if we can create function without analyzing the prefix
    Expression answer = createSimpleExpressionDirectly(function);
    if (answer != null) {
        return answer;
    }
    // body and headers first
    answer = createSimpleExpressionBodyOrHeader(function, strict);
    if (answer != null) {
        return answer;
    }
    // camelContext OGNL
    String remainder = ifStartsWithReturnRemainder(""camelContext"", function);
    if (remainder != null) {
        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);
        if (invalid) {
            throw new SimpleParserException(""Valid syntax: ${camelContext.OGNL} was: "" + function, token.getIndex());
        }
        return ExpressionBuilder.camelContextOgnlExpression(remainder);
    }
    // Exception OGNL
    remainder = ifStartsWithReturnRemainder(""exception"", function);
    if (remainder != null) {
        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);
        if (invalid) {
            throw new SimpleParserException(""Valid syntax: ${exception.OGNL} was: "" + function, token.getIndex());
        }
        return ExpressionBuilder.exchangeExceptionOgnlExpression(remainder);
    }
    // property
    remainder = ifStartsWithReturnRemainder(""property"", function);
    if (remainder == null) {
        remainder = ifStartsWithReturnRemainder(""exchangeProperty"", function);
    }
    if (remainder != null) {
        // remove leading character (dot or ?)
        if (remainder.startsWith(""."") || remainder.startsWith(""?"")) {
            remainder = remainder.substring(1);
        }
        // remove starting and ending brackets
        if (remainder.startsWith(""["") && remainder.endsWith(""]"")) {
            remainder = remainder.substring(1, remainder.length() - 1);
        }
        // validate syntax
        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);
        if (invalid) {
            throw new SimpleParserException(""Valid syntax: ${exchangeProperty.OGNL} was: "" + function, token.getIndex());
        }
        if (OgnlHelper.isValidOgnlExpression(remainder)) {
            // ognl based property
            return ExpressionBuilder.propertyOgnlExpression(remainder);
        } else {
            // regular property
            return ExpressionBuilder.exchangePropertyExpression(remainder);
        }
    }
    // system property
    remainder = ifStartsWithReturnRemainder(""sys."", function);
    if (remainder != null) {
        return ExpressionBuilder.systemPropertyExpression(remainder);
    }
    remainder = ifStartsWithReturnRemainder(""sysenv."", function);
    if (remainder != null) {
        return ExpressionBuilder.systemEnvironmentExpression(remainder);
    }
    // exchange OGNL
    remainder = ifStartsWithReturnRemainder(""exchange"", function);
    if (remainder != null) {
        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);
        if (invalid) {
            throw new SimpleParserException(""Valid syntax: ${exchange.OGNL} was: "" + function, token.getIndex());
        }
        return ExpressionBuilder.exchangeOgnlExpression(remainder);
    }
    // file: prefix
    remainder = ifStartsWithReturnRemainder(""file:"", function);
    if (remainder != null) {
        Expression fileExpression = createSimpleFileExpression(remainder);
        if (function != null) {
            return fileExpression;
        }
    }
    // date: prefix
    remainder = ifStartsWithReturnRemainder(""date:"", function);
    if (remainder != null) {
        String[] parts = remainder.split("":"");
        if (parts.length < 2) {
            throw new SimpleParserException(""Valid syntax: ${date:command:pattern} was: "" + function, token.getIndex());
        }
        String command = ObjectHelper.before(remainder, "":"");
        String pattern = ObjectHelper.after(remainder, "":"");
        return ExpressionBuilder.dateExpression(command, pattern);
    }
    // bean: prefix
    remainder = ifStartsWithReturnRemainder(""bean:"", function);
    if (remainder != null) {
        return ExpressionBuilder.beanExpression(remainder);
    }
    // properties: prefix
    remainder = ifStartsWithReturnRemainder(""properties:"", function);
    if (remainder != null) {
        String[] parts = remainder.split("":"");
        if (parts.length > 2) {
            throw new SimpleParserException(""Valid syntax: ${properties:key[:default]} was: "" + function, token.getIndex());
        }
        return ExpressionBuilder.propertiesComponentExpression(remainder, null);
    }
    // properties-location: prefix
    remainder = ifStartsWithReturnRemainder(""properties-location:"", function);
    if (remainder != null) {
        String[] parts = remainder.split("":"");
        if (parts.length > 3) {
            throw new SimpleParserException(""Valid syntax: ${properties-location:location:key[:default]} was: "" + function, token.getIndex());
        }
        String locations = null;
        String key = remainder;
        if (parts.length >= 2) {
            locations = ObjectHelper.before(remainder, "":"");
            key = ObjectHelper.after(remainder, "":"");
        }
        return ExpressionBuilder.propertiesComponentExpression(key, locations);
    }
    // ref: prefix
    remainder = ifStartsWithReturnRemainder(""ref:"", function);
    if (remainder != null) {
        return ExpressionBuilder.refExpression(remainder);
    }
    // const: prefix
    remainder = ifStartsWithReturnRemainder(""type:"", function);
    if (remainder != null) {
        Expression exp = ExpressionBuilder.typeExpression(remainder);
        // we want to cache this expression so we wont re-evaluate it as the type/constant wont change
        return ExpressionBuilder.cacheExpression(exp);
    }
    // random
    remainder = ifStartsWithReturnRemainder(""random"", function);
    if (remainder != null) {
        String values = ObjectHelper.between(remainder, ""("", "")"");
        if (values == null || ObjectHelper.isEmpty(values)) {
            throw new SimpleParserException(""Valid syntax: ${random(min,max)} or ${random(max)} was: "" + function, token.getIndex());
        }
        if (values.contains("","")) {
            String[] tokens = values.split("","", -1);
            if (tokens.length > 2) {
                throw new SimpleParserException(""Valid syntax: ${random(min,max)} or ${random(max)} was: "" + function, token.getIndex());
            }
            int min = Integer.parseInt(tokens[0].trim());
            int max = Integer.parseInt(tokens[1].trim());
            return ExpressionBuilder.randomExpression(min, max);
        } else {
            int max = Integer.parseInt(values.trim());
            return ExpressionBuilder.randomExpression(max);
        }
    }
    // collate function
    remainder = ifStartsWithReturnRemainder(""collate"", function);
    if (remainder != null) {
        String values = ObjectHelper.between(remainder, ""("", "")"");
        if (values == null || ObjectHelper.isEmpty(values)) {
            throw new SimpleParserException(""Valid syntax: ${collate(group)} was: "" + function, token.getIndex());
        }
        String exp = ""${body}"";
        int num = Integer.parseInt(values.trim());
        return ExpressionBuilder.collateExpression(exp, num);
    }
    if (strict) {
        throw new SimpleParserException(""Unknown function: "" + function, token.getIndex());
    } else {
        return null;
    }
}",,"private Expression createSimpleExpression(String function, boolean strict) {
        Expression answer = createSimpleExpressionDirectly(function);
    if (answer != null) {
        return answer;
    }
        answer = createSimpleExpressionBodyOrHeader(function, strict);
    if (answer != null) {
        return answer;
    }
        String remainder = ifStartsWithReturnRemainder(""camelContext"", function);
    if (remainder != null) {
        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);
        if (invalid) {
            throw new SimpleParserException(""Valid syntax: ${camelContext.OGNL} was: "" + function, token.getIndex());
        }
        return ExpressionBuilder.camelContextOgnlExpression(remainder);
    }
        remainder = ifStartsWithReturnRemainder(""exception"", function);
    if (remainder != null) {
        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);
        if (invalid) {
            throw new SimpleParserException(""Valid syntax: ${exception.OGNL} was: "" + function, token.getIndex());
        }
        return ExpressionBuilder.exchangeExceptionOgnlExpression(remainder);
    }
        remainder = ifStartsWithReturnRemainder(""property"", function);
    if (remainder == null) {
        remainder = ifStartsWithReturnRemainder(""exchangeProperty"", function);
    }
    if (remainder != null) {
                if (remainder.startsWith(""."") || remainder.startsWith(""?"")) {
            remainder = remainder.substring(1);
        }
                if (remainder.startsWith(""["") && remainder.endsWith(""]"")) {
            remainder = remainder.substring(1, remainder.length() - 1);
        }
                boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);
        if (invalid) {
            throw new SimpleParserException(""Valid syntax: ${exchangeProperty.OGNL} was: "" + function, token.getIndex());
        }
        if (OgnlHelper.isValidOgnlExpression(remainder)) {
                        return ExpressionBuilder.propertyOgnlExpression(remainder);
        } else {
                        return ExpressionBuilder.exchangePropertyExpression(remainder);
        }
    }
        remainder = ifStartsWithReturnRemainder(""sys."", function);
    if (remainder != null) {
        return ExpressionBuilder.systemPropertyExpression(remainder);
    }
    remainder = ifStartsWithReturnRemainder(""sysenv."", function);
    if (remainder != null) {
        return ExpressionBuilder.systemEnvironmentExpression(remainder);
    }
        remainder = ifStartsWithReturnRemainder(""exchange"", function);
    if (remainder != null) {
        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);
        if (invalid) {
            throw new SimpleParserException(""Valid syntax: ${exchange.OGNL} was: "" + function, token.getIndex());
        }
        return ExpressionBuilder.exchangeOgnlExpression(remainder);
    }
        remainder = ifStartsWithReturnRemainder(""file:"", function);
    if (remainder != null) {
        Expression fileExpression = createSimpleFileExpression(remainder);
        if (function != null) {
            return fileExpression;
        }
    }
        remainder = ifStartsWithReturnRemainder(""date:"", function);
    if (remainder != null) {
        String[] parts = remainder.split("":"");
        if (parts.length < 2) {
            throw new SimpleParserException(""Valid syntax: ${date:command:pattern} was: "" + function, token.getIndex());
        }
        String command = ObjectHelper.before(remainder, "":"");
        String pattern = ObjectHelper.after(remainder, "":"");
        return ExpressionBuilder.dateExpression(command, pattern);
    }
        remainder = ifStartsWithReturnRemainder(""bean:"", function);
    if (remainder != null) {
        return ExpressionBuilder.beanExpression(remainder);
    }
        remainder = ifStartsWithReturnRemainder(""properties:"", function);
    if (remainder != null) {
        String[] parts = remainder.split("":"");
        if (parts.length > 2) {
            throw new SimpleParserException(""Valid syntax: ${properties:key[:default]} was: "" + function, token.getIndex());
        }
        return ExpressionBuilder.propertiesComponentExpression(remainder, null);
    }
        remainder = ifStartsWithReturnRemainder(""properties-location:"", function);
    if (remainder != null) {
        String[] parts = remainder.split("":"");
        if (parts.length > 3) {
            throw new SimpleParserException(""Valid syntax: ${properties-location:location:key[:default]} was: "" + function, token.getIndex());
        }
        String locations = null;
        String key = remainder;
        if (parts.length >= 2) {
            locations = ObjectHelper.before(remainder, "":"");
            key = ObjectHelper.after(remainder, "":"");
        }
        return ExpressionBuilder.propertiesComponentExpression(key, locations);
    }
        remainder = ifStartsWithReturnRemainder(""ref:"", function);
    if (remainder != null) {
        return ExpressionBuilder.refExpression(remainder);
    }
        remainder = ifStartsWithReturnRemainder(""type:"", function);
    if (remainder != null) {
        Expression exp = ExpressionBuilder.typeExpression(remainder);
                return ExpressionBuilder.cacheExpression(exp);
    }
        remainder = ifStartsWithReturnRemainder(""random"", function);
    if (remainder != null) {
        String values = ObjectHelper.between(remainder, ""("", "")"");
        if (values == null || ObjectHelper.isEmpty(values)) {
            throw new SimpleParserException(""Valid syntax: ${random(min,max)} or ${random(max)} was: "" + function, token.getIndex());
        }
        if (values.contains("","")) {
            String[] tokens = values.split("","", -1);
            if (tokens.length > 2) {
                throw new SimpleParserException(""Valid syntax: ${random(min,max)} or ${random(max)} was: "" + function, token.getIndex());
            }
            int min = Integer.parseInt(tokens[0].trim());
            int max = Integer.parseInt(tokens[1].trim());
            return ExpressionBuilder.randomExpression(min, max);
        } else {
            int max = Integer.parseInt(values.trim());
            return ExpressionBuilder.randomExpression(max);
        }
    }
        remainder = ifStartsWithReturnRemainder(""collate"", function);
    if (remainder != null) {
        String values = ObjectHelper.between(remainder, ""("", "")"");
        if (values == null || ObjectHelper.isEmpty(values)) {
            throw new SimpleParserException(""Valid syntax: ${collate(group)} was: "" + function, token.getIndex());
        }
        String exp = ""${body}"";
        int num = Integer.parseInt(values.trim());
        return ExpressionBuilder.collateExpression(exp, num);
    }
    if (strict) {
        throw new SimpleParserException(""Unknown function: "" + function, token.getIndex());
    } else {
        return null;
    }
}",6.136363636363637,-0.005102040816326648,7.166666666666667,0.5,4.083333333333333,3.5442412259021263,-1.8161743619156876,6.166666666666667,-0.028571428571428574,27.969192353981693
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1822_016df669,1,"/**
 * Increment the value.
 *
 * @param property the key
 * @param value the increment
 */
public void increment(@Nonnull String property, long value) {
    Operation op = new Operation();
    op.type = Operation.Type.INCREMENT;
    op.value = value;
    changes.put(new Key(property, null), op);
}","/**
 * Increment the value.
 *
 * @param property the key
 * @param value the increment
 */
","public void increment(@Nonnull String property, long value) {
    Operation op = new Operation();
    op.type = Operation.Type.INCREMENT;
    op.value = value;
    changes.put(new Key(property, null), op);
}",-0.36363636363636365,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.4955549182678522,-0.4166666666666667,2.2285714285714286,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-8954_7b1253db,3,"/**
 * Creates a copy based on the source
 *
 * @param source the source
 * @return a copy of the source
 */
@SuppressWarnings(""unchecked"")
public GenericFile<T> copyFrom(GenericFile<T> source) {
    GenericFile<T> result;
    try {
        result = source.getClass().newInstance();
    } catch (Exception e) {
        throw ObjectHelper.wrapRuntimeCamelException(e);
    }
    result.setEndpointPath(source.getEndpointPath());
    result.setAbsolute(source.isAbsolute());
    result.setDirectory(source.isDirectory());
    result.setAbsoluteFilePath(source.getAbsoluteFilePath());
    result.setRelativeFilePath(source.getRelativeFilePath());
    result.setFileName(source.getFileName());
    result.setFileNameOnly(source.getFileNameOnly());
    result.setFileLength(source.getFileLength());
    result.setLastModified(source.getLastModified());
    result.setFile(source.getFile());
    result.setBody(source.getBody());
    result.setBinding(source.getBinding());
    result.setCharset(source.getCharset());
    copyFromPopulateAdditional(source, result);
    return result;
}","/**
 * Creates a copy based on the source
 *
 * @param source the source
 * @return a copy of the source
 */
","@SuppressWarnings(""unchecked"")
public GenericFile<T> copyFrom(GenericFile<T> source) {
    GenericFile<T> result;
    try {
        result = source.getClass().newInstance();
    } catch (Exception e) {
        throw ObjectHelper.wrapRuntimeCamelException(e);
    }
    result.setEndpointPath(source.getEndpointPath());
    result.setAbsolute(source.isAbsolute());
    result.setDirectory(source.isDirectory());
    result.setAbsoluteFilePath(source.getAbsoluteFilePath());
    result.setRelativeFilePath(source.getRelativeFilePath());
    result.setFileName(source.getFileName());
    result.setFileNameOnly(source.getFileNameOnly());
    result.setFileLength(source.getFileLength());
    result.setLastModified(source.getLastModified());
    result.setFile(source.getFile());
    result.setBody(source.getBody());
    result.setBinding(source.getBinding());
    result.setCharset(source.getCharset());
    copyFromPopulateAdditional(source, result);
    return result;
}",0.45454545454545453,-0.6122448979591837,-0.16666666666666666,-0.5,-0.4166666666666667,-0.3806228373702422,-0.3699455119013481,2.0,-0.028571428571428574,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-4138_50db442b,1,"@Override
public Options getOptions() {
    final Options o = new Options();
    verboseOpt = new Option(""v"", ""verbose"", false, ""verbose output during merge"");
    sizeOpt = new Option(""s"", ""size"", true, ""merge tablets to the given size over the entire table"");
    forceOpt = new Option(""f"", ""force"", false, ""merge small tablets to large tablets, even if it goes over the given size"");
    allOpt = new Option("""", ""all"", false, ""allow an entire table to be merged into one tablet without prompting the user for confirmation"");
    Option startRowOpt = OptUtil.startRowOpt();
    startRowOpt.setDescription(""begin row (NOT inclusive)"");
    o.addOption(startRowOpt);
    o.addOption(OptUtil.endRowOpt());
    o.addOption(OptUtil.tableOpt(""table to be merged""));
    o.addOption(verboseOpt);
    o.addOption(sizeOpt);
    o.addOption(forceOpt);
    o.addOption(allOpt);
    return o;
}",,"@Override
public Options getOptions() {
    final Options o = new Options();
    verboseOpt = new Option(""v"", ""verbose"", false, ""verbose output during merge"");
    sizeOpt = new Option(""s"", ""size"", true, ""merge tablets to the given size over the entire table"");
    forceOpt = new Option(""f"", ""force"", false, ""merge small tablets to large tablets, even if it goes over the given size"");
    allOpt = new Option("""", ""all"", false, ""allow an entire table to be merged into one tablet without prompting the user for confirmation"");
    Option startRowOpt = OptUtil.startRowOpt();
    startRowOpt.setDescription(""begin row (NOT inclusive)"");
    o.addOption(startRowOpt);
    o.addOption(OptUtil.endRowOpt());
    o.addOption(OptUtil.tableOpt(""table to be merged""));
    o.addOption(verboseOpt);
    o.addOption(sizeOpt);
    o.addOption(forceOpt);
    o.addOption(allOpt);
    return o;
}",0.18181818181818182,-0.7806122448979592,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,-0.19501003728133062,0.4166666666666667,-0.028571428571428574,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-3448_b345dd82,0,"public static ExceptionPolicyKey newInstance(Class exceptionClass) {
    return new ExceptionPolicyKey(exceptionClass, null);
}",,"public static ExceptionPolicyKey newInstance(Class exceptionClass) {
    return new ExceptionPolicyKey(exceptionClass, null);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.0585030111843994,-0.5,1.2,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-7167_1e33fcbc,3,"/**
 * Common work which must be done when we are done multicasting.
 * <p/>
 * This logic applies for both running synchronous and asynchronous as there are multiple exist points
 * when using the asynchronous routing engine. And therefore we want the logic in one method instead
 * of being scattered.
 *
 * @param original     the original exchange
 * @param subExchange  the current sub exchange, can be <tt>null</tt> for the synchronous part
 * @param pairs        the pairs with the exchanges to process
 * @param callback     the callback
 * @param doneSync     the <tt>doneSync</tt> parameter to call on callback
 * @param forceExhaust whether or not error handling is exhausted
 */
protected void doDone(Exchange original, Exchange subExchange, final Iterable<ProcessorExchangePair> pairs, AsyncCallback callback, boolean doneSync, boolean forceExhaust) {
    // we are done so close the pairs iterator
    if (pairs != null && pairs instanceof Closeable) {
        IOHelper.close((Closeable) pairs, ""pairs"", LOG);
    }
    // cleanup any per exchange aggregation strategy
    removeAggregationStrategyFromExchange(original);
    // we need to know if there was an exception, and if the stopOnException option was enabled
    // also we would need to know if any error handler has attempted redelivery and exhausted
    boolean stoppedOnException = false;
    boolean exception = false;
    boolean exhaust = forceExhaust || subExchange != null && (subExchange.getException() != null || ExchangeHelper.isRedeliveryExhausted(subExchange));
    if (original.getException() != null || subExchange != null && subExchange.getException() != null) {
        // there was an exception and we stopped
        stoppedOnException = isStopOnException();
        exception = true;
    }
    // must copy results at this point
    if (subExchange != null) {
        if (stoppedOnException) {
            // if we stopped due an exception then only propagte the exception
            original.setException(subExchange.getException());
        } else {
            // copy the current result to original so it will contain this result of this eip
            ExchangeHelper.copyResults(original, subExchange);
        }
    }
    // handled has been in use, then the exhaust would be false (if not forced)
    if (exception) {
        // multicast uses error handling on its output processors and they have tried to redeliver
        // so we shall signal back to the other error handlers that we are exhausted and they should not
        // also try to redeliver as we will then do that twice
        original.setProperty(Exchange.REDELIVERY_EXHAUSTED, exhaust);
    }
    callback.done(doneSync);
}","/**
 * Common work which must be done when we are done multicasting.
 * <p/>
 * This logic applies for both running synchronous and asynchronous as there are multiple exist points
 * when using the asynchronous routing engine. And therefore we want the logic in one method instead
 * of being scattered.
 *
 * @param original     the original exchange
 * @param subExchange  the current sub exchange, can be <tt>null</tt> for the synchronous part
 * @param pairs        the pairs with the exchanges to process
 * @param callback     the callback
 * @param doneSync     the <tt>doneSync</tt> parameter to call on callback
 * @param forceExhaust whether or not error handling is exhausted
 */
","protected void doDone(Exchange original, Exchange subExchange, final Iterable<ProcessorExchangePair> pairs, AsyncCallback callback, boolean doneSync, boolean forceExhaust) {
        if (pairs != null && pairs instanceof Closeable) {
        IOHelper.close((Closeable) pairs, ""pairs"", LOG);
    }
        removeAggregationStrategyFromExchange(original);
            boolean stoppedOnException = false;
    boolean exception = false;
    boolean exhaust = forceExhaust || subExchange != null && (subExchange.getException() != null || ExchangeHelper.isRedeliveryExhausted(subExchange));
    if (original.getException() != null || subExchange != null && subExchange.getException() != null) {
                stoppedOnException = isStopOnException();
        exception = true;
    }
        if (subExchange != null) {
        if (stoppedOnException) {
                        original.setException(subExchange.getException());
        } else {
                        ExchangeHelper.copyResults(original, subExchange);
        }
    }
        if (exception) {
                                original.setProperty(Exchange.REDELIVERY_EXHAUSTED, exhaust);
    }
    callback.done(doneSync);
}",0.45454545454545453,-0.005102040816326648,0.3333333333333333,0.0,0.75,0.4972812654473556,-0.40321193002581035,0.5,-0.028571428571428574,0.7102762109122369
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1363_69b68890,0,"/**
 * Create the {@code AuthInfo} for the specified {@code tokenInfo} as well as
 * userId and principals, that have been set upon {@link #login}.
 *
 * @param tokenInfo The tokenInfo to retrieve attributes from.
 * @return The {@code AuthInfo} resulting from the successful login.
 */
@Nonnull
private AuthInfo getAuthInfo(TokenInfo tokenInfo) {
    Map<String, Object> attributes = new HashMap<String, Object>();
    if (tokenProvider != null && tokenInfo != null) {
        Map<String, String> publicAttributes = tokenInfo.getPublicAttributes();
        for (String attrName : publicAttributes.keySet()) {
            attributes.put(attrName, publicAttributes.get(attrName));
        }
    }
    return new AuthInfoImpl(userId, attributes, principals);
}","/**
 * Create the {@code AuthInfo} for the specified {@code tokenInfo} as well as
 * userId and principals, that have been set upon {@link #login}.
 *
 * @param tokenInfo The tokenInfo to retrieve attributes from.
 * @return The {@code AuthInfo} resulting from the successful login.
 */
","@Nonnull
private AuthInfo getAuthInfo(TokenInfo tokenInfo) {
    Map<String, Object> attributes = new HashMap<String, Object>();
    if (tokenProvider != null && tokenInfo != null) {
        Map<String, String> publicAttributes = tokenInfo.getPublicAttributes();
        for (String attrName : publicAttributes.keySet()) {
            attributes.put(attrName, publicAttributes.get(attrName));
        }
    }
    return new AuthInfoImpl(userId, attributes, principals);
}",-0.13636363636363635,0.36734693877551033,-0.16666666666666666,0.0,-0.08333333333333333,-0.04844290657439445,0.10696874103814182,-0.16666666666666666,0.05714285714285714,-0.023732123813072596
Math,103,3,"/**
 * For this disbution, X, this method returns P(X &lt; <code>x</code>).
 * @param x the value at which the CDF is evaluated.
 * @return CDF evaluted at <code>x</code>.
 * @throws MathException if the algorithm fails to converge; unless
 * x is more than 20 standard deviations from the mean, in which case the
 * convergence exception is caught and 0 or 1 is returned.
 */
public double cumulativeProbability(double x) throws MathException {
    return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0))));
}","/**
 * For this disbution, X, this method returns P(X &lt; <code>x</code>).
 * @param x the value at which the CDF is evaluated.
 * @return CDF evaluted at <code>x</code>.
 * @throws MathException if the algorithm fails to converge; unless
 * x is more than 20 standard deviations from the mean, in which case the
 * convergence exception is caught and 0 or 1 is returned.
 */
","public double cumulativeProbability(double x) throws MathException {
    return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0))));
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,0.044488383588729634,0.8611987381703473,-0.3333333333333333,0.6,-0.09258569219765206
wicket,remotes/origin/bugs-dot-jar_WICKET-4927_8c827e33,1,"@Override
public void setContentType(String mimeType) {
    checkHeader();
    bufferedResponse.setContentType(mimeType);
}",,"@Override
public void setContentType(String mimeType) {
    checkHeader();
    bufferedResponse.setContentType(mimeType);
}",-0.4090909090909091,-0.5408163265306123,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7912245483223405,-0.3333333333333333,1.342857142857143,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-3428_ffc0cae9,1,"/**
 *  Processes the request.
 *
 *  @return <code>true</code> if the request resolved to a Wicket request, <code>false</code>
 *          otherwise.
 */
public boolean processRequest() {
    try {
        set(this);
        IRequestHandler handler = resolveRequestHandler();
        if (handler != null) {
            executeRequestHandler(handler);
            return true;
        }
        // Did not find any suitable handler, thus not executing the request
        log.debug(""No suitable handler found for URL {}, falling back to container to process this request"", request.getUrl());
    } catch (Exception e) {
        IRequestHandler handler = handleException(e);
        if (handler != null) {
            executeExceptionRequestHandler(handler, getExceptionRetryCount());
        } else {
            log.error(""Error during request processing. URL="" + request.getUrl(), e);
        }
        return true;
    } finally {
        set(null);
    }
    return false;
}","/**
 *  Processes the request.
 *
 *  @return <code>true</code> if the request resolved to a Wicket request, <code>false</code>
 *          otherwise.
 */
","public boolean processRequest() {
    try {
        set(this);
        IRequestHandler handler = resolveRequestHandler();
        if (handler != null) {
            executeRequestHandler(handler);
            return true;
        }
                log.debug(""No suitable handler found for URL {}, falling back to container to process this request"", request.getUrl());
    } catch (Exception e) {
        IRequestHandler handler = handleException(e);
        if (handler != null) {
            executeExceptionRequestHandler(handler, getExceptionRetryCount());
        } else {
            log.error(""Error during request processing. URL="" + request.getUrl(), e);
        }
        return true;
    } finally {
        set(null);
    }
    return false;
}",0.36363636363636365,0.1938775510204081,0.0,0.0,-0.16666666666666666,-0.04844290657439445,-0.2216805276742187,0.4166666666666667,-0.028571428571428574,-0.023732123813072596
flink,remotes/origin/bugs-dot-jar_FLINK-3260_6968a57a,0,"public void cancel() {
    // successful atomic state transition
    while (true) {
        ExecutionState current = this.state;
        if (current == CANCELING || current == CANCELED) {
            // already taken care of, no need to cancel again
            return;
        } else // these two are the common cases where we need to send a cancel call
        if (current == RUNNING || current == DEPLOYING) {
            // try to transition to canceling, if successful, send the cancel call
            if (transitionState(current, CANCELING)) {
                sendCancelRpcCall();
                return;
            }
        // else: fall through the loop
        } else if (current == FINISHED || current == FAILED) {
            // nothing to do any more. finished failed before it could be cancelled.
            // in any case, the task is removed from the TaskManager already
            sendFailIntermediateResultPartitionsRpcCall();
            return;
        } else if (current == CREATED || current == SCHEDULED) {
            // from here, we can directly switch to cancelled, because the no task has been deployed
            if (transitionState(current, CANCELED)) {
                // we skip the canceling state. set the timestamp, for a consistent appearance
                markTimestamp(CANCELING, getStateTimestamp(CANCELED));
                try {
                    vertex.getExecutionGraph().deregisterExecution(this);
                    if (assignedResource != null) {
                        assignedResource.releaseSlot();
                    }
                } finally {
                    vertex.executionCanceled();
                }
                return;
            }
        // else: fall through the loop
        } else {
            throw new IllegalStateException(current.name());
        }
    }
}",,"public void cancel() {
        while (true) {
        ExecutionState current = this.state;
        if (current == CANCELING || current == CANCELED) {
                        return;
        } else         if (current == RUNNING || current == DEPLOYING) {
                        if (transitionState(current, CANCELING)) {
                sendCancelRpcCall();
                return;
            }
                } else if (current == FINISHED || current == FAILED) {
                                    sendFailIntermediateResultPartitionsRpcCall();
            return;
        } else if (current == CREATED || current == SCHEDULED) {
                        if (transitionState(current, CANCELED)) {
                                markTimestamp(CANCELING, getStateTimestamp(CANCELED));
                try {
                    vertex.getExecutionGraph().deregisterExecution(this);
                    if (assignedResource != null) {
                        assignedResource.releaseSlot();
                    }
                } finally {
                    vertex.executionCanceled();
                }
                return;
            }
                } else {
            throw new IllegalStateException(current.name());
        }
    }
}",0.8181818181818182,1.3877551020408165,1.0,3.0,0.9166666666666666,0.2698961937716264,-0.4992830513335246,0.4166666666666667,-0.028571428571428574,0.25795246722431375
wicket,remotes/origin/bugs-dot-jar_WICKET-5656_f539c18c,1,"boolean isRequired() {
    List<NotNull> constraints = findNotNullConstraints();
    if (constraints.isEmpty()) {
        return false;
    }
    HashSet<Class<?>> validatorGroups = new HashSet<Class<?>>();
    validatorGroups.addAll(Arrays.asList(getGroups()));
    for (NotNull constraint : constraints) {
        if (constraint.groups().length == 0 && validatorGroups.isEmpty()) {
            return true;
        }
        for (Class<?> constraintGroup : constraint.groups()) {
            if (validatorGroups.contains(constraintGroup)) {
                return true;
            }
        }
    }
    return false;
}",,"boolean isRequired() {
    List<NotNull> constraints = findNotNullConstraints();
    if (constraints.isEmpty()) {
        return false;
    }
    HashSet<Class<?>> validatorGroups = new HashSet<Class<?>>();
    validatorGroups.addAll(Arrays.asList(getGroups()));
    for (NotNull constraint : constraints) {
        if (constraint.groups().length == 0 && validatorGroups.isEmpty()) {
            return true;
        }
        for (Class<?> constraintGroup : constraint.groups()) {
            if (validatorGroups.contains(constraintGroup)) {
                return true;
            }
        }
    }
    return false;
}",0.22727272727272727,0.5765306122448981,0.3333333333333333,0.5,0.3333333333333333,-0.0385565991102323,-0.16661887008890175,0.25,0.028571428571428574,-0.019937382485084445
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1025_a96b455c,1,"@Override
public Level toLevel(final java.util.logging.Level javaLevel) {
    return julToLog4j.get(javaLevel);
}",,"@Override
public Level toLevel(final java.util.logging.Level javaLevel) {
    return julToLog4j.get(javaLevel);
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.8270719816461145,-0.4166666666666667,0.39999999999999997,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-612_df9e6913,1,"@Override
public Node perform() throws RepositoryException {
    String oakPath = sessionDelegate.getOakPathKeepIndexOrThrowNotFound(relPath);
    String oakName = PathUtils.getName(oakPath);
    String parentPath = sessionDelegate.getOakPath(PathUtils.getParentPath(oakPath));
    // handle index
    if (oakName.contains(""["")) {
        throw new RepositoryException(""Cannot create a new node using a name including an index"");
    }
    NodeDelegate parent = dlg.getChild(parentPath);
    if (parent == null) {
        // is it a property?
        String grandParentPath = PathUtils.getParentPath(parentPath);
        NodeDelegate grandParent = dlg.getChild(grandParentPath);
        if (grandParent != null) {
            String propName = PathUtils.getName(parentPath);
            if (grandParent.getProperty(propName) != null) {
                throw new ConstraintViolationException(""Can't add new node to property."");
            }
        }
        throw new PathNotFoundException(relPath);
    }
    if (parent.getChild(oakName) != null) {
        throw new ItemExistsException(relPath);
    }
    String ntName = primaryNodeTypeName;
    if (ntName == null) {
        DefinitionProvider dp = sessionDelegate.getDefinitionProvider();
        try {
            String childName = sessionDelegate.getOakName(PathUtils.getName(relPath));
            NodeDefinition def = dp.getDefinition(new NodeImpl<NodeDelegate>(parent), childName);
            ntName = def.getDefaultPrimaryTypeName();
        } catch (RepositoryException e) {
            throw new ConstraintViolationException(""no matching child node definition found for "" + relPath);
        }
    }
    // TODO: figure out the right place for this check
    NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();
    // throws on not found
    NodeType nt = ntm.getNodeType(ntName);
    if (nt.isAbstract() || nt.isMixin()) {
        throw new ConstraintViolationException();
    }
    // TODO: END
    NodeDelegate added = parent.addChild(oakName);
    if (added == null) {
        throw new ItemExistsException();
    }
    NodeImpl<?> childNode = new NodeImpl<NodeDelegate>(added);
    childNode.internalSetPrimaryType(ntName);
    childNode.autoCreateItems();
    return childNode;
}",,"@Override
public Node perform() throws RepositoryException {
    String oakPath = sessionDelegate.getOakPathKeepIndexOrThrowNotFound(relPath);
    String oakName = PathUtils.getName(oakPath);
    String parentPath = sessionDelegate.getOakPath(PathUtils.getParentPath(oakPath));
        if (oakName.contains(""["")) {
        throw new RepositoryException(""Cannot create a new node using a name including an index"");
    }
    NodeDelegate parent = dlg.getChild(parentPath);
    if (parent == null) {
                String grandParentPath = PathUtils.getParentPath(parentPath);
        NodeDelegate grandParent = dlg.getChild(grandParentPath);
        if (grandParent != null) {
            String propName = PathUtils.getName(parentPath);
            if (grandParent.getProperty(propName) != null) {
                throw new ConstraintViolationException(""Can't add new node to property."");
            }
        }
        throw new PathNotFoundException(relPath);
    }
    if (parent.getChild(oakName) != null) {
        throw new ItemExistsException(relPath);
    }
    String ntName = primaryNodeTypeName;
    if (ntName == null) {
        DefinitionProvider dp = sessionDelegate.getDefinitionProvider();
        try {
            String childName = sessionDelegate.getOakName(PathUtils.getName(relPath));
            NodeDefinition def = dp.getDefinition(new NodeImpl<NodeDelegate>(parent), childName);
            ntName = def.getDefaultPrimaryTypeName();
        } catch (RepositoryException e) {
            throw new ConstraintViolationException(""no matching child node definition found for "" + relPath);
        }
    }
        NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();
        NodeType nt = ntm.getNodeType(ntName);
    if (nt.isAbstract() || nt.isMixin()) {
        throw new ConstraintViolationException();
    }
        NodeDelegate added = parent.addChild(oakName);
    if (added == null) {
        throw new ItemExistsException();
    }
    NodeImpl<?> childNode = new NodeImpl<NodeDelegate>(added);
    childNode.internalSetPrimaryType(ntName);
    childNode.autoCreateItems();
    return childNode;
}",1.5454545454545454,0.27040816326530603,2.1666666666666665,0.5,1.25,0.4913494809688583,-0.9016346429595643,1.4166666666666667,-0.028571428571428574,1.579751671442216
commons-math,remotes/origin/bugs-dot-jar_MATH-1096_faf99727,0,"/**
 * Compute enclosing ball using Grtner's pivoting heuristic.
 * @param points points to be enclosed
 * @return enclosing ball
 */
private EnclosingBall<S, P> pivotingBall(final List<P> points) {
    List<P> extreme = new ArrayList<P>(max);
    List<P> support = new ArrayList<P>(max);
    // start with only first point selected as a candidate support
    extreme.add(points.get(0));
    EnclosingBall<S, P> ball = moveToFrontBall(extreme, support);
    while (true) {
        // select the point farthest to current ball
        final P farthest = selectFarthest(points, ball);
        if (ball.contains(farthest, tolerance)) {
            // we have found a ball containing all points
            return ball;
        }
        // recurse search, restricted to the small subset containing support and farthest point
        support.clear();
        support.add(farthest);
        EnclosingBall<S, P> savedBall = ball;
        ball = moveToFrontBall(extreme, support);
        if (ball.getRadius() < savedBall.getRadius()) {
            // TODO: fix this, it should never happen but it does!
            throw new MathInternalError();
        }
        // it was an interesting point, move it to the front
        // according to Grtner's heuristic
        extreme.add(0, farthest);
        // prune the least interesting points
        extreme.subList(ball.getSupportSize(), extreme.size()).clear();
    }
}","/**
 * Compute enclosing ball using Grtner's pivoting heuristic.
 * @param points points to be enclosed
 * @return enclosing ball
 */
","private EnclosingBall<S, P> pivotingBall(final List<P> points) {
    List<P> extreme = new ArrayList<P>(max);
    List<P> support = new ArrayList<P>(max);
        extreme.add(points.get(0));
    EnclosingBall<S, P> ball = moveToFrontBall(extreme, support);
    while (true) {
                final P farthest = selectFarthest(points, ball);
        if (ball.contains(farthest, tolerance)) {
                        return ball;
        }
                support.clear();
        support.add(farthest);
        EnclosingBall<S, P> savedBall = ball;
        ball = moveToFrontBall(extreme, support);
        if (ball.getRadius() < savedBall.getRadius()) {
                        throw new MathInternalError();
        }
                        extreme.add(0, farthest);
                extreme.subList(ball.getSupportSize(), extreme.size()).clear();
    }
}",0.3181818181818182,0.06122448979591842,0.16666666666666666,0.0,0.25,0.1354424122590213,-0.31086894178376845,0.75,-0.028571428571428574,0.27411224039643484
camel,remotes/origin/bugs-dot-jar_CAMEL-8146_17475d80,3,"@Override
protected void doStop() throws Exception {
    ServiceHelper.stopService(scheduler);
    // clear counters
    backoffCounter = 0;
    idleCounter = 0;
    errorCounter = 0;
    super.doStop();
}",,"@Override
protected void doStop() throws Exception {
    ServiceHelper.stopService(scheduler);
        backoffCounter = 0;
    idleCounter = 0;
    errorCounter = 0;
    super.doStop();
}",-0.2727272727272727,-0.5510204081632654,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.44164037854889576,-0.3333333333333333,2.0,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1269_b8fe2ded,1,"/**
 * Returns <code>true</code> if a node type index lookup exists at the given
 * <code>path</code> or further up the tree.
 *
 * @param path the path to check.
 * @return <code>true</code> if a node type index exists; <code>false</code>
 *         otherwise.
 */
public boolean isIndexed(String path) {
    PropertyIndexLookup lookup = new PropertyIndexLookup(root);
    if (lookup.isIndexed(JCR_PRIMARYTYPE, path, null) && lookup.isIndexed(JCR_MIXINTYPES, path, null)) {
        return true;
    }
    if (path.startsWith(""/"")) {
        path = path.substring(1);
    }
    int slash = path.indexOf('/');
    if (slash == -1) {
        return false;
    }
    NodeState child = root.getChildNode(path.substring(0, slash));
    return new NodeTypeIndexLookup(child).isIndexed(path.substring(slash));
}","/**
 * Returns <code>true</code> if a node type index lookup exists at the given
 * <code>path</code> or further up the tree.
 *
 * @param path the path to check.
 * @return <code>true</code> if a node type index exists; <code>false</code>
 *         otherwise.
 */
","public boolean isIndexed(String path) {
    PropertyIndexLookup lookup = new PropertyIndexLookup(root);
    if (lookup.isIndexed(JCR_PRIMARYTYPE, path, null) && lookup.isIndexed(JCR_MIXINTYPES, path, null)) {
        return true;
    }
    if (path.startsWith(""/"")) {
        path = path.substring(1);
    }
    int slash = path.indexOf('/');
    if (slash == -1) {
        return false;
    }
    NodeState child = root.getChildNode(path.substring(0, slash));
    return new NodeTypeIndexLookup(child).isIndexed(path.substring(slash));
}",0.045454545454545456,-0.37244897959183676,0.0,-0.5,0.3333333333333333,0.42807711319822056,-0.0845999426441068,0.25,-0.028571428571428574,0.28522235214000285
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-369_4e245a76,3,"/**
 * Get a property
 * @param relPath  oak path
 * @return  property at the path given by {@code relPath} or {@code null} if
 * no such property exists
 */
@CheckForNull
public PropertyDelegate getProperty(String relPath) throws InvalidItemStateException {
    TreeLocation propertyLocation = getChildLocation(relPath);
    PropertyState propertyState = propertyLocation.getProperty();
    return propertyState == null ? null : new PropertyDelegate(sessionDelegate, propertyLocation);
}","/**
 * Get a property
 * @param relPath  oak path
 * @return  property at the path given by {@code relPath} or {@code null} if
 * no such property exists
 */
","@CheckForNull
public PropertyDelegate getProperty(String relPath) throws InvalidItemStateException {
    TreeLocation propertyLocation = getChildLocation(relPath);
    PropertyState propertyState = propertyLocation.getProperty();
    return propertyState == null ? null : new PropertyDelegate(sessionDelegate, propertyLocation);
}",-0.36363636363636365,-0.5204081632653061,-0.3333333333333333,-1.0,-0.25,-0.08403361344537813,0.5010037281330658,-0.3333333333333333,2.7714285714285714,-0.10255224193831618
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-766_6fc5ea9d,1,"@Override
public TreeImpl getChild(@Nonnull String name) {
    checkNotNull(name);
    enter();
    TreeImpl child = internalGetChild(name);
    if (child != null && canRead(child)) {
        return child;
    } else {
        return null;
    }
}",,"@Override
public TreeImpl getChild(@Nonnull String name) {
    checkNotNull(name);
    enter();
    TreeImpl child = internalGetChild(name);
    if (child != null && canRead(child)) {
        return child;
    } else {
        return null;
    }
}",-0.13636363636363635,-0.17857142857142863,-0.3333333333333333,-0.5,-0.08333333333333333,-0.07612456747404842,0.2256954402064814,-0.16666666666666666,1.7428571428571429,-0.10360586086233999
Math,65,1,"/**
 * Get the Root Mean Square value.
 * Get the Root Mean Square value, i.e. the root of the arithmetic
 * mean of the square of all weighted residuals. This is related to the
 * criterion that is minimized by the optimizer as follows: if
 * <em>c</em> if the criterion, and <em>n</em> is the number of
 * measurements, then the RMS is <em>sqrt (c/n)</em>.
 *
 * @return RMS value
 */
public double getRMS() {
    double criterion = 0;
    for (int i = 0; i < rows; ++i) {
        final double residual = residuals[i];
        criterion += residual * residual * residualsWeights[i];
    }
    return Math.sqrt(criterion / rows);
}","/**
 * Get the Root Mean Square value.
 * Get the Root Mean Square value, i.e. the root of the arithmetic
 * mean of the square of all weighted residuals. This is related to the
 * criterion that is minimized by the optimizer as follows: if
 * <em>c</em> if the criterion, and <em>n</em> is the number of
 * measurements, then the RMS is <em>sqrt (c/n)</em>.
 *
 * @return RMS value
 */
","public double getRMS() {
    double criterion = 0;
    for (int i = 0; i < rows; ++i) {
        final double residual = residuals[i];
        criterion += residual * residual * residualsWeights[i];
    }
    return Math.sqrt(criterion / rows);
}",-0.2727272727272727,-0.09693877551020405,-0.3333333333333333,-0.5,-0.16666666666666666,0.7523479980227388,0.3358187553771149,-0.4166666666666667,0.05714285714285714,0.12654134597676042
Math,6,1,"/**
 * {@inheritDoc}
 */
@Override
protected PointValuePair doOptimize() {
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    final double[] point = getStartPoint();
    final GoalType goal = getGoalType();
    final int n = point.length;
    double[] r = computeObjectiveGradient(point);
    if (goal == GoalType.MINIMIZE) {
        for (int i = 0; i < n; i++) {
            r[i] = -r[i];
        }
    }
    // Initial search direction.
    double[] steepestDescent = preconditioner.precondition(point, r);
    double[] searchDirection = steepestDescent.clone();
    double delta = 0;
    for (int i = 0; i < n; ++i) {
        delta += r[i] * searchDirection[i];
    }
    PointValuePair current = null;
    int iter = 0;
    int maxEval = getMaxEvaluations();
    while (true) {
        ++iter;
        final double objective = computeObjectiveValue(point);
        PointValuePair previous = current;
        current = new PointValuePair(point, objective);
        if (previous != null) {
            if (checker.converged(iter, previous, current)) {
                // We have found an optimum.
                return current;
            }
        }
        // Find the optimal step in the search direction.
        final UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);
        final double uB = findUpperBound(lsf, 0, initialStep);
        // XXX Last parameters is set to a value close to zero in order to
        // work around the divergence problem in the ""testCircleFitting""
        // unit test (see MATH-439).
        final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);
        // Subtract used up evaluations.
        maxEval -= solver.getEvaluations();
        // Validate new point.
        for (int i = 0; i < point.length; ++i) {
            point[i] += step * searchDirection[i];
        }
        r = computeObjectiveGradient(point);
        if (goal == GoalType.MINIMIZE) {
            for (int i = 0; i < n; ++i) {
                r[i] = -r[i];
            }
        }
        // Compute beta.
        final double deltaOld = delta;
        final double[] newSteepestDescent = preconditioner.precondition(point, r);
        delta = 0;
        for (int i = 0; i < n; ++i) {
            delta += r[i] * newSteepestDescent[i];
        }
        final double beta;
        switch(updateFormula) {
            case FLETCHER_REEVES:
                beta = delta / deltaOld;
                break;
            case POLAK_RIBIERE:
                double deltaMid = 0;
                for (int i = 0; i < r.length; ++i) {
                    deltaMid += r[i] * steepestDescent[i];
                }
                beta = (delta - deltaMid) / deltaOld;
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
        }
        steepestDescent = newSteepestDescent;
        // Compute conjugate search direction.
        if (iter % n == 0 || beta < 0) {
            // Break conjugation: reset search direction.
            searchDirection = steepestDescent.clone();
        } else {
            // Compute new conjugate search direction.
            for (int i = 0; i < n; ++i) {
                searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];
            }
        }
    }
}","/**
 * {@inheritDoc}
 */
","@Override
protected PointValuePair doOptimize() {
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    final double[] point = getStartPoint();
    final GoalType goal = getGoalType();
    final int n = point.length;
    double[] r = computeObjectiveGradient(point);
    if (goal == GoalType.MINIMIZE) {
        for (int i = 0; i < n; i++) {
            r[i] = -r[i];
        }
    }
        double[] steepestDescent = preconditioner.precondition(point, r);
    double[] searchDirection = steepestDescent.clone();
    double delta = 0;
    for (int i = 0; i < n; ++i) {
        delta += r[i] * searchDirection[i];
    }
    PointValuePair current = null;
    int iter = 0;
    int maxEval = getMaxEvaluations();
    while (true) {
        ++iter;
        final double objective = computeObjectiveValue(point);
        PointValuePair previous = current;
        current = new PointValuePair(point, objective);
        if (previous != null) {
            if (checker.converged(iter, previous, current)) {
                                return current;
            }
        }
                final UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);
        final double uB = findUpperBound(lsf, 0, initialStep);
                                final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);
                maxEval -= solver.getEvaluations();
                for (int i = 0; i < point.length; ++i) {
            point[i] += step * searchDirection[i];
        }
        r = computeObjectiveGradient(point);
        if (goal == GoalType.MINIMIZE) {
            for (int i = 0; i < n; ++i) {
                r[i] = -r[i];
            }
        }
                final double deltaOld = delta;
        final double[] newSteepestDescent = preconditioner.precondition(point, r);
        delta = 0;
        for (int i = 0; i < n; ++i) {
            delta += r[i] * newSteepestDescent[i];
        }
        final double beta;
        switch(updateFormula) {
            case FLETCHER_REEVES:
                beta = delta / deltaOld;
                break;
            case POLAK_RIBIERE:
                double deltaMid = 0;
                for (int i = 0; i < r.length; ++i) {
                    deltaMid += r[i] * steepestDescent[i];
                }
                beta = (delta - deltaMid) / deltaOld;
                break;
            default:
                                throw new MathInternalError();
        }
        steepestDescent = newSteepestDescent;
                if (iter % n == 0 || beta < 0) {
                        searchDirection = steepestDescent.clone();
        } else {
                        for (int i = 0; i < n; ++i) {
                searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];
            }
        }
    }
}",2.772727272727273,0.7193877551020407,2.6666666666666665,1.0,1.8333333333333333,3.8151260504201683,-1.211356466876972,0.75,-0.028571428571428574,14.447244101233077
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2047_a0a495f0,0,"/**
 * Copies the full content from the source to the target repository.
 * <p>
 * The source repository <strong>must not be modified</strong> while
 * the copy operation is running to avoid an inconsistent copy.
 * <p>
 * Note that both the source and the target repository must be closed
 * during the copy operation as this method requires exclusive access
 * to the repositories.
 *
 * @param initializer optional extra repository initializer to use
 * @throws RepositoryException if the copy operation fails
 */
public void copy(RepositoryInitializer initializer) throws RepositoryException {
    RepositoryConfig config = source.getRepositoryConfig();
    logger.info(""Copying repository content from {} to Oak"", config.getHomeDir());
    try {
        NodeState base = target.getRoot();
        NodeBuilder builder = base.builder();
        String workspaceName = source.getRepositoryConfig().getDefaultWorkspaceName();
        SecurityProviderImpl security = new SecurityProviderImpl(mapSecurityConfig(config.getSecurityConfig()));
        // init target repository first
        new InitialContent().initialize(builder);
        if (initializer != null) {
            initializer.initialize(builder);
        }
        for (SecurityConfiguration sc : security.getConfigurations()) {
            sc.getRepositoryInitializer().initialize(builder);
        }
        for (SecurityConfiguration sc : security.getConfigurations()) {
            sc.getWorkspaceInitializer().initialize(builder, workspaceName);
        }
        HashBiMap<String, String> uriToPrefix = HashBiMap.create();
        Map<Integer, String> idxToPrefix = newHashMap();
        copyNamespaces(builder, uriToPrefix, idxToPrefix);
        copyNodeTypes(builder, uriToPrefix.inverse());
        copyPrivileges(builder);
        // Triggers compilation of type information, which we need for
        // the type predicates used by the bulk  copy operations below.
        new TypeEditorProvider(false).getRootEditor(base, builder.getNodeState(), builder, null);
        Map<String, String> versionablePaths = newHashMap();
        NodeState root = builder.getNodeState();
        copyWorkspace(builder, root, workspaceName, uriToPrefix, idxToPrefix, versionablePaths);
        copyVersionStore(builder, root, workspaceName, uriToPrefix, idxToPrefix, versionablePaths);
        logger.info(""Applying default commit hooks"");
        // TODO: default hooks?
        List<CommitHook> hooks = newArrayList();
        UserConfiguration userConf = security.getConfiguration(UserConfiguration.class);
        String groupsPath = userConf.getParameters().getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);
        // hooks specific to the upgrade, need to run first
        hooks.add(new EditorHook(new CompositeEditorProvider(new RestrictionEditorProvider(), new GroupEditorProvider(groupsPath))));
        // security-related hooks
        for (SecurityConfiguration sc : security.getConfigurations()) {
            hooks.addAll(sc.getCommitHooks(workspaceName));
        }
        // type validation, reference and indexing hooks
        hooks.add(new EditorHook(new CompositeEditorProvider(createTypeEditorProvider(), createIndexEditorProvider())));
        target.merge(builder, CompositeHook.compose(hooks), CommitInfo.EMPTY);
    } catch (Exception e) {
        throw new RepositoryException(""Failed to copy content"", e);
    }
}","/**
 * Copies the full content from the source to the target repository.
 * <p>
 * The source repository <strong>must not be modified</strong> while
 * the copy operation is running to avoid an inconsistent copy.
 * <p>
 * Note that both the source and the target repository must be closed
 * during the copy operation as this method requires exclusive access
 * to the repositories.
 *
 * @param initializer optional extra repository initializer to use
 * @throws RepositoryException if the copy operation fails
 */
","public void copy(RepositoryInitializer initializer) throws RepositoryException {
    RepositoryConfig config = source.getRepositoryConfig();
    logger.info(""Copying repository content from {} to Oak"", config.getHomeDir());
    try {
        NodeState base = target.getRoot();
        NodeBuilder builder = base.builder();
        String workspaceName = source.getRepositoryConfig().getDefaultWorkspaceName();
        SecurityProviderImpl security = new SecurityProviderImpl(mapSecurityConfig(config.getSecurityConfig()));
                new InitialContent().initialize(builder);
        if (initializer != null) {
            initializer.initialize(builder);
        }
        for (SecurityConfiguration sc : security.getConfigurations()) {
            sc.getRepositoryInitializer().initialize(builder);
        }
        for (SecurityConfiguration sc : security.getConfigurations()) {
            sc.getWorkspaceInitializer().initialize(builder, workspaceName);
        }
        HashBiMap<String, String> uriToPrefix = HashBiMap.create();
        Map<Integer, String> idxToPrefix = newHashMap();
        copyNamespaces(builder, uriToPrefix, idxToPrefix);
        copyNodeTypes(builder, uriToPrefix.inverse());
        copyPrivileges(builder);
                        new TypeEditorProvider(false).getRootEditor(base, builder.getNodeState(), builder, null);
        Map<String, String> versionablePaths = newHashMap();
        NodeState root = builder.getNodeState();
        copyWorkspace(builder, root, workspaceName, uriToPrefix, idxToPrefix, versionablePaths);
        copyVersionStore(builder, root, workspaceName, uriToPrefix, idxToPrefix, versionablePaths);
        logger.info(""Applying default commit hooks"");
                List<CommitHook> hooks = newArrayList();
        UserConfiguration userConf = security.getConfiguration(UserConfiguration.class);
        String groupsPath = userConf.getParameters().getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);
                hooks.add(new EditorHook(new CompositeEditorProvider(new RestrictionEditorProvider(), new GroupEditorProvider(groupsPath))));
                for (SecurityConfiguration sc : security.getConfigurations()) {
            hooks.addAll(sc.getCommitHooks(workspaceName));
        }
                hooks.add(new EditorHook(new CompositeEditorProvider(createTypeEditorProvider(), createIndexEditorProvider())));
        target.merge(builder, CompositeHook.compose(hooks), CommitInfo.EMPTY);
    } catch (Exception e) {
        throw new RepositoryException(""Failed to copy content"", e);
    }
}",1.2727272727272727,-0.2653061224489796,0.5,0.0,-0.25,0.010874938210578382,-0.8064238600516207,3.0833333333333335,-0.028571428571428574,0.8093892008343292
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3517_24f7f60a,1,"@Nonnull
@Override
public Node perform() throws RepositoryException {
    String oakName = PathUtils.getName(oakPath);
    String parentPath = PathUtils.getParentPath(oakPath);
    NodeDelegate parent = dlg.getChild(parentPath);
    if (parent == null) {
        // is it a property?
        String grandParentPath = PathUtils.getParentPath(parentPath);
        NodeDelegate grandParent = dlg.getChild(grandParentPath);
        if (grandParent != null) {
            String propName = PathUtils.getName(parentPath);
            if (grandParent.getPropertyOrNull(propName) != null) {
                throw new ConstraintViolationException(""Can't add new node to property."");
            }
        }
        throw new PathNotFoundException(relPath);
    }
    if (parent.getChild(oakName) != null) {
        throw new ItemExistsException(relPath);
    }
    // modification of that property in the PermissionValidator
    if (oakTypeName != null) {
        PropertyState prop = PropertyStates.createProperty(JCR_PRIMARYTYPE, oakTypeName, NAME);
        sessionContext.getAccessManager().checkPermissions(dlg.getTree(), prop, Permissions.NODE_TYPE_MANAGEMENT);
    }
    NodeDelegate added = parent.addChild(oakName, oakTypeName);
    if (added == null) {
        throw new ItemExistsException();
    }
    return createNode(added, sessionContext);
}",,"@Nonnull
@Override
public Node perform() throws RepositoryException {
    String oakName = PathUtils.getName(oakPath);
    String parentPath = PathUtils.getParentPath(oakPath);
    NodeDelegate parent = dlg.getChild(parentPath);
    if (parent == null) {
                String grandParentPath = PathUtils.getParentPath(parentPath);
        NodeDelegate grandParent = dlg.getChild(grandParentPath);
        if (grandParent != null) {
            String propName = PathUtils.getName(parentPath);
            if (grandParent.getPropertyOrNull(propName) != null) {
                throw new ConstraintViolationException(""Can't add new node to property."");
            }
        }
        throw new PathNotFoundException(relPath);
    }
    if (parent.getChild(oakName) != null) {
        throw new ItemExistsException(relPath);
    }
        if (oakTypeName != null) {
        PropertyState prop = PropertyStates.createProperty(JCR_PRIMARYTYPE, oakTypeName, NAME);
        sessionContext.getAccessManager().checkPermissions(dlg.getTree(), prop, Permissions.NODE_TYPE_MANAGEMENT);
    }
    NodeDelegate added = parent.addChild(oakName, oakTypeName);
    if (added == null) {
        throw new ItemExistsException();
    }
    return createNode(added, sessionContext);
}",0.7272727272727273,0.413265306122449,1.1666666666666667,0.5,0.75,0.0009886307464162364,-0.5623745339833669,0.6666666666666666,-0.028571428571428574,0.2787164694343437
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-43_668f08f2,1,"public void removeNode(String nodePath) throws NotFoundException, Exception {
    String parentPath = PathUtils.getParentPath(nodePath);
    String nodeName = PathUtils.getName(nodePath);
    MutableNode parent = getOrCreateStagedNode(parentPath);
    if (parent.remove(nodeName) == null) {
        throw new NotFoundException(nodePath);
    }
    // update staging area
    removeStagedNodes(nodePath);
    // update change log
    changeLog.add(new RemoveNode(nodePath));
}",,"public void removeNode(String nodePath) throws NotFoundException, Exception {
    String parentPath = PathUtils.getParentPath(nodePath);
    String nodeName = PathUtils.getName(nodePath);
    MutableNode parent = getOrCreateStagedNode(parentPath);
    if (parent.remove(nodeName) == null) {
        throw new NotFoundException(nodePath);
    }
        removeStagedNodes(nodePath);
        changeLog.add(new RemoveNode(nodePath));
}",-0.18181818181818182,-0.4438775510204082,-0.16666666666666666,-0.5,-0.16666666666666666,-0.06426099851705384,0.18038428448523067,0.0,0.6,-0.05421426154590737
wicket,remotes/origin/bugs-dot-jar_WICKET-2621_c849f986,1,"@Override
public void onFormComponent(FormComponent<?> formComponent) {
    if (formComponent.isVisible() && formComponent.isMultiPart()) {
        setMultiPart(true);
    }
}",,"@Override
public void onFormComponent(FormComponent<?> formComponent) {
    if (formComponent.isVisible() && formComponent.isMultiPart()) {
        setMultiPart(true);
    }
}",-0.36363636363636365,-0.02040816326530614,-0.3333333333333333,-0.5,-0.08333333333333333,-0.3806228373702422,0.6320619443647835,-0.25,0.0,-0.16422749602751402
Closure,81,2,"@Override
Node processFunctionNode(FunctionNode functionNode) {
    Name name = functionNode.getFunctionName();
    Boolean isUnnamedFunction = false;
    if (name == null) {
        name = new Name();
        name.setIdentifier("""");
        isUnnamedFunction = true;
    }
    Node node = newNode(Token.FUNCTION);
    Node newName = transform(name);
    if (isUnnamedFunction) {
        // Old Rhino tagged the empty name node with the line number of the
        // declaration.
        newName.setLineno(functionNode.getLineno());
        // TODO(bowdidge) Mark line number of paren correctly.
        // Same problem as below - the left paren might not be on the
        // same line as the function keyword.
        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();
        newName.setCharno(position2charno(lpColumn));
    }
    node.addChildToBack(newName);
    Node lp = newNode(Token.LP);
    // The left paren's complicated because it's not represented by an
    // AstNode, so there's nothing that has the actual line number that it
    // appeared on.  We know the paren has to appear on the same line as the
    // function name (or else a semicolon will be inserted.)  If there's no
    // function name, assume the paren was on the same line as the function.
    // TODO(bowdidge): Mark line number of paren correctly.
    Name fnName = functionNode.getFunctionName();
    if (fnName != null) {
        lp.setLineno(fnName.getLineno());
    } else {
        lp.setLineno(functionNode.getLineno());
    }
    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();
    lp.setCharno(position2charno(lparenCharno));
    for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
    }
    node.addChildToBack(lp);
    Node bodyNode = transform(functionNode.getBody());
    parseDirectives(bodyNode);
    node.addChildToBack(bodyNode);
    return node;
}",,"@Override
Node processFunctionNode(FunctionNode functionNode) {
    Name name = functionNode.getFunctionName();
    Boolean isUnnamedFunction = false;
    if (name == null) {
        name = new Name();
        name.setIdentifier("""");
        isUnnamedFunction = true;
    }
    Node node = newNode(Token.FUNCTION);
    Node newName = transform(name);
    if (isUnnamedFunction) {
                        newName.setLineno(functionNode.getLineno());
                                int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();
        newName.setCharno(position2charno(lpColumn));
    }
    node.addChildToBack(newName);
    Node lp = newNode(Token.LP);
                            Name fnName = functionNode.getFunctionName();
    if (fnName != null) {
        lp.setLineno(fnName.getLineno());
    } else {
        lp.setLineno(functionNode.getLineno());
    }
    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();
    lp.setCharno(position2charno(lparenCharno));
    for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
    }
    node.addChildToBack(lp);
    Node bodyNode = transform(functionNode.getBody());
    parseDirectives(bodyNode);
    node.addChildToBack(bodyNode);
    return node;
}",0.9545454545454546,-0.3979591836734693,0.16666666666666666,-0.5,0.08333333333333333,0.5882352941176473,-0.6157155147691427,1.9166666666666667,-0.028571428571428574,1.130477426428703
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3318_e12e2052,3,"/**
 * Returns <code>true</code> if this rule applies to the given node
 * <code>state</code>.
 *
 * @param state the state to check.
 * @return <code>true</code> the rule applies to the given node;
 *         <code>false</code> otherwise.
 */
public boolean appliesTo(Tree state) {
    if (!nodeTypeName.equals(getPrimaryTypeName(state))) {
        return false;
    }
    // return condition == null || condition.evaluate(state);
    return true;
}","/**
 * Returns <code>true</code> if this rule applies to the given node
 * <code>state</code>.
 *
 * @param state the state to check.
 * @return <code>true</code> the rule applies to the given node;
 *         <code>false</code> otherwise.
 */
","public boolean appliesTo(Tree state) {
    if (!nodeTypeName.equals(getPrimaryTypeName(state))) {
        return false;
    }
        return true;
}",-0.36363636363636365,-0.13775510204081634,-0.3333333333333333,-0.5,-0.08333333333333333,-0.3806228373702422,0.6449670203613421,-0.3333333333333333,1.0857142857142859,-0.16422749602751402
Closure,155,2,"/**
 * For all variables in this scope, see if they are only used once.
 * If it looks safe to do so, inline them.
 */
private void doInlinesForScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) {
    for (Iterator<Var> it = t.getScope().getVars(); it.hasNext(); ) {
        Var v = it.next();
        ReferenceCollection referenceInfo = referenceMap.get(v);
        // and the variable is not a constant.
        if (referenceInfo == null || isVarInlineForbidden(v)) {
            // were not collected or variables that have already been inlined.
            continue;
        } else if (isInlineableDeclaredConstant(v, referenceInfo)) {
            Reference init = referenceInfo.getInitializingReferenceForConstants();
            Node value = init.getAssignedValue();
            inlineDeclaredConstant(v, value, referenceInfo.references);
            staleVars.add(v);
        } else if (mode == Mode.CONSTANTS_ONLY) {
            // inlining heuristics. See InlineConstantsTest.
            continue;
        } else {
            inlineNonConstants(v, referenceInfo);
        }
    }
}","/**
 * For all variables in this scope, see if they are only used once.
 * If it looks safe to do so, inline them.
 */
","private void doInlinesForScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) {
    for (Iterator<Var> it = t.getScope().getVars(); it.hasNext(); ) {
        Var v = it.next();
        ReferenceCollection referenceInfo = referenceMap.get(v);
                if (referenceInfo == null || isVarInlineForbidden(v)) {
                        continue;
        } else if (isInlineableDeclaredConstant(v, referenceInfo)) {
            Reference init = referenceInfo.getInitializingReferenceForConstants();
            Node value = init.getAssignedValue();
            inlineDeclaredConstant(v, value, referenceInfo.references);
            staleVars.add(v);
        } else if (mode == Mode.CONSTANTS_ONLY) {
                        continue;
        } else {
            inlineNonConstants(v, referenceInfo);
        }
    }
}",0.18181818181818182,0.43877551020408156,0.5,1.0,0.5,-0.06623826000988627,-0.2234012044737599,0.5,-0.028571428571428574,0.0554820306577409
Compress,23,3,"@Override
InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException {
    byte propsByte = coder.properties[0];
    long dictSize = coder.properties[1];
    for (int i = 1; i < 4; i++) {
        dictSize |= (coder.properties[i + 1] << (8 * i));
    }
    if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {
        throw new IOException(""Dictionary larger than 4GiB maximum size"");
    }
    return new LZMAInputStream(in, -1, propsByte, (int) dictSize);
}",,"@Override
InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException {
    byte propsByte = coder.properties[0];
    long dictSize = coder.properties[1];
    for (int i = 1; i < 4; i++) {
        dictSize |= (coder.properties[i + 1] << (8 * i));
    }
    if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {
        throw new IOException(""Dictionary larger than 4GiB maximum size"");
    }
    return new LZMAInputStream(in, -1, propsByte, (int) dictSize);
}",-0.09090909090909091,-0.2346938775510204,0.0,-0.5,-0.08333333333333333,1.2011863568956997,0.024376254660166175,-0.5,0.0,0.6846895464727323
Math,34,1,"/**
 * Returns an iterator over the unmodifiable list of chromosomes.
 * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>
 *
 * @return chromosome iterator
 */
public Iterator<Chromosome> iterator() {
    return chromosomes.iterator();
}","/**
 * Returns an iterator over the unmodifiable list of chromosomes.
 * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>
 *
 * @return chromosome iterator
 */
","public Iterator<Chromosome> iterator() {
    return chromosomes.iterator();
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.1172928018353891,-0.4166666666666667,2.8000000000000003,-0.16422749602751402
Closure,64,2,"/**
 * Generates JavaScript source code for an AST.
 */
private String toSource(Node n, SourceMap sourceMap) {
    CodePrinter.Builder builder = new CodePrinter.Builder(n);
    builder.setPrettyPrint(options.prettyPrint);
    builder.setLineBreak(options.lineBreak);
    builder.setSourceMap(sourceMap);
    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);
    builder.setTagAsStrict(options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);
    builder.setLineLengthThreshold(options.lineLengthThreshold);
    Charset charset = options.outputCharset != null ? Charset.forName(options.outputCharset) : null;
    builder.setOutputCharset(charset);
    return builder.build();
}","/**
 * Generates JavaScript source code for an AST.
 */
","private String toSource(Node n, SourceMap sourceMap) {
    CodePrinter.Builder builder = new CodePrinter.Builder(n);
    builder.setPrettyPrint(options.prettyPrint);
    builder.setLineBreak(options.lineBreak);
    builder.setSourceMap(sourceMap);
    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);
    builder.setTagAsStrict(options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);
    builder.setLineLengthThreshold(options.lineLengthThreshold);
    Charset charset = options.outputCharset != null ? Charset.forName(options.outputCharset) : null;
    builder.setOutputCharset(charset);
    return builder.build();
}",-0.09090909090909091,-0.7806122448979592,-0.3333333333333333,-1.0,-0.25,-0.042511122095897164,0.014052193862919272,0.3333333333333333,-0.028571428571428574,0.04811526419708669
Math,99,3,"/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,
 * <code>gcd(Integer.MIN_VALUE, 0)</code> and
 * <code>gcd(0, Integer.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^31, which
 * is too large for an int value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and
 * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns
 * <code>0</code>.</li>
 * </ul>
 *
 * @param u any number
 * @param v any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */
public static int gcd(final int p, final int q) {
    int u = p;
    int v = q;
    if ((u == 0) || (v == 0)) {
        return (Math.abs(u) + Math.abs(v));
    }
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    }
    // make u negative
    if (v > 0) {
        v = -v;
    }
    // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
        // while u and v are
        // both even...
        u /= 2;
        v /= 2;
        // cast out twos.
        k++;
    }
    if (k == 31) {
        throw MathRuntimeException.createArithmeticException(""overflow: gcd({0}, {1}) is 2^31"", new Object[] { p, q });
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2);
    // t positive: u was even, v is odd (t replaces u)
    do {
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) {
            // while t is even..
            // cast out twos
            t /= 2;
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
    // |u| larger: t positive (replace u)
    // |v| larger: t negative (replace v)
    } while (t != 0);
    // gcd is u*2^k
    return -u * (1 << k);
}","/**
 * <p>
 * Gets the greatest common divisor of the absolute value of two numbers,
 * using the ""binary gcd"" method which avoids division and modulo
 * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef
 * Stein (1961).
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations
 * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,
 * <code>gcd(Integer.MIN_VALUE, 0)</code> and
 * <code>gcd(0, Integer.MIN_VALUE)</code> throw an
 * <code>ArithmeticException</code>, because the result would be 2^31, which
 * is too large for an int value.</li>
 * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and
 * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except
 * for the special cases above.
 * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns
 * <code>0</code>.</li>
 * </ul>
 *
 * @param u any number
 * @param v any number
 * @return the greatest common divisor, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */
","public static int gcd(final int p, final int q) {
    int u = p;
    int v = q;
    if ((u == 0) || (v == 0)) {
        return (Math.abs(u) + Math.abs(v));
    }
        if (u > 0) {
        u = -u;
    }
        if (v > 0) {
        v = -v;
    }
            int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
                        u /= 2;
        v /= 2;
                k++;
    }
    if (k == 31) {
        throw MathRuntimeException.createArithmeticException(""overflow: gcd({0}, {1}) is 2^31"", new Object[] { p, q });
    }
            int t = ((u & 1) == 1) ? v : -(u / 2);
        do {
                while ((t & 1) == 0) {
                                    t /= 2;
        }
                if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
                t = (v - u) / 2;
            } while (t != 0);
        return -u * (1 << k);
}",0.9545454545454546,-0.0459183673469387,1.1666666666666667,0.0,0.9166666666666666,5.464162135442413,-0.6509893891597365,-0.25,-0.028571428571428574,7.434544995095961
camel,remotes/origin/bugs-dot-jar_CAMEL-5681_78c73502,1,"@Override
protected boolean processNext(final Exchange exchange, final AsyncCallback callback) {
    final Exception caught = exchange.getException();
    if (caught == null) {
        return true;
    }
    // store the last to endpoint as the failure endpoint
    if (exchange.getProperty(Exchange.FAILURE_ENDPOINT) == null) {
        exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));
    }
    // give the rest of the pipeline another chance
    exchange.setProperty(Exchange.EXCEPTION_CAUGHT, caught);
    exchange.setException(null);
    // is the exception handled by the catch clause
    final Boolean handled = catchClause.handles(exchange);
    if (LOG.isDebugEnabled()) {
        LOG.debug(""The exception is handled: {} for the exception: {} caused by: {}"", new Object[] { handled, caught.getClass().getName(), caught.getMessage() });
    }
    boolean sync = super.processNext(exchange, new AsyncCallback() {

        public void done(boolean doneSync) {
            // we only have to handle async completion of the pipeline
            if (doneSync) {
                return;
            }
            if (!handled) {
                if (exchange.getException() == null) {
                    exchange.setException(exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class));
                }
            }
            // always clear redelivery exhausted in a catch clause
            exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED);
            // signal callback to continue routing async
            ExchangeHelper.prepareOutToIn(exchange);
            callback.done(false);
        }
    });
    if (sync) {
        // set exception back on exchange
        if (!handled) {
            if (exchange.getException() == null) {
                exchange.setException(exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class));
            }
        }
        // always clear redelivery exhausted in a catch clause
        exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED);
    }
    return sync;
}",,"@Override
protected boolean processNext(final Exchange exchange, final AsyncCallback callback) {
    final Exception caught = exchange.getException();
    if (caught == null) {
        return true;
    }
        if (exchange.getProperty(Exchange.FAILURE_ENDPOINT) == null) {
        exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));
    }
        exchange.setProperty(Exchange.EXCEPTION_CAUGHT, caught);
    exchange.setException(null);
        final Boolean handled = catchClause.handles(exchange);
    if (LOG.isDebugEnabled()) {
        LOG.debug(""The exception is handled: {} for the exception: {} caused by: {}"", new Object[] { handled, caught.getClass().getName(), caught.getMessage() });
    }
    boolean sync = super.processNext(exchange, new AsyncCallback() {

        public void done(boolean doneSync) {
                        if (doneSync) {
                return;
            }
            if (!handled) {
                if (exchange.getException() == null) {
                    exchange.setException(exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class));
                }
            }
                        exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED);
                        ExchangeHelper.prepareOutToIn(exchange);
            callback.done(false);
        }
    });
    if (sync) {
                if (!handled) {
            if (exchange.getException() == null) {
                exchange.setException(exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class));
            }
        }
                exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED);
    }
    return sync;
}",1.1818181818181819,0.9795918367346941,1.0,0.5,0.9166666666666666,0.12357884330202672,-0.6983080011471183,1.4166666666666667,-0.028571428571428574,0.45665386048543566
camel,remotes/origin/bugs-dot-jar_CAMEL-3498_b4606700,1,"public Object next() {
    Object part = iterator.next();
    Exchange newExchange = ExchangeHelper.createCopy(exchange, true);
    if (part instanceof Message) {
        newExchange.setIn((Message) part);
    } else {
        Message in = newExchange.getIn();
        in.setBody(part);
    }
    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);
}",,"public Object next() {
    Object part = iterator.next();
    Exchange newExchange = ExchangeHelper.createCopy(exchange, true);
    if (part instanceof Message) {
        newExchange.setIn((Message) part);
    } else {
        Message in = newExchange.getIn();
        in.setBody(part);
    }
    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);
}",-0.13636363636363635,-0.17857142857142863,-0.3333333333333333,-0.5,-0.25,-0.04844290657439445,0.14482363062804698,0.25,0.05714285714285714,-0.05016682299630377
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-844_692efde2,0,"@Override
public boolean accept(Key k, Value v) {
    Text testVis = k.getColumnVisibility(tmpVis);
    if (testVis.getLength() == 0 && defaultVisibility.getLength() == 0)
        return true;
    else if (testVis.getLength() == 0)
        testVis = defaultVisibility;
    Boolean b = (Boolean) cache.get(testVis);
    if (b != null)
        return b;
    try {
        Boolean bb = ve.evaluate(new ColumnVisibility(testVis));
        cache.put(new Text(testVis), bb);
        return bb;
    } catch (VisibilityParseException e) {
        log.error(""Parse Error"", e);
        return false;
    }
}",,"@Override
public boolean accept(Key k, Value v) {
    Text testVis = k.getColumnVisibility(tmpVis);
    if (testVis.getLength() == 0 && defaultVisibility.getLength() == 0)
        return true;
    else if (testVis.getLength() == 0)
        testVis = defaultVisibility;
    Boolean b = (Boolean) cache.get(testVis);
    if (b != null)
        return b;
    try {
        Boolean bb = ve.evaluate(new ColumnVisibility(testVis));
        cache.put(new Text(testVis), bb);
        return bb;
    } catch (VisibilityParseException e) {
        log.error(""Parse Error"", e);
        return false;
    }
}",0.22727272727272727,-0.08163265306122457,0.16666666666666666,-0.5,0.16666666666666666,0.28175976272862097,-0.23057069113851472,0.16666666666666666,0.0,0.28535084225268864
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2899_31aea2ad,0,"private int removeMetadataEntries(Map<String, Path> nameToFileMap, Map<String, Path> sortedWALogs, GCStatus status) throws IOException, KeeperException, InterruptedException {
    int count = 0;
    Iterator<LogEntry> iterator = MetadataTableUtil.getLogEntries(SystemCredentials.get());
    while (iterator.hasNext()) {
        for (String entry : iterator.next().logSet) {
            String uuid = new Path(entry).getName();
            if (!isUUID(uuid)) {
                // fully expect this to be a uuid, if its not then something is wrong and walog GC should not proceed!
                throw new IllegalArgumentException(""Expected uuid, but got "" + uuid + "" from "" + entry);
            }
            Path pathFromNN = nameToFileMap.remove(uuid);
            if (pathFromNN != null) {
                status.currentLog.inUse++;
                sortedWALogs.remove(uuid);
            }
            count++;
        }
    }
    return count;
}",,"private int removeMetadataEntries(Map<String, Path> nameToFileMap, Map<String, Path> sortedWALogs, GCStatus status) throws IOException, KeeperException, InterruptedException {
    int count = 0;
    Iterator<LogEntry> iterator = MetadataTableUtil.getLogEntries(SystemCredentials.get());
    while (iterator.hasNext()) {
        for (String entry : iterator.next().logSet) {
            String uuid = new Path(entry).getName();
            if (!isUUID(uuid)) {
                                throw new IllegalArgumentException(""Expected uuid, but got "" + uuid + "" from "" + entry);
            }
            Path pathFromNN = nameToFileMap.remove(uuid);
            if (pathFromNN != null) {
                status.currentLog.inUse++;
                sortedWALogs.remove(uuid);
            }
            count++;
        }
    }
    return count;
}",0.22727272727272727,1.0714285714285714,0.3333333333333333,0.5,0.16666666666666666,0.2560553633217994,-0.25752796099799274,0.16666666666666666,-0.028571428571428574,0.33116185042894286
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3028_89317b28,0,"/**
 * Creates an update operation for the document with the given id. The
 * changes are shared with the this update operation.
 *
 * @param id the primary key.
 */
public UpdateOp shallowCopy(String id) {
    return new UpdateOp(id, isNew, isDelete, changes);
}","/**
 * Creates an update operation for the document with the given id. The
 * changes are shared with the this update operation.
 *
 * @param id the primary key.
 */
","public UpdateOp shallowCopy(String id) {
    return new UpdateOp(id, isNew, isDelete, changes);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.003154574132492,-0.5,2.6,-0.16422749602751402
wicket,remotes/origin/bugs-dot-jar_WICKET-2181_d79d0192,1,"/**
 *  Gets the index of the current page being displayed by this list view.
 *
 *  @return Returns the currentPage.
 */
public final int getCurrentPage() {
    // If first cell is out of range, bring page back into range
    while ((currentPage * rowsPerPage) >= getList().size()) {
        currentPage--;
    }
    return currentPage;
}","/**
 *  Gets the index of the current page being displayed by this list view.
 *
 *  @return Returns the currentPage.
 */
","public final int getCurrentPage() {
        while ((currentPage * rowsPerPage) >= getList().size()) {
        currentPage--;
    }
    return currentPage;
}",-0.36363636363636365,-0.13775510204081634,-0.3333333333333333,-0.5,-0.08333333333333333,-0.11764705882352938,0.6521365070260969,-0.3333333333333333,2.657142857142857,-0.14431581156496673
camel,remotes/origin/bugs-dot-jar_CAMEL-9444_baece126,1,"private AggregationStrategy createAggregationStrategy(RouteContext routeContext) {
    AggregationStrategy strategy = getAggregationStrategy();
    if (strategy == null && strategyRef != null) {
        Object aggStrategy = routeContext.lookup(strategyRef, Object.class);
        if (aggStrategy instanceof AggregationStrategy) {
            strategy = (AggregationStrategy) aggStrategy;
        } else if (aggStrategy != null) {
            AggregationStrategyBeanAdapter adapter = new AggregationStrategyBeanAdapter(aggStrategy, getStrategyMethodName());
            if (getStrategyMethodAllowNull() != null) {
                adapter.setAllowNullNewExchange(getStrategyMethodAllowNull());
                adapter.setAllowNullOldExchange(getStrategyMethodAllowNull());
            }
            strategy = adapter;
        } else {
            throw new IllegalArgumentException(""Cannot find AggregationStrategy in Registry with name: "" + strategyRef);
        }
    }
    if (strategy != null && strategy instanceof CamelContextAware) {
        ((CamelContextAware) strategy).setCamelContext(routeContext.getCamelContext());
    }
    return strategy;
}",,"private AggregationStrategy createAggregationStrategy(RouteContext routeContext) {
    AggregationStrategy strategy = getAggregationStrategy();
    if (strategy == null && strategyRef != null) {
        Object aggStrategy = routeContext.lookup(strategyRef, Object.class);
        if (aggStrategy instanceof AggregationStrategy) {
            strategy = (AggregationStrategy) aggStrategy;
        } else if (aggStrategy != null) {
            AggregationStrategyBeanAdapter adapter = new AggregationStrategyBeanAdapter(aggStrategy, getStrategyMethodName());
            if (getStrategyMethodAllowNull() != null) {
                adapter.setAllowNullNewExchange(getStrategyMethodAllowNull());
                adapter.setAllowNullOldExchange(getStrategyMethodAllowNull());
            }
            strategy = adapter;
        } else {
            throw new IllegalArgumentException(""Cannot find AggregationStrategy in Registry with name: "" + strategyRef);
        }
    }
    if (strategy != null && strategy instanceof CamelContextAware) {
        ((CamelContextAware) strategy).setCamelContext(routeContext.getCamelContext());
    }
    return strategy;
}",0.36363636363636365,0.760204081632653,0.5,1.0,0.5,0.5308947108255069,-0.31402351591626054,0.3333333333333333,-0.028571428571428574,0.46206329422950904
JxPath,15,1,"public boolean setPosition(int position) {
    if (!prepared) {
        prepared = true;
        BasicNodeSet nodeSet = (BasicNodeSet) getNodeSet();
        ArrayList pointers = new ArrayList();
        for (int i = 0; i < contexts.length; i++) {
            EvalContext ctx = (EvalContext) contexts[i];
            while (ctx.nextSet()) {
                while (ctx.nextNode()) {
                    NodePointer ptr = ctx.getCurrentNodePointer();
                    if (!pointers.contains(ptr)) {
                        nodeSet.add(ptr);
                        pointers.add(ptr);
                    }
                }
            }
        }
    }
    return super.setPosition(position);
}",,"public boolean setPosition(int position) {
    if (!prepared) {
        prepared = true;
        BasicNodeSet nodeSet = (BasicNodeSet) getNodeSet();
        ArrayList pointers = new ArrayList();
        for (int i = 0; i < contexts.length; i++) {
            EvalContext ctx = (EvalContext) contexts[i];
            while (ctx.nextSet()) {
                while (ctx.nextNode()) {
                    NodePointer ptr = ctx.getCurrentNodePointer();
                    if (!pointers.contains(ptr)) {
                        nodeSet.add(ptr);
                        pointers.add(ptr);
                    }
                }
            }
        }
    }
    return super.setPosition(position);
}",0.2727272727272727,2.1836734693877546,0.3333333333333333,1.5,0.5833333333333334,0.35887296094908566,-0.22856323487238317,0.16666666666666666,0.14285714285714285,0.2393556649149181
JxPath,19,1,"/**
 * Get relative position of this among like-named siblings.
 * @return 1..n
 */
private int getRelativePositionByQName() {
    if (node instanceof Element) {
        Object parent = ((Element) node).getParent();
        if (!(parent instanceof Element)) {
            return 1;
        }
        List children = ((Element) parent).getContent();
        int count = 0;
        String name = ((Element) node).getQualifiedName();
        for (int i = 0; i < children.size(); i++) {
            Object child = children.get(i);
            if ((child instanceof Element) && ((Element) child).getQualifiedName().equals(name)) {
                count++;
            }
            if (child == node) {
                break;
            }
        }
        return count;
    }
    return 1;
}","/**
 * Get relative position of this among like-named siblings.
 * @return 1..n
 */
","private int getRelativePositionByQName() {
    if (node instanceof Element) {
        Object parent = ((Element) node).getParent();
        if (!(parent instanceof Element)) {
            return 1;
        }
        List children = ((Element) parent).getContent();
        int count = 0;
        String name = ((Element) node).getQualifiedName();
        for (int i = 0; i < children.size(); i++) {
            Object child = children.get(i);
            if ((child instanceof Element) && ((Element) child).getQualifiedName().equals(name)) {
                count++;
            }
            if (child == node) {
                break;
            }
        }
        return count;
    }
    return 1;
}",0.36363636363636365,0.6173469387755104,0.5,0.5,0.6666666666666666,0.9461196243203165,-0.29566963005448826,0.08333333333333333,0.08571428571428572,0.6425233744929993
wicket,remotes/origin/bugs-dot-jar_WICKET-5400_6cefb9f8,3,"private void internalAdd(final Behavior behavior) {
    component.data_add(behavior);
    if (behavior.getStatelessHint(component)) {
        getBehaviorId(behavior);
    }
}",,"private void internalAdd(final Behavior behavior) {
    component.data_add(behavior);
    if (behavior.getStatelessHint(component)) {
        getBehaviorId(behavior);
    }
}",-0.36363636363636365,-0.13775510204081634,-0.3333333333333333,-0.5,-0.16666666666666666,-0.3806228373702422,0.6472612560940636,-0.25,0.8571428571428572,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2434_8159fc21,1,"static Query getFullTextQuery(FullTextExpression ft, final Analyzer analyzer, final IndexReader reader) {
    // a reference to the query, so it can be set in the visitor
    // (a ""non-local return"")
    final AtomicReference<Query> result = new AtomicReference<Query>();
    ft.accept(new FullTextVisitor() {

        @Override
        public boolean visit(FullTextContains contains) {
            return contains.getBase().accept(this);
        }

        @Override
        public boolean visit(FullTextOr or) {
            BooleanQuery q = new BooleanQuery();
            for (FullTextExpression e : or.list) {
                Query x = getFullTextQuery(e, analyzer, reader);
                q.add(x, SHOULD);
            }
            result.set(q);
            return true;
        }

        @Override
        public boolean visit(FullTextAnd and) {
            BooleanQuery q = new BooleanQuery();
            for (FullTextExpression e : and.list) {
                Query x = getFullTextQuery(e, analyzer, reader);
                // Lucene can't deal with ""must(must_not(x))""
                if (x instanceof BooleanQuery) {
                    BooleanQuery bq = (BooleanQuery) x;
                    for (BooleanClause c : bq.clauses()) {
                        q.add(c);
                    }
                } else {
                    q.add(x, MUST);
                }
            }
            result.set(q);
            return true;
        }

        @Override
        public boolean visit(FullTextTerm term) {
            return visitTerm(term.getPropertyName(), term.getText(), term.getBoost(), term.isNot());
        }

        private boolean visitTerm(String propertyName, String text, String boost, boolean not) {
            String p = propertyName;
            if (p != null && p.indexOf('/') >= 0) {
                p = getName(p);
            }
            Query q = tokenToQuery(text, p, analyzer, reader);
            if (q == null) {
                return false;
            }
            if (boost != null) {
                q.setBoost(Float.parseFloat(boost));
            }
            if (not) {
                BooleanQuery bq = new BooleanQuery();
                bq.add(q, MUST_NOT);
                result.set(bq);
            } else {
                result.set(q);
            }
            return true;
        }
    });
    return result.get();
}",,"static Query getFullTextQuery(FullTextExpression ft, final Analyzer analyzer, final IndexReader reader) {
            final AtomicReference<Query> result = new AtomicReference<Query>();
    ft.accept(new FullTextVisitor() {

        @Override
        public boolean visit(FullTextContains contains) {
            return contains.getBase().accept(this);
        }

        @Override
        public boolean visit(FullTextOr or) {
            BooleanQuery q = new BooleanQuery();
            for (FullTextExpression e : or.list) {
                Query x = getFullTextQuery(e, analyzer, reader);
                q.add(x, SHOULD);
            }
            result.set(q);
            return true;
        }

        @Override
        public boolean visit(FullTextAnd and) {
            BooleanQuery q = new BooleanQuery();
            for (FullTextExpression e : and.list) {
                Query x = getFullTextQuery(e, analyzer, reader);
                                if (x instanceof BooleanQuery) {
                    BooleanQuery bq = (BooleanQuery) x;
                    for (BooleanClause c : bq.clauses()) {
                        q.add(c);
                    }
                } else {
                    q.add(x, MUST);
                }
            }
            result.set(q);
            return true;
        }

        @Override
        public boolean visit(FullTextTerm term) {
            return visitTerm(term.getPropertyName(), term.getText(), term.getBoost(), term.isNot());
        }

        private boolean visitTerm(String propertyName, String text, String boost, boolean not) {
            String p = propertyName;
            if (p != null && p.indexOf('/') >= 0) {
                p = getName(p);
            }
            Query q = tokenToQuery(text, p, analyzer, reader);
            if (q == null) {
                return false;
            }
            if (boost != null) {
                q.setBoost(Float.parseFloat(boost));
            }
            if (not) {
                BooleanQuery bq = new BooleanQuery();
                bq.add(q, MUST_NOT);
                result.set(bq);
            } else {
                result.set(q);
            }
            return true;
        }
    });
    return result.get();
}",2.1818181818181817,0.8571428571428572,0.8333333333333334,1.0,0.5833333333333334,0.6178942165101335,-0.9827932320045887,1.5833333333333333,-0.028571428571428574,2.0448387663235983
Lang,7,1,"/**
 * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * @param str  a <code>String</code> to convert, may be null
 * @return converted <code>BigDecimal</code> (or null if the input is null)
 * @throws NumberFormatException if the value cannot be converted
 */
public static BigDecimal createBigDecimal(String str) {
    if (str == null) {
        return null;
    }
    // handle JDK1.3.1 bug where """" throws IndexOutOfBoundsException
    if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
    // a wrong value.
    return new BigDecimal(str);
}","/**
 * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>
 *
 * <p>Returns <code>null</code> if the string is <code>null</code>.</p>
 *
 * @param str  a <code>String</code> to convert, may be null
 * @return converted <code>BigDecimal</code> (or null if the input is null)
 * @throws NumberFormatException if the value cannot be converted
 */
","public static BigDecimal createBigDecimal(String str) {
    if (str == null) {
        return null;
    }
        if (StringUtils.isBlank(str)) {
        throw new NumberFormatException(""A blank string is not a valid number"");
    }
        return new BigDecimal(str);
}",-0.22727272727272727,-0.17857142857142863,0.0,-0.5,-0.08333333333333333,-0.3806228373702422,0.3814166905649556,-0.4166666666666667,0.0,-0.16422749602751402
camel,remotes/origin/bugs-dot-jar_CAMEL-4486_f98ac676,1,"private boolean doRoutingSlip(Exchange exchange, AsyncCallback callback) {
    Exchange current = exchange;
    RoutingSlipIterator iter;
    try {
        iter = createRoutingSlipIterator(exchange);
    } catch (Exception e) {
        exchange.setException(e);
        callback.done(true);
        return true;
    }
    // ensure the slip is empty when we start
    if (current.hasProperties()) {
        current.setProperty(Exchange.SLIP_ENDPOINT, null);
    }
    while (iter.hasNext(current)) {
        Endpoint endpoint;
        try {
            endpoint = resolveEndpoint(iter, exchange);
            // if no endpoint was resolved then try the next
            if (endpoint == null) {
                continue;
            }
        } catch (Exception e) {
            // error resolving endpoint so we should break out
            exchange.setException(e);
            return true;
        }
        // prepare and process the routing slip
        Exchange copy = prepareExchangeForRoutingSlip(current, endpoint);
        boolean sync = processExchange(endpoint, copy, exchange, callback, iter);
        current = copy;
        if (!sync) {
            log.trace(""Processing exchangeId: {} is continued being processed asynchronously"", exchange.getExchangeId());
            // so we break out now, then the callback will be invoked which then continue routing from where we left here
            return false;
        }
        log.trace(""Processing exchangeId: {} is continued being processed synchronously"", exchange.getExchangeId());
        // we ignore some kind of exceptions and allow us to continue
        if (isIgnoreInvalidEndpoints()) {
            FailedToCreateProducerException e = current.getException(FailedToCreateProducerException.class);
            if (e != null) {
                if (log.isDebugEnabled()) {
                    log.debug(""Endpoint uri is invalid: "" + endpoint + "". This exception will be ignored."", e);
                }
                current.setException(null);
            }
        }
        // check for error if so we should break out
        if (!continueProcessing(current, ""so breaking out of the routing slip"", log)) {
            break;
        }
    }
    // logging nextExchange as it contains the exchange that might have altered the payload and since
    // we are logging the completion if will be confusing if we log the original instead
    // we could also consider logging the original and the nextExchange then we have *before* and *after* snapshots
    log.trace(""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), current);
    // copy results back to the original exchange
    ExchangeHelper.copyResults(exchange, current);
    callback.done(true);
    return true;
}",,"private boolean doRoutingSlip(Exchange exchange, AsyncCallback callback) {
    Exchange current = exchange;
    RoutingSlipIterator iter;
    try {
        iter = createRoutingSlipIterator(exchange);
    } catch (Exception e) {
        exchange.setException(e);
        callback.done(true);
        return true;
    }
        if (current.hasProperties()) {
        current.setProperty(Exchange.SLIP_ENDPOINT, null);
    }
    while (iter.hasNext(current)) {
        Endpoint endpoint;
        try {
            endpoint = resolveEndpoint(iter, exchange);
                        if (endpoint == null) {
                continue;
            }
        } catch (Exception e) {
                        exchange.setException(e);
            return true;
        }
                Exchange copy = prepareExchangeForRoutingSlip(current, endpoint);
        boolean sync = processExchange(endpoint, copy, exchange, callback, iter);
        current = copy;
        if (!sync) {
            log.trace(""Processing exchangeId: {} is continued being processed asynchronously"", exchange.getExchangeId());
                        return false;
        }
        log.trace(""Processing exchangeId: {} is continued being processed synchronously"", exchange.getExchangeId());
                if (isIgnoreInvalidEndpoints()) {
            FailedToCreateProducerException e = current.getException(FailedToCreateProducerException.class);
            if (e != null) {
                if (log.isDebugEnabled()) {
                    log.debug(""Endpoint uri is invalid: "" + endpoint + "". This exception will be ignored."", e);
                }
                current.setException(null);
            }
        }
                if (!continueProcessing(current, ""so breaking out of the routing slip"", log)) {
            break;
        }
    }
                log.trace(""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), current);
        ExchangeHelper.copyResults(exchange, current);
    callback.done(true);
    return true;
}",1.6363636363636365,0.6275510204081632,1.5,1.0,1.0833333333333333,0.5862580326248147,-0.8503011184399201,1.5,-0.028571428571428574,1.2775386434013902
Closure,65,2,"/**
 * Helper to escape javascript string as well as regular expression
 */
static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch(c) {
            case '\0':
                sb.append(""\\0"");
                break;
            case '\n':
                sb.append(""\\n"");
                break;
            case '\r':
                sb.append(""\\r"");
                break;
            case '\t':
                sb.append(""\\t"");
                break;
            case '\\':
                sb.append(backslashEscape);
                break;
            case '\""':
                sb.append(doublequoteEscape);
                break;
            case '\'':
                sb.append(singlequoteEscape);
                break;
            case // Break --> into --\> or ]]> into ]]\>
            '>':
                if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':
                // Break </script into <\/script
                final String END_SCRIPT = ""/script"";
                // Break <!-- into <\!--
                final String START_COMMENT = ""!--"";
                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {
                    sb.append(""<\\"");
                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {
                    sb.append(""<\\"");
                } else {
                    sb.append(c);
                }
                break;
            default:
                // character can be represented in this character set.
                if (outputCharsetEncoder != null) {
                    if (outputCharsetEncoder.canEncode(c)) {
                        sb.append(c);
                    } else {
                        // Unicode-escape the character.
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                } else {
                    // check is measurably faster than using the CharsetEncoder.
                    if (c > 0x1f && c < 0x7f) {
                        sb.append(c);
                    } else {
                        // Other characters can be misinterpreted by some js parsers,
                        // or perhaps mangled by proxies along the way,
                        // so we play it safe and unicode escape them.
                        appendHexJavaScriptRepresentation(sb, c);
                    }
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}","/**
 * Helper to escape javascript string as well as regular expression
 */
","static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) {
    StringBuilder sb = new StringBuilder(s.length() + 2);
    sb.append(quote);
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        switch(c) {
            case '\0':
                sb.append(""\\0"");
                break;
            case '\n':
                sb.append(""\\n"");
                break;
            case '\r':
                sb.append(""\\r"");
                break;
            case '\t':
                sb.append(""\\t"");
                break;
            case '\\':
                sb.append(backslashEscape);
                break;
            case '\""':
                sb.append(doublequoteEscape);
                break;
            case '\'':
                sb.append(singlequoteEscape);
                break;
            case             '>':
                if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {
                    sb.append(""\\>"");
                } else {
                    sb.append(c);
                }
                break;
            case '<':
                                final String END_SCRIPT = ""/script"";
                                final String START_COMMENT = ""!--"";
                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {
                    sb.append(""<\\"");
                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {
                    sb.append(""<\\"");
                } else {
                    sb.append(c);
                }
                break;
            default:
                                if (outputCharsetEncoder != null) {
                    if (outputCharsetEncoder.canEncode(c)) {
                        sb.append(c);
                    } else {
                                                appendHexJavaScriptRepresentation(sb, c);
                    }
                } else {
                                        if (c > 0x1f && c < 0x7f) {
                        sb.append(c);
                    } else {
                                                                                                appendHexJavaScriptRepresentation(sb, c);
                    }
                }
        }
    }
    sb.append(quote);
    return sb.toString();
}",2.3181818181818183,1.3112244897959182,3.8333333333333335,1.5,2.25,2.605042016806723,-1.1284772010324065,2.0833333333333335,-0.028571428571428574,6.663154603586587
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-43_668f08f2,1,"void apply() throws Exception {
    removeNode(nodePath);
}",,"void apply() throws Exception {
    removeNode(nodePath);
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.144536851161457,-0.4166666666666667,2.5142857142857147,-0.16422749602751402
Closure,24,2,"private void findAliases(NodeTraversal t) {
    Scope scope = t.getScope();
    for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        int type = n.getType();
        Node parent = n.getParent();
        if (parent.isVar()) {
            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
                String name = n.getString();
                Var aliasVar = scope.getVar(name);
                aliases.put(name, aliasVar);
                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();
                transformation.addAlias(name, qualifiedName);
            // Bleeding functions already get a BAD_PARAMETERS error, so just
            // do nothing.
            // Parameters of the scope function also get a BAD_PARAMETERS
            // error.
            } else {
                // TODO(robbyw): Support using locals for private variables.
                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
            }
        }
    }
}",,"private void findAliases(NodeTraversal t) {
    Scope scope = t.getScope();
    for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        int type = n.getType();
        Node parent = n.getParent();
        if (parent.isVar()) {
            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
                String name = n.getString();
                Var aliasVar = scope.getVar(name);
                aliases.put(name, aliasVar);
                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();
                transformation.addAlias(name, qualifiedName);
                                                            } else {
                                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
            }
        }
    }
}",0.22727272727272727,1.2142857142857144,0.0,0.5,0.08333333333333333,-0.05239742956005931,-0.23802695726985945,0.9166666666666666,0.028571428571428574,0.07980520898916828
Closure,43,2,"private void attachLiteralTypes(NodeTraversal t, Node n) {
    switch(n.getType()) {
        case Token.NULL:
            n.setJSType(getNativeType(NULL_TYPE));
            break;
        case Token.VOID:
            n.setJSType(getNativeType(VOID_TYPE));
            break;
        case Token.STRING:
            // Defer keys to the Token.OBJECTLIT case
            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
                n.setJSType(getNativeType(STRING_TYPE));
            }
            break;
        case Token.NUMBER:
            n.setJSType(getNativeType(NUMBER_TYPE));
            break;
        case Token.TRUE:
        case Token.FALSE:
            n.setJSType(getNativeType(BOOLEAN_TYPE));
            break;
        case Token.REGEXP:
            n.setJSType(getNativeType(REGEXP_TYPE));
            break;
        case Token.OBJECTLIT:
            defineObjectLiteral(n);
            break;
    }
}",,"private void attachLiteralTypes(NodeTraversal t, Node n) {
    switch(n.getType()) {
        case Token.NULL:
            n.setJSType(getNativeType(NULL_TYPE));
            break;
        case Token.VOID:
            n.setJSType(getNativeType(VOID_TYPE));
            break;
        case Token.STRING:
                        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
                n.setJSType(getNativeType(STRING_TYPE));
            }
            break;
        case Token.NUMBER:
            n.setJSType(getNativeType(NUMBER_TYPE));
            break;
        case Token.TRUE:
        case Token.FALSE:
            n.setJSType(getNativeType(BOOLEAN_TYPE));
            break;
        case Token.REGEXP:
            n.setJSType(getNativeType(REGEXP_TYPE));
            break;
        case Token.OBJECTLIT:
            defineObjectLiteral(n);
            break;
    }
}",0.6363636363636364,0.37755102040816313,2.1666666666666665,0.5,0.6666666666666666,-0.3806228373702422,-0.46888442787496454,0.8333333333333334,-0.028571428571428574,-0.16422749602751402
flink,remotes/origin/bugs-dot-jar_FLINK-1705_5308ac83,1,"/**
 *  Returns the host name of the instance. If the host name could not be determined, the return value will be a
 *  textual representation of the instance's IP address.
 *
 *  @return the host name of the instance
 */
public String getFQDNHostname() {
    return this.fqdnHostName;
}","/**
 *  Returns the host name of the instance. If the host name could not be determined, the return value will be a
 *  textual representation of the instance's IP address.
 *
 *  @return the host name of the instance
 */
","public String getFQDNHostname() {
    return this.fqdnHostName;
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,1.2001720676799543,-0.5,2.628571428571429,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1287_14849e22,1,"public List<RecordId> getEntries() {
    if (size == 0) {
        return emptyList();
    } else if (size == 1) {
        return singletonList(getRecordId());
    } else {
        List<RecordId> list = newArrayListWithCapacity(size);
        Segment segment = getSegment();
        int offset = getOffset();
        for (int i = 0; i < size; i += bucketSize) {
            RecordId id = segment.readRecordId(offset);
            if (bucketSize == 1) {
                list.add(id);
            } else {
                ListRecord bucket = new ListRecord(segment, id, Math.min(bucketSize, size - offset));
                list.addAll(bucket.getEntries());
            }
            offset += Segment.RECORD_ID_BYTES;
        }
        return list;
    }
}",,"public List<RecordId> getEntries() {
    if (size == 0) {
        return emptyList();
    } else if (size == 1) {
        return singletonList(getRecordId());
    } else {
        List<RecordId> list = newArrayListWithCapacity(size);
        Segment segment = getSegment();
        int offset = getOffset();
        for (int i = 0; i < size; i += bucketSize) {
            RecordId id = segment.readRecordId(offset);
            if (bucketSize == 1) {
                list.add(id);
            } else {
                ListRecord bucket = new ListRecord(segment, id, Math.min(bucketSize, size - offset));
                list.addAll(bucket.getEntries());
            }
            offset += Segment.RECORD_ID_BYTES;
        }
        return list;
    }
}",0.36363636363636365,0.7857142857142855,0.16666666666666666,1.0,0.16666666666666666,0.39644092931290176,-0.31230283911671936,0.4166666666666667,0.028571428571428574,0.4129372411459604
flink,remotes/origin/bugs-dot-jar_FLINK-2082_0cfa43d7,3,"public StreamingRuntimeContext createRuntimeContext(String taskName) {
    Environment env = getEnvironment();
    return new StreamingRuntimeContext(taskName, env, getUserCodeClassLoader(), getExecutionConfig());
}",,"public StreamingRuntimeContext createRuntimeContext(String taskName) {
    Environment env = getEnvironment();
    return new StreamingRuntimeContext(taskName, env, getUserCodeClassLoader(), getExecutionConfig());
}",-0.45454545454545453,-0.5204081632653061,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.7981072555205045,-0.25,0.5714285714285714,-0.16422749602751402
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1822_3e83a4c1,1,"@Override
public <T extends Document> boolean create(Collection<T> collection, List<UpdateOp> updateOps) {
    log(""create"", updateOps);
    List<T> docs = new ArrayList<T>();
    DBObject[] inserts = new DBObject[updateOps.size()];
    for (int i = 0; i < updateOps.size(); i++) {
        inserts[i] = new BasicDBObject();
        UpdateOp update = updateOps.get(i);
        T target = collection.newDocument(this);
        UpdateUtils.applyChanges(target, update, comparator);
        docs.add(target);
        for (Entry<Key, Operation> entry : update.getChanges().entrySet()) {
            Key k = entry.getKey();
            Operation op = entry.getValue();
            switch(op.type) {
                case SET:
                case INCREMENT:
                    {
                        inserts[i].put(k.toString(), op.value);
                        break;
                    }
                case SET_MAP_ENTRY:
                    {
                        Revision r = k.getRevision();
                        if (r == null) {
                            throw new IllegalStateException(""SET_MAP_ENTRY must not have null revision"");
                        }
                        DBObject value = new RevisionEntry(r, op.value);
                        inserts[i].put(k.getName(), value);
                        break;
                    }
                case REMOVE_MAP_ENTRY:
                    // nothing to do for new entries
                    break;
                case CONTAINS_MAP_ENTRY:
                    // no effect
                    break;
            }
        }
        if (!inserts[i].containsField(Document.MOD_COUNT)) {
            inserts[i].put(Document.MOD_COUNT, 1L);
            target.put(Document.MOD_COUNT, 1L);
        }
    }
    DBCollection dbCollection = getDBCollection(collection);
    long start = start();
    try {
        try {
            WriteResult writeResult = dbCollection.insert(inserts, WriteConcern.SAFE);
            if (writeResult.getError() != null) {
                return false;
            }
            if (collection == Collection.NODES) {
                for (T doc : docs) {
                    Lock lock = getAndLock(doc.getId());
                    try {
                        addToCache((NodeDocument) doc);
                    } finally {
                        lock.unlock();
                    }
                }
            }
            return true;
        } catch (MongoException e) {
            return false;
        }
    } finally {
        end(""create"", start);
    }
}",,"@Override
public <T extends Document> boolean create(Collection<T> collection, List<UpdateOp> updateOps) {
    log(""create"", updateOps);
    List<T> docs = new ArrayList<T>();
    DBObject[] inserts = new DBObject[updateOps.size()];
    for (int i = 0; i < updateOps.size(); i++) {
        inserts[i] = new BasicDBObject();
        UpdateOp update = updateOps.get(i);
        T target = collection.newDocument(this);
        UpdateUtils.applyChanges(target, update, comparator);
        docs.add(target);
        for (Entry<Key, Operation> entry : update.getChanges().entrySet()) {
            Key k = entry.getKey();
            Operation op = entry.getValue();
            switch(op.type) {
                case SET:
                case INCREMENT:
                    {
                        inserts[i].put(k.toString(), op.value);
                        break;
                    }
                case SET_MAP_ENTRY:
                    {
                        Revision r = k.getRevision();
                        if (r == null) {
                            throw new IllegalStateException(""SET_MAP_ENTRY must not have null revision"");
                        }
                        DBObject value = new RevisionEntry(r, op.value);
                        inserts[i].put(k.getName(), value);
                        break;
                    }
                case REMOVE_MAP_ENTRY:
                                        break;
                case CONTAINS_MAP_ENTRY:
                                        break;
            }
        }
        if (!inserts[i].containsField(Document.MOD_COUNT)) {
            inserts[i].put(Document.MOD_COUNT, 1L);
            target.put(Document.MOD_COUNT, 1L);
        }
    }
    DBCollection dbCollection = getDBCollection(collection);
    long start = start();
    try {
        try {
            WriteResult writeResult = dbCollection.insert(inserts, WriteConcern.SAFE);
            if (writeResult.getError() != null) {
                return false;
            }
            if (collection == Collection.NODES) {
                for (T doc : docs) {
                    Lock lock = getAndLock(doc.getId());
                    try {
                        addToCache((NodeDocument) doc);
                    } finally {
                        lock.unlock();
                    }
                }
            }
            return true;
        } catch (MongoException e) {
            return false;
        }
    } finally {
        end(""create"", start);
    }
}",2.4545454545454546,2.198979591836735,2.5,1.5,1.0,0.7543252595155712,-1.1063951821049618,1.8333333333333333,-0.028571428571428574,2.6080623262706606
commons-math,remotes/origin/bugs-dot-jar_MATH-705_645d642b,1,"/**
 * {@inheritDoc}
 */
@Override
public void writeExternal(final ObjectOutput out) throws IOException {
    // save the state of the base class
    writeBaseExternal(out);
    // save the local attributes
    final int n = (currentState == null) ? -1 : currentState.length;
    final int kMax = (yDotK == null) ? -1 : yDotK.length;
    out.writeInt(kMax);
    for (int k = 0; k < kMax; ++k) {
        for (int i = 0; i < n; ++i) {
            out.writeDouble(yDotK[k][i]);
        }
    }
// we do not save any reference to the equations
}","/**
 * {@inheritDoc}
 */
","@Override
public void writeExternal(final ObjectOutput out) throws IOException {
        writeBaseExternal(out);
        final int n = (currentState == null) ? -1 : currentState.length;
    final int kMax = (yDotK == null) ? -1 : yDotK.length;
    out.writeInt(kMax);
    for (int k = 0; k < kMax; ++k) {
        for (int i = 0; i < n; ++i) {
            out.writeDouble(yDotK[k][i]);
        }
    }
}",-0.09090909090909091,0.2193877551020409,0.16666666666666666,0.0,0.4166666666666667,0.41028175976272874,0.02925150559219949,-0.25,2.142857142857143,0.22851966541174656
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1516_7c62bd81,1,"private static Term[] extractMatchingTokens(IndexReader reader, String token) {
    if (reader == null) {
        // getPlan call
        return null;
    }
    try {
        List<Term> terms = new ArrayList<Term>();
        Terms t = MultiFields.getTerms(reader, FieldNames.FULLTEXT);
        Automaton a = WildcardQuery.toAutomaton(newFulltextTerm(token));
        CompiledAutomaton ca = new CompiledAutomaton(a);
        TermsEnum te = ca.getTermsEnum(t);
        BytesRef text;
        while ((text = te.next()) != null) {
            terms.add(newFulltextTerm(text.utf8ToString()));
        }
        return terms.toArray(new Term[terms.size()]);
    } catch (IOException e) {
        LOG.error(""Building fulltext query failed"", e.getMessage());
        return null;
    }
}",,"private static Term[] extractMatchingTokens(IndexReader reader, String token) {
    if (reader == null) {
                return null;
    }
    try {
        List<Term> terms = new ArrayList<Term>();
        Terms t = MultiFields.getTerms(reader, FieldNames.FULLTEXT);
        Automaton a = WildcardQuery.toAutomaton(newFulltextTerm(token));
        CompiledAutomaton ca = new CompiledAutomaton(a);
        TermsEnum te = ca.getTermsEnum(t);
        BytesRef text;
        while ((text = te.next()) != null) {
            terms.add(newFulltextTerm(text.utf8ToString()));
        }
        return terms.toArray(new Term[terms.size()]);
    } catch (IOException e) {
        LOG.error(""Building fulltext query failed"", e.getMessage());
        return null;
    }
}",0.2727272727272727,-0.04081632653061228,0.0,0.0,-0.16666666666666666,-0.08007909045971327,-0.27444794952681417,0.5,0.028571428571428574,0.0803234524436678
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-177_f91ce934,1,"@Override
public synchronized void flush() throws IOException {
    if (this.ds != null && this.address != null) {
        final DatagramPacket packet = new DatagramPacket(data, data.length, address, port);
        ds.send(packet);
    }
    data = null;
}",,"@Override
public synchronized void flush() throws IOException {
    if (this.ds != null && this.address != null) {
        final DatagramPacket packet = new DatagramPacket(data, data.length, address, port);
        ds.send(packet);
    }
    data = null;
}",-0.2727272727272727,0.051020408163265356,-0.3333333333333333,-0.5,-0.08333333333333333,-0.06030647553138898,0.35531975910524816,-0.4166666666666667,0.4285714285714286,-0.09227303292344988
wicket,remotes/origin/bugs-dot-jar_WICKET-5853_b80f6640,3,"/**
 *  @see org.apache.wicket.util.convert.converter.AbstractConverter#getTargetType()
 */
@Override
protected Class<Integer> getTargetType() {
    return Integer.class;
}","/**
 *  @see org.apache.wicket.util.convert.converter.AbstractConverter#getTargetType()
 */
","@Override
protected Class<Integer> getTargetType() {
    return Integer.class;
}",-0.45454545454545453,-0.6581632653061225,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9836535704043596,-0.5,2.2571428571428576,-0.16422749602751402
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-412_5594b2e0,1,"public AssignmentStats importFiles(List<String> files, Path failureDir) throws IOException, AccumuloException, AccumuloSecurityException, ThriftTableOperationException {
    int numThreads = acuConf.getCount(Property.TSERV_BULK_PROCESS_THREADS);
    int numAssignThreads = acuConf.getCount(Property.TSERV_BULK_ASSIGNMENT_THREADS);
    timer = new StopWatch<Timers>(Timers.class);
    timer.start(Timers.TOTAL);
    Configuration conf = CachedConfiguration.getInstance();
    final FileSystem fs = FileSystem.get(conf);
    Set<Path> paths = new HashSet<Path>();
    for (String file : files) {
        paths.add(new Path(file));
    }
    AssignmentStats assignmentStats = new AssignmentStats(paths.size());
    final Map<Path, List<KeyExtent>> completeFailures = Collections.synchronizedSortedMap(new TreeMap<Path, List<KeyExtent>>());
    if (!fs.exists(failureDir)) {
        log.error(failureDir + "" does not exist"");
        throw new RuntimeException(""Directory does not exist "" + failureDir);
    }
    ClientService.Iface client = null;
    final TabletLocator locator = TabletLocator.getInstance(instance, credentials, new Text(tableId));
    try {
        final Map<Path, List<TabletLocation>> assignments = Collections.synchronizedSortedMap(new TreeMap<Path, List<TabletLocation>>());
        timer.start(Timers.EXAMINE_MAP_FILES);
        ExecutorService threadPool = Executors.newFixedThreadPool(numThreads);
        for (Path path : paths) {
            final Path mapFile = path;
            Runnable getAssignments = new Runnable() {

                public void run() {
                    List<TabletLocation> tabletsToAssignMapFileTo = Collections.emptyList();
                    try {
                        tabletsToAssignMapFileTo = findOverlappingTablets(instance.getConfiguration(), fs, locator, mapFile);
                    } catch (Exception ex) {
                        log.warn(""Unable to find tablets that overlap file "" + mapFile.toString());
                    }
                    if (tabletsToAssignMapFileTo.size() == 0) {
                        List<KeyExtent> empty = Collections.emptyList();
                        completeFailures.put(mapFile, empty);
                    } else
                        assignments.put(mapFile, tabletsToAssignMapFileTo);
                }
            };
            threadPool.submit(new TraceRunnable(new LoggingRunnable(log, getAssignments)));
        }
        threadPool.shutdown();
        while (!threadPool.isTerminated()) {
            try {
                threadPool.awaitTermination(60, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        timer.stop(Timers.EXAMINE_MAP_FILES);
        assignmentStats.attemptingAssignments(assignments);
        Map<Path, List<KeyExtent>> assignmentFailures = assignMapFiles(acuConf, instance, conf, credentials, fs, tableId, assignments, paths, numAssignThreads, numThreads);
        assignmentStats.assignmentsFailed(assignmentFailures);
        Map<Path, Integer> failureCount = new TreeMap<Path, Integer>();
        for (Entry<Path, List<KeyExtent>> entry : assignmentFailures.entrySet()) failureCount.put(entry.getKey(), 1);
        while (assignmentFailures.size() > 0) {
            locator.invalidateCache();
            // assumption about assignment failures is that it caused by a split
            // happening or a missing location
            // 
            // for splits we need to find children key extents that cover the
            // same key range and are contiguous (no holes, no overlap)
            timer.start(Timers.SLEEP);
            UtilWaitThread.sleep(4000);
            timer.stop(Timers.SLEEP);
            log.debug(""Trying to assign "" + assignmentFailures.size() + "" map files that previously failed on some key extents"");
            assignments.clear();
            // assign to
            for (Entry<Path, List<KeyExtent>> entry : assignmentFailures.entrySet()) {
                Iterator<KeyExtent> keListIter = entry.getValue().iterator();
                List<TabletLocation> tabletsToAssignMapFileTo = new ArrayList<TabletLocation>();
                while (keListIter.hasNext()) {
                    KeyExtent ke = keListIter.next();
                    try {
                        timer.start(Timers.QUERY_METADATA);
                        tabletsToAssignMapFileTo.addAll(findOverlappingTablets(instance.getConfiguration(), fs, locator, entry.getKey(), ke));
                        timer.stop(Timers.QUERY_METADATA);
                        keListIter.remove();
                    } catch (Exception ex) {
                        log.warn(""Exception finding overlapping tablets, will retry tablet "" + ke);
                    }
                }
                if (tabletsToAssignMapFileTo.size() > 0)
                    assignments.put(entry.getKey(), tabletsToAssignMapFileTo);
            }
            assignmentStats.attemptingAssignments(assignments);
            Map<Path, List<KeyExtent>> assignmentFailures2 = assignMapFiles(acuConf, instance, conf, credentials, fs, tableId, assignments, paths, numAssignThreads, numThreads);
            assignmentStats.assignmentsFailed(assignmentFailures2);
            // merge assignmentFailures2 into assignmentFailures
            for (Entry<Path, List<KeyExtent>> entry : assignmentFailures2.entrySet()) {
                assignmentFailures.get(entry.getKey()).addAll(entry.getValue());
                Integer fc = failureCount.get(entry.getKey());
                if (fc == null)
                    fc = 0;
                failureCount.put(entry.getKey(), fc + 1);
            }
            // remove map files that have no more key extents to assign
            Iterator<Entry<Path, List<KeyExtent>>> afIter = assignmentFailures.entrySet().iterator();
            while (afIter.hasNext()) {
                Entry<Path, List<KeyExtent>> entry = afIter.next();
                if (entry.getValue().size() == 0)
                    afIter.remove();
            }
            Set<Entry<Path, Integer>> failureIter = failureCount.entrySet();
            for (Entry<Path, Integer> entry : failureIter) {
                if (entry.getValue() > acuConf.getCount(Property.TSERV_BULK_RETRY) && assignmentFailures.get(entry.getKey()) != null) {
                    log.error(""Map file "" + entry.getKey() + "" failed more than three times, giving up."");
                    completeFailures.put(entry.getKey(), assignmentFailures.get(entry.getKey()));
                    assignmentFailures.remove(entry.getKey());
                }
            }
        }
        assignmentStats.assignmentsAbandoned(completeFailures);
        Set<Path> failedFailures = processFailures(conf, fs, failureDir, completeFailures);
        assignmentStats.unrecoveredMapFiles(failedFailures);
        timer.stop(Timers.TOTAL);
        printReport();
        return assignmentStats;
    } finally {
        if (client != null)
            ServerClient.close(client);
        locator.invalidateCache();
    }
}",,"public AssignmentStats importFiles(List<String> files, Path failureDir) throws IOException, AccumuloException, AccumuloSecurityException, ThriftTableOperationException {
    int numThreads = acuConf.getCount(Property.TSERV_BULK_PROCESS_THREADS);
    int numAssignThreads = acuConf.getCount(Property.TSERV_BULK_ASSIGNMENT_THREADS);
    timer = new StopWatch<Timers>(Timers.class);
    timer.start(Timers.TOTAL);
    Configuration conf = CachedConfiguration.getInstance();
    final FileSystem fs = FileSystem.get(conf);
    Set<Path> paths = new HashSet<Path>();
    for (String file : files) {
        paths.add(new Path(file));
    }
    AssignmentStats assignmentStats = new AssignmentStats(paths.size());
    final Map<Path, List<KeyExtent>> completeFailures = Collections.synchronizedSortedMap(new TreeMap<Path, List<KeyExtent>>());
    if (!fs.exists(failureDir)) {
        log.error(failureDir + "" does not exist"");
        throw new RuntimeException(""Directory does not exist "" + failureDir);
    }
    ClientService.Iface client = null;
    final TabletLocator locator = TabletLocator.getInstance(instance, credentials, new Text(tableId));
    try {
        final Map<Path, List<TabletLocation>> assignments = Collections.synchronizedSortedMap(new TreeMap<Path, List<TabletLocation>>());
        timer.start(Timers.EXAMINE_MAP_FILES);
        ExecutorService threadPool = Executors.newFixedThreadPool(numThreads);
        for (Path path : paths) {
            final Path mapFile = path;
            Runnable getAssignments = new Runnable() {

                public void run() {
                    List<TabletLocation> tabletsToAssignMapFileTo = Collections.emptyList();
                    try {
                        tabletsToAssignMapFileTo = findOverlappingTablets(instance.getConfiguration(), fs, locator, mapFile);
                    } catch (Exception ex) {
                        log.warn(""Unable to find tablets that overlap file "" + mapFile.toString());
                    }
                    if (tabletsToAssignMapFileTo.size() == 0) {
                        List<KeyExtent> empty = Collections.emptyList();
                        completeFailures.put(mapFile, empty);
                    } else
                        assignments.put(mapFile, tabletsToAssignMapFileTo);
                }
            };
            threadPool.submit(new TraceRunnable(new LoggingRunnable(log, getAssignments)));
        }
        threadPool.shutdown();
        while (!threadPool.isTerminated()) {
            try {
                threadPool.awaitTermination(60, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        timer.stop(Timers.EXAMINE_MAP_FILES);
        assignmentStats.attemptingAssignments(assignments);
        Map<Path, List<KeyExtent>> assignmentFailures = assignMapFiles(acuConf, instance, conf, credentials, fs, tableId, assignments, paths, numAssignThreads, numThreads);
        assignmentStats.assignmentsFailed(assignmentFailures);
        Map<Path, Integer> failureCount = new TreeMap<Path, Integer>();
        for (Entry<Path, List<KeyExtent>> entry : assignmentFailures.entrySet()) failureCount.put(entry.getKey(), 1);
        while (assignmentFailures.size() > 0) {
            locator.invalidateCache();
                                                                        timer.start(Timers.SLEEP);
            UtilWaitThread.sleep(4000);
            timer.stop(Timers.SLEEP);
            log.debug(""Trying to assign "" + assignmentFailures.size() + "" map files that previously failed on some key extents"");
            assignments.clear();
                        for (Entry<Path, List<KeyExtent>> entry : assignmentFailures.entrySet()) {
                Iterator<KeyExtent> keListIter = entry.getValue().iterator();
                List<TabletLocation> tabletsToAssignMapFileTo = new ArrayList<TabletLocation>();
                while (keListIter.hasNext()) {
                    KeyExtent ke = keListIter.next();
                    try {
                        timer.start(Timers.QUERY_METADATA);
                        tabletsToAssignMapFileTo.addAll(findOverlappingTablets(instance.getConfiguration(), fs, locator, entry.getKey(), ke));
                        timer.stop(Timers.QUERY_METADATA);
                        keListIter.remove();
                    } catch (Exception ex) {
                        log.warn(""Exception finding overlapping tablets, will retry tablet "" + ke);
                    }
                }
                if (tabletsToAssignMapFileTo.size() > 0)
                    assignments.put(entry.getKey(), tabletsToAssignMapFileTo);
            }
            assignmentStats.attemptingAssignments(assignments);
            Map<Path, List<KeyExtent>> assignmentFailures2 = assignMapFiles(acuConf, instance, conf, credentials, fs, tableId, assignments, paths, numAssignThreads, numThreads);
            assignmentStats.assignmentsFailed(assignmentFailures2);
                        for (Entry<Path, List<KeyExtent>> entry : assignmentFailures2.entrySet()) {
                assignmentFailures.get(entry.getKey()).addAll(entry.getValue());
                Integer fc = failureCount.get(entry.getKey());
                if (fc == null)
                    fc = 0;
                failureCount.put(entry.getKey(), fc + 1);
            }
                        Iterator<Entry<Path, List<KeyExtent>>> afIter = assignmentFailures.entrySet().iterator();
            while (afIter.hasNext()) {
                Entry<Path, List<KeyExtent>> entry = afIter.next();
                if (entry.getValue().size() == 0)
                    afIter.remove();
            }
            Set<Entry<Path, Integer>> failureIter = failureCount.entrySet();
            for (Entry<Path, Integer> entry : failureIter) {
                if (entry.getValue() > acuConf.getCount(Property.TSERV_BULK_RETRY) && assignmentFailures.get(entry.getKey()) != null) {
                    log.error(""Map file "" + entry.getKey() + "" failed more than three times, giving up."");
                    completeFailures.put(entry.getKey(), assignmentFailures.get(entry.getKey()));
                    assignmentFailures.remove(entry.getKey());
                }
            }
        }
        assignmentStats.assignmentsAbandoned(completeFailures);
        Set<Path> failedFailures = processFailures(conf, fs, failureDir, completeFailures);
        assignmentStats.unrecoveredMapFiles(failedFailures);
        timer.stop(Timers.TOTAL);
        printReport();
        return assignmentStats;
    } finally {
        if (client != null)
            ServerClient.close(client);
        locator.invalidateCache();
    }
}",4.681818181818182,1.6581632653061222,3.1666666666666665,1.5,1.75,1.4740484429065748,-1.5557786062517929,7.583333333333333,-0.028571428571428574,14.076528711115678
wicket,remotes/origin/bugs-dot-jar_WICKET-3455_f30bd1cb,1,"/**
 *  Removes all children from this container.
 *  <p>
 *  Note: implementation does not call {@link MarkupContainer#remove(Component) } for each
 *  component.
 */
public final void removeAll() {
    if (children != null) {
        addStateChange();
        // Loop through child components
        int size = children_size();
        for (int i = 0; i < size; i++) {
            Object childObject = children_get(i, false);
            if (childObject instanceof Component) {
                // Get next child
                final Component child = (Component) childObject;
                // Do not call remove() because the state change would than be
                // recorded twice.
                child.detachModel();
                child.setParent(null);
            }
        }
        children = null;
    }
}","/**
 *  Removes all children from this container.
 *  <p>
 *  Note: implementation does not call {@link MarkupContainer#remove(Component) } for each
 *  component.
 */
","public final void removeAll() {
    if (children != null) {
        addStateChange();
                int size = children_size();
        for (int i = 0; i < size; i++) {
            Object childObject = children_get(i, false);
            if (childObject instanceof Component) {
                                final Component child = (Component) childObject;
                                                child.detachModel();
                child.setParent(null);
            }
        }
        children = null;
    }
}",0.045454545454545456,1.0612244897959182,0.0,0.5,0.16666666666666666,0.3173504695996046,-0.020361342127903876,-0.08333333333333333,1.885714285714286,0.08807997224613567
commons-math,remotes/origin/bugs-dot-jar_MATH-949_f83bbc1d,1,"/**
 * {@inheritDoc}
 */
@Override
protected PointValuePair doOptimize() {
    checkParameters();
    final GoalType goal = getGoalType();
    final double[] guess = getStartPoint();
    final int n = guess.length;
    final double[][] direc = new double[n][n];
    for (int i = 0; i < n; i++) {
        direc[i][i] = 1;
    }
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    double[] x = guess;
    double fVal = computeObjectiveValue(x);
    double[] x1 = x.clone();
    int iter = 0;
    while (true) {
        ++iter;
        double fX = fVal;
        double fX2 = 0;
        double delta = 0;
        int bigInd = 0;
        double alphaMin = 0;
        for (int i = 0; i < n; i++) {
            final double[] d = MathArrays.copyOf(direc[i]);
            fX2 = fVal;
            final UnivariatePointValuePair optimum = line.search(x, d);
            fVal = optimum.getValue();
            alphaMin = optimum.getPoint();
            final double[][] result = newPointAndDirection(x, d, alphaMin);
            x = result[0];
            if ((fX2 - fVal) > delta) {
                delta = fX2 - fVal;
                bigInd = i;
            }
        }
        // Default convergence check.
        boolean stop = 2 * (fX - fVal) <= (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) + absoluteThreshold);
        final PointValuePair previous = new PointValuePair(x1, fX);
        final PointValuePair current = new PointValuePair(x, fVal);
        if (!stop) {
            // User-defined stopping criteria.
            if (checker != null) {
                stop = checker.converged(iter, previous, current);
            }
        }
        if (stop) {
            if (goal == GoalType.MINIMIZE) {
                return (fVal < fX) ? current : previous;
            } else {
                return (fVal > fX) ? current : previous;
            }
        }
        final double[] d = new double[n];
        final double[] x2 = new double[n];
        for (int i = 0; i < n; i++) {
            d[i] = x[i] - x1[i];
            x2[i] = 2 * x[i] - x1[i];
        }
        x1 = x.clone();
        fX2 = computeObjectiveValue(x2);
        if (fX > fX2) {
            double t = 2 * (fX + fX2 - 2 * fVal);
            double temp = fX - fVal - delta;
            t *= temp * temp;
            temp = fX - fX2;
            t -= delta * temp * temp;
            if (t < 0.0) {
                final UnivariatePointValuePair optimum = line.search(x, d);
                fVal = optimum.getValue();
                alphaMin = optimum.getPoint();
                final double[][] result = newPointAndDirection(x, d, alphaMin);
                x = result[0];
                final int lastInd = n - 1;
                direc[bigInd] = direc[lastInd];
                direc[lastInd] = result[1];
            }
        }
    }
}","/**
 * {@inheritDoc}
 */
","@Override
protected PointValuePair doOptimize() {
    checkParameters();
    final GoalType goal = getGoalType();
    final double[] guess = getStartPoint();
    final int n = guess.length;
    final double[][] direc = new double[n][n];
    for (int i = 0; i < n; i++) {
        direc[i][i] = 1;
    }
    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
    double[] x = guess;
    double fVal = computeObjectiveValue(x);
    double[] x1 = x.clone();
    int iter = 0;
    while (true) {
        ++iter;
        double fX = fVal;
        double fX2 = 0;
        double delta = 0;
        int bigInd = 0;
        double alphaMin = 0;
        for (int i = 0; i < n; i++) {
            final double[] d = MathArrays.copyOf(direc[i]);
            fX2 = fVal;
            final UnivariatePointValuePair optimum = line.search(x, d);
            fVal = optimum.getValue();
            alphaMin = optimum.getPoint();
            final double[][] result = newPointAndDirection(x, d, alphaMin);
            x = result[0];
            if ((fX2 - fVal) > delta) {
                delta = fX2 - fVal;
                bigInd = i;
            }
        }
                boolean stop = 2 * (fX - fVal) <= (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) + absoluteThreshold);
        final PointValuePair previous = new PointValuePair(x1, fX);
        final PointValuePair current = new PointValuePair(x, fVal);
        if (!stop) {
                        if (checker != null) {
                stop = checker.converged(iter, previous, current);
            }
        }
        if (stop) {
            if (goal == GoalType.MINIMIZE) {
                return (fVal < fX) ? current : previous;
            } else {
                return (fVal > fX) ? current : previous;
            }
        }
        final double[] d = new double[n];
        final double[] x2 = new double[n];
        for (int i = 0; i < n; i++) {
            d[i] = x[i] - x1[i];
            x2[i] = 2 * x[i] - x1[i];
        }
        x1 = x.clone();
        fX2 = computeObjectiveValue(x2);
        if (fX > fX2) {
            double t = 2 * (fX + fX2 - 2 * fVal);
            double temp = fX - fVal - delta;
            t *= temp * temp;
            temp = fX - fX2;
            t -= delta * temp * temp;
            if (t < 0.0) {
                final UnivariatePointValuePair optimum = line.search(x, d);
                fVal = optimum.getValue();
                alphaMin = optimum.getPoint();
                final double[][] result = newPointAndDirection(x, d, alphaMin);
                x = result[0];
                final int lastInd = n - 1;
                direc[bigInd] = direc[lastInd];
                direc[lastInd] = result[1];
            }
        }
    }
}",2.8636363636363638,0.6683673469387755,1.6666666666666667,0.5,1.5,4.058329214038557,-1.205620877545168,1.1666666666666667,-0.028571428571428574,17.69224476509866
wicket,remotes/origin/bugs-dot-jar_WICKET-5147_184e51e9,1,"/**
 *  @see javax.servlet.Filter#destroy()
 */
@Override
public void destroy() {
    if (application != null) {
        try {
            ThreadContext.setApplication(application);
            application.internalDestroy();
        } finally {
            ThreadContext.detach();
            application = null;
        }
    }
    if (applicationFactory != null) {
        applicationFactory.destroy(this);
    }
}","/**
 *  @see javax.servlet.Filter#destroy()
 */
","@Override
public void destroy() {
    if (application != null) {
        try {
            ThreadContext.setApplication(application);
            application.internalDestroy();
        } finally {
            ThreadContext.detach();
            application = null;
        }
    }
    if (applicationFactory != null) {
        applicationFactory.destroy(this);
    }
}",0.045454545454545456,0.6683673469387755,-0.16666666666666666,0.0,-0.08333333333333333,-0.0247157686604053,0.10496128477201025,-0.16666666666666666,1.2857142857142858,-0.10618851212732514
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1075_79467350,1,"public static boolean match(PropertyValue p1, PropertyValue p2) {
    if (p1.getType().tag() != p2.getType().tag()) {
        return false;
    }
    switch(p1.getType().tag()) {
        case PropertyType.BINARY:
            if (p1.isArray() && !p2.isArray()) {
                return contains(p1.getValue(Type.BINARIES), p2.getValue(Type.BINARY));
            }
            if (!p1.isArray() && p2.isArray()) {
                return contains(p2.getValue(Type.BINARIES), p2.getValue(Type.BINARY));
            }
            break;
        default:
            if (p1.isArray() && !p2.isArray()) {
                return contains(p1.getValue(Type.STRINGS), p2.getValue(Type.STRING));
            }
            if (!p1.isArray() && p2.isArray()) {
                return contains(p2.getValue(Type.STRINGS), p1.getValue(Type.STRING));
            }
    }
    // both arrays or both single values
    return p1.compareTo(p2) == 0;
}",,"public static boolean match(PropertyValue p1, PropertyValue p2) {
    if (p1.getType().tag() != p2.getType().tag()) {
        return false;
    }
    switch(p1.getType().tag()) {
        case PropertyType.BINARY:
            if (p1.isArray() && !p2.isArray()) {
                return contains(p1.getValue(Type.BINARIES), p2.getValue(Type.BINARY));
            }
            if (!p1.isArray() && p2.isArray()) {
                return contains(p2.getValue(Type.BINARIES), p2.getValue(Type.BINARY));
            }
            break;
        default:
            if (p1.isArray() && !p2.isArray()) {
                return contains(p1.getValue(Type.STRINGS), p2.getValue(Type.STRING));
            }
            if (!p1.isArray() && p2.isArray()) {
                return contains(p2.getValue(Type.STRINGS), p1.getValue(Type.STRING));
            }
    }
        return p1.compareTo(p2) == 0;
}",0.4090909090909091,0.9846938775510206,0.8333333333333334,0.5,0.75,1.1596638655462188,-0.3745339833667911,1.75,-0.028571428571428574,1.103473087745898
commons-math,remotes/origin/bugs-dot-jar_MATH-305_ef9b639a,1,"/**
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */
public static double distance(int[] p1, int[] p2) {
    int sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final int dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return Math.sqrt(sum);
}","/**
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 *
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */
","public static double distance(int[] p1, int[] p2) {
    int sum = 0;
    for (int i = 0; i < p1.length; i++) {
        final int dp = p1[i] - p2[i];
        sum += dp * dp;
    }
    return Math.sqrt(sum);
}",-0.2727272727272727,-0.09693877551020405,-0.3333333333333333,-0.5,-0.16666666666666666,0.8591201186356896,0.3260682535130487,-0.4166666666666667,2.142857142857143,0.17619849152607708
Csv,9,1,"/**
 * Puts all values of this record into the given Map.
 *
 * @param map The Map to populate.
 * @return the given map.
 */
<M extends Map<String, String>> M putIn(final M map) {
    for (final Entry<String, Integer> entry : mapping.entrySet()) {
        final int col = entry.getValue().intValue();
        if (col < values.length) {
            map.put(entry.getKey(), values[col]);
        }
    }
    return map;
}","/**
 * Puts all values of this record into the given Map.
 *
 * @param map The Map to populate.
 * @return the given map.
 */
","<M extends Map<String, String>> M putIn(final M map) {
    for (final Entry<String, Integer> entry : mapping.entrySet()) {
        final int col = entry.getValue().intValue();
        if (col < values.length) {
            map.put(entry.getKey(), values[col]);
        }
    }
    return map;
}",-0.22727272727272727,0.3826530612244898,-0.16666666666666666,0.0,-0.16666666666666666,-0.06228373702422141,0.2563808431316318,-0.08333333333333333,0.6285714285714287,-0.07177457694630397
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3634_90ad50da,1,"@CheckForNull
private <T extends Document> void internalUpdate(Collection<T> collection, List<String> ids, UpdateOp update) {
    if (isAppendableUpdate(update) && !requiresPreviousState(update)) {
        Operation modOperation = update.getChanges().get(MODIFIEDKEY);
        long modified = getModifiedFromOperation(modOperation);
        boolean modifiedIsConditional = modOperation == null || modOperation.type != UpdateOp.Operation.Type.SET;
        String appendData = ser.asString(update);
        for (List<String> chunkedIds : Lists.partition(ids, CHUNKSIZE)) {
            Set<QueryContext> seenQueryContext = Collections.emptySet();
            Map<String, NodeDocument> cachedDocs = Collections.emptyMap();
            if (collection == Collection.NODES) {
                // remember what we already have in the cache
                cachedDocs = new HashMap<String, NodeDocument>();
                for (String key : chunkedIds) {
                    cachedDocs.put(key, nodesCache.getIfPresent(key));
                }
                // keep concurrently running queries from updating
                // the cache entry for this key
                seenQueryContext = new HashSet<QueryContext>();
                for (QueryContext qc : qmap.values()) {
                    qc.addKeys(chunkedIds);
                    seenQueryContext.add(qc);
                }
            }
            Connection connection = null;
            RDBTableMetaData tmd = getTable(collection);
            boolean success = false;
            try {
                connection = this.ch.getRWConnection();
                success = db.batchedAppendingUpdate(connection, tmd, chunkedIds, modified, modifiedIsConditional, appendData);
                connection.commit();
            } catch (SQLException ex) {
                success = false;
                this.ch.rollbackConnection(connection);
            } finally {
                this.ch.closeConnection(connection);
            }
            if (success) {
                if (collection == Collection.NODES) {
                    // the cache entry for this key
                    for (QueryContext qc : qmap.values()) {
                        if (!seenQueryContext.contains(qc)) {
                            qc.addKeys(chunkedIds);
                        }
                    }
                }
                for (Entry<String, NodeDocument> entry : cachedDocs.entrySet()) {
                    T oldDoc = castAsT(entry.getValue());
                    String id = entry.getKey();
                    Lock lock = locks.acquire(id);
                    try {
                        if (oldDoc == null) {
                            // make sure concurrently loaded document is
                            // invalidated
                            nodesCache.invalidate(id);
                        } else {
                            addUpdateCounters(update);
                            T newDoc = createNewDocument(collection, oldDoc, update);
                            nodesCache.replaceCachedDocument((NodeDocument) oldDoc, (NodeDocument) newDoc);
                        }
                    } finally {
                        lock.unlock();
                    }
                }
            } else {
                for (String id : chunkedIds) {
                    UpdateOp up = update.copy();
                    up = up.shallowCopy(id);
                    internalCreateOrUpdate(collection, up, false, true);
                }
            }
        }
    } else {
        for (String id : ids) {
            UpdateOp up = update.copy();
            up = up.shallowCopy(id);
            internalCreateOrUpdate(collection, up, false, true);
        }
    }
}",,"@CheckForNull
private <T extends Document> void internalUpdate(Collection<T> collection, List<String> ids, UpdateOp update) {
    if (isAppendableUpdate(update) && !requiresPreviousState(update)) {
        Operation modOperation = update.getChanges().get(MODIFIEDKEY);
        long modified = getModifiedFromOperation(modOperation);
        boolean modifiedIsConditional = modOperation == null || modOperation.type != UpdateOp.Operation.Type.SET;
        String appendData = ser.asString(update);
        for (List<String> chunkedIds : Lists.partition(ids, CHUNKSIZE)) {
            Set<QueryContext> seenQueryContext = Collections.emptySet();
            Map<String, NodeDocument> cachedDocs = Collections.emptyMap();
            if (collection == Collection.NODES) {
                                cachedDocs = new HashMap<String, NodeDocument>();
                for (String key : chunkedIds) {
                    cachedDocs.put(key, nodesCache.getIfPresent(key));
                }
                                                seenQueryContext = new HashSet<QueryContext>();
                for (QueryContext qc : qmap.values()) {
                    qc.addKeys(chunkedIds);
                    seenQueryContext.add(qc);
                }
            }
            Connection connection = null;
            RDBTableMetaData tmd = getTable(collection);
            boolean success = false;
            try {
                connection = this.ch.getRWConnection();
                success = db.batchedAppendingUpdate(connection, tmd, chunkedIds, modified, modifiedIsConditional, appendData);
                connection.commit();
            } catch (SQLException ex) {
                success = false;
                this.ch.rollbackConnection(connection);
            } finally {
                this.ch.closeConnection(connection);
            }
            if (success) {
                if (collection == Collection.NODES) {
                                        for (QueryContext qc : qmap.values()) {
                        if (!seenQueryContext.contains(qc)) {
                            qc.addKeys(chunkedIds);
                        }
                    }
                }
                for (Entry<String, NodeDocument> entry : cachedDocs.entrySet()) {
                    T oldDoc = castAsT(entry.getValue());
                    String id = entry.getKey();
                    Lock lock = locks.acquire(id);
                    try {
                        if (oldDoc == null) {
                                                                                    nodesCache.invalidate(id);
                        } else {
                            addUpdateCounters(update);
                            T newDoc = createNewDocument(collection, oldDoc, update);
                            nodesCache.replaceCachedDocument((NodeDocument) oldDoc, (NodeDocument) newDoc);
                        }
                    } finally {
                        lock.unlock();
                    }
                }
            } else {
                for (String id : chunkedIds) {
                    UpdateOp up = update.copy();
                    up = up.shallowCopy(id);
                    internalCreateOrUpdate(collection, up, false, true);
                }
            }
        }
    } else {
        for (String id : ids) {
            UpdateOp up = update.copy();
            up = up.shallowCopy(id);
            internalCreateOrUpdate(collection, up, false, true);
        }
    }
}",2.727272727272727,1.8520408163265307,1.8333333333333333,2.0,0.8333333333333334,0.9263470093919923,-1.169773444221394,2.75,-0.028571428571428574,4.309909585790707
JxPath,9,1,"protected boolean equal(Object l, Object r) {
    if (l instanceof Pointer && r instanceof Pointer) {
        if (l.equals(r)) {
            return true;
        }
    }
    if (l instanceof Pointer) {
        l = ((Pointer) l).getValue();
    }
    if (r instanceof Pointer) {
        r = ((Pointer) r).getValue();
    }
    if (l == r) {
        return true;
    }
    if (l instanceof Boolean || r instanceof Boolean) {
        return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));
    }
    // if either side is NaN, no comparison returns true:
    if (l instanceof Number || r instanceof Number) {
        return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));
    }
    if (l instanceof String || r instanceof String) {
        return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));
    }
    return l != null && l.equals(r);
}",,"protected boolean equal(Object l, Object r) {
    if (l instanceof Pointer && r instanceof Pointer) {
        if (l.equals(r)) {
            return true;
        }
    }
    if (l instanceof Pointer) {
        l = ((Pointer) l).getValue();
    }
    if (r instanceof Pointer) {
        r = ((Pointer) r).getValue();
    }
    if (l == r) {
        return true;
    }
    if (l instanceof Boolean || r instanceof Boolean) {
        return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));
    }
        if (l instanceof Number || r instanceof Number) {
        return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));
    }
    if (l instanceof String || r instanceof String) {
        return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));
    }
    return l != null && l.equals(r);
}",0.5454545454545454,-0.18367346938775503,0.8333333333333334,0.0,0.8333333333333334,1.1319822046465648,-0.41468310868941816,0.4166666666666667,-0.028571428571428574,0.9458071534728735
wicket,remotes/origin/bugs-dot-jar_WICKET-5398_19e7c1cd,3,"/**
 *  Reads and parses markup from an input stream
 *
 *  @param inputStream
 *             The input stream to read and parse
 *  @param encoding
 *             The default character encoding of the input
 *  @throws IOException
 */
@Override
public void parse(final InputStream inputStream, final String encoding) throws IOException {
    Args.notNull(inputStream, ""inputStream"");
    try {
        xmlReader = new XmlReader(new BufferedInputStream(inputStream, 4000), encoding);
        input = new FullyBufferedReader(xmlReader);
    } finally {
        IOUtils.closeQuietly(inputStream);
        IOUtils.closeQuietly(xmlReader);
    }
}","/**
 *  Reads and parses markup from an input stream
 *
 *  @param inputStream
 *             The input stream to read and parse
 *  @param encoding
 *             The default character encoding of the input
 *  @throws IOException
 */
","@Override
public void parse(final InputStream inputStream, final String encoding) throws IOException {
    Args.notNull(inputStream, ""inputStream"");
    try {
        xmlReader = new XmlReader(new BufferedInputStream(inputStream, 4000), encoding);
        input = new FullyBufferedReader(xmlReader);
    } finally {
        IOUtils.closeQuietly(inputStream);
        IOUtils.closeQuietly(xmlReader);
    }
}",-0.13636363636363635,0.07653061224489792,-0.5,-0.5,-0.4166666666666667,-0.3806228373702422,0.18870088901634643,-0.25,1.8285714285714287,-0.16422749602751402
commons-math,remotes/origin/bugs-dot-jar_MATH-293_59a0da9c,1,"/**
 * Get the original number of decision variables.
 * @return original number of decision variables
 * @see #getNumDecisionVariables()
 */
protected final int getOriginalNumDecisionVariables() {
    return restrictToNonNegative ? numDecisionVariables : numDecisionVariables - 1;
}","/**
 * Get the original number of decision variables.
 * @return original number of decision variables
 * @see #getNumDecisionVariables()
 */
","protected final int getOriginalNumDecisionVariables() {
    return restrictToNonNegative ? numDecisionVariables : numDecisionVariables - 1;
}",-0.5,-0.576530612244898,-0.3333333333333333,-1.0,-0.25,-0.3806228373702422,1.0719816461141385,-0.5,2.8285714285714287,-0.16422749602751402
Math,4,1,"/**
 * Get the intersection of the instance and another sub-line.
 * <p>
 * This method is related to the {@link Line#intersection(Line)
 * intersection} method in the {@link Line Line} class, but in addition
 * to compute the point along infinite lines, it also checks the point
 * lies on both sub-line ranges.
 * </p>
 * @param subLine other sub-line which may intersect instance
 * @param includeEndPoints if true, endpoints are considered to belong to
 * instance (i.e. they are closed sets) and may be returned, otherwise endpoints
 * are considered to not belong to instance (i.e. they are open sets) and intersection
 * occurring on endpoints lead to null being returned
 * @return the intersection point if there is one, null if the sub-lines don't intersect
 */
public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {
    // compute the intersection on infinite line
    Vector3D v1D = line.intersection(subLine.line);
    // check location of point with respect to first sub-line
    Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
    // check location of point with respect to second sub-line
    Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
    if (includeEndPoints) {
        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;
    } else {
        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;
    }
}","/**
 * Get the intersection of the instance and another sub-line.
 * <p>
 * This method is related to the {@link Line#intersection(Line)
 * intersection} method in the {@link Line Line} class, but in addition
 * to compute the point along infinite lines, it also checks the point
 * lies on both sub-line ranges.
 * </p>
 * @param subLine other sub-line which may intersect instance
 * @param includeEndPoints if true, endpoints are considered to belong to
 * instance (i.e. they are closed sets) and may be returned, otherwise endpoints
 * are considered to not belong to instance (i.e. they are open sets) and intersection
 * occurring on endpoints lead to null being returned
 * @return the intersection point if there is one, null if the sub-lines don't intersect
 */
","public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {
        Vector3D v1D = line.intersection(subLine.line);
        Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
        Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
    if (includeEndPoints) {
        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;
    } else {
        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;
    }
}",-0.18181818181818182,-0.2500000000000001,0.0,-0.5,0.25,0.6653484923381119,0.1155721250358475,-0.08333333333333333,-0.028571428571428574,0.3735850026340473
commons-math,remotes/origin/bugs-dot-jar_MATH-1093_7cfbc0da,1,"/**
 * Add an arc limit to a BSP tree under construction.
 * @param tree BSP tree under construction
 * @param alpha arc limit
 * @param isStart if true, the limit is the start of an arc
 */
private void addArcLimit(final BSPTree<Sphere1D> tree, final double alpha, final boolean isStart) {
    final LimitAngle limit = new LimitAngle(new S1Point(alpha), !isStart, getTolerance());
    final BSPTree<Sphere1D> node = tree.getCell(limit.getLocation(), getTolerance());
    if (node.getCut() != null) {
        // we find again an already added limit,
        // this means we have done a full turn around the circle
        leafBefore(node).setAttribute(Boolean.valueOf(!isStart));
    } else {
        // it's a new node
        node.insertCut(limit);
        node.setAttribute(null);
        node.getPlus().setAttribute(Boolean.FALSE);
        node.getMinus().setAttribute(Boolean.TRUE);
    }
}","/**
 * Add an arc limit to a BSP tree under construction.
 * @param tree BSP tree under construction
 * @param alpha arc limit
 * @param isStart if true, the limit is the start of an arc
 */
","private void addArcLimit(final BSPTree<Sphere1D> tree, final double alpha, final boolean isStart) {
    final LimitAngle limit = new LimitAngle(new S1Point(alpha), !isStart, getTolerance());
    final BSPTree<Sphere1D> node = tree.getCell(limit.getLocation(), getTolerance());
    if (node.getCut() != null) {
                        leafBefore(node).setAttribute(Boolean.valueOf(!isStart));
    } else {
                node.insertCut(limit);
        node.setAttribute(null);
        node.getPlus().setAttribute(Boolean.FALSE);
        node.getMinus().setAttribute(Boolean.TRUE);
    }
}",-0.09090909090909091,-0.06632653061224485,-0.3333333333333333,-0.5,-0.25,-0.00889767671774591,0.03613421279036396,0.6666666666666666,-0.028571428571428574,0.03706083150234924
Chart,2,3,"/**
 * Iterates over the items in an {@link XYDataset} to find
 * the range of x-values.
 *
 * @param dataset  the dataset (<code>null</code> not permitted).
 * @param includeInterval  a flag that determines, for an
 *          {@link IntervalXYDataset}, whether the x-interval or just the
 *          x-value is used to determine the overall range.
 *
 * @return The range (possibly <code>null</code>).
 */
public static Range iterateDomainBounds(XYDataset dataset, boolean includeInterval) {
    if (dataset == null) {
        throw new IllegalArgumentException(""Null 'dataset' argument."");
    }
    double minimum = Double.POSITIVE_INFINITY;
    double maximum = Double.NEGATIVE_INFINITY;
    int seriesCount = dataset.getSeriesCount();
    double lvalue;
    double uvalue;
    if (includeInterval && dataset instanceof IntervalXYDataset) {
        IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;
        for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                lvalue = intervalXYData.getStartXValue(series, item);
                uvalue = intervalXYData.getEndXValue(series, item);
                if (!Double.isNaN(lvalue)) {
                    minimum = Math.min(minimum, lvalue);
                }
                if (!Double.isNaN(uvalue)) {
                    maximum = Math.max(maximum, uvalue);
                }
            }
        }
    } else {
        for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                lvalue = dataset.getXValue(series, item);
                uvalue = lvalue;
                if (!Double.isNaN(lvalue)) {
                    minimum = Math.min(minimum, lvalue);
                    maximum = Math.max(maximum, uvalue);
                }
            }
        }
    }
    if (minimum > maximum) {
        return null;
    } else {
        return new Range(minimum, maximum);
    }
}","/**
 * Iterates over the items in an {@link XYDataset} to find
 * the range of x-values.
 *
 * @param dataset  the dataset (<code>null</code> not permitted).
 * @param includeInterval  a flag that determines, for an
 *          {@link IntervalXYDataset}, whether the x-interval or just the
 *          x-value is used to determine the overall range.
 *
 * @return The range (possibly <code>null</code>).
 */
","public static Range iterateDomainBounds(XYDataset dataset, boolean includeInterval) {
    if (dataset == null) {
        throw new IllegalArgumentException(""Null 'dataset' argument."");
    }
    double minimum = Double.POSITIVE_INFINITY;
    double maximum = Double.NEGATIVE_INFINITY;
    int seriesCount = dataset.getSeriesCount();
    double lvalue;
    double uvalue;
    if (includeInterval && dataset instanceof IntervalXYDataset) {
        IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;
        for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                lvalue = intervalXYData.getStartXValue(series, item);
                uvalue = intervalXYData.getEndXValue(series, item);
                if (!Double.isNaN(lvalue)) {
                    minimum = Math.min(minimum, lvalue);
                }
                if (!Double.isNaN(uvalue)) {
                    maximum = Math.max(maximum, uvalue);
                }
            }
        }
    } else {
        for (int series = 0; series < seriesCount; series++) {
            int itemCount = dataset.getItemCount(series);
            for (int item = 0; item < itemCount; item++) {
                lvalue = dataset.getXValue(series, item);
                uvalue = lvalue;
                if (!Double.isNaN(lvalue)) {
                    minimum = Math.min(minimum, lvalue);
                    maximum = Math.max(maximum, uvalue);
                }
            }
        }
    }
    if (minimum > maximum) {
        return null;
    } else {
        return new Range(minimum, maximum);
    }
}",1.3181818181818181,1.4540816326530612,1.3333333333333333,1.0,1.5,1.6203657933761744,-0.7846286205907659,0.5833333333333334,-0.028571428571428574,3.044624616135789
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1822_016df669,1,"public static void setModified(@Nonnull UpdateOp op, @Nonnull Revision revision) {
    checkNotNull(op).set(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));
}",,"public static void setModified(@Nonnull UpdateOp op, @Nonnull Revision revision) {
    checkNotNull(op).set(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));
}",-0.5,-0.576530612244898,-0.5,-1.0,-0.4166666666666667,-0.3806228373702422,0.9065098938915972,-0.08333333333333333,0.14285714285714285,-0.16422749602751402
JxPath,18,3,"public boolean nextNode() {
    super.setPosition(getCurrentPosition() + 1);
    if (!setStarted) {
        setStarted = true;
        if (!(nodeTest instanceof NodeNameTest)) {
            return false;
        }
        QName name = ((NodeNameTest) nodeTest).getNodeName();
        iterator = parentContext.getCurrentNodePointer().attributeIterator(name);
    }
    if (iterator == null) {
        return false;
    }
    if (!iterator.setPosition(iterator.getPosition() + 1)) {
        return false;
    }
    currentNodePointer = iterator.getNodePointer();
    return true;
}",,"public boolean nextNode() {
    super.setPosition(getCurrentPosition() + 1);
    if (!setStarted) {
        setStarted = true;
        if (!(nodeTest instanceof NodeNameTest)) {
            return false;
        }
        QName name = ((NodeNameTest) nodeTest).getNodeName();
        iterator = parentContext.getCurrentNodePointer().attributeIterator(name);
    }
    if (iterator == null) {
        return false;
    }
    if (!iterator.setPosition(iterator.getPosition() + 1)) {
        return false;
    }
    currentNodePointer = iterator.getNodePointer();
    return true;
}",0.22727272727272727,-0.03061224489795921,0.16666666666666666,0.0,0.3333333333333333,0.2600098863074643,-0.16690564955549209,0.16666666666666666,0.028571428571428574,0.11915316449732526
Closure,130,2,"/**
 * For each qualified name N in the global scope, we check if:
 * (a) No ancestor of N is ever aliased or assigned an unknown value type.
 *     (If N = ""a.b.c"", ""a"" and ""a.b"" are never aliased).
 * (b) N has exactly one write, and it lives in the global scope.
 * (c) N is aliased in a local scope.
 *
 * If (a) is true, then GlobalNamespace must know all the writes to N.
 * If (a) and (b) are true, then N cannot change during the execution of
 *    a local scope.
 * If (a) and (b) and (c) are true, then the alias can be inlined if the
 *    alias obeys the usual rules for how we decide whether a variable is
 *    inlineable.
 * @see InlineVariables
 */
private void inlineAliases(GlobalNamespace namespace) {
    // Invariant: All the names in the worklist meet condition (a).
    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());
    while (!workList.isEmpty()) {
        Name name = workList.pop();
        // Don't attempt to inline a getter or setter property as a variable.
        if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
            continue;
        }
        if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {
            // {@code name} meets condition (b). Find all of its local aliases
            // and try to inline them.
            List<Ref> refs = Lists.newArrayList(name.getRefs());
            for (Ref ref : refs) {
                if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {
                    // {@code name} meets condition (c). Try to inline it.
                    if (inlineAliasIfPossible(ref, namespace)) {
                        name.removeRef(ref);
                    }
                }
            }
        }
        // local-alias-inlining above.
        if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) {
            // All of {@code name}'s children meet condition (a), so they can be
            // added to the worklist.
            workList.addAll(name.props);
        }
    }
}","/**
 * For each qualified name N in the global scope, we check if:
 * (a) No ancestor of N is ever aliased or assigned an unknown value type.
 *     (If N = ""a.b.c"", ""a"" and ""a.b"" are never aliased).
 * (b) N has exactly one write, and it lives in the global scope.
 * (c) N is aliased in a local scope.
 *
 * If (a) is true, then GlobalNamespace must know all the writes to N.
 * If (a) and (b) are true, then N cannot change during the execution of
 *    a local scope.
 * If (a) and (b) and (c) are true, then the alias can be inlined if the
 *    alias obeys the usual rules for how we decide whether a variable is
 *    inlineable.
 * @see InlineVariables
 */
","private void inlineAliases(GlobalNamespace namespace) {
        Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());
    while (!workList.isEmpty()) {
        Name name = workList.pop();
                if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
            continue;
        }
        if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {
                                    List<Ref> refs = Lists.newArrayList(name.getRefs());
            for (Ref ref : refs) {
                if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {
                                        if (inlineAliasIfPossible(ref, namespace)) {
                        name.removeRef(ref);
                    }
                }
            }
        }
                if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) {
                                    workList.addAll(name.props);
        }
    }
}",0.36363636363636365,1.5816326530612246,0.8333333333333334,1.5,1.5833333333333333,0.8531883341571925,-0.40894751935761425,0.25,-0.028571428571428574,1.3027783845366432
flink,remotes/origin/bugs-dot-jar_FLINK-3684_e3759a5e,1,"@Override
public void processWatermark(Watermark mark) throws Exception {
    while (!priorityQueue.isEmpty() && priorityQueue.peek().getTimestamp() <= mark.getTimestamp()) {
        StreamRecord<IN> streamRecord = priorityQueue.poll();
        processEvent(nfa, streamRecord.getValue(), streamRecord.getTimestamp());
    }
}",,"@Override
public void processWatermark(Watermark mark) throws Exception {
    while (!priorityQueue.isEmpty() && priorityQueue.peek().getTimestamp() <= mark.getTimestamp()) {
        StreamRecord<IN> streamRecord = priorityQueue.poll();
        processEvent(nfa, streamRecord.getValue(), streamRecord.getTimestamp());
    }
}",-0.3181818181818182,0.15816326530612249,-0.3333333333333333,-0.5,0.0,0.17696490360850226,0.3923143102953828,0.16666666666666666,0.0,-0.01550019059366715
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-414_116d5928,1,"@Override
protected void consume() throws IOException {
    while (getSource().hasTop()) {
        Key k = getSource().getTopKey();
        Value v = getSource().getTopValue();
        if (match(v.get()) || match(k.getRowData()) || match(k.getColumnFamilyData()) || match(k.getColumnQualifierData())) {
            break;
        }
        getSource().next();
    }
}",,"@Override
protected void consume() throws IOException {
    while (getSource().hasTop()) {
        Key k = getSource().getTopKey();
        Value v = getSource().getTopValue();
        if (match(v.get()) || match(k.getRowData()) || match(k.getColumnFamilyData()) || match(k.getColumnQualifierData())) {
            break;
        }
        getSource().next();
    }
}",-0.13636363636363635,0.4591836734693877,0.0,0.0,0.75,-0.07217004448838356,0.15658158875824477,0.8333333333333334,0.2285714285714286,-0.07496541474466874
commons-math,remotes/origin/bugs-dot-jar_MATH-727_69273dca,1,"/**
 * {@inheritDoc}
 */
@Override
public void integrate(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException {
    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();
    // create some internal working arrays
    final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][];
    for (int i = 0; i < stages; ++i) {
        yDotK[i] = new double[y0.length];
    }
    final double[] yTmp = y0.clone();
    final double[] yDotTmp = new double[y0.length];
    // set up an interpolator sharing the integrator arrays
    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());
    // set up integration control objects
    stepStart = equations.getTime();
    stepSize = forward ? step : -step;
    initIntegration(equations.getTime(), y0, t);
    // main integration loop
    isLastStep = false;
    do {
        interpolator.shift();
        // first stage
        computeDerivatives(stepStart, y, yDotK[0]);
        // next stages
        for (int k = 1; k < stages; ++k) {
            for (int j = 0; j < y0.length; ++j) {
                double sum = a[k - 1][0] * yDotK[0][j];
                for (int l = 1; l < k; ++l) {
                    sum += a[k - 1][l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
            computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
        }
        // estimate the state at the end of the step
        for (int j = 0; j < y0.length; ++j) {
            double sum = b[0] * yDotK[0][j];
            for (int l = 1; l < stages; ++l) {
                sum += b[l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
        }
        // discrete events handling
        interpolator.storeTime(stepStart + stepSize);
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
        stepStart = acceptStep(interpolator, y, yDotTmp, t);
        if (!isLastStep) {
            // prepare next step
            interpolator.storeTime(stepStart);
            // stepsize control for next step
            final double nextT = stepStart + stepSize;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            if (nextIsLast) {
                stepSize = t - stepStart;
            }
        }
    } while (!isLastStep);
    // dispatch results
    equations.setTime(stepStart);
    equations.setCompleteState(y);
    stepStart = Double.NaN;
    stepSize = Double.NaN;
}","/**
 * {@inheritDoc}
 */
","@Override
public void integrate(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException {
    sanityChecks(equations, t);
    setEquations(equations);
    final boolean forward = t > equations.getTime();
        final double[] y0 = equations.getCompleteState();
    final double[] y = y0.clone();
    final int stages = c.length + 1;
    final double[][] yDotK = new double[stages][];
    for (int i = 0; i < stages; ++i) {
        yDotK[i] = new double[y0.length];
    }
    final double[] yTmp = y0.clone();
    final double[] yDotTmp = new double[y0.length];
        final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());
    interpolator.storeTime(equations.getTime());
        stepStart = equations.getTime();
    stepSize = forward ? step : -step;
    initIntegration(equations.getTime(), y0, t);
        isLastStep = false;
    do {
        interpolator.shift();
                computeDerivatives(stepStart, y, yDotK[0]);
                for (int k = 1; k < stages; ++k) {
            for (int j = 0; j < y0.length; ++j) {
                double sum = a[k - 1][0] * yDotK[0][j];
                for (int l = 1; l < k; ++l) {
                    sum += a[k - 1][l] * yDotK[l][j];
                }
                yTmp[j] = y[j] + stepSize * sum;
            }
            computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);
        }
                for (int j = 0; j < y0.length; ++j) {
            double sum = b[0] * yDotK[0][j];
            for (int l = 1; l < stages; ++l) {
                sum += b[l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
        }
                interpolator.storeTime(stepStart + stepSize);
        System.arraycopy(yTmp, 0, y, 0, y0.length);
        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
        stepStart = acceptStep(interpolator, y, yDotTmp, t);
        if (!isLastStep) {
                        interpolator.storeTime(stepStart);
                        final double nextT = stepStart + stepSize;
            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
            if (nextIsLast) {
                stepSize = t - stepStart;
            }
        }
    } while (!isLastStep);
        equations.setTime(stepStart);
    equations.setCompleteState(y);
    stepStart = Double.NaN;
    stepSize = Double.NaN;
}",2.0454545454545454,0.8469387755102039,1.3333333333333333,1.0,1.25,3.35244686109738,-1.05907657011758,1.5833333333333333,-0.028571428571428574,13.912956514662865
